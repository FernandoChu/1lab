<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>Cat.Thin - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />
  <link rel="stylesheet" href="/css/agda-cats.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Cat.Thin - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="Cat.Thin - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script src="/equations.js"></script>
  <script src="/highlight-hover.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>
</head>

<body>
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">Cat.Thin</a>
              </h3>

      <!-- Cube logo -->
      <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#thin-categories"><a href="#thin-categories" class="header-link">Thin categories<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#posets"><a href="#posets" class="header-link">Posets<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#making-posets"><a href="#making-posets" class="header-link">Making posets<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#monotone-maps"><a href="#monotone-maps" class="header-link">Monotone maps<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#prosetal-reflection"><a href="#prosetal-reflection" class="header-link">Prosetal reflection<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#poset-completions"><a href="#poset-completions" class="header-link">Poset completions<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
              <a href="index.html">️back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/5a40bc0ad707483d84d7624fa2cfd647d01da6fc/src/Cat/Thin.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao and Reed Mullanix</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="index.html">️back to index</a>
      </div>
      
      <!-- Font toggle checkbox -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="Cat.Instances.StrictCat.html" class="Module">Cat.Instances.StrictCat</a>
<a id="45" class="Keyword">open</a> <a id="50" class="Keyword">import</a> <a id="57" href="Cat.Instances.Functor.html" class="Module">Cat.Instances.Functor</a>
<a id="79" class="Keyword">open</a> <a id="84" class="Keyword">import</a> <a id="91" href="Cat.Functor.Adjoint.html" class="Module">Cat.Functor.Adjoint</a>
<a id="111" class="Keyword">open</a> <a id="116" class="Keyword">import</a> <a id="123" href="Cat.Prelude.html" class="Module">Cat.Prelude</a>

<a id="136" class="Keyword">open</a> <a id="141" class="Keyword">import</a> <a id="148" href="Data.Set.Coequaliser.html" class="Module">Data.Set.Coequaliser</a>

<a id="170" class="Keyword">module</a> <a id="177" href="Cat.Thin.html" class="Module">Cat.Thin</a> <a id="186" class="Keyword">where</a>
</pre>
<!--
<pre class="Agda"><a id="210" class="Keyword">private</a> <a id="218" class="Keyword">variable</a>
  <a id="229" href="Cat.Thin.html#229" class="Generalizable">o</a> <a id="231" href="Cat.Thin.html#231" class="Generalizable">h</a> <a id="233" href="Cat.Thin.html#233" class="Generalizable">o′</a> <a id="236" href="Cat.Thin.html#236" class="Generalizable">h′</a> <a id="239" class="Symbol">:</a> <a id="241" href="Agda.Primitive.html#597" class="Postulate">Level</a>
<a id="247" class="Keyword">open</a> <a id="252" href="Cat.Base.html#6614" class="Module">Functor</a>
<a id="260" class="Keyword">open</a> <a id="265" href="Cat.Functor.Adjoint.html#1862" class="Module Operator">_⊣_</a>
<a id="269" class="Keyword">open</a> <a id="274" href="Cat.Base.html#10813" class="Module Operator">_=&gt;_</a>
<a id="279" href="Cat.Thin.html#279" class="Function">_</a> <a id="281" class="Symbol">=</a> <a id="283" href="1Lab.Path.html#3593" class="Function">refl</a>
</pre>-->
<h1 id="thin-categories"><a href="#thin-categories" class="header-link">Thin categories<span class="header-link-emoji">🔗</span></a></h1>
<p>A category is called <strong>thin</strong> if all of its hom-sets are <a href="1Lab.HLevel.html#is-prop"><em>propositions</em></a> rather than sets. Furthermore, we require that the space of objects be a set; In other words, a thin category is necessarily <a href="Cat.Instances.StrictCat.html">strict</a>.</p>
<pre class="Agda"><a id="617" class="Keyword">record</a> <a id="is-thin"></a><a data-type="(C : Precategory o h) → Type (o ⊔ h)" id="624" href="Cat.Thin.html#624" class="Record">is-thin</a> <a id="632" class="Symbol">(</a><a id="633" href="Cat.Thin.html#633" class="Bound">C</a> <a id="635" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="637" href="Cat.Base.html#644" class="Record">Precategory</a> <a id="649" href="Cat.Thin.html#229" class="Generalizable">o</a> <a id="651" href="Cat.Thin.html#231" class="Generalizable">h</a><a id="652" class="Symbol">)</a> <a id="654" class="Symbol">:</a> <a id="656" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="661" class="Symbol">(</a><a id="662" href="Cat.Thin.html#649" class="Bound">o</a> <a data-type="Level → Level → Level" id="664" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="666" href="Cat.Thin.html#651" class="Bound">h</a><a id="667" class="Symbol">)</a> <a id="669" class="Keyword">where</a>
  <a id="677" class="Keyword">no-eta-equality</a>
  <a id="695" class="Keyword">open</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="700" href="Cat.Base.html#644" class="Module">Precategory</a> <a id="712" href="Cat.Thin.html#633" class="Bound">C</a>
  <a id="716" class="Keyword">field</a>
    <a id="is-thin.Ob-is-set"></a><a data-type="(r : Poset o h) → is-set (Ob (r .underlying))" id="726" href="Cat.Thin.html#726" class="Field">Ob-is-set</a> <a id="736" class="Symbol">:</a> <a data-type="Type ℓ → Type ℓ" id="738" href="1Lab.HLevel.html#3356" class="Function">is-set</a> <a data-type="Precategory o h → Type o" id="745" href="Cat.Base.html#1341" class="Function">Ob</a>
    <a id="is-thin.Hom-is-prop"></a><a data-type="(r : Poset o h) (A B₁ : r .underlying .Ob) →
is-prop (Hom (r .underlying) A B₁)" id="752" href="Cat.Thin.html#752" class="Field">Hom-is-prop</a> <a id="764" class="Symbol">:</a> <a id="766" class="Symbol">∀</a> <a id="768" href="Cat.Thin.html#768" class="Bound">A</a> <a id="770" href="Cat.Thin.html#770" class="Bound">B</a> <a id="772" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="774" href="1Lab.HLevel.html#2597" class="Function">is-prop</a> <a id="782" class="Symbol">(</a><a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="783" href="Cat.Base.html#1358" class="Function">Hom</a> <a id="787" href="Cat.Thin.html#768" class="Bound">A</a> <a id="789" href="Cat.Thin.html#770" class="Bound">B</a><a id="790" class="Symbol">)</a>
</pre>
<p>To avoid Agda record weirdness, we package <span class="Agda"><a data-type="(C : Precategory o h) → Type (o ⊔ h)" href="Cat.Thin.html#624" class="Record">is-thin</a></span> into a convenient packaged record together with the underlying category.</p>
<pre class="Agda"><a id="939" class="Keyword">record</a> <a id="Proset"></a><a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="946" href="Cat.Thin.html#946" class="Record">Proset</a> <a id="953" class="Symbol">(</a><a id="954" href="Cat.Thin.html#954" class="Bound">o</a> <a id="956" href="Cat.Thin.html#956" class="Bound">h</a> <a id="958" class="Symbol">:</a> <a data-type="Type" id="960" href="Agda.Primitive.html#597" class="Postulate">Level</a><a id="965" class="Symbol">)</a> <a id="967" class="Symbol">:</a> <a id="969" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="974" class="Symbol">(</a><a data-type="Level → Level" id="975" href="Agda.Primitive.html#780" class="Primitive">lsuc</a> <a id="980" class="Symbol">(</a><a id="981" href="Cat.Thin.html#954" class="Bound">o</a> <a data-type="Level → Level → Level" id="983" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="985" href="Cat.Thin.html#956" class="Bound">h</a><a id="986" class="Symbol">))</a> <a id="989" class="Keyword">where</a>
  <a id="997" class="Keyword">no-eta-equality</a>
  <a id="1015" class="Keyword">field</a>
    <a id="1025" class="Symbol">{</a><a id="Proset.underlying"></a><a data-type="(C : Proset o h) → Precategory o h" id="1026" href="Cat.Thin.html#1026" class="Field">underlying</a><a id="1036" class="Symbol">}</a> <a id="1038" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="1040" href="Cat.Base.html#644" class="Record">Precategory</a> <a id="1052" href="Cat.Thin.html#954" class="Bound">o</a> <a id="1054" href="Cat.Thin.html#956" class="Bound">h</a>
    <a id="Proset.has-is-thin"></a><a data-type="(r : Proset o h) → is-thin (r .underlying)" id="1060" href="Cat.Thin.html#1060" class="Field">has-is-thin</a>    <a id="1075" class="Symbol">:</a> <a data-type="(C : Precategory o h) → Type (o ⊔ h)" id="1077" href="Cat.Thin.html#624" class="Record">is-thin</a> <a data-type="(C : Proset o h) → Precategory o h" id="1085" href="Cat.Thin.html#1026" class="Field">underlying</a>

  <a id="1099" class="Keyword">open</a> <a id="1104" class="Keyword">import</a> <a id="1111" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a data-type="(C : Proset o h) → Precategory o h" id="1125" href="Cat.Thin.html#1026" class="Field">underlying</a> <a id="1136" class="Keyword">public</a>
  <a id="1145" class="Keyword">open</a> <a data-type="(C : Precategory o h) → Type (o ⊔ h)" id="1150" href="Cat.Thin.html#624" class="Module">is-thin</a> <a data-type="(r : Proset o h) → is-thin (r .underlying)" id="1158" href="Cat.Thin.html#1060" class="Field">has-is-thin</a> <a id="1170" class="Keyword">public</a>

  <a id="Proset._≤_"></a><a data-type="(r : Proset o h) → Ob r → Ob r → Type h" id="1180" href="Cat.Thin.html#1180" class="Function Operator">_≤_</a> <a id="1184" class="Symbol">:</a> <a data-type="Precategory o h → Type o" id="1186" href="Cat.Base.html#1341" class="Function">Ob</a> <a id="1189" class="Symbol">→</a> <a data-type="Precategory o h → Type o" id="1191" href="Cat.Base.html#1341" class="Function">Ob</a> <a id="1194" class="Symbol">→</a> <a id="1196" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="1201" href="Cat.Thin.html#956" class="Bound">h</a>
  <a data-type="(r : Proset o h) → Ob r → Ob r → Type h" id="1205" href="Cat.Thin.html#1180" class="Function Operator">_≤_</a> <a id="1209" class="Symbol">=</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1211" href="Cat.Base.html#1358" class="Function">Hom</a>
</pre>
<p>The collection of all thin categories assembles into a subcategory of <span class="Agda"><a data-type="(o h : Level) → Precategory (lsuc o ⊔ lsuc h) (o ⊔ h)" href="Cat.Instances.StrictCat.html#2161" class="Function">Strict-Cat</a></span>, which we call <span class="Agda"><a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" href="Cat.Thin.html#946" class="Record">Proset</a></span>.</p>
<pre class="Agda"><a id="Prosets"></a><a data-type="(o h : Level) → Precategory (lsuc (o ⊔ h)) (o ⊔ h)" id="1351" href="Cat.Thin.html#1351" class="Function">Prosets</a> <a id="1359" class="Symbol">:</a> <a id="1361" class="Symbol">∀</a> <a id="1363" href="Cat.Thin.html#1363" class="Bound">o</a> <a id="1365" href="Cat.Thin.html#1365" class="Bound">h</a> <a id="1367" class="Symbol">→</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="1369" href="Cat.Base.html#644" class="Record">Precategory</a> <a id="1381" class="Symbol">(</a><a data-type="Level → Level" id="1382" href="Agda.Primitive.html#780" class="Primitive">lsuc</a> <a id="1387" class="Symbol">(</a><a id="1388" href="Cat.Thin.html#1363" class="Bound">o</a> <a data-type="Level → Level → Level" id="1390" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="1392" href="Cat.Thin.html#1365" class="Bound">h</a><a id="1393" class="Symbol">))</a> <a id="1396" class="Symbol">(</a><a id="1397" href="Cat.Thin.html#1363" class="Bound">o</a> <a data-type="Level → Level → Level" id="1399" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="1401" href="Cat.Thin.html#1365" class="Bound">h</a><a id="1402" class="Symbol">)</a>
<a data-type="(o h : Level) → Precategory (lsuc (o ⊔ h)) (o ⊔ h)" id="1404" href="Cat.Thin.html#1351" class="Function">Prosets</a> <a id="1412" href="Cat.Thin.html#1412" class="Bound">o</a> <a id="1414" href="Cat.Thin.html#1414" class="Bound">h</a> <a id="1416" class="Symbol">=</a> <a id="1418" href="Cat.Thin.html#1467" class="Function">proset</a> <a id="1425" class="Keyword">where</a>
  <a id="1433" class="Keyword">open</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="1438" href="Cat.Base.html#644" class="Module">Precategory</a>
  <a id="1452" class="Keyword">open</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="1457" href="Cat.Thin.html#946" class="Module">Proset</a>

  <a id="1467" href="Cat.Thin.html#1467" class="Function">proset</a> <a id="1474" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="1476" href="Cat.Base.html#644" class="Record">Precategory</a> <a id="1488" class="Symbol">_</a> <a id="1490" class="Symbol">_</a>
  <a id="1494" href="Cat.Thin.html#1467" class="Function">proset</a> <a id="1501" class="Symbol">.</a><a data-type="Precategory o h → Type o" id="1502" href="Cat.Base.html#1341" class="Field">Ob</a> <a id="1505" class="Symbol">=</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="1507" href="Cat.Thin.html#946" class="Record">Proset</a> <a id="1514" href="Cat.Thin.html#1412" class="Bound">o</a> <a id="1516" href="Cat.Thin.html#1414" class="Bound">h</a>
  <a id="1520" href="Cat.Thin.html#1467" class="Function">proset</a> <a id="1527" class="Symbol">.</a><a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1528" href="Cat.Base.html#1358" class="Field">Hom</a> <a id="1532" href="Cat.Thin.html#1532" class="Bound">C</a> <a id="1534" href="Cat.Thin.html#1534" class="Bound">D</a> <a id="1536" class="Symbol">=</a> <a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="1538" href="Cat.Base.html#6614" class="Record">Functor</a> <a id="1546" class="Symbol">(</a><a id="1547" href="Cat.Thin.html#1532" class="Bound">C</a> <a id="1549" class="Symbol">.</a><a data-type="(C : Proset o h) → Precategory o h" id="1550" href="Cat.Thin.html#1026" class="Field">underlying</a><a id="1560" class="Symbol">)</a> <a id="1562" class="Symbol">(</a><a id="1563" href="Cat.Thin.html#1534" class="Bound">D</a> <a id="1565" class="Symbol">.</a><a data-type="(C : Proset o h) → Precategory o h" id="1566" href="Cat.Thin.html#1026" class="Field">underlying</a><a id="1576" class="Symbol">)</a>
  <a id="1580" href="Cat.Thin.html#1467" class="Function">proset</a> <a id="1587" class="Symbol">.</a><a data-type="(r : Precategory o h) (x y : r .Ob) → is-set (r .Hom x y)" id="1588" href="Cat.Base.html#1706" class="Field">Hom-set</a> <a id="1596" class="Symbol">_</a> <a id="1598" href="Cat.Thin.html#1598" class="Bound">D</a> <a id="1600" class="Symbol">=</a> <a data-type="is-set (Ob D) → is-set (Functor C D)" id="1602" href="Cat.Instances.StrictCat.html#646" class="Function">Functor-is-set</a> <a id="1617" class="Symbol">(</a><a id="1618" href="Cat.Thin.html#1598" class="Bound">D</a> <a id="1620" class="Symbol">.</a><a data-type="(r : Poset o h) → is-set (Ob (r .underlying))" id="1621" href="Cat.Thin.html#726" class="Function">Ob-is-set</a><a id="1630" class="Symbol">)</a>
  <a id="1634" href="Cat.Thin.html#1467" class="Function">proset</a> <a id="1641" class="Symbol">.</a><a data-type="(r : Precategory o h) → r .Hom x x" id="1642" href="Cat.Base.html#2898" class="Field">id</a> <a id="1645" class="Symbol">=</a> <a data-type="Functor C C" id="1647" href="Cat.Base.html#10294" class="Function">Id</a>
  <a id="1652" href="Cat.Thin.html#1467" class="Function">proset</a> <a id="1659" class="Symbol">.</a><a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="1660" href="Cat.Base.html#2928" class="Field Operator">_∘_</a> <a id="1664" class="Symbol">=</a> <a data-type="Functor D E → Functor C D → Functor C E" id="1666" href="Cat.Base.html#8513" class="Function Operator">_F∘_</a>
  <a id="1673" href="Cat.Thin.html#1467" class="Function">proset</a> <a id="1680" class="Symbol">.</a><a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" id="1681" href="Cat.Base.html#3359" class="Field">idr</a> <a id="1685" href="Cat.Thin.html#1685" class="Bound">f</a> <a id="1687" class="Symbol">=</a> <a data-type="(p0 : (x : C .Ob) → F₀ F x ≡ F₀ G x) →
((f : C .Hom x y) →
 PathP (λ i → D .Hom (p0 x i) (p0 y i)) (F₁ F f) (F₁ G f)) →
F ≡ G" id="1689" href="Cat.Instances.Functor.html#3044" class="Function">Functor-path</a> <a id="1702" class="Symbol">(λ</a> <a id="1705" href="Cat.Thin.html#1705" class="Bound">_</a> <a id="1707" class="Symbol">→</a> <a data-type="x ≡ x" id="1709" href="1Lab.Path.html#3593" class="Function">refl</a><a id="1713" class="Symbol">)</a> <a id="1715" class="Symbol">λ</a> <a id="1717" href="Cat.Thin.html#1717" class="Bound">_</a> <a id="1719" class="Symbol">→</a> <a data-type="x ≡ x" id="1721" href="1Lab.Path.html#3593" class="Function">refl</a>
  <a id="1728" href="Cat.Thin.html#1467" class="Function">proset</a> <a id="1735" class="Symbol">.</a><a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" id="1736" href="Cat.Base.html#3404" class="Field">idl</a> <a id="1740" href="Cat.Thin.html#1740" class="Bound">f</a> <a id="1742" class="Symbol">=</a> <a data-type="(p0 : (x : C .Ob) → F₀ F x ≡ F₀ G x) →
((f : C .Hom x y) →
 PathP (λ i → D .Hom (p0 x i) (p0 y i)) (F₁ F f) (F₁ G f)) →
F ≡ G" id="1744" href="Cat.Instances.Functor.html#3044" class="Function">Functor-path</a> <a id="1757" class="Symbol">(λ</a> <a id="1760" href="Cat.Thin.html#1760" class="Bound">_</a> <a id="1762" class="Symbol">→</a> <a data-type="x ≡ x" id="1764" href="1Lab.Path.html#3593" class="Function">refl</a><a id="1768" class="Symbol">)</a> <a id="1770" class="Symbol">λ</a> <a id="1772" href="Cat.Thin.html#1772" class="Bound">_</a> <a id="1774" class="Symbol">→</a> <a data-type="x ≡ x" id="1776" href="1Lab.Path.html#3593" class="Function">refl</a>
  <a id="1783" href="Cat.Thin.html#1467" class="Function">proset</a> <a id="1790" class="Symbol">.</a><a data-type="(r : Precategory o h) (f : r .Hom y z) (g : r .Hom x y)
(h : r .Hom w x) →
r ._∘_ f (r ._∘_ g h) ≡ r ._∘_ (r ._∘_ f g) h" id="1791" href="Cat.Base.html#3779" class="Field">assoc</a> <a id="1797" href="Cat.Thin.html#1797" class="Bound">f</a> <a id="1799" href="Cat.Thin.html#1799" class="Bound">g</a> <a id="1801" href="Cat.Thin.html#1801" class="Bound">h</a> <a id="1803" class="Symbol">=</a> <a data-type="(p0 : (x : C .Ob) → F₀ F x ≡ F₀ G x) →
((f : C .Hom x y) →
 PathP (λ i → D .Hom (p0 x i) (p0 y i)) (F₁ F f) (F₁ G f)) →
F ≡ G" id="1805" href="Cat.Instances.Functor.html#3044" class="Function">Functor-path</a> <a id="1818" class="Symbol">(λ</a> <a id="1821" href="Cat.Thin.html#1821" class="Bound">_</a> <a id="1823" class="Symbol">→</a> <a data-type="x ≡ x" id="1825" href="1Lab.Path.html#3593" class="Function">refl</a><a id="1829" class="Symbol">)</a> <a id="1831" class="Symbol">λ</a> <a id="1833" href="Cat.Thin.html#1833" class="Bound">_</a> <a id="1835" class="Symbol">→</a> <a data-type="x ≡ x" id="1837" href="1Lab.Path.html#3593" class="Function">refl</a>
</pre>
<p>We also have a convenience function for making any set with a preorder into a <code class="sourceCode agda">ThinCat</code>.</p>
<pre class="Agda"><a id="1952" class="Keyword">module</a> <a id="1959" href="Cat.Thin.html#1959" class="Module">_</a> <a id="1961" class="Keyword">where</a>
  <a id="1969" class="Keyword">open</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="1974" href="Cat.Thin.html#946" class="Module">Proset</a>

  <a data-type="is-set A →
R₁ x x →
(R₁ x y → R₁ y z → R₁ x z) → is-prop (R₁ x y) → Proset ℓ ℓ&#39;" id="1984" href="Cat.Thin.html#1984" class="Function">make-proset</a> <a id="1996" class="Symbol">:</a> <a id="1998" class="Symbol">∀</a> <a id="2000" class="Symbol">{</a><a id="2001" href="Cat.Thin.html#2001" class="Bound">ℓ</a> <a id="2003" href="Cat.Thin.html#2003" class="Bound">ℓ&#39;</a><a id="2005" class="Symbol">}</a> <a id="2007" class="Symbol">{</a><a id="2008" href="Cat.Thin.html#2008" class="Bound">A</a> <a id="2010" class="Symbol">:</a> <a id="2012" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2017" href="Cat.Thin.html#2001" class="Bound">ℓ</a><a id="2018" class="Symbol">}</a> <a id="2020" class="Symbol">{</a><a id="2021" href="Cat.Thin.html#2021" class="Bound">R</a> <a id="2023" class="Symbol">:</a> <a id="2025" href="Cat.Thin.html#2008" class="Bound">A</a> <a id="2027" class="Symbol">→</a> <a id="2029" href="Cat.Thin.html#2008" class="Bound">A</a> <a id="2031" class="Symbol">→</a> <a id="2033" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2038" href="Cat.Thin.html#2003" class="Bound">ℓ&#39;</a><a id="2040" class="Symbol">}</a>
             <a id="2055" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="2057" href="1Lab.HLevel.html#3356" class="Function">is-set</a> <a id="2064" href="Cat.Thin.html#2008" class="Bound">A</a>
             <a id="2079" class="Symbol">→</a> <a id="2081" class="Symbol">(∀</a> <a id="2084" class="Symbol">{</a><a id="2085" href="Cat.Thin.html#2085" class="Bound">x</a><a id="2086" class="Symbol">}</a> <a id="2088" class="Symbol">→</a> <a id="2090" href="Cat.Thin.html#2021" class="Bound">R</a> <a id="2092" href="Cat.Thin.html#2085" class="Bound">x</a> <a id="2094" href="Cat.Thin.html#2085" class="Bound">x</a><a id="2095" class="Symbol">)</a>
             <a id="2110" class="Symbol">→</a> <a id="2112" class="Symbol">(∀</a> <a id="2115" class="Symbol">{</a><a id="2116" href="Cat.Thin.html#2116" class="Bound">x</a> <a id="2118" href="Cat.Thin.html#2118" class="Bound">y</a> <a id="2120" href="Cat.Thin.html#2120" class="Bound">z</a><a id="2121" class="Symbol">}</a> <a id="2123" class="Symbol">→</a> <a id="2125" href="Cat.Thin.html#2021" class="Bound">R</a> <a id="2127" href="Cat.Thin.html#2116" class="Bound">x</a> <a id="2129" href="Cat.Thin.html#2118" class="Bound">y</a> <a id="2131" class="Symbol">→</a> <a id="2133" href="Cat.Thin.html#2021" class="Bound">R</a> <a id="2135" href="Cat.Thin.html#2118" class="Bound">y</a> <a id="2137" href="Cat.Thin.html#2120" class="Bound">z</a> <a id="2139" class="Symbol">→</a> <a id="2141" href="Cat.Thin.html#2021" class="Bound">R</a> <a id="2143" href="Cat.Thin.html#2116" class="Bound">x</a> <a id="2145" href="Cat.Thin.html#2120" class="Bound">z</a><a id="2146" class="Symbol">)</a>
             <a id="2161" class="Symbol">→</a> <a id="2163" class="Symbol">(∀</a> <a id="2166" class="Symbol">{</a><a id="2167" href="Cat.Thin.html#2167" class="Bound">x</a> <a id="2169" href="Cat.Thin.html#2169" class="Bound">y</a><a id="2170" class="Symbol">}</a> <a id="2172" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="2174" href="1Lab.HLevel.html#2597" class="Function">is-prop</a> <a id="2182" class="Symbol">(</a><a id="2183" href="Cat.Thin.html#2021" class="Bound">R</a> <a id="2185" href="Cat.Thin.html#2167" class="Bound">x</a> <a id="2187" href="Cat.Thin.html#2169" class="Bound">y</a><a id="2188" class="Symbol">))</a>
             <a id="2204" class="Symbol">→</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="2206" href="Cat.Thin.html#946" class="Record">Proset</a> <a id="2213" href="Cat.Thin.html#2001" class="Bound">ℓ</a> <a id="2215" href="Cat.Thin.html#2003" class="Bound">ℓ&#39;</a>
  <a data-type="is-set A →
R₁ x x →
(R₁ x y → R₁ y z → R₁ x z) → is-prop (R₁ x y) → Proset ℓ ℓ&#39;" id="2220" href="Cat.Thin.html#1984" class="Function">make-proset</a> <a id="2232" class="Symbol">{</a><a id="2233" class="Argument">A</a> <a id="2235" class="Symbol">=</a> <a id="2237" href="Cat.Thin.html#2237" class="Bound">A</a><a id="2238" class="Symbol">}</a> <a id="2240" class="Symbol">{</a><a id="2241" href="Cat.Thin.html#2241" class="Bound">R</a><a id="2242" class="Symbol">}</a> <a id="2244" href="Cat.Thin.html#2244" class="Bound">Aset</a> <a id="2249" href="Cat.Thin.html#2249" class="Bound">Rrefl</a> <a id="2255" href="Cat.Thin.html#2255" class="Bound">Rtrans</a> <a id="2262" href="Cat.Thin.html#2262" class="Bound">Rprop</a> <a id="2268" class="Symbol">=</a> <a id="2270" href="Cat.Thin.html#2305" class="Function">tc</a> <a id="2273" class="Keyword">where</a>
    <a id="2283" class="Keyword">open</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="2288" href="Cat.Base.html#644" class="Module">Precategory</a>

    <a id="2305" href="Cat.Thin.html#2305" class="Function">tc</a> <a id="2308" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="2310" href="Cat.Thin.html#946" class="Record">Proset</a> <a id="2317" class="Symbol">_</a> <a id="2319" class="Symbol">_</a>
    <a id="2325" href="Cat.Thin.html#2305" class="Function">tc</a> <a id="2328" class="Symbol">.</a><a data-type="(C : Proset o h) → Precategory o h" id="2329" href="Cat.Thin.html#1026" class="Field">underlying</a> <a id="2340" class="Symbol">.</a><a data-type="Precategory o h → Type o" id="2341" href="Cat.Base.html#1341" class="Field">Ob</a>          <a id="2353" class="Symbol">=</a> <a id="2355" href="Cat.Thin.html#2237" class="Bound">A</a>
    <a id="2361" href="Cat.Thin.html#2305" class="Function">tc</a> <a id="2364" class="Symbol">.</a><a data-type="(C : Proset o h) → Precategory o h" id="2365" href="Cat.Thin.html#1026" class="Field">underlying</a> <a id="2376" class="Symbol">.</a><a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="2377" href="Cat.Base.html#1358" class="Field">Hom</a>         <a id="2389" class="Symbol">=</a> <a id="2391" href="Cat.Thin.html#2241" class="Bound">R</a>
    <a id="2397" href="Cat.Thin.html#2305" class="Function">tc</a> <a id="2400" class="Symbol">.</a><a data-type="(C : Proset o h) → Precategory o h" id="2401" href="Cat.Thin.html#1026" class="Field">underlying</a> <a id="2412" class="Symbol">.</a><a data-type="(r : Precategory o h) (x y : r .Ob) → is-set (r .Hom x y)" id="2413" href="Cat.Base.html#1706" class="Field">Hom-set</a> <a id="2421" class="Symbol">_</a> <a id="2423" class="Symbol">_</a> <a id="2425" class="Symbol">=</a> <a data-type="is-prop A → is-set A" id="2427" href="1Lab.HLevel.html#5554" class="Function">is-prop→is-set</a> <a id="2442" href="Cat.Thin.html#2262" class="Bound">Rprop</a>
    <a id="2452" href="Cat.Thin.html#2305" class="Function">tc</a> <a id="2455" class="Symbol">.</a><a data-type="(C : Proset o h) → Precategory o h" id="2456" href="Cat.Thin.html#1026" class="Field">underlying</a> <a id="2467" class="Symbol">.</a><a data-type="(r : Precategory o h) → r .Hom x x" id="2468" href="Cat.Base.html#2898" class="Field">id</a>          <a id="2480" class="Symbol">=</a> <a id="2482" href="Cat.Thin.html#2249" class="Bound">Rrefl</a>
    <a id="2492" href="Cat.Thin.html#2305" class="Function">tc</a> <a id="2495" class="Symbol">.</a><a data-type="(C : Proset o h) → Precategory o h" id="2496" href="Cat.Thin.html#1026" class="Field">underlying</a> <a id="2507" class="Symbol">.</a><a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2508" href="Cat.Base.html#2928" class="Field Operator">_∘_</a> <a id="2512" href="Cat.Thin.html#2512" class="Bound">f</a> <a id="2514" href="Cat.Thin.html#2514" class="Bound">g</a>     <a id="2520" class="Symbol">=</a> <a id="2522" href="Cat.Thin.html#2255" class="Bound">Rtrans</a> <a id="2529" href="Cat.Thin.html#2514" class="Bound">g</a> <a id="2531" href="Cat.Thin.html#2512" class="Bound">f</a>
    <a id="2537" href="Cat.Thin.html#2305" class="Function">tc</a> <a id="2540" class="Symbol">.</a><a data-type="(C : Proset o h) → Precategory o h" id="2541" href="Cat.Thin.html#1026" class="Field">underlying</a> <a id="2552" class="Symbol">.</a><a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" id="2553" href="Cat.Base.html#3359" class="Field">idr</a> <a id="2557" href="Cat.Thin.html#2557" class="Bound">f</a>       <a id="2565" class="Symbol">=</a> <a id="2567" href="Cat.Thin.html#2262" class="Bound">Rprop</a> <a id="2573" class="Symbol">_</a> <a id="2575" class="Symbol">_</a>
    <a id="2581" href="Cat.Thin.html#2305" class="Function">tc</a> <a id="2584" class="Symbol">.</a><a data-type="(C : Proset o h) → Precategory o h" id="2585" href="Cat.Thin.html#1026" class="Field">underlying</a> <a id="2596" class="Symbol">.</a><a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" id="2597" href="Cat.Base.html#3404" class="Field">idl</a> <a id="2601" href="Cat.Thin.html#2601" class="Bound">f</a>       <a id="2609" class="Symbol">=</a> <a id="2611" href="Cat.Thin.html#2262" class="Bound">Rprop</a> <a id="2617" class="Symbol">_</a> <a id="2619" class="Symbol">_</a>
    <a id="2625" href="Cat.Thin.html#2305" class="Function">tc</a> <a id="2628" class="Symbol">.</a><a data-type="(C : Proset o h) → Precategory o h" id="2629" href="Cat.Thin.html#1026" class="Field">underlying</a> <a id="2640" class="Symbol">.</a><a data-type="(r : Precategory o h) (f : r .Hom y z) (g : r .Hom x y)
(h : r .Hom w x) →
r ._∘_ f (r ._∘_ g h) ≡ r ._∘_ (r ._∘_ f g) h" id="2641" href="Cat.Base.html#3779" class="Field">assoc</a> <a id="2647" href="Cat.Thin.html#2647" class="Bound">f</a> <a id="2649" href="Cat.Thin.html#2649" class="Bound">g</a> <a id="2651" href="Cat.Thin.html#2651" class="Bound">h</a> <a id="2653" class="Symbol">=</a> <a id="2655" href="Cat.Thin.html#2262" class="Bound">Rprop</a> <a id="2661" class="Symbol">_</a> <a id="2663" class="Symbol">_</a>

    <a id="2670" href="Cat.Thin.html#2305" class="Function">tc</a> <a id="2673" class="Symbol">.</a><a data-type="(r : Proset o h) → is-thin (r .underlying)" id="2674" href="Cat.Thin.html#1060" class="Field">has-is-thin</a> <a id="2686" class="Symbol">.</a><a data-type="(r : Poset o h) → is-set (Ob (r .underlying))" id="2687" href="Cat.Thin.html#726" class="Field">is-thin.Ob-is-set</a> <a id="2705" class="Symbol">=</a> <a id="2707" href="Cat.Thin.html#2244" class="Bound">Aset</a>
    <a id="2716" href="Cat.Thin.html#2305" class="Function">tc</a> <a id="2719" class="Symbol">.</a><a data-type="(r : Proset o h) → is-thin (r .underlying)" id="2720" href="Cat.Thin.html#1060" class="Field">has-is-thin</a> <a id="2732" class="Symbol">.</a><a data-type="(r : Poset o h) (A B₁ : r .underlying .Ob) →
is-prop (Hom (r .underlying) A B₁)" id="2733" href="Cat.Thin.html#752" class="Field">is-thin.Hom-is-prop</a> <a id="2753" href="Cat.Thin.html#2753" class="Bound">A</a> <a id="2755" href="Cat.Thin.html#2755" class="Bound">B</a> <a id="2757" href="Cat.Thin.html#2757" class="Bound">x</a> <a id="2759" href="Cat.Thin.html#2759" class="Bound">y</a> <a id="2761" class="Symbol">=</a> <a id="2763" href="Cat.Thin.html#2262" class="Bound">Rprop</a> <a id="2769" href="Cat.Thin.html#2757" class="Bound">x</a> <a id="2771" href="Cat.Thin.html#2759" class="Bound">y</a>
</pre>
<h1 id="posets"><a href="#posets" class="header-link">Posets<span class="header-link-emoji">🔗</span></a></h1>
<p>We refer to a [univalent] <span class="Agda"><a data-type="(C : Precategory o h) → Type (o ⊔ h)" href="Cat.Thin.html#624" class="Record">thin</a></span> category as a <strong>poset</strong>, short for partially-ordered set. Recall that a category <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span> is <em>univalent</em> when the type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mrow><mo stretchy="false">(</mo><mi>B</mi><mo>:</mo><mi mathvariant="script">C</mi><mo stretchy="false">)</mo></mrow></msub><mi>A</mi><mo>≅</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\sum_{(B : \ca{C})} A \cong B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2247em;vertical-align:-0.4747em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2253em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mrel mtight">:</span><span class="mord mathcal mtight" style="margin-right:0.05834em;">C</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4747em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> is contractible for any fixed <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>:</mo><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">A : \ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span> or (more useful here) we have a function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">o</mi><mo>→</mo><mi mathvariant="normal">p</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">h</mi></mrow><mo>:</mo><mi>A</mi><mo>≅</mo><mi>B</mi><mo>→</mo><mi>A</mi><mo>≡</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\id{iso→path} : A \cong B \to A \equiv B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">iso</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathrm">path</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> sending the identity isomorphism to <span class="Agda"><a data-type="x ≡ x" href="1Lab.Path.html#3593" class="Function">refl</a></span>.</p>
<p>In a thin category, any pair of maps <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>→</mo><mi>B</mi><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mi>B</mi><mo>←</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A \to B) \times (B \ot A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span> is an isomorphism, so in effect we have a map <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>→</mo><mi>B</mi><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mi>B</mi><mo>→</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>A</mi><mo>≡</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A \to B) \times (B \to A) \to (A \equiv B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>:</span> If a thin category is a preordered set, then a <em>univalent</em> thin category is a partially ordered set.</p>
<pre class="Agda"><a id="3441" class="Keyword">record</a> <a id="Poset"></a><a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="3448" href="Cat.Thin.html#3448" class="Record">Poset</a> <a id="3454" class="Symbol">(</a><a id="3455" href="Cat.Thin.html#3455" class="Bound">o</a> <a id="3457" href="Cat.Thin.html#3457" class="Bound">h</a> <a id="3459" class="Symbol">:</a> <a data-type="Type" id="3461" href="Agda.Primitive.html#597" class="Postulate">Level</a><a id="3466" class="Symbol">)</a> <a id="3468" class="Symbol">:</a> <a id="3470" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="3475" class="Symbol">(</a><a data-type="Level → Level" id="3476" href="Agda.Primitive.html#780" class="Primitive">lsuc</a> <a id="3481" class="Symbol">(</a><a id="3482" href="Cat.Thin.html#3455" class="Bound">o</a> <a data-type="Level → Level → Level" id="3484" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="3486" href="Cat.Thin.html#3457" class="Bound">h</a><a id="3487" class="Symbol">))</a> <a id="3490" class="Keyword">where</a>
  <a id="3498" class="Keyword">no-eta-equality</a>
  <a id="3516" class="Keyword">field</a>
    <a id="3526" class="Symbol">{</a><a id="Poset.underlying"></a><a data-type="Poset o h → Precategory o h" id="3527" href="Cat.Thin.html#3527" class="Field">underlying</a><a id="3537" class="Symbol">}</a>     <a id="3543" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="3545" href="Cat.Base.html#644" class="Record">Precategory</a> <a id="3557" href="Cat.Thin.html#3455" class="Bound">o</a> <a id="3559" href="Cat.Thin.html#3457" class="Bound">h</a>
    <a id="Poset.has-is-thin"></a><a data-type="(r : Poset o h) → is-thin (r .underlying)" id="3565" href="Cat.Thin.html#3565" class="Field">has-is-thin</a>      <a id="3582" class="Symbol">:</a> <a data-type="(C : Precategory o h) → Type (o ⊔ h)" id="3584" href="Cat.Thin.html#624" class="Record">is-thin</a> <a data-type="Poset o h → Precategory o h" id="3592" href="Cat.Thin.html#3527" class="Field">underlying</a>
    <a id="Poset.has-is-univalent"></a><a data-type="(r : Poset o h) → is-category (r .underlying)" id="3607" href="Cat.Thin.html#3607" class="Field">has-is-univalent</a> <a id="3624" class="Symbol">:</a> <a data-type="(C : Precategory o h) → Type (o ⊔ h)" id="3626" href="Cat.Univalent.html#946" class="Function">is-category</a> <a data-type="Poset o h → Precategory o h" id="3638" href="Cat.Thin.html#3527" class="Field">underlying</a>

  <a id="3652" class="Keyword">open</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="3657" href="Cat.Base.html#644" class="Module">Precategory</a> <a data-type="Poset o h → Precategory o h" id="3669" href="Cat.Thin.html#3527" class="Field">underlying</a> <a id="3680" class="Keyword">public</a>
  <a id="3689" class="Keyword">open</a> <a data-type="(C : Precategory o h) → Type (o ⊔ h)" id="3694" href="Cat.Thin.html#624" class="Module">is-thin</a> <a data-type="(r : Poset o h) → is-thin (r .underlying)" id="3702" href="Cat.Thin.html#3565" class="Field">has-is-thin</a> <a id="3714" class="Keyword">public</a>

  <a id="3724" class="Keyword">open</a> <a id="3729" class="Keyword">import</a> <a id="3736" href="Cat.Univalent.html" class="Module">Cat.Univalent</a> <a data-type="Poset o h → Precategory o h" id="3750" href="Cat.Thin.html#3527" class="Field">underlying</a>
</pre>
<p>Sincce posets are most commonly considered in the context of order theory, we abbreviate their <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>hom</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\hom</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mop">hom</span></span></span></span>-props</span> by <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>≤</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a \le b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>.</span> Similarly, we rename the identity, composition and univalence operations to order-theoretic names.</p>
<pre class="Agda">  <a id="Poset._≤_"></a><a data-type="(r : Poset o h) → Ob r → Ob r → Type h" id="4000" href="Cat.Thin.html#4000" class="Function Operator">_≤_</a> <a id="4004" class="Symbol">:</a> <a data-type="Precategory o h → Type o" id="4006" href="Cat.Base.html#1341" class="Function">Ob</a> <a id="4009" class="Symbol">→</a> <a data-type="Precategory o h → Type o" id="4011" href="Cat.Base.html#1341" class="Function">Ob</a> <a id="4014" class="Symbol">→</a> <a id="4016" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="4021" href="Cat.Thin.html#3457" class="Bound">h</a>
  <a data-type="(r : Poset o h) → Ob r → Ob r → Type h" id="4025" href="Cat.Thin.html#4000" class="Function Operator">_≤_</a> <a id="4029" class="Symbol">=</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="4031" href="Cat.Base.html#1358" class="Function">Hom</a>

  <a id="Poset.reflexive"></a><a data-type="(r : Poset o h) → (r ≤ x) x" id="4038" href="Cat.Thin.html#4038" class="Function">reflexive</a> <a id="4048" class="Symbol">:</a> <a id="4050" class="Symbol">∀</a> <a id="4052" class="Symbol">{</a><a id="4053" href="Cat.Thin.html#4053" class="Bound">x</a><a id="4054" class="Symbol">}</a> <a id="4056" class="Symbol">→</a> <a id="4058" href="Cat.Thin.html#4053" class="Bound">x</a> <a data-type="(r : Poset o h) → Ob r → Ob r → Type h" id="4060" href="Cat.Thin.html#4000" class="Function Operator">≤</a> <a id="4062" href="Cat.Thin.html#4053" class="Bound">x</a>
  <a data-type="(r : Poset o h) → (r ≤ x) x" id="4066" href="Cat.Thin.html#4038" class="Function">reflexive</a> <a id="4076" class="Symbol">=</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="4078" href="Cat.Base.html#2898" class="Function">id</a>

  <a id="Poset.transitive"></a><a data-type="(r : Poset o h) → (r ≤ x) y → (r ≤ y) z → (r ≤ x) z" id="4084" href="Cat.Thin.html#4084" class="Function">transitive</a> <a id="4095" class="Symbol">:</a> <a id="4097" class="Symbol">∀</a> <a id="4099" class="Symbol">{</a><a id="4100" href="Cat.Thin.html#4100" class="Bound">x</a> <a id="4102" href="Cat.Thin.html#4102" class="Bound">y</a> <a id="4104" href="Cat.Thin.html#4104" class="Bound">z</a><a id="4105" class="Symbol">}</a> <a id="4107" class="Symbol">→</a> <a id="4109" href="Cat.Thin.html#4100" class="Bound">x</a> <a data-type="(r : Poset o h) → Ob r → Ob r → Type h" id="4111" href="Cat.Thin.html#4000" class="Function Operator">≤</a> <a id="4113" href="Cat.Thin.html#4102" class="Bound">y</a> <a id="4115" class="Symbol">→</a> <a id="4117" href="Cat.Thin.html#4102" class="Bound">y</a> <a data-type="(r : Poset o h) → Ob r → Ob r → Type h" id="4119" href="Cat.Thin.html#4000" class="Function Operator">≤</a> <a id="4121" href="Cat.Thin.html#4104" class="Bound">z</a> <a id="4123" class="Symbol">→</a> <a id="4125" href="Cat.Thin.html#4100" class="Bound">x</a> <a data-type="(r : Poset o h) → Ob r → Ob r → Type h" id="4127" href="Cat.Thin.html#4000" class="Function Operator">≤</a> <a id="4129" href="Cat.Thin.html#4104" class="Bound">z</a>
  <a data-type="(r : Poset o h) → (r ≤ x) y → (r ≤ y) z → (r ≤ x) z" id="4133" href="Cat.Thin.html#4084" class="Function">transitive</a> <a id="4144" href="Cat.Thin.html#4144" class="Bound">f</a> <a id="4146" href="Cat.Thin.html#4146" class="Bound">g</a> <a id="4148" class="Symbol">=</a> <a id="4150" href="Cat.Thin.html#4146" class="Bound">g</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="4152" href="Cat.Base.html#2928" class="Function Operator">∘</a> <a id="4154" href="Cat.Thin.html#4144" class="Bound">f</a>
</pre>
<p>Any pair of opposing morphisms in a proset (thus in a poset) gives an isomorphism. The “inversion” equations hold by thinness: Since <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>f</mi><mo>∘</mo><mi>g</mi><mo stretchy="false">)</mo><mo>:</mo><mi>A</mi><mo>≤</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">(f \circ g) : A \le A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.136em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>,</span> then it must be equal to <span class="Agda"><a data-type="(r : Poset o h) → (r ≤ x) x" href="Cat.Thin.html#4038" class="Function">reflexive</a></span> above.</p>
<pre class="Agda">  <a id="Poset.antisym"></a><a data-type="(r : Poset o h) → (r ≤ x) y → (r ≤ y) x → x ≡ y" id="4381" href="Cat.Thin.html#4381" class="Function">antisym</a> <a id="4389" class="Symbol">:</a> <a id="4391" class="Symbol">∀</a> <a id="4393" class="Symbol">{</a><a id="4394" href="Cat.Thin.html#4394" class="Bound">x</a> <a id="4396" href="Cat.Thin.html#4396" class="Bound">y</a><a id="4397" class="Symbol">}</a> <a id="4399" class="Symbol">→</a> <a id="4401" href="Cat.Thin.html#4394" class="Bound">x</a> <a data-type="(r : Poset o h) → Ob r → Ob r → Type h" id="4403" href="Cat.Thin.html#4000" class="Function Operator">≤</a> <a id="4405" href="Cat.Thin.html#4396" class="Bound">y</a> <a id="4407" class="Symbol">→</a> <a id="4409" href="Cat.Thin.html#4396" class="Bound">y</a> <a data-type="(r : Poset o h) → Ob r → Ob r → Type h" id="4411" href="Cat.Thin.html#4000" class="Function Operator">≤</a> <a id="4413" href="Cat.Thin.html#4394" class="Bound">x</a> <a id="4415" class="Symbol">→</a> <a id="4417" href="Cat.Thin.html#4394" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="4419" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="4421" href="Cat.Thin.html#4396" class="Bound">y</a>
  <a data-type="(r : Poset o h) → (r ≤ x) y → (r ≤ y) x → x ≡ y" id="4425" href="Cat.Thin.html#4381" class="Function">antisym</a> <a id="4433" href="Cat.Thin.html#4433" class="Bound">f</a> <a id="4435" href="Cat.Thin.html#4435" class="Bound">g</a> <a id="4437" class="Symbol">=</a> <a data-type="(C : Precategory o h) → is-category C → (C ≅ A) B₁ → A ≡ B₁" id="4439" href="Cat.Univalent.html#2601" class="Function">iso→path</a> <a data-type="(r : Poset o h) → is-category (r .underlying)" id="4448" href="Cat.Thin.html#3607" class="Field">has-is-univalent</a>
    <a id="4469" class="Symbol">(</a><a id="4470" class="Keyword">record</a>
      <a id="4483" class="Symbol">{</a> <a data-type="(C ≅ a) b → Hom C a b" id="4485" href="Cat.Morphism.html#1965" class="Field">to</a> <a id="4488" class="Symbol">=</a> <a id="4490" href="Cat.Thin.html#4433" class="Bound">f</a>
      <a id="4498" class="Symbol">;</a> <a data-type="(C ≅ a) b → Hom C b a" id="4500" href="Cat.Morphism.html#1988" class="Field">from</a> <a id="4505" class="Symbol">=</a> <a id="4507" href="Cat.Thin.html#4435" class="Bound">g</a>
      <a id="4515" class="Symbol">;</a> <a data-type="(r : (C ≅ a) b) → Inverses C (r .to) (r .from)" id="4517" href="Cat.Morphism.html#2011" class="Field">inverses</a> <a id="4526" class="Symbol">=</a> <a id="4528" class="Keyword">record</a>
        <a id="4543" class="Symbol">{</a> <a data-type="(r : (C ≅ a) b) → (C ∘ r .to) (r .from) ≡ id C" id="4545" href="Cat.Morphism.html#1576" class="Field">invˡ</a> <a id="4550" class="Symbol">=</a> <a data-type="(r : Poset o h) (A B₁ : r .underlying .Ob) →
is-prop (Hom (r .underlying) A B₁)" id="4552" href="Cat.Thin.html#752" class="Function">Hom-is-prop</a> <a id="4564" class="Symbol">_</a> <a id="4566" class="Symbol">_</a> <a id="4568" class="Symbol">_</a> <a id="4570" class="Symbol">_</a> <a id="4572" class="Symbol">;</a> <a data-type="(r : (C ≅ a) b) → (C ∘ r .from) (r .to) ≡ id C" id="4574" href="Cat.Morphism.html#1598" class="Field">invʳ</a> <a id="4579" class="Symbol">=</a> <a data-type="(r : Poset o h) (A B₁ : r .underlying .Ob) →
is-prop (Hom (r .underlying) A B₁)" id="4581" href="Cat.Thin.html#752" class="Function">Hom-is-prop</a> <a id="4593" class="Symbol">_</a> <a id="4595" class="Symbol">_</a> <a id="4597" class="Symbol">_</a> <a id="4599" class="Symbol">_</a> <a id="4601" class="Symbol">}</a> <a id="4603" class="Symbol">})</a>
</pre>
<p>Forgetting the univalence datum lets us turn a <span class="Agda"><a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" href="Cat.Thin.html#3448" class="Record">Poset</a></span> into a <span class="Agda"><a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" href="Cat.Thin.html#946" class="Record">Proset</a></span>.</p>
<pre class="Agda">  <a id="Poset.→Proset"></a><a data-type="(r : Poset o h) → Proset o h" id="4708" href="Cat.Thin.html#4708" class="Function">→Proset</a> <a id="4716" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="4718" href="Cat.Thin.html#946" class="Record">Proset</a> <a id="4725" href="Cat.Thin.html#3455" class="Bound">o</a> <a id="4727" href="Cat.Thin.html#3457" class="Bound">h</a>
  <a data-type="(r : Poset o h) → Proset o h" id="4731" href="Cat.Thin.html#4708" class="Function">→Proset</a> <a id="4739" class="Symbol">.</a><a data-type="(C : Proset o h) → Precategory o h" id="4740" href="Cat.Thin.html#1026" class="Field">Proset.underlying</a> <a id="4758" class="Symbol">=</a> <a data-type="Poset o h → Precategory o h" id="4760" href="Cat.Thin.html#3527" class="Field">underlying</a>
  <a data-type="(r : Poset o h) → Proset o h" id="4773" href="Cat.Thin.html#4708" class="Function">→Proset</a> <a id="4781" class="Symbol">.</a><a data-type="(r : Proset o h) → is-thin (r .underlying)" id="4782" href="Cat.Thin.html#1060" class="Field">Proset.has-is-thin</a>  <a id="4802" class="Symbol">=</a> <a data-type="(r : Poset o h) → is-thin (r .underlying)" id="4804" href="Cat.Thin.html#3565" class="Field">has-is-thin</a>
</pre>
<h2 id="making-posets"><a href="#making-posets" class="header-link">Making posets<span class="header-link-emoji">🔗</span></a></h2>
<p><a href="1Lab.HLevel.Sets.html#rijkes-theorem">Rijke’s theorem</a> says that any type equipped with a reflexive relation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∼</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \sim y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> which implies <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≡</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \equiv y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> is automatically a set. If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≤</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \le y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> is a reflexive, antisymmetric relation, we can take the relation <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∼</mo><mi>y</mi><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo>≤</mo><mi>y</mi><mo stretchy="false">)</mo><mo>∧</mo><mo stretchy="false">(</mo><mi>y</mi><mo>≤</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x \sim y = (x \le y) \land (y \le x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>,</span> which is evidently reflexive and, by antisymmetry, implies <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≡</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \equiv y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>.</span></p>
<pre class="Agda"><a id="5230" class="Keyword">module</a> <a id="5237" href="Cat.Thin.html#5237" class="Module">_</a> <a id="5239" class="Keyword">where</a>
  <a id="5247" class="Keyword">open</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="5252" href="Cat.Thin.html#3448" class="Module">Poset</a>

  <a data-type="R₁ x x →
(R₁ x y → R₁ y z → R₁ x z) →
(R₁ x y → R₁ y x → x ≡ y) → is-prop (R₁ x y) → Poset ℓ ℓ&#39;" id="5261" href="Cat.Thin.html#5261" class="Function">make-poset</a> <a id="5272" class="Symbol">:</a> <a id="5274" class="Symbol">∀</a> <a id="5276" class="Symbol">{</a><a id="5277" href="Cat.Thin.html#5277" class="Bound">ℓ</a> <a id="5279" href="Cat.Thin.html#5279" class="Bound">ℓ&#39;</a><a id="5281" class="Symbol">}</a> <a id="5283" class="Symbol">{</a><a id="5284" href="Cat.Thin.html#5284" class="Bound">A</a> <a id="5286" class="Symbol">:</a> <a id="5288" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="5293" href="Cat.Thin.html#5277" class="Bound">ℓ</a><a id="5294" class="Symbol">}</a> <a id="5296" class="Symbol">{</a><a id="5297" href="Cat.Thin.html#5297" class="Bound">R</a> <a id="5299" class="Symbol">:</a> <a id="5301" href="Cat.Thin.html#5284" class="Bound">A</a> <a id="5303" class="Symbol">→</a> <a id="5305" href="Cat.Thin.html#5284" class="Bound">A</a> <a id="5307" class="Symbol">→</a> <a id="5309" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="5314" href="Cat.Thin.html#5279" class="Bound">ℓ&#39;</a><a id="5316" class="Symbol">}</a>
             <a id="5331" class="Symbol">→</a> <a id="5333" class="Symbol">(∀</a> <a id="5336" class="Symbol">{</a><a id="5337" href="Cat.Thin.html#5337" class="Bound">x</a><a id="5338" class="Symbol">}</a> <a id="5340" class="Symbol">→</a> <a id="5342" href="Cat.Thin.html#5297" class="Bound">R</a> <a id="5344" href="Cat.Thin.html#5337" class="Bound">x</a> <a id="5346" href="Cat.Thin.html#5337" class="Bound">x</a><a id="5347" class="Symbol">)</a>
             <a id="5362" class="Symbol">→</a> <a id="5364" class="Symbol">(∀</a> <a id="5367" class="Symbol">{</a><a id="5368" href="Cat.Thin.html#5368" class="Bound">x</a> <a id="5370" href="Cat.Thin.html#5370" class="Bound">y</a> <a id="5372" href="Cat.Thin.html#5372" class="Bound">z</a><a id="5373" class="Symbol">}</a> <a id="5375" class="Symbol">→</a> <a id="5377" href="Cat.Thin.html#5297" class="Bound">R</a> <a id="5379" href="Cat.Thin.html#5368" class="Bound">x</a> <a id="5381" href="Cat.Thin.html#5370" class="Bound">y</a> <a id="5383" class="Symbol">→</a> <a id="5385" href="Cat.Thin.html#5297" class="Bound">R</a> <a id="5387" href="Cat.Thin.html#5370" class="Bound">y</a> <a id="5389" href="Cat.Thin.html#5372" class="Bound">z</a> <a id="5391" class="Symbol">→</a> <a id="5393" href="Cat.Thin.html#5297" class="Bound">R</a> <a id="5395" href="Cat.Thin.html#5368" class="Bound">x</a> <a id="5397" href="Cat.Thin.html#5372" class="Bound">z</a><a id="5398" class="Symbol">)</a>
             <a id="5413" class="Symbol">→</a> <a id="5415" class="Symbol">(∀</a> <a id="5418" class="Symbol">{</a><a id="5419" href="Cat.Thin.html#5419" class="Bound">x</a> <a id="5421" href="Cat.Thin.html#5421" class="Bound">y</a><a id="5422" class="Symbol">}</a> <a id="5424" class="Symbol">→</a> <a id="5426" href="Cat.Thin.html#5297" class="Bound">R</a> <a id="5428" href="Cat.Thin.html#5419" class="Bound">x</a> <a id="5430" href="Cat.Thin.html#5421" class="Bound">y</a> <a id="5432" class="Symbol">→</a> <a id="5434" href="Cat.Thin.html#5297" class="Bound">R</a> <a id="5436" href="Cat.Thin.html#5421" class="Bound">y</a> <a id="5438" href="Cat.Thin.html#5419" class="Bound">x</a> <a id="5440" class="Symbol">→</a> <a id="5442" href="Cat.Thin.html#5419" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="5444" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="5446" href="Cat.Thin.html#5421" class="Bound">y</a><a id="5447" class="Symbol">)</a>
             <a id="5462" class="Symbol">→</a> <a id="5464" class="Symbol">(∀</a> <a id="5467" class="Symbol">{</a><a id="5468" href="Cat.Thin.html#5468" class="Bound">x</a> <a id="5470" href="Cat.Thin.html#5470" class="Bound">y</a><a id="5471" class="Symbol">}</a> <a id="5473" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="5475" href="1Lab.HLevel.html#2597" class="Function">is-prop</a> <a id="5483" class="Symbol">(</a><a id="5484" href="Cat.Thin.html#5297" class="Bound">R</a> <a id="5486" href="Cat.Thin.html#5468" class="Bound">x</a> <a id="5488" href="Cat.Thin.html#5470" class="Bound">y</a><a id="5489" class="Symbol">))</a>
             <a id="5505" class="Symbol">→</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="5507" href="Cat.Thin.html#3448" class="Record">Poset</a> <a id="5513" href="Cat.Thin.html#5277" class="Bound">ℓ</a> <a id="5515" href="Cat.Thin.html#5279" class="Bound">ℓ&#39;</a>
</pre>
<p>Thus, to make a poset, it suffices to have a type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> (any old type!), a relation on <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>,</span> and witnesses of reflexivity, transitivity, and antisymmetry. We derive that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> is a set using Rijke’s theorem as described above, and prove that any antisymmetric proset is univalent.</p>
<pre class="Agda">  <a data-type="R₁ x x →
(R₁ x y → R₁ y z → R₁ x z) →
(R₁ x y → R₁ y x → x ≡ y) → is-prop (R₁ x y) → Poset ℓ ℓ&#39;" id="5810" href="Cat.Thin.html#5261" class="Function">make-poset</a> <a id="5821" class="Symbol">{</a><a id="5822" class="Argument">A</a> <a id="5824" class="Symbol">=</a> <a id="5826" href="Cat.Thin.html#5826" class="Bound">A</a><a id="5827" class="Symbol">}</a> <a id="5829" class="Symbol">{</a><a id="5830" href="Cat.Thin.html#5830" class="Bound">R</a><a id="5831" class="Symbol">}</a> <a id="5833" href="Cat.Thin.html#5833" class="Bound">Rrefl</a> <a id="5839" href="Cat.Thin.html#5839" class="Bound">Rtrans</a> <a id="5846" href="Cat.Thin.html#5846" class="Bound">Rantisym</a> <a id="5855" href="Cat.Thin.html#5855" class="Bound">Rprop</a> <a id="5861" class="Symbol">=</a> <a id="5863" href="Cat.Thin.html#6210" class="Function">tc</a> <a id="5866" class="Keyword">where</a>
    <a id="5876" class="Keyword">abstract</a>
      <a id="5891" href="Cat.Thin.html#5891" class="Function">Aset</a> <a id="5896" class="Symbol">:</a> <a data-type="Type ℓ → Type ℓ" id="5898" href="1Lab.HLevel.html#3356" class="Function">is-set</a> <a id="5905" href="Cat.Thin.html#5826" class="Bound">A</a>
      <a id="5913" href="Cat.Thin.html#5891" class="Function">Aset</a> <a id="5918" class="Symbol">=</a> <a data-type="R₁ x x → (R₁ x y → x ≡ y) → is-prop (R₁ x y) → is-set A" id="5920" href="1Lab.HLevel.Sets.html#2285" class="Function">Rijke-is-set</a> <a id="5933" class="Symbol">{</a><a id="5934" class="Argument">R</a> <a id="5936" class="Symbol">=</a> <a id="5938" class="Symbol">λ</a> <a id="5940" href="Cat.Thin.html#5940" class="Bound">x</a> <a id="5942" href="Cat.Thin.html#5942" class="Bound">y</a> <a id="5944" class="Symbol">→</a> <a id="5946" href="Cat.Thin.html#5830" class="Bound">R</a> <a id="5948" href="Cat.Thin.html#5940" class="Bound">x</a> <a id="5950" href="Cat.Thin.html#5942" class="Bound">y</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="5952" href="1Lab.Type.html#1846" class="Function Operator">×</a> <a id="5954" href="Cat.Thin.html#5830" class="Bound">R</a> <a id="5956" href="Cat.Thin.html#5942" class="Bound">y</a> <a id="5958" href="Cat.Thin.html#5940" class="Bound">x</a><a id="5959" class="Symbol">}</a>
        <a id="5969" class="Symbol">(</a><a id="5970" href="Cat.Thin.html#5833" class="Bound">Rrefl</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="5976" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5978" href="Cat.Thin.html#5833" class="Bound">Rrefl</a><a id="5983" class="Symbol">)</a>
        <a id="5993" class="Symbol">(λ</a> <a id="5996" class="Symbol">(</a><a id="5997" href="Cat.Thin.html#5997" class="Bound">f</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="5999" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="6001" href="Cat.Thin.html#6001" class="Bound">g</a><a id="6002" class="Symbol">)</a> <a id="6004" class="Symbol">→</a> <a id="6006" href="Cat.Thin.html#5846" class="Bound">Rantisym</a> <a id="6015" href="Cat.Thin.html#5997" class="Bound">f</a> <a id="6017" href="Cat.Thin.html#6001" class="Bound">g</a><a id="6018" class="Symbol">)</a>
        <a id="6028" class="Symbol">λ</a> <a id="6030" href="Cat.Thin.html#6030" class="Bound">x</a> <a id="6032" href="Cat.Thin.html#6032" class="Bound">y</a> <a id="6034" href="Cat.Thin.html#6034" class="Bound">i</a> <a id="6036" class="Symbol">→</a> <a id="6038" href="Cat.Thin.html#5855" class="Bound">Rprop</a> <a id="6044" class="Symbol">(</a><a id="6045" href="Cat.Thin.html#6030" class="Bound">x</a> <a id="6047" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="6048" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="6051" class="Symbol">)</a> <a id="6053" class="Symbol">(</a><a id="6054" href="Cat.Thin.html#6032" class="Bound">y</a> <a id="6056" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="6057" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="6060" class="Symbol">)</a> <a id="6062" href="Cat.Thin.html#6034" class="Bound">i</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="6064" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="6066" href="Cat.Thin.html#5855" class="Bound">Rprop</a> <a id="6072" class="Symbol">(</a><a id="6073" href="Cat.Thin.html#6030" class="Bound">x</a> <a id="6075" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="6076" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="6079" class="Symbol">)</a> <a id="6081" class="Symbol">(</a><a id="6082" href="Cat.Thin.html#6032" class="Bound">y</a> <a id="6084" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="6085" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="6088" class="Symbol">)</a> <a id="6090" href="Cat.Thin.html#6034" class="Bound">i</a>

    <a id="6097" class="Keyword">open</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="6102" href="Cat.Thin.html#946" class="Module">Proset</a> <a id="6109" class="Symbol">(</a><a data-type="is-set A →
R₁ x x →
(R₁ x y → R₁ y z → R₁ x z) → is-prop (R₁ x y) → Proset ℓ ℓ&#39;" id="6110" href="Cat.Thin.html#1984" class="Function">make-proset</a> <a id="6122" href="Cat.Thin.html#5891" class="Function">Aset</a> <a id="6127" href="Cat.Thin.html#5833" class="Bound">Rrefl</a> <a id="6133" href="Cat.Thin.html#5839" class="Bound">Rtrans</a> <a id="6140" href="Cat.Thin.html#5855" class="Bound">Rprop</a><a id="6145" class="Symbol">)</a>
      <a id="6153" class="Keyword">renaming</a> <a id="6162" class="Symbol">(</a> <a data-type="(C : Proset o h) → Precategory o h" id="6164" href="Cat.Thin.html#1026" class="Field">underlying</a> <a id="6175" class="Symbol">to</a> <a id="6178" class="Field">cat</a> <a id="6182" class="Symbol">;</a> <a data-type="(r : Proset o h) → is-thin (r .underlying)" id="6184" href="Cat.Thin.html#1060" class="Field">has-is-thin</a> <a id="6196" class="Symbol">to</a> <a id="6199" class="Field">ist</a> <a id="6203" class="Symbol">)</a>

    <a id="6210" href="Cat.Thin.html#6210" class="Function">tc</a> <a id="6213" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="6215" href="Cat.Thin.html#3448" class="Record">Poset</a> <a id="6221" class="Symbol">_</a> <a id="6223" class="Symbol">_</a>
    <a id="6229" href="Cat.Thin.html#6210" class="Function">tc</a> <a id="6232" class="Symbol">.</a><a data-type="Poset o h → Precategory o h" id="6233" href="Cat.Thin.html#3527" class="Field">underlying</a> <a id="6244" class="Symbol">=</a> <a id="6246" href="Cat.Thin.html#6178" class="Function">cat</a>
    <a id="6254" href="Cat.Thin.html#6210" class="Function">tc</a> <a id="6257" class="Symbol">.</a><a data-type="(r : Poset o h) → is-thin (r .underlying)" id="6258" href="Cat.Thin.html#3565" class="Field">has-is-thin</a>  <a id="6271" class="Symbol">=</a> <a id="6273" href="Cat.Thin.html#6199" class="Function">ist</a>
</pre>
<p>For the centre of contraction, we take <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> and the identity isomorphism. Then, assume that we have some other object <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> equipped with an iso <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>:</mo><mi>A</mi><mo>≅</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">i : A \cong B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>.</span> Since an iso is a big conjunction of propositional components, it’s a proposition, so it suffices to show <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>≡</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \equiv B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>.</span> But from the iso we have <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>≤</mo><mi>B</mi><mo stretchy="false">)</mo><mo>∧</mo><mo stretchy="false">(</mo><mi>B</mi><mo>≤</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A \le B) \land (B \le A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span>,</span> and antisymmetry finishes the job.</p>
<pre class="Agda">    <a id="6663" href="Cat.Thin.html#6210" class="Function">tc</a> <a id="6666" class="Symbol">.</a><a data-type="(r : Poset o h) → is-category (r .underlying)" id="6667" href="Cat.Thin.html#3607" class="Field">has-is-univalent</a> <a id="6684" href="Cat.Thin.html#6684" class="Bound">A</a> <a id="6686" class="Symbol">.</a><a data-type="is-contr A → A" id="6687" href="1Lab.HLevel.html#1401" class="Field">centre</a>        <a id="6701" class="Symbol">=</a> <a id="6703" href="Cat.Thin.html#6684" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="6705" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="(C : Precategory o h) → (C ≅ a) a" id="6707" href="Cat.Morphism.html#4612" class="Function">id-iso</a>
    <a id="6718" href="Cat.Thin.html#6210" class="Function">tc</a> <a id="6721" class="Symbol">.</a><a data-type="(r : Poset o h) → is-category (r .underlying)" id="6722" href="Cat.Thin.html#3607" class="Field">has-is-univalent</a> <a id="6739" href="Cat.Thin.html#6739" class="Bound">A</a> <a id="6741" class="Symbol">.</a><a data-type="(r : is-contr A) (x : A) → r .centre ≡ x" id="6742" href="1Lab.HLevel.html#1416" class="Field">paths</a> <a id="6748" class="Symbol">(</a><a id="6749" href="Cat.Thin.html#6749" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="6751" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="6753" href="Cat.Thin.html#6753" class="Bound">i</a><a id="6754" class="Symbol">)</a> <a id="6756" class="Symbol">=</a> <a data-type="((x : A) → is-prop (B₁ x)) → x .fst ≡ y .fst → x ≡ y" id="6758" href="1Lab.Type.Sigma.html#5139" class="Function">Σ-prop-path</a> <a id="6770" href="Cat.Thin.html#6849" class="Function">isp</a> <a id="6774" class="Symbol">(</a><a id="6775" href="Cat.Thin.html#5846" class="Bound">Rantisym</a> <a data-type="(C ≅ a) b → Hom C a b" id="6784" href="Cat.Morphism.html#1965" class="Field">i.to</a> <a data-type="(C ≅ a) b → Hom C b a" id="6789" href="Cat.Morphism.html#1988" class="Field">i.from</a><a id="6795" class="Symbol">)</a> <a id="6797" class="Keyword">where</a>
      <a id="6809" class="Keyword">module</a> <a id="6816" href="Cat.Thin.html#6816" class="Module">i</a> <a id="6818" class="Symbol">=</a> <a data-type="(C : Precategory o h) (a b : Ob C) → Type (o ⊔ h)" id="6820" href="Cat.Morphism.html#1917" class="Module Operator">_≅_</a> <a id="6824" href="Cat.Thin.html#6753" class="Bound">i</a>
      <a id="6832" class="Keyword">abstract</a>
        <a id="6849" href="Cat.Thin.html#6849" class="Function">isp</a> <a id="6853" class="Symbol">:</a> <a id="6855" class="Symbol">∀</a> <a id="6857" href="Cat.Thin.html#6857" class="Bound">x</a> <a id="6859" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="6861" href="1Lab.HLevel.html#2597" class="Function">is-prop</a> <a id="6869" class="Symbol">(</a><a id="6870" href="Cat.Thin.html#6739" class="Bound">A</a> <a data-type="(C : Precategory o h) (a b : Ob C) → Type (o ⊔ h)" id="6872" href="Cat.Morphism.html#1917" class="Record Operator">≅</a> <a id="6874" href="Cat.Thin.html#6857" class="Bound">x</a><a id="6875" class="Symbol">)</a>
        <a id="6885" href="Cat.Thin.html#6849" class="Function">isp</a> <a id="6889" href="Cat.Thin.html#6889" class="Bound">ob</a> <a id="6892" href="Cat.Thin.html#6892" class="Bound">x</a> <a id="6894" href="Cat.Thin.html#6894" class="Bound">y</a> <a id="6896" href="Cat.Thin.html#6896" class="Bound">i</a> <a id="6898" class="Symbol">.</a><a data-type="(C ≅ a) b → Hom C a b" id="6899" href="Cat.Morphism.html#1965" class="Field">to</a>   <a id="6904" class="Symbol">=</a> <a id="6906" href="Cat.Thin.html#5855" class="Bound">Rprop</a> <a id="6912" class="Symbol">(</a><a id="6913" href="Cat.Thin.html#6892" class="Bound">x</a> <a id="6915" class="Symbol">.</a><a data-type="(C ≅ a) b → Hom C a b" id="6916" href="Cat.Morphism.html#1965" class="Field">to</a><a id="6918" class="Symbol">)</a>   <a id="6922" class="Symbol">(</a><a id="6923" href="Cat.Thin.html#6894" class="Bound">y</a> <a id="6925" class="Symbol">.</a><a data-type="(C ≅ a) b → Hom C a b" id="6926" href="Cat.Morphism.html#1965" class="Field">to</a><a id="6928" class="Symbol">)</a>   <a id="6932" href="Cat.Thin.html#6896" class="Bound">i</a>
        <a id="6942" href="Cat.Thin.html#6849" class="Function">isp</a> <a id="6946" href="Cat.Thin.html#6946" class="Bound">ob</a> <a id="6949" href="Cat.Thin.html#6949" class="Bound">x</a> <a id="6951" href="Cat.Thin.html#6951" class="Bound">y</a> <a id="6953" href="Cat.Thin.html#6953" class="Bound">i</a> <a id="6955" class="Symbol">.</a><a data-type="(C ≅ a) b → Hom C b a" id="6956" href="Cat.Morphism.html#1988" class="Field">from</a> <a id="6961" class="Symbol">=</a> <a id="6963" href="Cat.Thin.html#5855" class="Bound">Rprop</a> <a id="6969" class="Symbol">(</a><a id="6970" href="Cat.Thin.html#6949" class="Bound">x</a> <a id="6972" class="Symbol">.</a><a data-type="(C ≅ a) b → Hom C b a" id="6973" href="Cat.Morphism.html#1988" class="Field">from</a><a id="6977" class="Symbol">)</a> <a id="6979" class="Symbol">(</a><a id="6980" href="Cat.Thin.html#6951" class="Bound">y</a> <a id="6982" class="Symbol">.</a><a data-type="(C ≅ a) b → Hom C b a" id="6983" href="Cat.Morphism.html#1988" class="Field">from</a><a id="6987" class="Symbol">)</a> <a id="6989" href="Cat.Thin.html#6953" class="Bound">i</a>
        <a id="6999" href="Cat.Thin.html#6849" class="Function">isp</a> <a id="7003" href="Cat.Thin.html#7003" class="Bound">ob</a> <a id="7006" href="Cat.Thin.html#7006" class="Bound">x</a> <a id="7008" href="Cat.Thin.html#7008" class="Bound">y</a> <a id="7010" href="Cat.Thin.html#7010" class="Bound">i</a> <a id="7012" class="Symbol">.</a><a data-type="(r : (C ≅ a) b) → Inverses C (r .to) (r .from)" id="7013" href="Cat.Morphism.html#2011" class="Field">inverses</a> <a id="7022" class="Symbol">=</a>
          <a data-type="((i : I) → is-prop (B₁ i)) →
(b0 : B₁ i0) (b1 : B₁ i1) → PathP B₁ b0 b1" id="7034" href="1Lab.HLevel.html#13498" class="Function">is-prop→pathp</a>
            <a id="7060" class="Symbol">(λ</a> <a id="7063" href="Cat.Thin.html#7063" class="Bound">i</a> <a id="7065" class="Symbol">→</a> <a data-type="(C : Precategory o h) → is-prop (Inverses C f g)" id="7067" href="Cat.Morphism.html#2315" class="Function">Inverses-are-prop</a> <a id="7085" class="Symbol">{</a><a id="7086" class="Argument">f</a> <a id="7088" class="Symbol">=</a> <a id="7090" href="Cat.Thin.html#5855" class="Bound">Rprop</a> <a id="7096" class="Symbol">(</a><a id="7097" href="Cat.Thin.html#7006" class="Bound">x</a> <a id="7099" class="Symbol">.</a><a data-type="(C ≅ a) b → Hom C a b" id="7100" href="Cat.Morphism.html#1965" class="Field">to</a><a id="7102" class="Symbol">)</a>   <a id="7106" class="Symbol">(</a><a id="7107" href="Cat.Thin.html#7008" class="Bound">y</a> <a id="7109" class="Symbol">.</a><a data-type="(C ≅ a) b → Hom C a b" id="7110" href="Cat.Morphism.html#1965" class="Field">to</a><a id="7112" class="Symbol">)</a>   <a id="7116" href="Cat.Thin.html#7063" class="Bound">i</a><a id="7117" class="Symbol">}</a>
                                     <a id="7156" class="Symbol">{</a><a id="7157" class="Argument">g</a> <a id="7159" class="Symbol">=</a> <a id="7161" href="Cat.Thin.html#5855" class="Bound">Rprop</a> <a id="7167" class="Symbol">(</a><a id="7168" href="Cat.Thin.html#7006" class="Bound">x</a> <a id="7170" class="Symbol">.</a><a data-type="(C ≅ a) b → Hom C b a" id="7171" href="Cat.Morphism.html#1988" class="Field">from</a><a id="7175" class="Symbol">)</a> <a id="7177" class="Symbol">(</a><a id="7178" href="Cat.Thin.html#7008" class="Bound">y</a> <a id="7180" class="Symbol">.</a><a data-type="(C ≅ a) b → Hom C b a" id="7181" href="Cat.Morphism.html#1988" class="Field">from</a><a id="7185" class="Symbol">)</a> <a id="7187" href="Cat.Thin.html#7063" class="Bound">i</a><a id="7188" class="Symbol">})</a>
            <a id="7203" class="Symbol">(</a><a id="7204" href="Cat.Thin.html#7006" class="Bound">x</a> <a id="7206" class="Symbol">.</a><a data-type="(r : (C ≅ a) b) → Inverses C (r .to) (r .from)" id="7207" href="Cat.Morphism.html#2011" class="Field">inverses</a><a id="7215" class="Symbol">)</a> <a id="7217" class="Symbol">(</a><a id="7218" href="Cat.Thin.html#7008" class="Bound">y</a> <a id="7220" class="Symbol">.</a><a data-type="(r : (C ≅ a) b) → Inverses C (r .to) (r .from)" id="7221" href="Cat.Morphism.html#2011" class="Field">inverses</a><a id="7229" class="Symbol">)</a> <a id="7231" href="Cat.Thin.html#7010" class="Bound">i</a>
</pre>
<h2 id="monotone-maps"><a href="#monotone-maps" class="header-link">Monotone maps<span class="header-link-emoji">🔗</span></a></h2>
<p>Rather than considering <em>functors</em> between posets, we can consider <strong>monotone maps</strong> between them. This is because, since each hom-set is a proposition, the functor identities are automatically satisfied:</p>
<pre class="Agda"><a id="7470" class="Keyword">module</a> <a id="7477" href="Cat.Thin.html#7477" class="Module">_</a> <a id="7479" class="Keyword">where</a>
  <a id="7487" class="Keyword">open</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="7492" href="Cat.Thin.html#3448" class="Module">Poset</a>

  <a data-type="Poset o h → Poset o′ h′ → Type (o ⊔ h ⊔ o′ ⊔ h′)" id="7501" href="Cat.Thin.html#7501" class="Function">Monotone-map</a> <a id="7514" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="7516" href="Cat.Thin.html#3448" class="Record">Poset</a> <a id="7522" href="Cat.Thin.html#229" class="Generalizable">o</a> <a id="7524" href="Cat.Thin.html#231" class="Generalizable">h</a> <a id="7526" class="Symbol">→</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="7528" href="Cat.Thin.html#3448" class="Record">Poset</a> <a id="7534" href="Cat.Thin.html#233" class="Generalizable">o′</a> <a id="7537" href="Cat.Thin.html#236" class="Generalizable">h′</a> <a id="7540" class="Symbol">→</a> <a id="7542" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="7547" class="Symbol">_</a>
  <a data-type="Poset o h → Poset o′ h′ → Type (o ⊔ h ⊔ o′ ⊔ h′)" id="7551" href="Cat.Thin.html#7501" class="Function">Monotone-map</a> <a id="7564" href="Cat.Thin.html#7564" class="Bound">C</a> <a id="7566" href="Cat.Thin.html#7566" class="Bound">D</a> <a id="7568" class="Symbol">=</a> <a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="7570" href="Cat.Base.html#6614" class="Record">Functor</a> <a id="7578" class="Symbol">(</a><a id="7579" href="Cat.Thin.html#7564" class="Bound">C</a> <a id="7581" class="Symbol">.</a><a data-type="Poset o h → Precategory o h" id="7582" href="Cat.Thin.html#3527" class="Field">underlying</a><a id="7592" class="Symbol">)</a> <a id="7594" class="Symbol">(</a><a id="7595" href="Cat.Thin.html#7566" class="Bound">D</a> <a id="7597" class="Symbol">.</a><a data-type="Poset o h → Precategory o h" id="7598" href="Cat.Thin.html#3527" class="Field">underlying</a><a id="7608" class="Symbol">)</a>

  <a data-type="(C : Poset o h) (D : Poset o′ h′) (f : Ob C → Ob D) →
((x y : underlying C .Ob) → Hom C x y → Hom D (f x) (f y)) →
Monotone-map C D" id="7613" href="Cat.Thin.html#7613" class="Function">make-monotone-map</a>
    <a id="7635" class="Symbol">:</a> <a id="7637" class="Symbol">(</a><a id="7638" href="Cat.Thin.html#7638" class="Bound">C</a> <a id="7640" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="7642" href="Cat.Thin.html#3448" class="Record">Poset</a> <a id="7648" href="Cat.Thin.html#229" class="Generalizable">o</a> <a id="7650" href="Cat.Thin.html#231" class="Generalizable">h</a><a id="7651" class="Symbol">)</a> <a id="7653" class="Symbol">(</a><a id="7654" href="Cat.Thin.html#7654" class="Bound">D</a> <a id="7656" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="7658" href="Cat.Thin.html#3448" class="Record">Poset</a> <a id="7664" href="Cat.Thin.html#233" class="Generalizable">o′</a> <a id="7667" href="Cat.Thin.html#236" class="Generalizable">h′</a><a id="7669" class="Symbol">)</a>
    <a id="7675" class="Symbol">→</a> <a id="7677" class="Symbol">(</a><a id="7678" href="Cat.Thin.html#7678" class="Bound">f</a> <a id="7680" class="Symbol">:</a> <a id="7682" href="Cat.Thin.html#7638" class="Bound">C</a> <a id="7684" class="Symbol">.</a><a data-type="Precategory o h → Type o" id="7685" href="Cat.Base.html#1341" class="Function">Ob</a> <a id="7688" class="Symbol">→</a> <a id="7690" href="Cat.Thin.html#7654" class="Bound">D</a> <a id="7692" class="Symbol">.</a><a data-type="Precategory o h → Type o" id="7693" href="Cat.Base.html#1341" class="Function">Ob</a><a id="7695" class="Symbol">)</a>
    <a id="7701" class="Symbol">→</a> <a id="7703" class="Symbol">(∀</a> <a id="7706" href="Cat.Thin.html#7706" class="Bound">x</a> <a id="7708" href="Cat.Thin.html#7708" class="Bound">y</a> <a id="7710" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="7712" href="Cat.Base.html#1358" class="Function">Hom</a> <a id="7716" href="Cat.Thin.html#7638" class="Bound">C</a> <a id="7718" href="Cat.Thin.html#7706" class="Bound">x</a> <a id="7720" href="Cat.Thin.html#7708" class="Bound">y</a> <a id="7722" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="7724" href="Cat.Base.html#1358" class="Function">Hom</a> <a id="7728" href="Cat.Thin.html#7654" class="Bound">D</a> <a id="7730" class="Symbol">(</a><a id="7731" href="Cat.Thin.html#7678" class="Bound">f</a> <a id="7733" href="Cat.Thin.html#7706" class="Bound">x</a><a id="7734" class="Symbol">)</a> <a id="7736" class="Symbol">(</a><a id="7737" href="Cat.Thin.html#7678" class="Bound">f</a> <a id="7739" href="Cat.Thin.html#7708" class="Bound">y</a><a id="7740" class="Symbol">))</a>
    <a id="7747" class="Symbol">→</a> <a data-type="Poset o h → Poset o′ h′ → Type (o ⊔ h ⊔ o′ ⊔ h′)" id="7749" href="Cat.Thin.html#7501" class="Function">Monotone-map</a> <a id="7762" href="Cat.Thin.html#7638" class="Bound">C</a> <a id="7764" href="Cat.Thin.html#7654" class="Bound">D</a>
  <a data-type="(C : Poset o h) (D : Poset o′ h′) (f : Ob C → Ob D) →
((x y : underlying C .Ob) → Hom C x y → Hom D (f x) (f y)) →
Monotone-map C D" id="7768" href="Cat.Thin.html#7613" class="Function">make-monotone-map</a> <a id="7786" href="Cat.Thin.html#7786" class="Bound">C</a> <a id="7788" href="Cat.Thin.html#7788" class="Bound">D</a> <a id="7790" href="Cat.Thin.html#7790" class="Bound">f</a> <a id="7792" href="Cat.Thin.html#7792" class="Bound">ord</a> <a id="7796" class="Symbol">.</a><a data-type="Functor C D → C .Ob → Ob D" id="7797" href="Cat.Base.html#7400" class="Field">Functor.F₀</a> <a id="7808" class="Symbol">=</a> <a id="7810" href="Cat.Thin.html#7790" class="Bound">f</a>
  <a data-type="(C : Poset o h) (D : Poset o′ h′) (f : Ob C → Ob D) →
((x y : underlying C .Ob) → Hom C x y → Hom D (f x) (f y)) →
Monotone-map C D" id="7814" href="Cat.Thin.html#7613" class="Function">make-monotone-map</a> <a id="7832" href="Cat.Thin.html#7832" class="Bound">C</a> <a id="7834" href="Cat.Thin.html#7834" class="Bound">D</a> <a id="7836" href="Cat.Thin.html#7836" class="Bound">f</a> <a id="7838" href="Cat.Thin.html#7838" class="Bound">ord</a> <a id="7842" class="Symbol">.</a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="7843" href="Cat.Base.html#7421" class="Field">Functor.F₁</a> <a id="7854" class="Symbol">=</a> <a id="7856" href="Cat.Thin.html#7838" class="Bound">ord</a> <a id="7860" class="Symbol">_</a> <a id="7862" class="Symbol">_</a>
  <a data-type="(C : Poset o h) (D : Poset o′ h′) (f : Ob C → Ob D) →
((x y : underlying C .Ob) → Hom C x y → Hom D (f x) (f y)) →
Monotone-map C D" id="7866" href="Cat.Thin.html#7613" class="Function">make-monotone-map</a> <a id="7884" href="Cat.Thin.html#7884" class="Bound">C</a> <a id="7886" href="Cat.Thin.html#7886" class="Bound">D</a> <a id="7888" href="Cat.Thin.html#7888" class="Bound">f</a> <a id="7890" href="Cat.Thin.html#7890" class="Bound">ord</a> <a id="7894" class="Symbol">.</a><a data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" id="7895" href="Cat.Base.html#7747" class="Field">Functor.F-id</a> <a id="7908" class="Symbol">=</a> <a id="7910" href="Cat.Thin.html#7886" class="Bound">D</a> <a id="7912" class="Symbol">.</a><a data-type="(r : Poset o h) (A B₁ : r .underlying .Ob) →
is-prop (Hom (r .underlying) A B₁)" id="7913" href="Cat.Thin.html#752" class="Function">Hom-is-prop</a> <a id="7925" class="Symbol">_</a> <a id="7927" class="Symbol">_</a> <a id="7929" class="Symbol">_</a> <a id="7931" class="Symbol">_</a>
  <a data-type="(C : Poset o h) (D : Poset o′ h′) (f : Ob C → Ob D) →
((x y : underlying C .Ob) → Hom C x y → Hom D (f x) (f y)) →
Monotone-map C D" id="7935" href="Cat.Thin.html#7613" class="Function">make-monotone-map</a> <a id="7953" href="Cat.Thin.html#7953" class="Bound">C</a> <a id="7955" href="Cat.Thin.html#7955" class="Bound">D</a> <a id="7957" href="Cat.Thin.html#7957" class="Bound">f</a> <a id="7959" href="Cat.Thin.html#7959" class="Bound">ord</a> <a id="7963" class="Symbol">.</a><a data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" id="7964" href="Cat.Base.html#7787" class="Field">Functor.F-∘</a> <a id="7976" class="Symbol">_</a> <a id="7978" class="Symbol">_</a> <a id="7980" class="Symbol">=</a> <a id="7982" href="Cat.Thin.html#7955" class="Bound">D</a> <a id="7984" class="Symbol">.</a><a data-type="(r : Poset o h) (A B₁ : r .underlying .Ob) →
is-prop (Hom (r .underlying) A B₁)" id="7985" href="Cat.Thin.html#752" class="Function">Hom-is-prop</a> <a id="7997" class="Symbol">_</a> <a id="7999" class="Symbol">_</a> <a id="8001" class="Symbol">_</a> <a id="8003" class="Symbol">_</a>

  <a id="8008" class="Keyword">open</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="8013" href="Cat.Base.html#644" class="Module">Precategory</a>

  <a data-type="(o h : Level) → Precategory (lsuc (o ⊔ h)) (o ⊔ h)" id="8028" href="Cat.Thin.html#8028" class="Function">Posets</a> <a id="8035" class="Symbol">:</a> <a id="8037" class="Symbol">∀</a> <a id="8039" href="Cat.Thin.html#8039" class="Bound">o</a> <a id="8041" href="Cat.Thin.html#8041" class="Bound">h</a> <a id="8043" class="Symbol">→</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="8045" href="Cat.Base.html#644" class="Record">Precategory</a> <a id="8057" class="Symbol">(</a><a data-type="Level → Level" id="8058" href="Agda.Primitive.html#780" class="Primitive">lsuc</a> <a id="8063" class="Symbol">(</a><a id="8064" href="Cat.Thin.html#8039" class="Bound">o</a> <a data-type="Level → Level → Level" id="8066" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="8068" href="Cat.Thin.html#8041" class="Bound">h</a><a id="8069" class="Symbol">))</a> <a id="8072" class="Symbol">(</a><a id="8073" href="Cat.Thin.html#8039" class="Bound">o</a> <a data-type="Level → Level → Level" id="8075" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="8077" href="Cat.Thin.html#8041" class="Bound">h</a><a id="8078" class="Symbol">)</a>
  <a data-type="(o h : Level) → Precategory (lsuc (o ⊔ h)) (o ⊔ h)" id="8082" href="Cat.Thin.html#8028" class="Function">Posets</a> <a id="8089" href="Cat.Thin.html#8089" class="Bound">o</a> <a id="8091" href="Cat.Thin.html#8091" class="Bound">h</a> <a id="8093" class="Symbol">.</a><a data-type="Precategory o h → Type o" id="8094" href="Cat.Base.html#1341" class="Field">Ob</a> <a id="8097" class="Symbol">=</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="8099" href="Cat.Thin.html#3448" class="Record">Poset</a> <a id="8105" href="Cat.Thin.html#8089" class="Bound">o</a> <a id="8107" href="Cat.Thin.html#8091" class="Bound">h</a>
  <a data-type="(o h : Level) → Precategory (lsuc (o ⊔ h)) (o ⊔ h)" id="8111" href="Cat.Thin.html#8028" class="Function">Posets</a> <a id="8118" class="Symbol">_</a> <a id="8120" class="Symbol">_</a> <a id="8122" class="Symbol">.</a><a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="8123" href="Cat.Base.html#1358" class="Field">Hom</a> <a id="8127" class="Symbol">=</a> <a data-type="Poset o h → Poset o′ h′ → Type (o ⊔ h ⊔ o′ ⊔ h′)" id="8129" href="Cat.Thin.html#7501" class="Function">Monotone-map</a>
  <a data-type="(o h : Level) → Precategory (lsuc (o ⊔ h)) (o ⊔ h)" id="8144" href="Cat.Thin.html#8028" class="Function">Posets</a> <a id="8151" class="Symbol">_</a> <a id="8153" class="Symbol">_</a> <a id="8155" class="Symbol">.</a><a data-type="(r : Precategory o h) (x y : r .Ob) → is-set (r .Hom x y)" id="8156" href="Cat.Base.html#1706" class="Field">Hom-set</a> <a id="8164" class="Symbol">_</a> <a id="8166" href="Cat.Thin.html#8166" class="Bound">d</a> <a id="8168" class="Symbol">=</a> <a data-type="is-set (Ob D) → is-set (Functor C D)" id="8170" href="Cat.Instances.StrictCat.html#646" class="Function">Functor-is-set</a> <a id="8185" class="Symbol">(</a><a id="8186" href="Cat.Thin.html#8166" class="Bound">d</a> <a id="8188" class="Symbol">.</a><a data-type="(r : Poset o h) → is-set (Ob (r .underlying))" id="8189" href="Cat.Thin.html#726" class="Function">Ob-is-set</a><a id="8198" class="Symbol">)</a>
  <a data-type="(o h : Level) → Precategory (lsuc (o ⊔ h)) (o ⊔ h)" id="8202" href="Cat.Thin.html#8028" class="Function">Posets</a> <a id="8209" class="Symbol">_</a> <a id="8211" class="Symbol">_</a> <a id="8213" class="Symbol">.</a><a data-type="(r : Precategory o h) → r .Hom x x" id="8214" href="Cat.Base.html#2898" class="Field">id</a> <a id="8217" class="Symbol">=</a> <a data-type="Functor C C" id="8219" href="Cat.Base.html#10294" class="Function">Id</a>
  <a data-type="(o h : Level) → Precategory (lsuc (o ⊔ h)) (o ⊔ h)" id="8224" href="Cat.Thin.html#8028" class="Function">Posets</a> <a id="8231" class="Symbol">_</a> <a id="8233" class="Symbol">_</a> <a id="8235" class="Symbol">.</a><a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8236" href="Cat.Base.html#2928" class="Field Operator">_∘_</a> <a id="8240" class="Symbol">=</a> <a data-type="Functor D E → Functor C D → Functor C E" id="8242" href="Cat.Base.html#8513" class="Function Operator">_F∘_</a>
  <a data-type="(o h : Level) → Precategory (lsuc (o ⊔ h)) (o ⊔ h)" id="8249" href="Cat.Thin.html#8028" class="Function">Posets</a> <a id="8256" class="Symbol">_</a> <a id="8258" class="Symbol">_</a> <a id="8260" class="Symbol">.</a><a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" id="8261" href="Cat.Base.html#3359" class="Field">idr</a> <a id="8265" href="Cat.Thin.html#8265" class="Bound">f</a> <a id="8267" class="Symbol">=</a> <a data-type="(p0 : (x : C .Ob) → F₀ F x ≡ F₀ G x) →
((f : C .Hom x y) →
 PathP (λ i → D .Hom (p0 x i) (p0 y i)) (F₁ F f) (F₁ G f)) →
F ≡ G" id="8269" href="Cat.Instances.Functor.html#3044" class="Function">Functor-path</a> <a id="8282" class="Symbol">(λ</a> <a id="8285" href="Cat.Thin.html#8285" class="Bound">_</a> <a id="8287" class="Symbol">→</a> <a data-type="x ≡ x" id="8289" href="1Lab.Path.html#3593" class="Function">refl</a><a id="8293" class="Symbol">)</a> <a id="8295" class="Symbol">λ</a> <a id="8297" href="Cat.Thin.html#8297" class="Bound">_</a> <a id="8299" class="Symbol">→</a> <a data-type="x ≡ x" id="8301" href="1Lab.Path.html#3593" class="Function">refl</a>
  <a data-type="(o h : Level) → Precategory (lsuc (o ⊔ h)) (o ⊔ h)" id="8308" href="Cat.Thin.html#8028" class="Function">Posets</a> <a id="8315" class="Symbol">_</a> <a id="8317" class="Symbol">_</a> <a id="8319" class="Symbol">.</a><a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" id="8320" href="Cat.Base.html#3404" class="Field">idl</a> <a id="8324" href="Cat.Thin.html#8324" class="Bound">f</a> <a id="8326" class="Symbol">=</a> <a data-type="(p0 : (x : C .Ob) → F₀ F x ≡ F₀ G x) →
((f : C .Hom x y) →
 PathP (λ i → D .Hom (p0 x i) (p0 y i)) (F₁ F f) (F₁ G f)) →
F ≡ G" id="8328" href="Cat.Instances.Functor.html#3044" class="Function">Functor-path</a> <a id="8341" class="Symbol">(λ</a> <a id="8344" href="Cat.Thin.html#8344" class="Bound">_</a> <a id="8346" class="Symbol">→</a> <a data-type="x ≡ x" id="8348" href="1Lab.Path.html#3593" class="Function">refl</a><a id="8352" class="Symbol">)</a> <a id="8354" class="Symbol">λ</a> <a id="8356" href="Cat.Thin.html#8356" class="Bound">_</a> <a id="8358" class="Symbol">→</a> <a data-type="x ≡ x" id="8360" href="1Lab.Path.html#3593" class="Function">refl</a>
  <a data-type="(o h : Level) → Precategory (lsuc (o ⊔ h)) (o ⊔ h)" id="8367" href="Cat.Thin.html#8028" class="Function">Posets</a> <a id="8374" class="Symbol">_</a> <a id="8376" class="Symbol">_</a> <a id="8378" class="Symbol">.</a><a data-type="(r : Precategory o h) (f : r .Hom y z) (g : r .Hom x y)
(h : r .Hom w x) →
r ._∘_ f (r ._∘_ g h) ≡ r ._∘_ (r ._∘_ f g) h" id="8379" href="Cat.Base.html#3779" class="Field">assoc</a> <a id="8385" href="Cat.Thin.html#8385" class="Bound">f</a> <a id="8387" href="Cat.Thin.html#8387" class="Bound">g</a> <a id="8389" href="Cat.Thin.html#8389" class="Bound">h</a> <a id="8391" class="Symbol">=</a> <a data-type="(p0 : (x : C .Ob) → F₀ F x ≡ F₀ G x) →
((f : C .Hom x y) →
 PathP (λ i → D .Hom (p0 x i) (p0 y i)) (F₁ F f) (F₁ G f)) →
F ≡ G" id="8393" href="Cat.Instances.Functor.html#3044" class="Function">Functor-path</a> <a id="8406" class="Symbol">(λ</a> <a id="8409" href="Cat.Thin.html#8409" class="Bound">_</a> <a id="8411" class="Symbol">→</a> <a data-type="x ≡ x" id="8413" href="1Lab.Path.html#3593" class="Function">refl</a><a id="8417" class="Symbol">)</a> <a id="8419" class="Symbol">λ</a> <a id="8421" href="Cat.Thin.html#8421" class="Bound">_</a> <a id="8423" class="Symbol">→</a> <a data-type="x ≡ x" id="8425" href="1Lab.Path.html#3593" class="Function">refl</a>
</pre>
<h1 id="prosetal-reflection"><a href="#prosetal-reflection" class="header-link">Prosetal reflection<span class="header-link-emoji">🔗</span></a></h1>
<p>There is an evident functor from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">P</mi><mi mathvariant="bold">r</mi><mi mathvariant="bold">o</mi><mi mathvariant="bold">s</mi><mi mathvariant="bold">e</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">s</mi></mrow><annotation encoding="application/x-tex">\prosets</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord"><span class="mord mathbf">Prosets</span></span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="bold">C</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">t</mi></mrow><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">c</mi><mi mathvariant="normal">t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\strcat</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8361em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">Cat</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3175em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">strict</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> given by forgetting the thinness data. This functor is ff., since maps between prosets are functors between strict categories: it acts on morphisms literally by the identity function.</p>
<pre class="Agda"><a id="Forget"></a><a data-type="Functor (Prosets o h) (Strict-Cat o h)" id="8708" href="Cat.Thin.html#8708" class="Function">Forget</a> <a id="8715" class="Symbol">:</a> <a id="8717" class="Symbol">∀</a> <a id="8719" class="Symbol">{</a><a id="8720" href="Cat.Thin.html#8720" class="Bound">o</a> <a id="8722" href="Cat.Thin.html#8722" class="Bound">h</a><a id="8723" class="Symbol">}</a> <a id="8725" class="Symbol">→</a> <a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="8727" href="Cat.Base.html#6614" class="Record">Functor</a> <a id="8735" class="Symbol">(</a><a data-type="(o h : Level) → Precategory (lsuc (o ⊔ h)) (o ⊔ h)" id="8736" href="Cat.Thin.html#1351" class="Function">Prosets</a> <a id="8744" href="Cat.Thin.html#8720" class="Bound">o</a> <a id="8746" href="Cat.Thin.html#8722" class="Bound">h</a><a id="8747" class="Symbol">)</a> <a id="8749" class="Symbol">(</a><a data-type="(o h : Level) → Precategory (lsuc o ⊔ lsuc h) (o ⊔ h)" id="8750" href="Cat.Instances.StrictCat.html#2161" class="Function">Strict-Cat</a> <a id="8761" href="Cat.Thin.html#8720" class="Bound">o</a> <a id="8763" href="Cat.Thin.html#8722" class="Bound">h</a><a id="8764" class="Symbol">)</a>
<a data-type="Functor (Prosets o h) (Strict-Cat o h)" id="8766" href="Cat.Thin.html#8708" class="Function">Forget</a> <a id="8773" class="Symbol">.</a><a data-type="Functor C D → C .Ob → Ob D" id="8774" href="Cat.Base.html#7400" class="Field">F₀</a> <a id="8777" href="Cat.Thin.html#8777" class="Bound">C</a> <a id="8779" class="Symbol">=</a> <a data-type="(C : Proset o h) → Precategory o h" id="8781" href="Cat.Thin.html#1026" class="Field">Proset.underlying</a> <a id="8799" href="Cat.Thin.html#8777" class="Bound">C</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="8801" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="(r : Poset o h) → is-set (Ob (r .underlying))" id="8803" href="Cat.Thin.html#726" class="Function">Proset.Ob-is-set</a> <a id="8820" href="Cat.Thin.html#8777" class="Bound">C</a>
<a data-type="Functor (Prosets o h) (Strict-Cat o h)" id="8822" href="Cat.Thin.html#8708" class="Function">Forget</a> <a id="8829" class="Symbol">.</a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="8830" href="Cat.Base.html#7421" class="Field">F₁</a> <a id="8833" href="Cat.Thin.html#8833" class="Bound">f</a> <a id="8835" class="Symbol">=</a> <a id="8837" href="Cat.Thin.html#8833" class="Bound">f</a>
<a data-type="Functor (Prosets o h) (Strict-Cat o h)" id="8839" href="Cat.Thin.html#8708" class="Function">Forget</a> <a id="8846" class="Symbol">.</a><a data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" id="8847" href="Cat.Base.html#7747" class="Field">F-id</a> <a id="8852" class="Symbol">=</a> <a data-type="x ≡ x" id="8854" href="1Lab.Path.html#3593" class="Function">refl</a>
<a data-type="Functor (Prosets o h) (Strict-Cat o h)" id="8859" href="Cat.Thin.html#8708" class="Function">Forget</a> <a id="8866" class="Symbol">.</a><a data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" id="8867" href="Cat.Base.html#7787" class="Field">F-∘</a> <a id="8871" class="Symbol">_</a> <a id="8873" class="Symbol">_</a> <a id="8875" class="Symbol">=</a> <a data-type="x ≡ x" id="8877" href="1Lab.Path.html#3593" class="Function">refl</a>
</pre>
<p>This functor begs the question: is it possible to freely turn a strict category into a proset? The answer is yes! We can <a href="1Lab.HIT.Truncation.html">propositionally truncate</a> each of the <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>hom</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\hom</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mop">hom</span></span></span></span>-sets.</span> This provides a reflection of strict categories into prosets.</p>
<pre class="Agda"><a id="Free"></a><a data-type="Functor (Strict-Cat o h) (Prosets o h)" id="9185" href="Cat.Thin.html#9185" class="Function">Free</a> <a id="9190" class="Symbol">:</a> <a id="9192" class="Symbol">∀</a> <a id="9194" class="Symbol">{</a><a id="9195" href="Cat.Thin.html#9195" class="Bound">o</a> <a id="9197" href="Cat.Thin.html#9197" class="Bound">h</a><a id="9198" class="Symbol">}</a> <a id="9200" class="Symbol">→</a> <a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="9202" href="Cat.Base.html#6614" class="Record">Functor</a> <a id="9210" class="Symbol">(</a><a data-type="(o h : Level) → Precategory (lsuc o ⊔ lsuc h) (o ⊔ h)" id="9211" href="Cat.Instances.StrictCat.html#2161" class="Function">Strict-Cat</a> <a id="9222" href="Cat.Thin.html#9195" class="Bound">o</a> <a id="9224" href="Cat.Thin.html#9197" class="Bound">h</a><a id="9225" class="Symbol">)</a> <a id="9227" class="Symbol">(</a><a data-type="(o h : Level) → Precategory (lsuc (o ⊔ h)) (o ⊔ h)" id="9228" href="Cat.Thin.html#1351" class="Function">Prosets</a> <a id="9236" href="Cat.Thin.html#9195" class="Bound">o</a> <a id="9238" href="Cat.Thin.html#9197" class="Bound">h</a><a id="9239" class="Symbol">)</a>
<a data-type="Functor (Strict-Cat o h) (Prosets o h)" id="9241" href="Cat.Thin.html#9185" class="Function">Free</a> <a id="9246" class="Symbol">.</a><a data-type="Functor C D → C .Ob → Ob D" id="9247" href="Cat.Base.html#7400" class="Field">F₀</a> <a id="9250" href="Cat.Thin.html#9250" class="Bound">C</a> <a id="9252" class="Symbol">=</a> <a id="9254" href="Cat.Thin.html#9286" class="Function">pro</a> <a id="9258" class="Keyword">where</a>
  <a id="9266" class="Keyword">open</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="9271" href="Cat.Base.html#644" class="Module">Precategory</a>

  <a id="9286" href="Cat.Thin.html#9286" class="Function">pro</a> <a id="9290" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="9292" href="Cat.Thin.html#946" class="Record">Proset</a> <a id="9299" class="Symbol">_</a> <a id="9301" class="Symbol">_</a>
  <a id="9305" href="Cat.Thin.html#9286" class="Function">pro</a> <a id="9309" class="Symbol">=</a> <a data-type="is-set A →
R₁ x x →
(R₁ x y → R₁ y z → R₁ x z) → is-prop (R₁ x y) → Proset ℓ ℓ&#39;" id="9311" href="Cat.Thin.html#1984" class="Function">make-proset</a> <a id="9323" class="Symbol">{</a><a id="9324" class="Argument">R</a> <a id="9326" class="Symbol">=</a> <a id="9328" class="Symbol">λ</a> <a id="9330" href="Cat.Thin.html#9330" class="Bound">x</a> <a id="9332" href="Cat.Thin.html#9332" class="Bound">y</a> <a id="9334" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="9336" href="1Lab.HIT.Truncation.html#609" class="Datatype Operator">∥</a> <a id="9338" href="Cat.Thin.html#9250" class="Bound">C</a> <a id="9340" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="9341" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="9345" class="Symbol">.</a><a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="9346" href="Cat.Base.html#1358" class="Field">Hom</a> <a id="9350" href="Cat.Thin.html#9330" class="Bound">x</a> <a id="9352" href="Cat.Thin.html#9332" class="Bound">y</a> <a data-type="Type ℓ → Type ℓ" id="9354" href="1Lab.HIT.Truncation.html#609" class="Datatype Operator">∥</a><a id="9355" class="Symbol">}</a> <a id="9357" class="Symbol">(</a><a id="9358" href="Cat.Thin.html#9250" class="Bound">C</a> <a id="9360" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="9361" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="9364" class="Symbol">)</a>
    <a id="9370" class="Symbol">(</a><a data-type="A → ∥ A ∥" id="9371" href="1Lab.HIT.Truncation.html#647" class="InductiveConstructor">inc</a> <a id="9375" class="Symbol">(</a><a id="9376" href="Cat.Thin.html#9250" class="Bound">C</a> <a id="9378" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="9379" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="9383" class="Symbol">.</a><a data-type="(r : Precategory o h) → r .Hom x x" id="9384" href="Cat.Base.html#2898" class="Field">id</a><a id="9386" class="Symbol">))</a>
    <a id="9393" class="Symbol">(</a><a data-type="((x : ∥ A ∥) (y : ∥ B₁ ∥) → is-prop (P x y)) →
((x : A) (y : B₁) → P (inc x) (inc y)) →
(x : ∥ A ∥) (y : ∥ B₁ ∥) → P x y" id="9394" href="1Lab.HIT.Truncation.html#1554" class="Function">∥-∥-elim₂</a> <a id="9404" class="Symbol">(λ</a> <a id="9407" href="Cat.Thin.html#9407" class="Bound">_</a> <a id="9409" href="Cat.Thin.html#9409" class="Bound">_</a> <a id="9411" class="Symbol">→</a> <a data-type="is-prop ∥ A ∥" id="9413" href="1Lab.HIT.Truncation.html#668" class="InductiveConstructor">squash</a><a id="9419" class="Symbol">)</a> <a id="9421" class="Symbol">λ</a> <a id="9423" href="Cat.Thin.html#9423" class="Bound">f</a> <a id="9425" href="Cat.Thin.html#9425" class="Bound">g</a> <a id="9427" class="Symbol">→</a> <a data-type="A → ∥ A ∥" id="9429" href="1Lab.HIT.Truncation.html#647" class="InductiveConstructor">inc</a> <a id="9433" class="Symbol">(</a><a id="9434" href="Cat.Thin.html#9250" class="Bound">C</a> <a id="9436" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="9437" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="9441" class="Symbol">.</a><a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="9442" href="Cat.Base.html#2928" class="Field Operator">_∘_</a> <a id="9446" href="Cat.Thin.html#9425" class="Bound">g</a> <a id="9448" href="Cat.Thin.html#9423" class="Bound">f</a><a id="9449" class="Symbol">))</a>
    <a data-type="is-prop ∥ A ∥" id="9456" href="1Lab.HIT.Truncation.html#668" class="InductiveConstructor">squash</a>
</pre>
<p>The <span class="Agda"><a data-type="Functor (Strict-Cat o h) (Prosets o h)" href="Cat.Thin.html#9185" class="Function">Free</a></span> proset functor takes a strict category on the proset obtained by truncating each of its hom-sets. This induced relation is reflexive (by including the identity map), and transitive (by lifting the composition map onto the truncation). On morphisms, it preserves the object part, and lifts the morphism action onto the truncations.</p>
<pre class="Agda"><a data-type="Functor (Strict-Cat o h) (Prosets o h)" id="9826" href="Cat.Thin.html#9185" class="Function">Free</a> <a id="9831" class="Symbol">.</a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="9832" href="Cat.Base.html#7421" class="Field">F₁</a> <a id="9835" href="Cat.Thin.html#9835" class="Bound">F</a> <a id="9837" class="Symbol">.</a><a data-type="Functor C D → C .Ob → Ob D" id="9838" href="Cat.Base.html#7400" class="Field">F₀</a>      <a id="9846" class="Symbol">=</a> <a data-type="Functor C D → C .Ob → Ob D" id="9848" href="Cat.Base.html#7400" class="Field">F₀</a> <a id="9851" href="Cat.Thin.html#9835" class="Bound">F</a>
<a data-type="Functor (Strict-Cat o h) (Prosets o h)" id="9853" href="Cat.Thin.html#9185" class="Function">Free</a> <a id="9858" class="Symbol">.</a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="9859" href="Cat.Base.html#7421" class="Field">F₁</a> <a id="9862" href="Cat.Thin.html#9862" class="Bound">F</a> <a id="9864" class="Symbol">.</a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="9865" href="Cat.Base.html#7421" class="Field">F₁</a>      <a id="9873" class="Symbol">=</a> <a data-type="(A → B₁) → ∥ A ∥ → ∥ B₁ ∥" id="9875" href="1Lab.HIT.Truncation.html#2876" class="Function">∥-∥-map</a> <a id="9883" class="Symbol">(</a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="9884" href="Cat.Base.html#7421" class="Field">F₁</a> <a id="9887" href="Cat.Thin.html#9862" class="Bound">F</a><a id="9888" class="Symbol">)</a>
<a data-type="Functor (Strict-Cat o h) (Prosets o h)" id="9890" href="Cat.Thin.html#9185" class="Function">Free</a> <a id="9895" class="Symbol">.</a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="9896" href="Cat.Base.html#7421" class="Field">F₁</a> <a id="9899" href="Cat.Thin.html#9899" class="Bound">F</a> <a id="9901" class="Symbol">.</a><a data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" id="9902" href="Cat.Base.html#7747" class="Field">F-id</a> <a id="9907" href="Cat.Thin.html#9907" class="Bound">i</a>  <a id="9910" class="Symbol">=</a> <a data-type="A → ∥ A ∥" id="9912" href="1Lab.HIT.Truncation.html#647" class="InductiveConstructor">inc</a> <a id="9916" class="Symbol">(</a><a data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" id="9917" href="Cat.Base.html#7747" class="Field">F-id</a> <a id="9922" href="Cat.Thin.html#9899" class="Bound">F</a> <a id="9924" href="Cat.Thin.html#9907" class="Bound">i</a><a id="9925" class="Symbol">)</a>
<a data-type="Functor (Strict-Cat o h) (Prosets o h)" id="9927" href="Cat.Thin.html#9185" class="Function">Free</a> <a id="9932" class="Symbol">.</a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="9933" href="Cat.Base.html#7421" class="Field">F₁</a> <a id="9936" href="Cat.Thin.html#9936" class="Bound">F</a> <a id="9938" class="Symbol">.</a><a data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" id="9939" href="Cat.Base.html#7787" class="Field">F-∘</a> <a id="9943" class="Symbol">_</a> <a id="9945" class="Symbol">_</a> <a id="9947" class="Symbol">=</a> <a data-type="is-prop ∥ A ∥" id="9949" href="1Lab.HIT.Truncation.html#668" class="InductiveConstructor">squash</a> <a id="9956" class="Symbol">_</a> <a id="9958" class="Symbol">_</a>
<a data-type="Functor (Strict-Cat o h) (Prosets o h)" id="9960" href="Cat.Thin.html#9185" class="Function">Free</a> <a id="9965" class="Symbol">.</a><a data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" id="9966" href="Cat.Base.html#7747" class="Field">F-id</a>    <a id="9974" class="Symbol">=</a> <a data-type="(p0 : (x : C .Ob) → F₀ F x ≡ F₀ G x) →
((f : C .Hom x y) →
 PathP (λ i → D .Hom (p0 x i) (p0 y i)) (F₁ F f) (F₁ G f)) →
F ≡ G" id="9976" href="Cat.Instances.Functor.html#3044" class="Function">Functor-path</a> <a id="9989" class="Symbol">(λ</a> <a id="9992" href="Cat.Thin.html#9992" class="Bound">_</a> <a id="9994" class="Symbol">→</a> <a data-type="x ≡ x" id="9996" href="1Lab.Path.html#3593" class="Function">refl</a><a id="10000" class="Symbol">)</a> <a id="10002" class="Symbol">λ</a> <a id="10004" href="Cat.Thin.html#10004" class="Bound">f</a> <a id="10006" class="Symbol">→</a> <a data-type="is-prop ∥ A ∥" id="10008" href="1Lab.HIT.Truncation.html#668" class="InductiveConstructor">squash</a> <a id="10015" class="Symbol">_</a> <a id="10017" class="Symbol">_</a>
<a data-type="Functor (Strict-Cat o h) (Prosets o h)" id="10019" href="Cat.Thin.html#9185" class="Function">Free</a> <a id="10024" class="Symbol">.</a><a data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" id="10025" href="Cat.Base.html#7787" class="Field">F-∘</a> <a id="10029" href="Cat.Thin.html#10029" class="Bound">f</a> <a id="10031" href="Cat.Thin.html#10031" class="Bound">g</a> <a id="10033" class="Symbol">=</a> <a data-type="(p0 : (x : C .Ob) → F₀ F x ≡ F₀ G x) →
((f : C .Hom x y) →
 PathP (λ i → D .Hom (p0 x i) (p0 y i)) (F₁ F f) (F₁ G f)) →
F ≡ G" id="10035" href="Cat.Instances.Functor.html#3044" class="Function">Functor-path</a> <a id="10048" class="Symbol">(λ</a> <a id="10051" href="Cat.Thin.html#10051" class="Bound">_</a> <a id="10053" class="Symbol">→</a> <a data-type="x ≡ x" id="10055" href="1Lab.Path.html#3593" class="Function">refl</a><a id="10059" class="Symbol">)</a> <a id="10061" class="Symbol">λ</a> <a id="10063" href="Cat.Thin.html#10063" class="Bound">f</a> <a id="10065" class="Symbol">→</a> <a data-type="is-prop ∥ A ∥" id="10067" href="1Lab.HIT.Truncation.html#668" class="InductiveConstructor">squash</a> <a id="10074" class="Symbol">_</a> <a id="10076" class="Symbol">_</a>
</pre>
<p>This <span class="Agda"><a data-type="Functor (Strict-Cat o h) (Prosets o h)" href="Cat.Thin.html#9185" class="Function">Free</a></span> functor is a <a href="Cat.Functor.Adjoint.html">left adjoint</a> to the <span class="Agda"><a data-type="Functor (Prosets o h) (Strict-Cat o h)" href="Cat.Thin.html#8708" class="Function">Forget</a></span> functor defined above, so in particular we conclude that it induces an idempotent monad on <span class="Agda"><a data-type="(o h : Level) → Precategory (lsuc o ⊔ lsuc h) (o ⊔ h)" href="Cat.Instances.StrictCat.html#2161" class="Function">Strict-Cat</a></span>: The “thinning” of a <span class="Agda"><a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" href="Cat.Thin.html#946" class="Record">Proset</a></span> is the same proset we started with.</p>
<pre class="Agda"><a id="Free⊣Forget"></a><a data-type="Free ⊣ Forget" id="10388" href="Cat.Thin.html#10388" class="Function">Free⊣Forget</a> <a id="10400" class="Symbol">:</a> <a data-type="Functor (Strict-Cat o h) (Prosets o h)" id="10402" href="Cat.Thin.html#9185" class="Function">Free</a> <a data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" id="10407" href="Cat.Functor.Adjoint.html#1862" class="Record Operator">⊣</a> <a data-type="Functor (Prosets o h) (Strict-Cat o h)" id="10409" href="Cat.Thin.html#8708" class="Function">Forget</a> <a id="10416" class="Symbol">{</a><a id="10417" href="Cat.Thin.html#229" class="Generalizable">o</a><a id="10418" class="Symbol">}</a> <a id="10420" class="Symbol">{</a><a id="10421" href="Cat.Thin.html#231" class="Generalizable">h</a><a id="10422" class="Symbol">}</a>
<a data-type="Free ⊣ Forget" id="10424" href="Cat.Thin.html#10388" class="Function">Free⊣Forget</a> <a id="10436" class="Symbol">.</a><a data-type="L ⊣ R₁ → Id =&gt; (R₁ F∘ L)" id="10437" href="Cat.Functor.Adjoint.html#2012" class="Field">unit</a> <a id="10442" class="Symbol">.</a><a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" id="10443" href="Cat.Base.html#11363" class="Field">η</a> <a id="10445" class="Symbol">_</a> <a id="10447" class="Symbol">.</a><a data-type="Functor C D → C .Ob → Ob D" id="10448" href="Cat.Base.html#7400" class="Field">F₀</a> <a id="10451" href="Cat.Thin.html#10451" class="Bound">x</a> <a id="10453" class="Symbol">=</a> <a id="10455" href="Cat.Thin.html#10451" class="Bound">x</a>
<a data-type="Free ⊣ Forget" id="10457" href="Cat.Thin.html#10388" class="Function">Free⊣Forget</a> <a id="10469" class="Symbol">.</a><a data-type="L ⊣ R₁ → Id =&gt; (R₁ F∘ L)" id="10470" href="Cat.Functor.Adjoint.html#2012" class="Field">unit</a> <a id="10475" class="Symbol">.</a><a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" id="10476" href="Cat.Base.html#11363" class="Field">η</a> <a id="10478" class="Symbol">_</a> <a id="10480" class="Symbol">.</a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="10481" href="Cat.Base.html#7421" class="Field">F₁</a> <a id="10484" class="Symbol">=</a> <a data-type="A → ∥ A ∥" id="10486" href="1Lab.HIT.Truncation.html#647" class="InductiveConstructor">inc</a>
<a data-type="Free ⊣ Forget" id="10490" href="Cat.Thin.html#10388" class="Function">Free⊣Forget</a> <a id="10502" class="Symbol">.</a><a data-type="L ⊣ R₁ → Id =&gt; (R₁ F∘ L)" id="10503" href="Cat.Functor.Adjoint.html#2012" class="Field">unit</a> <a id="10508" class="Symbol">.</a><a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" id="10509" href="Cat.Base.html#11363" class="Field">η</a> <a id="10511" class="Symbol">_</a> <a id="10513" class="Symbol">.</a><a data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" id="10514" href="Cat.Base.html#7747" class="Field">F-id</a> <a id="10519" class="Symbol">=</a> <a data-type="x ≡ x" id="10521" href="1Lab.Path.html#3593" class="Function">refl</a>
<a data-type="Free ⊣ Forget" id="10526" href="Cat.Thin.html#10388" class="Function">Free⊣Forget</a> <a id="10538" class="Symbol">.</a><a data-type="L ⊣ R₁ → Id =&gt; (R₁ F∘ L)" id="10539" href="Cat.Functor.Adjoint.html#2012" class="Field">unit</a> <a id="10544" class="Symbol">.</a><a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" id="10545" href="Cat.Base.html#11363" class="Field">η</a> <a id="10547" class="Symbol">_</a> <a id="10549" class="Symbol">.</a><a data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" id="10550" href="Cat.Base.html#7787" class="Field">F-∘</a> <a id="10554" href="Cat.Thin.html#10554" class="Bound">f</a> <a id="10556" href="Cat.Thin.html#10556" class="Bound">g</a> <a id="10558" class="Symbol">=</a> <a data-type="x ≡ x" id="10560" href="1Lab.Path.html#3593" class="Function">refl</a>
<a data-type="Free ⊣ Forget" id="10565" href="Cat.Thin.html#10388" class="Function">Free⊣Forget</a> <a id="10577" class="Symbol">.</a><a data-type="L ⊣ R₁ → Id =&gt; (R₁ F∘ L)" id="10578" href="Cat.Functor.Adjoint.html#2012" class="Field">unit</a> <a id="10583" class="Symbol">.</a><a data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" id="10584" href="Cat.Base.html#11941" class="Field">is-natural</a> <a id="10595" href="Cat.Thin.html#10595" class="Bound">x</a> <a id="10597" href="Cat.Thin.html#10597" class="Bound">y</a> <a id="10599" href="Cat.Thin.html#10599" class="Bound">f</a> <a id="10601" class="Symbol">=</a> <a data-type="(p0 : (x : C .Ob) → F₀ F x ≡ F₀ G x) →
((f : C .Hom x y) →
 PathP (λ i → D .Hom (p0 x i) (p0 y i)) (F₁ F f) (F₁ G f)) →
F ≡ G" id="10603" href="Cat.Instances.Functor.html#3044" class="Function">Functor-path</a> <a id="10616" class="Symbol">(λ</a> <a id="10619" href="Cat.Thin.html#10619" class="Bound">x</a> <a id="10621" class="Symbol">→</a> <a data-type="x ≡ x" id="10623" href="1Lab.Path.html#3593" class="Function">refl</a><a id="10627" class="Symbol">)</a> <a id="10629" class="Symbol">λ</a> <a id="10631" href="Cat.Thin.html#10631" class="Bound">_</a> <a id="10633" class="Symbol">→</a> <a data-type="x ≡ x" id="10635" href="1Lab.Path.html#3593" class="Function">refl</a>

<a data-type="Free ⊣ Forget" id="10641" href="Cat.Thin.html#10388" class="Function">Free⊣Forget</a> <a id="10653" class="Symbol">.</a><a data-type="L ⊣ R₁ → (L F∘ R₁) =&gt; Id" id="10654" href="Cat.Functor.Adjoint.html#2040" class="Field">counit</a> <a id="10661" class="Symbol">.</a><a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" id="10662" href="Cat.Base.html#11363" class="Field">η</a> <a id="10664" href="Cat.Thin.html#10664" class="Bound">pro</a> <a id="10668" class="Symbol">.</a><a data-type="Functor C D → C .Ob → Ob D" id="10669" href="Cat.Base.html#7400" class="Field">F₀</a> <a id="10672" href="Cat.Thin.html#10672" class="Bound">x</a> <a id="10674" class="Symbol">=</a> <a id="10676" href="Cat.Thin.html#10672" class="Bound">x</a>
<a data-type="Free ⊣ Forget" id="10678" href="Cat.Thin.html#10388" class="Function">Free⊣Forget</a> <a id="10690" class="Symbol">.</a><a data-type="L ⊣ R₁ → (L F∘ R₁) =&gt; Id" id="10691" href="Cat.Functor.Adjoint.html#2040" class="Field">counit</a> <a id="10698" class="Symbol">.</a><a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" id="10699" href="Cat.Base.html#11363" class="Field">η</a> <a id="10701" href="Cat.Thin.html#10701" class="Bound">pro</a> <a id="10705" class="Symbol">.</a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="10706" href="Cat.Base.html#7421" class="Field">F₁</a> <a id="10709" class="Symbol">=</a> <a data-type="((x : ∥ A ∥) → is-prop (P x)) →
((x : A) → P (inc x)) → (x : ∥ A ∥) → P x" id="10711" href="1Lab.HIT.Truncation.html#1110" class="Function">∥-∥-elim</a> <a id="10720" class="Symbol">(λ</a> <a id="10723" href="Cat.Thin.html#10723" class="Bound">_</a> <a id="10725" class="Symbol">→</a> <a id="10727" href="Cat.Thin.html#10701" class="Bound">pro</a> <a id="10731" class="Symbol">.</a><a data-type="(r : Poset o h) (A B₁ : r .underlying .Ob) →
is-prop (Hom (r .underlying) A B₁)" id="10732" href="Cat.Thin.html#752" class="Function">Proset.Hom-is-prop</a> <a id="10751" class="Symbol">_</a> <a id="10753" class="Symbol">_)</a> <a id="10756" class="Symbol">λ</a> <a id="10758" href="Cat.Thin.html#10758" class="Bound">x</a> <a id="10760" class="Symbol">→</a> <a id="10762" href="Cat.Thin.html#10758" class="Bound">x</a>
<a data-type="Free ⊣ Forget" id="10764" href="Cat.Thin.html#10388" class="Function">Free⊣Forget</a> <a id="10776" class="Symbol">.</a><a data-type="L ⊣ R₁ → (L F∘ R₁) =&gt; Id" id="10777" href="Cat.Functor.Adjoint.html#2040" class="Field">counit</a> <a id="10784" class="Symbol">.</a><a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" id="10785" href="Cat.Base.html#11363" class="Field">η</a> <a id="10787" href="Cat.Thin.html#10787" class="Bound">pro</a> <a id="10791" class="Symbol">.</a><a data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" id="10792" href="Cat.Base.html#7747" class="Field">F-id</a> <a id="10797" class="Symbol">=</a> <a data-type="x ≡ x" id="10799" href="1Lab.Path.html#3593" class="Function">refl</a>
<a data-type="Free ⊣ Forget" id="10804" href="Cat.Thin.html#10388" class="Function">Free⊣Forget</a> <a id="10816" class="Symbol">.</a><a data-type="L ⊣ R₁ → (L F∘ R₁) =&gt; Id" id="10817" href="Cat.Functor.Adjoint.html#2040" class="Field">counit</a> <a id="10824" class="Symbol">.</a><a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" id="10825" href="Cat.Base.html#11363" class="Field">η</a> <a id="10827" href="Cat.Thin.html#10827" class="Bound">pro</a> <a id="10831" class="Symbol">.</a><a data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" id="10832" href="Cat.Base.html#7787" class="Field">F-∘</a> <a id="10836" href="Cat.Thin.html#10836" class="Bound">f</a> <a id="10838" href="Cat.Thin.html#10838" class="Bound">g</a> <a id="10840" class="Symbol">=</a> <a id="10842" href="Cat.Thin.html#10827" class="Bound">pro</a> <a id="10846" class="Symbol">.</a><a data-type="(r : Poset o h) (A B₁ : r .underlying .Ob) →
is-prop (Hom (r .underlying) A B₁)" id="10847" href="Cat.Thin.html#752" class="Function">Proset.Hom-is-prop</a> <a id="10866" class="Symbol">_</a> <a id="10868" class="Symbol">_</a> <a id="10870" class="Symbol">_</a> <a id="10872" class="Symbol">_</a>
<a data-type="Free ⊣ Forget" id="10874" href="Cat.Thin.html#10388" class="Function">Free⊣Forget</a> <a id="10886" class="Symbol">.</a><a data-type="L ⊣ R₁ → (L F∘ R₁) =&gt; Id" id="10887" href="Cat.Functor.Adjoint.html#2040" class="Field">counit</a> <a id="10894" class="Symbol">.</a><a data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" id="10895" href="Cat.Base.html#11941" class="Field">is-natural</a> <a id="10906" href="Cat.Thin.html#10906" class="Bound">x</a> <a id="10908" href="Cat.Thin.html#10908" class="Bound">y</a> <a id="10910" href="Cat.Thin.html#10910" class="Bound">f</a> <a id="10912" class="Symbol">=</a>
  <a data-type="(p0 : (x : C .Ob) → F₀ F x ≡ F₀ G x) →
((f : C .Hom x y) →
 PathP (λ i → D .Hom (p0 x i) (p0 y i)) (F₁ F f) (F₁ G f)) →
F ≡ G" id="10916" href="Cat.Instances.Functor.html#3044" class="Function">Functor-path</a> <a id="10929" class="Symbol">(λ</a> <a id="10932" href="Cat.Thin.html#10932" class="Bound">_</a> <a id="10934" class="Symbol">→</a> <a data-type="x ≡ x" id="10936" href="1Lab.Path.html#3593" class="Function">refl</a><a id="10940" class="Symbol">)</a> <a id="10942" class="Symbol">λ</a> <a id="10944" href="Cat.Thin.html#10944" class="Bound">f</a> <a id="10946" class="Symbol">→</a> <a id="10948" href="Cat.Thin.html#10908" class="Bound">y</a> <a id="10950" class="Symbol">.</a><a data-type="(r : Poset o h) (A B₁ : r .underlying .Ob) →
is-prop (Hom (r .underlying) A B₁)" id="10951" href="Cat.Thin.html#752" class="Function">Proset.Hom-is-prop</a> <a id="10970" class="Symbol">_</a> <a id="10972" class="Symbol">_</a> <a id="10974" class="Symbol">_</a> <a id="10976" class="Symbol">_</a>

<a data-type="Free ⊣ Forget" id="10979" href="Cat.Thin.html#10388" class="Function">Free⊣Forget</a> <a id="10991" class="Symbol">.</a><a data-type="(r : L ⊣ R₁) →
D ._∘_ (η (r .counit) (F₀ L A)) (F₁ L (r .unit .η A)) ≡ D .id" id="10992" href="Cat.Functor.Adjoint.html#2613" class="Field">zig</a> <a id="10996" class="Symbol">=</a> <a data-type="(p0 : (x : C .Ob) → F₀ F x ≡ F₀ G x) →
((f : C .Hom x y) →
 PathP (λ i → D .Hom (p0 x i) (p0 y i)) (F₁ F f) (F₁ G f)) →
F ≡ G" id="10998" href="Cat.Instances.Functor.html#3044" class="Function">Functor-path</a> <a id="11011" class="Symbol">(λ</a> <a id="11014" href="Cat.Thin.html#11014" class="Bound">_</a> <a id="11016" class="Symbol">→</a> <a data-type="x ≡ x" id="11018" href="1Lab.Path.html#3593" class="Function">refl</a><a id="11022" class="Symbol">)</a> <a id="11024" class="Symbol">λ</a> <a id="11026" href="Cat.Thin.html#11026" class="Bound">_</a> <a id="11028" class="Symbol">→</a> <a data-type="is-prop ∥ A ∥" id="11030" href="1Lab.HIT.Truncation.html#668" class="InductiveConstructor">squash</a> <a id="11037" class="Symbol">_</a> <a id="11039" class="Symbol">_</a>
<a data-type="Free ⊣ Forget" id="11041" href="Cat.Thin.html#10388" class="Function">Free⊣Forget</a> <a id="11053" class="Symbol">.</a><a data-type="(r : L ⊣ R₁) →
C ._∘_ (F₁ R₁ (η (r .counit) B₁)) (r .unit .η (F₀ R₁ B₁)) ≡ C .id" id="11054" href="Cat.Functor.Adjoint.html#2676" class="Field">zag</a> <a id="11058" class="Symbol">=</a> <a data-type="(p0 : (x : C .Ob) → F₀ F x ≡ F₀ G x) →
((f : C .Hom x y) →
 PathP (λ i → D .Hom (p0 x i) (p0 y i)) (F₁ F f) (F₁ G f)) →
F ≡ G" id="11060" href="Cat.Instances.Functor.html#3044" class="Function">Functor-path</a> <a id="11073" class="Symbol">(λ</a> <a id="11076" href="Cat.Thin.html#11076" class="Bound">_</a> <a id="11078" class="Symbol">→</a> <a data-type="x ≡ x" id="11080" href="1Lab.Path.html#3593" class="Function">refl</a><a id="11084" class="Symbol">)</a> <a id="11086" class="Symbol">λ</a> <a id="11088" href="Cat.Thin.html#11088" class="Bound">_</a> <a id="11090" class="Symbol">→</a> <a data-type="x ≡ x" id="11092" href="1Lab.Path.html#3593" class="Function">refl</a>
</pre>
<h2 id="poset-completions"><a href="#poset-completions" class="header-link">Poset completions<span class="header-link-emoji">🔗</span></a></h2>
<p>It’s also possible to freely turn a proset into a poset. We do this in a separate module: <a href="Cat.Thin.Completion.html"><code>Cat.Thin.Completion</code></a>.</p>
  </article>
</div>

</main>
</body>
<style>.equations { display: none !important; }</style></html>
