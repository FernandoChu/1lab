<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>Cat.Functor.Adjoint - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />
  <link rel="stylesheet" href="/css/agda-cats.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Cat.Functor.Adjoint - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="Cat.Functor.Adjoint - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script src="/equations.js"></script>
  <script src="/highlight-hover.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>
</head>

<body>
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">Cat.Functor.Adjoint</a>
              </h3>

      <!-- Cube logo -->
      <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#adjoint-functors"><a href="#adjoint-functors" class="header-link">Adjoint functors<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#universal-morphisms"><a href="#universal-morphisms" class="header-link">Universal morphisms<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#defining-the-l"><a href="#defining-the-l" class="header-link">Defining the L<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#building-the-adjunction"><a href="#building-the-adjunction" class="header-link">Building the adjunction<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
              <a href="index.html">️back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/a707db849cafe7fff32b1afe7808ab39c8844886/src/Cat/Functor/Adjoint.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao and Reed Mullanix</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="index.html">️back to index</a>
      </div>
      
      <!-- Font toggle checkbox -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="Cat.Diagram.Initial.html" class="Module">Cat.Diagram.Initial</a>
<a id="41" class="Keyword">open</a> <a id="46" class="Keyword">import</a> <a id="53" href="Cat.Instances.Comma.html" class="Module">Cat.Instances.Comma</a>
<a id="73" class="Keyword">open</a> <a id="78" class="Keyword">import</a> <a id="85" href="Cat.Prelude.html" class="Module">Cat.Prelude</a>

<a id="98" class="Keyword">module</a> <a id="105" href="Cat.Functor.Adjoint.html" class="Module">Cat.Functor.Adjoint</a> <a id="125" class="Keyword">where</a>
</pre>
<!--
<pre class="Agda"><a id="149" class="Keyword">private</a> <a id="157" class="Keyword">variable</a>
  <a id="168" href="Cat.Functor.Adjoint.html#168" class="Generalizable">o</a> <a id="170" href="Cat.Functor.Adjoint.html#170" class="Generalizable">h</a> <a id="172" class="Symbol">:</a> <a id="174" href="Agda.Primitive.html#597" class="Postulate">Level</a>
  <a id="182" href="Cat.Functor.Adjoint.html#182" class="Generalizable">C</a> <a id="184" href="Cat.Functor.Adjoint.html#184" class="Generalizable">D</a> <a id="186" class="Symbol">:</a> <a id="188" href="Cat.Base.html#611" class="Record">Precategory</a> <a id="200" href="Cat.Functor.Adjoint.html#168" class="Generalizable">o</a> <a id="202" href="Cat.Functor.Adjoint.html#170" class="Generalizable">h</a>

<a id="205" class="Keyword">open</a> <a id="210" href="Cat.Base.html#6604" class="Module">Functor</a>

<a id="adj-level"></a><a id="219" href="Cat.Functor.Adjoint.html#219" class="Function">adj-level</a> <a id="229" class="Symbol">:</a> <a id="231" class="Symbol">∀</a> <a id="233" class="Symbol">{</a><a id="234" href="Cat.Functor.Adjoint.html#234" class="Bound">o₁</a> <a id="237" href="Cat.Functor.Adjoint.html#237" class="Bound">h₁</a> <a id="240" href="Cat.Functor.Adjoint.html#240" class="Bound">o₂</a> <a id="243" href="Cat.Functor.Adjoint.html#243" class="Bound">h₂</a><a id="245" class="Symbol">}</a> <a id="247" class="Symbol">{</a><a id="248" href="Cat.Functor.Adjoint.html#248" class="Bound">C</a> <a id="250" class="Symbol">:</a> <a id="252" href="Cat.Base.html#611" class="Record">Precategory</a> <a id="264" href="Cat.Functor.Adjoint.html#234" class="Bound">o₁</a> <a id="267" href="Cat.Functor.Adjoint.html#237" class="Bound">h₁</a><a id="269" class="Symbol">}</a> <a id="271" class="Symbol">{</a><a id="272" href="Cat.Functor.Adjoint.html#272" class="Bound">D</a> <a id="274" class="Symbol">:</a> <a id="276" href="Cat.Base.html#611" class="Record">Precategory</a> <a id="288" href="Cat.Functor.Adjoint.html#240" class="Bound">o₂</a> <a id="291" href="Cat.Functor.Adjoint.html#243" class="Bound">h₂</a><a id="293" class="Symbol">}</a>
          <a id="305" class="Symbol">→</a> <a id="307" href="Cat.Base.html#6604" class="Record">Functor</a> <a id="315" href="Cat.Functor.Adjoint.html#248" class="Bound">C</a> <a id="317" href="Cat.Functor.Adjoint.html#272" class="Bound">D</a> <a id="319" class="Symbol">→</a> <a id="321" href="Cat.Base.html#6604" class="Record">Functor</a> <a id="329" href="Cat.Functor.Adjoint.html#272" class="Bound">D</a> <a id="331" href="Cat.Functor.Adjoint.html#248" class="Bound">C</a> <a id="333" class="Symbol">→</a> <a id="335" href="Agda.Primitive.html#597" class="Postulate">Level</a>
<a id="341" href="Cat.Functor.Adjoint.html#219" class="Function">adj-level</a> <a id="351" class="Symbol">{</a><a id="352" class="Argument">o₁</a> <a id="355" class="Symbol">=</a> <a id="357" href="Cat.Functor.Adjoint.html#357" class="Bound">o₁</a><a id="359" class="Symbol">}</a> <a id="361" class="Symbol">{</a><a id="362" href="Cat.Functor.Adjoint.html#362" class="Bound">h₁</a><a id="364" class="Symbol">}</a> <a id="366" class="Symbol">{</a><a id="367" href="Cat.Functor.Adjoint.html#367" class="Bound">o₂</a><a id="369" class="Symbol">}</a> <a id="371" class="Symbol">{</a><a id="372" href="Cat.Functor.Adjoint.html#372" class="Bound">h₂</a><a id="374" class="Symbol">}</a> <a id="376" class="Symbol">_</a> <a id="378" class="Symbol">_</a> <a id="380" class="Symbol">=</a> <a id="382" href="Cat.Functor.Adjoint.html#357" class="Bound">o₁</a> <a id="385" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="387" href="Cat.Functor.Adjoint.html#367" class="Bound">o₂</a> <a id="390" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="392" href="Cat.Functor.Adjoint.html#362" class="Bound">h₁</a> <a id="395" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="397" href="Cat.Functor.Adjoint.html#372" class="Bound">h₂</a>
</pre>-->
<h1 id="adjoint-functors"><a href="#adjoint-functors" class="header-link">Adjoint functors<span class="header-link-emoji">🔗</span></a></h1>
<p>Category theory is, in general, the study of how things can be related. For instance, structures at the level of sets (e.g. the collection of natural numbers) are often interestingly related by propositions (i.e. the proposition <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≤</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \le y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>).</span> Structures at the level of groupoids (e.g. the collection of all sets) are interestingly related by sets (i.e. the set of maps <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \to y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>).</span> Going further, we have structures at the level of 2-groupoids, which could be given an interesting <em>category</em> of relations, etc.</p>
<p>A particularly important relationship is, of course, “sameness”. Going up the ladder of category number, we have equality at the (-1)-level, isomorphism at the 0-level, and what’s generally referred to as “equivalence” at higher levels. It’s often interesting to weaken these relations, by making some components directed: This starts at the level of categories, where “directing” an equivalence gives us the concept of <strong>adjunction</strong>.</p>
<p>An <em>equivalence of categories</em> between <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">\ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span> is given by a pair of functors <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>:</mo><mi mathvariant="script">C</mi><mo>⇆</mo><mi mathvariant="script">D</mi><mo>:</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L : \ca{C} \leftrightarrows \ca{D} : R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8641em;vertical-align:-0.1808em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel amsrm">⇆</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>,</span> equipped with natural <em>isomorphisms</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi><mo>:</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">d</mi></mrow><mo>≅</mo><mo stretchy="false">(</mo><mi>R</mi><mo>∘</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\eta : \mathrm{Id} \cong (R \circ L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">Id</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span> (the “unit”) and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi><mo>:</mo><mo stretchy="false">(</mo><mi>L</mi><mo>∘</mo><mi>R</mi><mo stretchy="false">)</mo><mo>≅</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">d</mi></mrow></mrow><annotation encoding="application/x-tex">\eps : (L \circ R) \cong \mathrm{Id}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ε</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">Id</span></span></span></span></span> (the “counit”). We still want the correspondence to be bidirectional, so we can’t change the types of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>,</span> <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>;</span> What we <em>can</em> do is weaken the natural isomorphisms to natural <em>transformations</em>. The data of an <strong>adjunction</strong> starts as such:</p>
<pre class="Agda"><a id="1891" class="Keyword">record</a> <a id="_⊣_"></a><a data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" id="1898" href="Cat.Functor.Adjoint.html#1898" class="Record Operator">_⊣_</a> <a id="1902" class="Symbol">(</a><a id="1903" href="Cat.Functor.Adjoint.html#1903" class="Bound">L</a> <a id="1905" class="Symbol">:</a> <a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="1907" href="Cat.Base.html#6604" class="Record">Functor</a> <a id="1915" href="Cat.Functor.Adjoint.html#182" class="Generalizable">C</a> <a id="1917" href="Cat.Functor.Adjoint.html#184" class="Generalizable">D</a><a id="1918" class="Symbol">)</a> <a id="1920" class="Symbol">(</a><a id="1921" href="Cat.Functor.Adjoint.html#1921" class="Bound">R</a> <a id="1923" class="Symbol">:</a> <a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="1925" href="Cat.Base.html#6604" class="Record">Functor</a> <a id="1933" href="Cat.Functor.Adjoint.html#184" class="Generalizable">D</a> <a id="1935" href="Cat.Functor.Adjoint.html#182" class="Generalizable">C</a><a id="1936" class="Symbol">)</a> <a id="1938" class="Symbol">:</a> <a id="1940" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="1945" class="Symbol">(</a><a data-type="Functor C D → Functor D C → Level" id="1946" href="Cat.Functor.Adjoint.html#219" class="Function">adj-level</a> <a id="1956" href="Cat.Functor.Adjoint.html#1903" class="Bound">L</a> <a id="1958" href="Cat.Functor.Adjoint.html#1921" class="Bound">R</a><a id="1959" class="Symbol">)</a> <a id="1961" class="Keyword">where</a>
  <a id="1969" class="Keyword">private</a>
    <a id="1981" class="Keyword">module</a> <a id="_⊣_.C"></a><a id="1988" href="Cat.Functor.Adjoint.html#1988" class="Module">C</a> <a id="1990" class="Symbol">=</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="1992" href="Cat.Base.html#611" class="Module">Precategory</a> <a id="2004" href="Cat.Functor.Adjoint.html#1915" class="Bound">C</a>
    <a id="2010" class="Keyword">module</a> <a id="_⊣_.D"></a><a id="2017" href="Cat.Functor.Adjoint.html#2017" class="Module">D</a> <a id="2019" class="Symbol">=</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="2021" href="Cat.Base.html#611" class="Module">Precategory</a> <a id="2033" href="Cat.Functor.Adjoint.html#1917" class="Bound">D</a>

  <a id="2038" class="Keyword">field</a>
    <a id="_⊣_.unit"></a><a data-type="L ⊣ R₁ → Id =&gt; (R₁ F∘ L)" id="2048" href="Cat.Functor.Adjoint.html#2048" class="Field">unit</a>   <a id="2055" class="Symbol">:</a> <a data-type="Functor C C" id="2057" href="Cat.Base.html#10202" class="Function">Id</a> <a data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" id="2060" href="Cat.Base.html#10721" class="Record Operator">=&gt;</a> <a id="2063" class="Symbol">(</a><a id="2064" href="Cat.Functor.Adjoint.html#1921" class="Bound">R</a> <a data-type="Functor D E → Functor C D → Functor C E" id="2066" href="Cat.Base.html#8511" class="Function Operator">F∘</a> <a id="2069" href="Cat.Functor.Adjoint.html#1903" class="Bound">L</a><a id="2070" class="Symbol">)</a>
    <a id="_⊣_.counit"></a><a data-type="L ⊣ R₁ → (L F∘ R₁) =&gt; Id" id="2076" href="Cat.Functor.Adjoint.html#2076" class="Field">counit</a> <a id="2083" class="Symbol">:</a> <a id="2085" class="Symbol">(</a><a id="2086" href="Cat.Functor.Adjoint.html#1903" class="Bound">L</a> <a data-type="Functor D E → Functor C D → Functor C E" id="2088" href="Cat.Base.html#8511" class="Function Operator">F∘</a> <a id="2091" href="Cat.Functor.Adjoint.html#1921" class="Bound">R</a><a id="2092" class="Symbol">)</a> <a data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" id="2094" href="Cat.Base.html#10721" class="Record Operator">=&gt;</a> <a data-type="Functor C C" id="2097" href="Cat.Base.html#10202" class="Function">Id</a>

  <a id="2103" class="Keyword">module</a> <a id="_⊣_.unit"></a><a id="2110" href="Cat.Functor.Adjoint.html#2110" class="Module">unit</a> <a id="2115" class="Symbol">=</a> <a data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" id="2117" href="Cat.Base.html#10721" class="Module Operator">_=&gt;_</a> <a data-type="L ⊣ R₁ → Id =&gt; (R₁ F∘ L)" id="2122" href="Cat.Functor.Adjoint.html#2048" class="Field">unit</a>
  <a id="2129" class="Keyword">module</a> <a id="_⊣_.counit"></a><a id="2136" href="Cat.Functor.Adjoint.html#2136" class="Module">counit</a> <a id="2143" class="Symbol">=</a> <a data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" id="2145" href="Cat.Base.html#10721" class="Module Operator">_=&gt;_</a> <a data-type="L ⊣ R₁ → (L F∘ R₁) =&gt; Id" id="2150" href="Cat.Functor.Adjoint.html#2076" class="Field">counit</a> <a id="2157" class="Keyword">renaming</a> <a id="2166" class="Symbol">(</a><a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" id="2167" href="Cat.Base.html#11272" class="Field">η</a> <a id="2169" class="Symbol">to</a> <a id="2172" class="Field">ε</a><a id="2173" class="Symbol">)</a>
</pre>
<p>Unfortunately, the data that we have here is not particularly coherent. The <span class="Agda"><a data-type="L ⊣ R₁ → Id =&gt; (R₁ F∘ L)" href="Cat.Functor.Adjoint.html#2048" class="Field">unit</a></span> and <span class="Agda"><a data-type="L ⊣ R₁ → (L F∘ R₁) =&gt; Id" href="Cat.Functor.Adjoint.html#2076" class="Field">counit</a></span> let us introduce <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∘</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">R\circ L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> and eliminate <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>∘</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L\circ R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> in a composition, which gives us two ways of mapping <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mstyle mathcolor="#cc0000"><mtext>\To</mtext></mstyle><mi>L</mi></mrow><annotation encoding="application/x-tex">L \To L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord text" style="color:#cc0000;"><span class="mord" style="color:#cc0000;">\To</span></span><span class="mord mathnormal">L</span></span></span></span>.</span> One is the identity, and the other is going through the unit: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mstyle mathcolor="#cc0000"><mtext>\To</mtext></mstyle><mi>L</mi><mo>∘</mo><mi>R</mi><mo>∘</mo><mi>L</mi><mstyle mathcolor="#cc0000"><mtext>\To</mtext></mstyle><mi>L</mi></mrow><annotation encoding="application/x-tex">L \To L\circ R\circ L \To L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord text" style="color:#cc0000;"><span class="mord" style="color:#cc0000;">\To</span></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord text" style="color:#cc0000;"><span class="mord" style="color:#cc0000;">\To</span></span><span class="mord mathnormal">L</span></span></span></span> (the situation with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> is symmetric). We must impose further equations on the natural transformations to make sure these match:</p>
<pre class="Agda">  <a id="2639" class="Keyword">field</a>
    <a id="_⊣_.zig"></a><a data-type="(r : L ⊣ R₁) →
D ._∘_ (η (r .counit) (F₀ L A)) (F₁ L (r .unit .η A)) ≡ D .id" id="2649" href="Cat.Functor.Adjoint.html#2649" class="Field">zig</a> <a id="2653" class="Symbol">:</a> <a id="2655" class="Symbol">∀</a> <a id="2657" class="Symbol">{</a><a id="2658" href="Cat.Functor.Adjoint.html#2658" class="Bound">A</a><a id="2659" class="Symbol">}</a> <a id="2661" class="Symbol">→</a> <a data-type="(r : L ⊣ R₁) (x : D .Ob) → D .Hom (₀ (L F∘ R₁) x) (₀ Id x)" id="2663" href="Cat.Functor.Adjoint.html#2172" class="Function">counit.ε</a> <a id="2672" class="Symbol">(</a><a data-type="Functor C D → C .Ob → Ob D" id="2673" href="Cat.Base.html#7390" class="Field">F₀</a> <a id="2676" href="Cat.Functor.Adjoint.html#1903" class="Bound">L</a> <a id="2678" href="Cat.Functor.Adjoint.html#2658" class="Bound">A</a><a id="2679" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2681" href="Cat.Base.html#2898" class="Function Operator">D.∘</a> <a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="2685" href="Cat.Base.html#7411" class="Field">F₁</a> <a id="2688" href="Cat.Functor.Adjoint.html#1903" class="Bound">L</a> <a id="2690" class="Symbol">(</a><a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" id="2691" href="Cat.Base.html#11272" class="Function">unit.η</a> <a id="2698" href="Cat.Functor.Adjoint.html#2658" class="Bound">A</a><a id="2699" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="2701" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="2703" href="Cat.Base.html#2868" class="Function">D.id</a>
    <a id="_⊣_.zag"></a><a data-type="(r : L ⊣ R₁) →
C ._∘_ (F₁ R₁ (η (r .counit) B₁)) (r .unit .η (F₀ R₁ B₁)) ≡ C .id" id="2712" href="Cat.Functor.Adjoint.html#2712" class="Field">zag</a> <a id="2716" class="Symbol">:</a> <a id="2718" class="Symbol">∀</a> <a id="2720" class="Symbol">{</a><a id="2721" href="Cat.Functor.Adjoint.html#2721" class="Bound">B</a><a id="2722" class="Symbol">}</a> <a id="2724" class="Symbol">→</a> <a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="2726" href="Cat.Base.html#7411" class="Field">F₁</a> <a id="2729" href="Cat.Functor.Adjoint.html#1921" class="Bound">R</a> <a id="2731" class="Symbol">(</a><a data-type="(r : L ⊣ R₁) (x : D .Ob) → D .Hom (₀ (L F∘ R₁) x) (₀ Id x)" id="2732" href="Cat.Functor.Adjoint.html#2172" class="Function">counit.ε</a> <a id="2741" href="Cat.Functor.Adjoint.html#2721" class="Bound">B</a><a id="2742" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2744" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" id="2748" href="Cat.Base.html#11272" class="Function">unit.η</a> <a id="2755" class="Symbol">(</a><a data-type="Functor C D → C .Ob → Ob D" id="2756" href="Cat.Base.html#7390" class="Field">F₀</a> <a id="2759" href="Cat.Functor.Adjoint.html#1921" class="Bound">R</a> <a id="2761" href="Cat.Functor.Adjoint.html#2721" class="Bound">B</a><a id="2762" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="2764" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="2766" href="Cat.Base.html#2868" class="Function">C.id</a>
</pre>
<p>These are called “triangle identities” because of the shape they have as commutative diagrams:</p>
<div class="mathpar">
<div class="diagram-container">
<img src="736f61228a1ec522ec947b5c2df33b28d5800b19.svg" title="commutative diagram" class="diagram quiver" />
</div>
<div class="diagram-container">
<img src="88202b89d1455fa535f2b6e8e82bb43f2c2d6e04.svg" title="commutative diagram" class="diagram quiver" />
</div>
</div>
<h1 id="universal-morphisms"><a href="#universal-morphisms" class="header-link">Universal morphisms<span class="header-link-emoji">🔗</span></a></h1>
<!--
<pre class="Agda"><a id="3287" class="Keyword">module</a> <a id="3294" href="Cat.Functor.Adjoint.html#3294" class="Module">_</a> 
  <a id="3299" class="Symbol">{</a><a id="3300" href="Cat.Functor.Adjoint.html#3300" class="Bound">o</a> <a id="3302" href="Cat.Functor.Adjoint.html#3302" class="Bound">h</a> <a id="3304" href="Cat.Functor.Adjoint.html#3304" class="Bound">o&#39;</a> <a id="3307" href="Cat.Functor.Adjoint.html#3307" class="Bound">h&#39;</a><a id="3309" class="Symbol">}</a>
  <a id="3313" class="Symbol">{</a><a id="3314" href="Cat.Functor.Adjoint.html#3314" class="Bound">C</a> <a id="3316" class="Symbol">:</a> <a id="3318" href="Cat.Base.html#611" class="Record">Precategory</a> <a id="3330" href="Cat.Functor.Adjoint.html#3300" class="Bound">o</a> <a id="3332" href="Cat.Functor.Adjoint.html#3302" class="Bound">h</a><a id="3333" class="Symbol">}</a>
  <a id="3337" class="Symbol">{</a><a id="3338" href="Cat.Functor.Adjoint.html#3338" class="Bound">D</a> <a id="3340" class="Symbol">:</a> <a id="3342" href="Cat.Base.html#611" class="Record">Precategory</a> <a id="3354" href="Cat.Functor.Adjoint.html#3304" class="Bound">o&#39;</a> <a id="3357" href="Cat.Functor.Adjoint.html#3307" class="Bound">h&#39;</a><a id="3359" class="Symbol">}</a>
  <a id="3363" class="Keyword">where</a>

  <a id="3372" class="Keyword">private</a>
    <a id="3384" class="Keyword">module</a> <a id="3391" href="Cat.Functor.Adjoint.html#3391" class="Module">C</a> <a id="3393" class="Symbol">=</a> <a id="3395" href="Cat.Base.html#611" class="Module">Precategory</a> <a id="3407" href="Cat.Functor.Adjoint.html#3314" class="Bound">C</a>
    <a id="3413" class="Keyword">module</a> <a id="3420" href="Cat.Functor.Adjoint.html#3420" class="Module">D</a> <a id="3422" class="Symbol">=</a> <a id="3424" href="Cat.Base.html#611" class="Module">Precategory</a> <a id="3436" href="Cat.Functor.Adjoint.html#3338" class="Bound">D</a>
</pre>-->
<p>Another perspective on adjoint functors is given by finding “most efficient solutions” to the “problem” posed by a functor. For instance, the (<a href="Cat.Functor.Base.html#ff-functors">ff</a>) inclusion of <a href="Cat.Thin.html#prosets">prosets</a> into <a href="Cat.Instances.StrictCat.html#strict-precategories">strict precategories</a> poses the problem of turning a precategory into a proset. While this can’t be done in a 1:1 way (precategories are strictly more general than prosets), we <em>can</em> still ponder whether there is some “most efficient” way to turn a category into a proset.</p>
<p>While we can’t directly consider maps from precategories to proset, we <em>can</em> consider maps from precategories to the inclusion of a proset; Let us write <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span> for a generic precategory, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">P</mi></mrow><annotation encoding="application/x-tex">\ca{P}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.08222em;">P</span></span></span></span> for a generic proset, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo stretchy="false">(</mo><mi mathvariant="script">P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">U(\ca{P})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mopen">(</span><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="mclose">)</span></span></span></span> for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">P</mi></mrow><annotation encoding="application/x-tex">\ca{P}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.08222em;">P</span></span></span></span> considered as a precategory. Any functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi><mo>→</mo><mi>U</mi><mo stretchy="false">(</mo><mi mathvariant="script">P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\ca{C} \to U(\ca{P})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mopen">(</span><span class="mord mathcal" style="margin-right:0.08222em;">P</span><span class="mclose">)</span></span></span></span> can be seen as “a way to turn <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span> into a proset”, but not all of these can be the “most efficient” way. In fact, there is a vast sea of uninteresting ways to turn a precategory into a proset: turn them all into the <a href="Cat.Diagram.Terminal.html">terminal</a> proset!</p>
<p>A “most efficient” solution, then, would be one through which all others factor. A “universal” way of turning a strict precategory into a proset: A <strong>universal morphism</strong> from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span> to <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>.</span> The way we think about universal morphisms (reusing the same variables) is as <a href="Cat.Diagram.Initial.html">initial objects</a> in the <a href="Cat.Instances.Comma.html">comma category</a> <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi><mo>↙</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">\ca{C} \swarrow U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↙</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>,</span> where that category is conceptualised as being “the category of maps from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>”.</p>
<pre class="Agda">  <a data-type="C .Ob → Functor D C → Type (h ⊔ o&#39; ⊔ h&#39;)" id="5164" href="Cat.Functor.Adjoint.html#5164" class="Function">Universal-morphism</a> <a id="5183" class="Symbol">:</a> <a data-type="Precategory o h → Type o" id="5185" href="Cat.Base.html#1312" class="Function">C.Ob</a> <a id="5190" class="Symbol">→</a> <a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="5192" href="Cat.Base.html#6604" class="Record">Functor</a> <a id="5200" href="Cat.Functor.Adjoint.html#3338" class="Bound">D</a> <a id="5202" href="Cat.Functor.Adjoint.html#3314" class="Bound">C</a> <a id="5204" class="Symbol">→</a> <a id="5206" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="5211" class="Symbol">_</a>
  <a data-type="C .Ob → Functor D C → Type (h ⊔ o&#39; ⊔ h&#39;)" id="5215" href="Cat.Functor.Adjoint.html#5164" class="Function">Universal-morphism</a> <a id="5234" href="Cat.Functor.Adjoint.html#5234" class="Bound">X</a> <a id="5236" href="Cat.Functor.Adjoint.html#5236" class="Bound">R</a> <a id="5238" class="Symbol">=</a> <a data-type="(C : Precategory o h) → Type (o ⊔ h)" id="5240" href="Cat.Diagram.Initial.html#398" class="Record">Initial</a> <a id="5248" class="Symbol">(</a><a id="5249" href="Cat.Functor.Adjoint.html#5234" class="Bound">X</a> <a data-type="A .Ob →
Functor B₁ A → Precategory (ah ⊔ bo ⊔ lzero) (ah ⊔ bh ⊔ lzero)" id="5251" href="Cat.Instances.Comma.html#5865" class="Function Operator">↙</a> <a id="5253" href="Cat.Functor.Adjoint.html#5236" class="Bound">R</a><a id="5254" class="Symbol">)</a>
</pre>
<p>Abstracting away, suppose that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>:</mo><mi>D</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">R : D \to C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> has universal morphisms for every object of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>.</span> To show the correspondence between these two ideas of adjunction, we show that this assignment extends to a functor <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">L : C \to D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>,</span> with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊣</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L \dashv R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> as defined above.</p>
<!--
<pre class="Agda"><a id="5536" class="Keyword">module</a> <a id="5543" href="Cat.Functor.Adjoint.html#5543" class="Module">_</a> 
  <a id="5548" class="Symbol">{</a><a id="5549" href="Cat.Functor.Adjoint.html#5549" class="Bound">o</a> <a id="5551" href="Cat.Functor.Adjoint.html#5551" class="Bound">h</a> <a id="5553" href="Cat.Functor.Adjoint.html#5553" class="Bound">o&#39;</a> <a id="5556" href="Cat.Functor.Adjoint.html#5556" class="Bound">h&#39;</a><a id="5558" class="Symbol">}</a>
  <a id="5562" class="Symbol">{</a><a id="5563" href="Cat.Functor.Adjoint.html#5563" class="Bound">C</a> <a id="5565" class="Symbol">:</a> <a id="5567" href="Cat.Base.html#611" class="Record">Precategory</a> <a id="5579" href="Cat.Functor.Adjoint.html#5549" class="Bound">o</a> <a id="5581" href="Cat.Functor.Adjoint.html#5551" class="Bound">h</a><a id="5582" class="Symbol">}</a>
  <a id="5586" class="Symbol">{</a><a id="5587" href="Cat.Functor.Adjoint.html#5587" class="Bound">D</a> <a id="5589" class="Symbol">:</a> <a id="5591" href="Cat.Base.html#611" class="Record">Precategory</a> <a id="5603" href="Cat.Functor.Adjoint.html#5553" class="Bound">o&#39;</a> <a id="5606" href="Cat.Functor.Adjoint.html#5556" class="Bound">h&#39;</a><a id="5608" class="Symbol">}</a>
  <a id="5612" class="Symbol">(</a><a id="5613" href="Cat.Functor.Adjoint.html#5613" class="Bound">R</a> <a id="5615" class="Symbol">:</a> <a id="5617" href="Cat.Base.html#6604" class="Record">Functor</a> <a id="5625" href="Cat.Functor.Adjoint.html#5587" class="Bound">D</a> <a id="5627" href="Cat.Functor.Adjoint.html#5563" class="Bound">C</a><a id="5628" class="Symbol">)</a>
  <a id="5632" class="Symbol">(</a><a id="5633" href="Cat.Functor.Adjoint.html#5633" class="Bound">universal-map-for</a> <a id="5651" class="Symbol">:</a> <a id="5653" class="Symbol">∀</a> <a id="5655" href="Cat.Functor.Adjoint.html#5655" class="Bound">c</a> <a id="5657" class="Symbol">→</a> <a id="5659" href="Cat.Functor.Adjoint.html#5164" class="Function">Universal-morphism</a> <a id="5678" href="Cat.Functor.Adjoint.html#5655" class="Bound">c</a> <a id="5680" href="Cat.Functor.Adjoint.html#5613" class="Bound">R</a><a id="5681" class="Symbol">)</a>
  <a id="5685" class="Keyword">where</a>

  <a id="5694" class="Keyword">open</a> <a id="5699" href="Cat.Diagram.Initial.html#398" class="Module">Initial</a>
  <a id="5709" class="Keyword">open</a> <a id="5714" href="Cat.Instances.Comma.html#2452" class="Module">↓Hom</a> <a id="5719" class="Keyword">using</a> <a id="5725" class="Symbol">(</a><a id="5726" href="Cat.Instances.Comma.html#2621" class="Field">β</a><a id="5727" class="Symbol">)</a>
  <a id="5731" class="Keyword">open</a> <a id="5736" href="Cat.Instances.Comma.html#1730" class="Module">↓Obj</a> <a id="5741" class="Keyword">using</a> <a id="5747" class="Symbol">(</a><a id="5748" href="Cat.Instances.Comma.html#1832" class="Field">map</a><a id="5751" class="Symbol">)</a>

  <a id="5756" class="Keyword">open</a> <a id="5761" href="Cat.Base.html#611" class="Module">Precategory</a>

  <a id="5776" class="Keyword">private</a>
    <a id="5788" class="Keyword">import</a> <a id="5795" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="5809" href="Cat.Functor.Adjoint.html#5563" class="Bound">C</a> as <a id="5814" href="Cat.Functor.Adjoint.html#5814" class="Module">C</a>
    <a id="5820" class="Keyword">import</a> <a id="5827" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="5841" href="Cat.Functor.Adjoint.html#5587" class="Bound">D</a> as <a id="5846" href="Cat.Functor.Adjoint.html#5846" class="Module">D</a>
    <a id="5852" class="Keyword">module</a> <a id="5859" href="Cat.Functor.Adjoint.html#5859" class="Module">R</a> <a id="5861" class="Symbol">=</a> <a id="5863" href="Cat.Base.html#6604" class="Module">Functor</a> <a id="5871" href="Cat.Functor.Adjoint.html#5613" class="Bound">R</a>
</pre>-->
<h2 id="defining-the-l"><a href="#defining-the-l" class="header-link">Defining the L<span class="header-link-emoji">🔗</span></a></h2>
<p>We first show that the assignment of universal morphisms restricts to a functorial assignment <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">L : C \to D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>.</span> Recall that an object in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>↙</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">X \swarrow R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↙</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> is given by a codomain <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> and a map <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>R</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X \to R(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>.</span> We define <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L_0(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> to be the codomain of the universal morphism:</p>
<pre class="Agda">  <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Ob → D .Ob" id="6177" href="Cat.Functor.Adjoint.html#6177" class="Function">L₀</a> <a id="6180" class="Symbol">:</a> <a data-type="Precategory o h → Type o" id="6182" href="Cat.Base.html#1312" class="Function">C.Ob</a> <a id="6187" class="Symbol">→</a> <a data-type="Precategory o h → Type o" id="6189" href="Cat.Base.html#1312" class="Function">D.Ob</a>
  <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Ob → D .Ob" id="6196" href="Cat.Functor.Adjoint.html#6177" class="Function">L₀</a> <a id="6199" href="Cat.Functor.Adjoint.html#6199" class="Bound">x</a> <a id="6201" class="Symbol">=</a> <a id="6203" href="Cat.Functor.Adjoint.html#5633" class="Bound">universal-map-for</a> <a id="6221" href="Cat.Functor.Adjoint.html#6199" class="Bound">x</a> <a id="6223" class="Symbol">.</a><a data-type="Initial C → Ob C" id="6224" href="Cat.Diagram.Initial.html#439" class="Field">bot</a> <a id="6228" class="Symbol">.</a><a data-type="↓Obj F G → Ob B₁" id="6229" href="Cat.Instances.Comma.html#1816" class="Field">↓Obj.y</a>

  <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(c : C .Ob) →
C .Hom c (₀ R₁ (L₀ R₁ universal-map-for c))" id="6239" href="Cat.Functor.Adjoint.html#6239" class="Function">L₀′</a> <a id="6243" class="Symbol">:</a> <a id="6245" class="Symbol">(</a><a id="6246" href="Cat.Functor.Adjoint.html#6246" class="Bound">c</a> <a id="6248" class="Symbol">:</a> <a data-type="Precategory o h → Type o" id="6250" href="Cat.Base.html#1312" class="Function">C.Ob</a><a id="6254" class="Symbol">)</a> <a id="6256" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="6258" href="Cat.Base.html#1329" class="Function">C.Hom</a> <a id="6264" href="Cat.Functor.Adjoint.html#6246" class="Bound">c</a> <a id="6266" class="Symbol">(</a><a data-type="(r : Functor C D) → C .Ob → D .Ob" id="6267" href="Cat.Base.html#8129" class="Function">R.₀</a> <a id="6271" class="Symbol">(</a><a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Ob → D .Ob" id="6272" href="Cat.Functor.Adjoint.html#6177" class="Function">L₀</a> <a id="6275" href="Cat.Functor.Adjoint.html#6246" class="Bound">c</a><a id="6276" class="Symbol">))</a>
  <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(c : C .Ob) →
C .Hom c (₀ R₁ (L₀ R₁ universal-map-for c))" id="6281" href="Cat.Functor.Adjoint.html#6239" class="Function">L₀′</a> <a id="6285" href="Cat.Functor.Adjoint.html#6285" class="Bound">x</a> <a id="6287" class="Symbol">=</a> <a id="6289" href="Cat.Functor.Adjoint.html#5633" class="Bound">universal-map-for</a> <a id="6307" href="Cat.Functor.Adjoint.html#6285" class="Bound">x</a> <a id="6309" class="Symbol">.</a><a data-type="Initial C → Ob C" id="6310" href="Cat.Diagram.Initial.html#439" class="Field">bot</a> <a id="6314" class="Symbol">.</a><a data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" id="6315" href="Cat.Instances.Comma.html#1832" class="Field">map</a>
</pre>
<p>Given an arrow <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \to b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> in <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>,</span> we can send it to a uniquely-determined <em>object</em> in <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>↙</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">a \swarrow R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↙</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>:</span> We take the universal arrow assigned to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> (an object of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>↙</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">b \swarrow R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↙</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>),</span> and precompose with <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>.</span> This object will then serve as the domain of the morphism part of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span>,</span> which is given by the unique assignment arrows out of the initial object in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>↙</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">a \swarrow R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↙</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> (see <span class="Agda"><a href="Cat.Functor.Adjoint.html#6851" class="Function">lift↓</a></span> below).</p>
<pre class="Agda">  <a id="6731" class="Keyword">private</a>
    <a id="6743" href="Cat.Functor.Adjoint.html#6743" class="Function">toOb</a> <a id="6748" class="Symbol">:</a> <a id="6750" class="Symbol">∀</a> <a id="6752" class="Symbol">{</a><a id="6753" href="Cat.Functor.Adjoint.html#6753" class="Bound">a</a> <a id="6755" href="Cat.Functor.Adjoint.html#6755" class="Bound">b</a><a id="6756" class="Symbol">}</a> <a id="6758" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="6760" href="Cat.Base.html#1329" class="Function">C.Hom</a> <a id="6766" href="Cat.Functor.Adjoint.html#6753" class="Bound">a</a> <a id="6768" href="Cat.Functor.Adjoint.html#6755" class="Bound">b</a> <a id="6770" class="Symbol">→</a> <a id="6772" class="Symbol">(</a><a id="6773" href="Cat.Functor.Adjoint.html#6753" class="Bound">a</a> <a data-type="A .Ob →
Functor B₁ A → Precategory (ah ⊔ bo ⊔ lzero) (ah ⊔ bh ⊔ lzero)" id="6775" href="Cat.Instances.Comma.html#5865" class="Function Operator">↙</a> <a id="6777" href="Cat.Functor.Adjoint.html#5613" class="Bound">R</a><a id="6778" class="Symbol">)</a> <a id="6780" class="Symbol">.</a><a data-type="Precategory o h → Type o" id="6781" href="Cat.Base.html#1312" class="Field">Precategory.Ob</a>
    <a id="6800" href="Cat.Functor.Adjoint.html#6743" class="Function">toOb</a> <a id="6805" class="Symbol">{</a><a id="6806" href="Cat.Functor.Adjoint.html#6806" class="Bound">a</a><a id="6807" class="Symbol">}</a> <a id="6809" class="Symbol">{</a><a id="6810" href="Cat.Functor.Adjoint.html#6810" class="Bound">b</a><a id="6811" class="Symbol">}</a> <a id="6813" href="Cat.Functor.Adjoint.html#6813" class="Bound">h</a> <a id="6815" class="Symbol">=</a> <a id="6817" class="Keyword">record</a> <a id="6824" class="Symbol">{</a> <a data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" id="6826" href="Cat.Instances.Comma.html#1832" class="Field">map</a> <a id="6830" class="Symbol">=</a> <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(c : C .Ob) →
C .Hom c (₀ R₁ (L₀ R₁ universal-map-for c))" id="6832" href="Cat.Functor.Adjoint.html#6239" class="Function">L₀′</a> <a id="6836" href="Cat.Functor.Adjoint.html#6810" class="Bound">b</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="6838" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a id="6842" href="Cat.Functor.Adjoint.html#6813" class="Bound">h</a> <a id="6844" class="Symbol">}</a>

    <a id="6851" href="Cat.Functor.Adjoint.html#6851" class="Function">lift↓</a> <a id="6857" class="Symbol">:</a> <a id="6859" class="Symbol">∀</a> <a id="6861" class="Symbol">{</a><a id="6862" href="Cat.Functor.Adjoint.html#6862" class="Bound">x</a> <a id="6864" href="Cat.Functor.Adjoint.html#6864" class="Bound">y</a><a id="6865" class="Symbol">}</a> <a id="6867" class="Symbol">(</a><a id="6868" href="Cat.Functor.Adjoint.html#6868" class="Bound">g</a> <a id="6870" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="6872" href="Cat.Base.html#1329" class="Function">C.Hom</a> <a id="6878" href="Cat.Functor.Adjoint.html#6862" class="Bound">x</a> <a id="6880" href="Cat.Functor.Adjoint.html#6864" class="Bound">y</a><a id="6881" class="Symbol">)</a> 
          <a id="6894" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="6896" href="Cat.Base.html#1329" class="Field">Precategory.Hom</a> <a id="6912" class="Symbol">(</a><a id="6913" href="Cat.Functor.Adjoint.html#6862" class="Bound">x</a> <a data-type="A .Ob →
Functor B₁ A → Precategory (ah ⊔ bo ⊔ lzero) (ah ⊔ bh ⊔ lzero)" id="6915" href="Cat.Instances.Comma.html#5865" class="Function Operator">↙</a> <a id="6917" href="Cat.Functor.Adjoint.html#5613" class="Bound">R</a><a id="6918" class="Symbol">)</a> <a id="6920" class="Symbol">(</a><a id="6921" href="Cat.Functor.Adjoint.html#5633" class="Bound">universal-map-for</a> <a id="6939" href="Cat.Functor.Adjoint.html#6862" class="Bound">x</a> <a id="6941" class="Symbol">.</a><a data-type="Initial C → Ob C" id="6942" href="Cat.Diagram.Initial.html#439" class="Field">bot</a><a id="6945" class="Symbol">)</a> <a id="6947" class="Symbol">(</a><a id="6948" href="Cat.Functor.Adjoint.html#6743" class="Function">toOb</a> <a id="6953" href="Cat.Functor.Adjoint.html#6868" class="Bound">g</a><a id="6954" class="Symbol">)</a>
    <a id="6960" href="Cat.Functor.Adjoint.html#6851" class="Function">lift↓</a> <a id="6966" class="Symbol">{</a><a id="6967" href="Cat.Functor.Adjoint.html#6967" class="Bound">x</a><a id="6968" class="Symbol">}</a> <a id="6970" class="Symbol">{</a><a id="6971" href="Cat.Functor.Adjoint.html#6971" class="Bound">y</a><a id="6972" class="Symbol">}</a> <a id="6974" href="Cat.Functor.Adjoint.html#6974" class="Bound">g</a> <a id="6976" class="Symbol">=</a> <a data-type="(r : Initial C) → Hom C (bot r) x" id="6978" href="Cat.Diagram.Initial.html#596" class="Function">¡</a> <a id="6980" class="Symbol">(</a><a id="6981" href="Cat.Functor.Adjoint.html#5633" class="Bound">universal-map-for</a> <a id="6999" href="Cat.Functor.Adjoint.html#6967" class="Bound">x</a><a id="7000" class="Symbol">)</a> <a id="7002" class="Symbol">{</a><a id="7003" href="Cat.Functor.Adjoint.html#6743" class="Function">toOb</a> <a id="7008" href="Cat.Functor.Adjoint.html#6974" class="Bound">g</a><a id="7009" class="Symbol">}</a>

  <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom a b →
D .Hom (L₀ R₁ universal-map-for a) (L₀ R₁ universal-map-for b)" id="7014" href="Cat.Functor.Adjoint.html#7014" class="Function">L₁</a> <a id="7017" class="Symbol">:</a> <a id="7019" class="Symbol">∀</a> <a id="7021" class="Symbol">{</a><a id="7022" href="Cat.Functor.Adjoint.html#7022" class="Bound">a</a> <a id="7024" href="Cat.Functor.Adjoint.html#7024" class="Bound">b</a><a id="7025" class="Symbol">}</a> <a id="7027" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="7029" href="Cat.Base.html#1329" class="Function">C.Hom</a> <a id="7035" href="Cat.Functor.Adjoint.html#7022" class="Bound">a</a> <a id="7037" href="Cat.Functor.Adjoint.html#7024" class="Bound">b</a> <a id="7039" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="7041" href="Cat.Base.html#1329" class="Function">D.Hom</a> <a id="7047" class="Symbol">(</a><a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Ob → D .Ob" id="7048" href="Cat.Functor.Adjoint.html#6177" class="Function">L₀</a> <a id="7051" href="Cat.Functor.Adjoint.html#7022" class="Bound">a</a><a id="7052" class="Symbol">)</a> <a id="7054" class="Symbol">(</a><a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Ob → D .Ob" id="7055" href="Cat.Functor.Adjoint.html#6177" class="Function">L₀</a> <a id="7058" href="Cat.Functor.Adjoint.html#7024" class="Bound">b</a><a id="7059" class="Symbol">)</a>
  <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom a b →
D .Hom (L₀ R₁ universal-map-for a) (L₀ R₁ universal-map-for b)" id="7063" href="Cat.Functor.Adjoint.html#7014" class="Function">L₁</a> <a id="7066" class="Symbol">{</a><a id="7067" href="Cat.Functor.Adjoint.html#7067" class="Bound">a</a><a id="7068" class="Symbol">}</a> <a id="7070" class="Symbol">{</a><a id="7071" href="Cat.Functor.Adjoint.html#7071" class="Bound">b</a><a id="7072" class="Symbol">}</a> <a id="7074" href="Cat.Functor.Adjoint.html#7074" class="Bound">x</a> <a id="7076" class="Symbol">=</a> <a id="7078" href="Cat.Functor.Adjoint.html#6851" class="Function">lift↓</a> <a id="7084" href="Cat.Functor.Adjoint.html#7074" class="Bound">x</a> <a id="7086" class="Symbol">.</a><a data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" id="7087" href="Cat.Instances.Comma.html#2621" class="Field">β</a>
</pre>
<details>
<summary>
It now suffices to show the functor identities hold for <span class="Agda"><a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom a b →
D .Hom (L₀ R₁ universal-map-for a) (L₀ R₁ universal-map-for b)" href="Cat.Functor.Adjoint.html#7014" class="Function">L₁</a></span>. They follow essentially from the uniqueness of maps out of an initial object.
</summary>
<pre class="Agda">  <a id="7283" class="Keyword">private</a> <a id="7291" class="Keyword">abstract</a>
    <a id="7304" href="Cat.Functor.Adjoint.html#7304" class="Function">L-id</a> <a id="7309" class="Symbol">:</a> <a id="7311" class="Symbol">∀</a> <a id="7313" class="Symbol">{</a><a id="7314" href="Cat.Functor.Adjoint.html#7314" class="Bound">a</a><a id="7315" class="Symbol">}</a> <a id="7317" class="Symbol">→</a> <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom a b →
D .Hom (L₀ R₁ universal-map-for a) (L₀ R₁ universal-map-for b)" id="7319" href="Cat.Functor.Adjoint.html#7014" class="Function">L₁</a> <a id="7322" class="Symbol">(</a><a data-type="(r : Precategory o h) → r .Hom x x" id="7323" href="Cat.Base.html#2868" class="Function">C.id</a> <a id="7328" class="Symbol">{</a><a id="7329" href="Cat.Functor.Adjoint.html#7314" class="Bound">a</a><a id="7330" class="Symbol">})</a> <a data-type="A → A → Type ℓ" id="7333" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="7335" href="Cat.Base.html#2868" class="Function">D.id</a> <a id="7340" class="Symbol">{</a><a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Ob → D .Ob" id="7341" href="Cat.Functor.Adjoint.html#6177" class="Function">L₀</a> <a id="7344" href="Cat.Functor.Adjoint.html#7314" class="Bound">a</a><a id="7345" class="Symbol">}</a>
    <a id="7351" href="Cat.Functor.Adjoint.html#7304" class="Function">L-id</a> <a id="7356" class="Symbol">{</a><a id="7357" href="Cat.Functor.Adjoint.html#7357" class="Bound">a</a><a id="7358" class="Symbol">}</a> <a id="7360" class="Symbol">=</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="7362" href="1Lab.Path.html#20807" class="Function">ap</a> <a data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" id="7365" href="Cat.Instances.Comma.html#2621" class="Field">β</a> <a id="7367" class="Symbol">(</a><a data-type="(r : Initial C) (h : Hom C (bot r) x) → ¡ r ≡ h" id="7368" href="Cat.Diagram.Initial.html#642" class="Function">¡-unique</a> <a id="7377" class="Symbol">(</a><a id="7378" href="Cat.Functor.Adjoint.html#5633" class="Bound">universal-map-for</a> <a id="7396" href="Cat.Functor.Adjoint.html#7357" class="Bound">a</a><a id="7397" class="Symbol">)</a> 
                      <a id="7422" class="Symbol">(</a><a id="7423" class="Keyword">record</a> <a id="7430" class="Symbol">{</a> <a data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" id="7432" href="Cat.Instances.Comma.html#2646" class="Field">sq</a> <a id="7435" class="Symbol">=</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" id="7437" href="Cat.Reasoning.html#1114" class="Function">C.elimr</a> <a data-type="x ≡ x" id="7445" href="1Lab.Path.html#3591" class="Function">refl</a> 
                                  <a data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" id="7485" href="1Lab.Path.html#38409" class="Function Operator">··</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" id="7488" href="Cat.Reasoning.html#1114" class="Function">C.elimr</a> <a data-type="x ≡ x" id="7496" href="1Lab.Path.html#3591" class="Function">refl</a> 
                                  <a data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" id="7536" href="1Lab.Path.html#38409" class="Function Operator">··</a> <a data-type="x ≡ y → y ≡ x" id="7539" href="1Lab.Path.html#10628" class="Function">sym</a> <a id="7543" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ a) f ≡ f" id="7544" href="Cat.Reasoning.html#1015" class="Function">C.eliml</a> <a data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" id="7552" href="Cat.Base.html#7745" class="Function">R.F-id</a><a id="7558" class="Symbol">)</a> <a id="7560" class="Symbol">}))</a>

    <a id="7569" href="Cat.Functor.Adjoint.html#7569" class="Function">lemma</a> <a id="7575" class="Symbol">:</a> <a id="7577" class="Symbol">∀</a> <a id="7579" class="Symbol">{</a><a id="7580" href="Cat.Functor.Adjoint.html#7580" class="Bound">x</a> <a id="7582" href="Cat.Functor.Adjoint.html#7582" class="Bound">y</a> <a id="7584" href="Cat.Functor.Adjoint.html#7584" class="Bound">z</a><a id="7585" class="Symbol">}</a> <a id="7587" class="Symbol">(</a><a id="7588" href="Cat.Functor.Adjoint.html#7588" class="Bound">f</a> <a id="7590" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="7592" href="Cat.Base.html#1329" class="Function">C.Hom</a> <a id="7598" href="Cat.Functor.Adjoint.html#7582" class="Bound">y</a> <a id="7600" href="Cat.Functor.Adjoint.html#7584" class="Bound">z</a><a id="7601" class="Symbol">)</a> <a id="7603" class="Symbol">(</a><a id="7604" href="Cat.Functor.Adjoint.html#7604" class="Bound">g</a> <a id="7606" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="7608" href="Cat.Base.html#1329" class="Function">C.Hom</a> <a id="7614" href="Cat.Functor.Adjoint.html#7580" class="Bound">x</a> <a id="7616" href="Cat.Functor.Adjoint.html#7582" class="Bound">y</a><a id="7617" class="Symbol">)</a> 
          <a id="7630" class="Symbol">→</a> <a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="7632" href="Cat.Base.html#8210" class="Function">R.₁</a> <a id="7636" class="Symbol">(</a><a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom a b →
D .Hom (L₀ R₁ universal-map-for a) (L₀ R₁ universal-map-for b)" id="7637" href="Cat.Functor.Adjoint.html#7014" class="Function">L₁</a> <a id="7640" href="Cat.Functor.Adjoint.html#7588" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7642" href="Cat.Base.html#2898" class="Function Operator">D.∘</a> <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom a b →
D .Hom (L₀ R₁ universal-map-for a) (L₀ R₁ universal-map-for b)" id="7646" href="Cat.Functor.Adjoint.html#7014" class="Function">L₁</a> <a id="7649" href="Cat.Functor.Adjoint.html#7604" class="Bound">g</a><a id="7650" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7652" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a id="7656" class="Symbol">(</a><a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(c : C .Ob) →
C .Hom c (₀ R₁ (L₀ R₁ universal-map-for c))" id="7657" href="Cat.Functor.Adjoint.html#6239" class="Function">L₀′</a> <a id="7661" href="Cat.Functor.Adjoint.html#7580" class="Bound">x</a><a id="7662" class="Symbol">)</a>
          <a data-type="A → A → Type ℓ" id="7674" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="7676" href="Cat.Functor.Adjoint.html#6743" class="Function">toOb</a> <a id="7681" class="Symbol">(</a><a id="7682" href="Cat.Functor.Adjoint.html#7588" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7684" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a id="7688" href="Cat.Functor.Adjoint.html#7604" class="Bound">g</a><a id="7689" class="Symbol">)</a> <a id="7691" class="Symbol">.</a><a data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" id="7692" href="Cat.Instances.Comma.html#1832" class="Field">map</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7696" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="7700" href="Cat.Base.html#2868" class="Function">C.id</a>
    <a id="7709" href="Cat.Functor.Adjoint.html#7569" class="Function">lemma</a> <a id="7715" class="Symbol">{</a><a id="7716" href="Cat.Functor.Adjoint.html#7716" class="Bound">x</a><a id="7717" class="Symbol">}</a> <a id="7719" class="Symbol">{</a><a id="7720" href="Cat.Functor.Adjoint.html#7720" class="Bound">y</a><a id="7721" class="Symbol">}</a> <a id="7723" class="Symbol">{</a><a id="7724" href="Cat.Functor.Adjoint.html#7724" class="Bound">z</a><a id="7725" class="Symbol">}</a> <a id="7727" href="Cat.Functor.Adjoint.html#7727" class="Bound">f</a> <a id="7729" href="Cat.Functor.Adjoint.html#7729" class="Bound">g</a> <a id="7731" class="Symbol">=</a> 
      <a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="7740" href="Cat.Base.html#8210" class="Function">R.₁</a> <a id="7744" class="Symbol">(</a><a id="7745" href="Cat.Functor.Adjoint.html#6851" class="Function">lift↓</a> <a id="7751" href="Cat.Functor.Adjoint.html#7727" class="Bound">f</a> <a id="7753" class="Symbol">.</a><a data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" id="7754" href="Cat.Instances.Comma.html#2621" class="Field">β</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7756" href="Cat.Base.html#2898" class="Function Operator">D.∘</a> <a id="7760" href="Cat.Functor.Adjoint.html#6851" class="Function">lift↓</a> <a id="7766" href="Cat.Functor.Adjoint.html#7729" class="Bound">g</a> <a id="7768" class="Symbol">.</a><a data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" id="7769" href="Cat.Instances.Comma.html#2621" class="Field">β</a><a id="7770" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7772" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a id="7776" class="Symbol">(</a><a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(c : C .Ob) →
C .Hom c (₀ R₁ (L₀ R₁ universal-map-for c))" id="7777" href="Cat.Functor.Adjoint.html#6239" class="Function">L₀′</a> <a id="7781" href="Cat.Functor.Adjoint.html#7716" class="Bound">x</a><a id="7782" class="Symbol">)</a>       <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" id="7790" href="1Lab.Path.html#46911" class="Function Operator">≡˘⟨</a> <a data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ a) ((C ∘ b) f) ≡ (C ∘ c) f" id="7794" href="Cat.Reasoning.html#1554" class="Function">C.pulll</a> <a id="7802" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="7803" href="1Lab.Path.html#10628" class="Function">sym</a> <a id="7807" class="Symbol">(</a><a data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" id="7808" href="Cat.Base.html#7785" class="Function">R.F-∘</a> <a id="7814" class="Symbol">_</a> <a id="7816" class="Symbol">_))</a> <a data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" id="7820" href="1Lab.Path.html#46911" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
      <a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="7828" href="Cat.Base.html#8210" class="Function">R.₁</a> <a id="7832" class="Symbol">(</a><a id="7833" href="Cat.Functor.Adjoint.html#6851" class="Function">lift↓</a> <a id="7839" href="Cat.Functor.Adjoint.html#7727" class="Bound">f</a> <a id="7841" class="Symbol">.</a><a data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" id="7842" href="Cat.Instances.Comma.html#2621" class="Field">β</a><a id="7843" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7845" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="7849" href="Cat.Base.html#8210" class="Function">R.₁</a> <a id="7853" class="Symbol">(</a><a id="7854" href="Cat.Functor.Adjoint.html#6851" class="Function">lift↓</a> <a id="7860" href="Cat.Functor.Adjoint.html#7729" class="Bound">g</a> <a id="7862" class="Symbol">.</a><a data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" id="7863" href="Cat.Instances.Comma.html#2621" class="Field">β</a><a id="7864" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7866" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a id="7870" class="Symbol">(</a><a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(c : C .Ob) →
C .Hom c (₀ R₁ (L₀ R₁ universal-map-for c))" id="7871" href="Cat.Functor.Adjoint.html#6239" class="Function">L₀′</a> <a id="7875" href="Cat.Functor.Adjoint.html#7716" class="Bound">x</a><a id="7876" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="7878" href="1Lab.Path.html#46757" class="Function">≡⟨</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="7881" href="1Lab.Path.html#20807" class="Function">ap</a> <a id="7884" class="Symbol">(</a><a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="7885" href="Cat.Base.html#8210" class="Function">R.₁</a> <a id="7889" class="Symbol">(</a><a id="7890" href="Cat.Functor.Adjoint.html#6851" class="Function">lift↓</a> <a id="7896" href="Cat.Functor.Adjoint.html#7727" class="Bound">f</a> <a id="7898" class="Symbol">.</a><a data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" id="7899" href="Cat.Instances.Comma.html#2621" class="Field">β</a><a id="7900" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7902" href="Cat.Base.html#2898" class="Function Operator">C.∘_</a><a id="7906" class="Symbol">)</a> <a id="7908" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="7909" href="1Lab.Path.html#10628" class="Function">sym</a> <a id="7913" class="Symbol">(</a><a id="7914" href="Cat.Functor.Adjoint.html#6851" class="Function">lift↓</a> <a id="7920" href="Cat.Functor.Adjoint.html#7729" class="Bound">g</a> <a id="7922" class="Symbol">.</a><a data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" id="7923" href="Cat.Instances.Comma.html#2646" class="Field">↓Hom.sq</a><a id="7930" class="Symbol">)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="7932" href="1Lab.Path.html#39580" class="Function Operator">∙</a> <a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" id="7934" href="Cat.Base.html#3331" class="Function">C.idr</a> <a id="7940" class="Symbol">_)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="7943" href="1Lab.Path.html#46757" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="7951" href="Cat.Base.html#8210" class="Function">R.₁</a> <a id="7955" class="Symbol">(</a><a id="7956" href="Cat.Functor.Adjoint.html#6851" class="Function">lift↓</a> <a id="7962" href="Cat.Functor.Adjoint.html#7727" class="Bound">f</a> <a id="7964" class="Symbol">.</a><a data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" id="7965" href="Cat.Instances.Comma.html#2621" class="Field">β</a><a id="7966" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7968" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(c : C .Ob) →
C .Hom c (₀ R₁ (L₀ R₁ universal-map-for c))" id="7972" href="Cat.Functor.Adjoint.html#6239" class="Function">L₀′</a> <a id="7976" href="Cat.Functor.Adjoint.html#7720" class="Bound">y</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7978" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a id="7982" href="Cat.Functor.Adjoint.html#7729" class="Bound">g</a>                  <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="8001" href="1Lab.Path.html#46757" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (p : (C ∘ f) h ≡ (C ∘ g) i) →
(C ∘ f) ((C ∘ h) b) ≡ (C ∘ g) ((C ∘ i) b)" id="8004" href="Cat.Reasoning.html#1850" class="Function">C.extendl</a> <a id="8014" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="8015" href="1Lab.Path.html#10628" class="Function">sym</a> <a id="8019" class="Symbol">(</a><a id="8020" href="Cat.Functor.Adjoint.html#6851" class="Function">lift↓</a> <a id="8026" href="Cat.Functor.Adjoint.html#7727" class="Bound">f</a> <a id="8028" class="Symbol">.</a><a data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" id="8029" href="Cat.Instances.Comma.html#2646" class="Field">↓Hom.sq</a><a id="8036" class="Symbol">)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="8038" href="1Lab.Path.html#39580" class="Function Operator">∙</a> <a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" id="8040" href="Cat.Base.html#3331" class="Function">C.idr</a> <a id="8046" class="Symbol">_)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="8049" href="1Lab.Path.html#46757" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(c : C .Ob) →
C .Hom c (₀ R₁ (L₀ R₁ universal-map-for c))" id="8057" href="Cat.Functor.Adjoint.html#6239" class="Function">L₀′</a> <a id="8061" href="Cat.Functor.Adjoint.html#7724" class="Bound">z</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8063" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a id="8067" href="Cat.Functor.Adjoint.html#7727" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8069" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a id="8073" href="Cat.Functor.Adjoint.html#7729" class="Bound">g</a>                                 <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" id="8107" href="1Lab.Path.html#46911" class="Function Operator">≡˘⟨</a> <a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" id="8111" href="Cat.Base.html#3331" class="Function">C.idr</a> <a id="8117" class="Symbol">_</a> <a data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" id="8119" href="1Lab.Path.html#46911" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
      <a id="8127" href="Cat.Functor.Adjoint.html#6743" class="Function">toOb</a> <a id="8132" class="Symbol">(</a><a id="8133" href="Cat.Functor.Adjoint.html#7727" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8135" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a id="8139" href="Cat.Functor.Adjoint.html#7729" class="Bound">g</a><a id="8140" class="Symbol">)</a> <a id="8142" class="Symbol">.</a><a data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" id="8143" href="Cat.Instances.Comma.html#1832" class="Field">map</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8147" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="8151" href="Cat.Base.html#2868" class="Function">C.id</a>                      <a data-type="(x : A) → x ≡ x" id="8177" href="1Lab.Path.html#47085" class="Function Operator">∎</a>

    <a id="8184" href="Cat.Functor.Adjoint.html#8184" class="Function">L-∘</a> <a id="8188" class="Symbol">:</a> <a id="8190" class="Symbol">∀</a> <a id="8192" class="Symbol">{</a><a id="8193" href="Cat.Functor.Adjoint.html#8193" class="Bound">x</a> <a id="8195" href="Cat.Functor.Adjoint.html#8195" class="Bound">y</a> <a id="8197" href="Cat.Functor.Adjoint.html#8197" class="Bound">z</a><a id="8198" class="Symbol">}</a> <a id="8200" class="Symbol">(</a><a id="8201" href="Cat.Functor.Adjoint.html#8201" class="Bound">f</a> <a id="8203" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="8205" href="Cat.Base.html#1329" class="Function">C.Hom</a> <a id="8211" href="Cat.Functor.Adjoint.html#8195" class="Bound">y</a> <a id="8213" href="Cat.Functor.Adjoint.html#8197" class="Bound">z</a><a id="8214" class="Symbol">)</a> <a id="8216" class="Symbol">(</a><a id="8217" href="Cat.Functor.Adjoint.html#8217" class="Bound">g</a> <a id="8219" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="8221" href="Cat.Base.html#1329" class="Function">C.Hom</a> <a id="8227" href="Cat.Functor.Adjoint.html#8193" class="Bound">x</a> <a id="8229" href="Cat.Functor.Adjoint.html#8195" class="Bound">y</a><a id="8230" class="Symbol">)</a>
        <a id="8240" class="Symbol">→</a> <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom a b →
D .Hom (L₀ R₁ universal-map-for a) (L₀ R₁ universal-map-for b)" id="8242" href="Cat.Functor.Adjoint.html#7014" class="Function">L₁</a> <a id="8245" class="Symbol">(</a><a id="8246" href="Cat.Functor.Adjoint.html#8201" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8248" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a id="8252" href="Cat.Functor.Adjoint.html#8217" class="Bound">g</a><a id="8253" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="8255" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom a b →
D .Hom (L₀ R₁ universal-map-for a) (L₀ R₁ universal-map-for b)" id="8257" href="Cat.Functor.Adjoint.html#7014" class="Function">L₁</a> <a id="8260" href="Cat.Functor.Adjoint.html#8201" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8262" href="Cat.Base.html#2898" class="Function Operator">D.∘</a> <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom a b →
D .Hom (L₀ R₁ universal-map-for a) (L₀ R₁ universal-map-for b)" id="8266" href="Cat.Functor.Adjoint.html#7014" class="Function">L₁</a> <a id="8269" href="Cat.Functor.Adjoint.html#8217" class="Bound">g</a>
    <a id="8275" href="Cat.Functor.Adjoint.html#8184" class="Function">L-∘</a> <a id="8279" href="Cat.Functor.Adjoint.html#8279" class="Bound">f</a> <a id="8281" href="Cat.Functor.Adjoint.html#8281" class="Bound">g</a> <a id="8283" class="Symbol">=</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="8285" href="1Lab.Path.html#20807" class="Function">ap</a> <a data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" id="8288" href="Cat.Instances.Comma.html#2621" class="Field">β</a> <a id="8290" class="Symbol">(</a><a data-type="(r : Initial C) (h : Hom C (bot r) x) → ¡ r ≡ h" id="8291" href="Cat.Diagram.Initial.html#642" class="Function">¡-unique</a> <a id="8300" class="Symbol">(</a><a id="8301" href="Cat.Functor.Adjoint.html#5633" class="Bound">universal-map-for</a> <a id="8319" class="Symbol">_)</a> <a id="8322" class="Symbol">(</a><a id="8323" class="Keyword">record</a> <a id="8330" class="Symbol">{</a> <a data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" id="8332" href="Cat.Instances.Comma.html#2646" class="Field">sq</a> <a id="8335" class="Symbol">=</a> <a data-type="x ≡ y → y ≡ x" id="8337" href="1Lab.Path.html#10628" class="Function">sym</a> <a id="8341" class="Symbol">(</a><a id="8342" href="Cat.Functor.Adjoint.html#7569" class="Function">lemma</a> <a id="8348" href="Cat.Functor.Adjoint.html#8279" class="Bound">f</a> <a id="8350" href="Cat.Functor.Adjoint.html#8281" class="Bound">g</a><a id="8351" class="Symbol">)</a> <a id="8353" class="Symbol">}))</a>
</pre>
</details>
<p>That out of the way, we have our <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span></span></span></span> functor. We now have to show that it defines a left adjoint to the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> we started with.</p>
<pre class="Agda">  <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
Functor C D" id="8509" href="Cat.Functor.Adjoint.html#8509" class="Function">universalMaps→L</a> <a id="8525" class="Symbol">:</a> <a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="8527" href="Cat.Base.html#6604" class="Record">Functor</a> <a id="8535" href="Cat.Functor.Adjoint.html#5563" class="Bound">C</a> <a id="8537" href="Cat.Functor.Adjoint.html#5587" class="Bound">D</a>
  <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
Functor C D" id="8541" href="Cat.Functor.Adjoint.html#8509" class="Function">universalMaps→L</a> <a id="8557" class="Symbol">.</a><a data-type="Functor C D → C .Ob → Ob D" id="8558" href="Cat.Base.html#7390" class="Field">F₀</a> <a id="8561" class="Symbol">=</a> <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Ob → D .Ob" id="8563" href="Cat.Functor.Adjoint.html#6177" class="Function">L₀</a>
  <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
Functor C D" id="8568" href="Cat.Functor.Adjoint.html#8509" class="Function">universalMaps→L</a> <a id="8584" class="Symbol">.</a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="8585" href="Cat.Base.html#7411" class="Field">F₁</a> <a id="8588" class="Symbol">=</a> <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom a b →
D .Hom (L₀ R₁ universal-map-for a) (L₀ R₁ universal-map-for b)" id="8590" href="Cat.Functor.Adjoint.html#7014" class="Function">L₁</a>
  <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
Functor C D" id="8595" href="Cat.Functor.Adjoint.html#8509" class="Function">universalMaps→L</a> <a id="8611" class="Symbol">.</a><a data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" id="8612" href="Cat.Base.html#7745" class="Field">F-id</a> <a id="8617" class="Symbol">=</a> <a id="8619" href="Cat.Functor.Adjoint.html#7304" class="Function">L-id</a>
  <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
Functor C D" id="8626" href="Cat.Functor.Adjoint.html#8509" class="Function">universalMaps→L</a> <a id="8642" class="Symbol">.</a><a data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" id="8643" href="Cat.Base.html#7785" class="Field">F-∘</a> <a id="8647" class="Symbol">=</a> <a id="8649" href="Cat.Functor.Adjoint.html#8184" class="Function">L-∘</a>
</pre>
<!--
<pre class="Agda">  <a id="8673" class="Keyword">open</a> <a id="8678" href="Cat.Functor.Adjoint.html#1898" class="Module Operator">_⊣_</a> 
  <a id="8685" class="Keyword">open</a> <a id="8690" href="Cat.Base.html#10721" class="Module Operator">_=&gt;_</a>
</pre>-->
<h2 id="building-the-adjunction"><a href="#building-the-adjunction" class="header-link">Building the adjunction<span class="header-link-emoji">🔗</span></a></h2>
<p>We now prove that <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊣</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L \dashv R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>,</span> which, recall, means giving natural transformations <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi><mo>:</mo><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">d</mi></mrow><mstyle mathcolor="#cc0000"><mtext>\To</mtext></mstyle><mo stretchy="false">(</mo><mi>R</mi><mi>F</mi><mo>∘</mo><mi>L</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\eta : \mathrm{Id} \To (R F\circ L)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">Id</span></span><span class="mord text" style="color:#cc0000;"><span class="mord" style="color:#cc0000;">\To</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">RF</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mclose">)</span></span></span></span> (the <em>adjunction unit</em>) and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi><mo>:</mo><mo stretchy="false">(</mo><mi>L</mi><mo>∘</mo><mi>R</mi><mo stretchy="false">)</mo><mstyle mathcolor="#cc0000"><mtext>\To</mtext></mstyle><mrow><mi mathvariant="normal">I</mi><mi mathvariant="normal">d</mi></mrow></mrow><annotation encoding="application/x-tex">\eps : (L \circ R) \To \mathrm{Id}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ε</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mord text" style="color:#cc0000;"><span class="mord" style="color:#cc0000;">\To</span></span><span class="mord"><span class="mord mathrm">Id</span></span></span></span></span> (the <em>adjunction counit</em>). We begin with the counit, since that’s more involved.</p>
<p>The construction begins by defining a function <span class="Agda"><a href="Cat.Functor.Adjoint.html#9263" class="Function">mapd</a></span> which sends each object of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span> to the initial object in <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>↙</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">x \swarrow R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↙</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>.</span> Note that this is the same as <span class="Agda"><a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Ob → D .Ob" href="Cat.Functor.Adjoint.html#6177" class="Function">L₀</a></span>, but returning the entire object rather than a part of it.</p>
<pre class="Agda">  <a id="9251" class="Keyword">private</a>
    <a id="9263" href="Cat.Functor.Adjoint.html#9263" class="Function">mapd</a> <a id="9268" class="Symbol">:</a> <a id="9270" class="Symbol">∀</a> <a id="9272" class="Symbol">(</a><a id="9273" href="Cat.Functor.Adjoint.html#9273" class="Bound">x</a> <a id="9275" class="Symbol">:</a> <a data-type="Precategory o h → Type o" id="9277" href="Cat.Base.html#1312" class="Function">C.Ob</a><a id="9281" class="Symbol">)</a> <a id="9283" class="Symbol">→</a> <a data-type="Precategory o h → Type o" id="9285" href="Cat.Base.html#1312" class="Field">Ob</a> <a id="9288" class="Symbol">(</a><a id="9289" href="Cat.Functor.Adjoint.html#9273" class="Bound">x</a> <a data-type="A .Ob →
Functor B₁ A → Precategory (ah ⊔ bo ⊔ lzero) (ah ⊔ bh ⊔ lzero)" id="9291" href="Cat.Instances.Comma.html#5865" class="Function Operator">↙</a> <a id="9293" href="Cat.Functor.Adjoint.html#5613" class="Bound">R</a><a id="9294" class="Symbol">)</a>
    <a id="9300" href="Cat.Functor.Adjoint.html#9263" class="Function">mapd</a> <a id="9305" href="Cat.Functor.Adjoint.html#9305" class="Bound">x</a> <a id="9307" class="Symbol">=</a> <a id="9309" href="Cat.Functor.Adjoint.html#5633" class="Bound">universal-map-for</a> <a id="9327" href="Cat.Functor.Adjoint.html#9305" class="Bound">x</a> <a id="9329" class="Symbol">.</a><a data-type="Initial C → Ob C" id="9330" href="Cat.Diagram.Initial.html#439" class="Field">bot</a>
</pre>
<p>Now for an object <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">x : \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>,</span> we have <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>:</mo><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">R(x) : \ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>,</span> so by the assumption that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> has a collection of universal objects, the comma category <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>↙</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">R(x) \swarrow R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↙</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> has an initial object; Let us write that object as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>L</mi><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(L(R(x)), !)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mclose">!)</span></span></span></span> — recall that here, <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">!</mo><mo>:</mo><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>→</mo><mi>R</mi><mi>L</mi><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">! : R(x) \to RLR(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>.</span></p>
<p>This means, in particular, that for any other object <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>y</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(y, f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span> (with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>∈</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">y \in \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>→</mo><mi>R</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f : R(x) \to R(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> in <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>),</span> there is a unique map <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">d</mi></mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>→</mo><mo stretchy="false">(</mo><mi>y</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{mapd}(x) \to (y, f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">mapd</span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>,</span> which breaks down as a map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>:</mo><mi>L</mi><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">\beta : L(R(x)) \to y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> such that the square below commutes.</p>
<div class="diagram-container">
<img src="4c81dcc8079c0e802c9a787115956570c20814bc.svg" title="commutative diagram" class="diagram quiver" />
</div>
<pre class="Agda">    <a id="10081" href="Cat.Functor.Adjoint.html#10081" class="Function">ε</a> <a id="10083" class="Symbol">:</a> <a id="10085" class="Symbol">∀</a> <a id="10087" class="Symbol">(</a><a id="10088" href="Cat.Functor.Adjoint.html#10088" class="Bound">x</a> <a id="10090" class="Symbol">:</a> <a data-type="Precategory o h → Type o" id="10092" href="Cat.Base.html#1312" class="Function">D.Ob</a><a id="10096" class="Symbol">)</a> <a id="10098" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="10100" href="Cat.Base.html#1329" class="Field">Hom</a> <a id="10104" class="Symbol">(</a><a data-type="(r : Functor C D) → C .Ob → D .Ob" id="10105" href="Cat.Base.html#8129" class="Function">R.₀</a> <a id="10109" href="Cat.Functor.Adjoint.html#10088" class="Bound">x</a> <a data-type="A .Ob →
Functor B₁ A → Precategory (ah ⊔ bo ⊔ lzero) (ah ⊔ bh ⊔ lzero)" id="10111" href="Cat.Instances.Comma.html#5865" class="Function Operator">↙</a> <a id="10113" href="Cat.Functor.Adjoint.html#5613" class="Bound">R</a><a id="10114" class="Symbol">)</a> <a id="10116" class="Symbol">(</a><a id="10117" href="Cat.Functor.Adjoint.html#9263" class="Function">mapd</a> <a id="10122" class="Symbol">(</a><a data-type="(r : Functor C D) → C .Ob → D .Ob" id="10123" href="Cat.Base.html#8129" class="Function">R.₀</a> <a id="10127" href="Cat.Functor.Adjoint.html#10088" class="Bound">x</a><a id="10128" class="Symbol">))</a> <a id="10131" class="Symbol">_</a>
    <a id="10137" href="Cat.Functor.Adjoint.html#10081" class="Function">ε</a> <a id="10139" href="Cat.Functor.Adjoint.html#10139" class="Bound">x</a> <a id="10141" class="Symbol">=</a> <a data-type="(r : Initial C) → Hom C (bot r) x" id="10143" href="Cat.Diagram.Initial.html#596" class="Function">Initial.¡</a> <a id="10153" class="Symbol">(</a><a id="10154" href="Cat.Functor.Adjoint.html#5633" class="Bound">universal-map-for</a> <a id="10172" class="Symbol">(</a><a data-type="(r : Functor C D) → C .Ob → D .Ob" id="10173" href="Cat.Base.html#8129" class="Function">R.₀</a> <a id="10177" href="Cat.Functor.Adjoint.html#10139" class="Bound">x</a><a id="10178" class="Symbol">))</a> <a id="10181" class="Symbol">{</a><a id="10182" class="Argument">x</a> <a id="10184" class="Symbol">=</a> <a id="10186" class="Keyword">record</a> <a id="10193" class="Symbol">{</a> <a data-type="↓Obj F G → Ob B₁" id="10195" href="Cat.Instances.Comma.html#1816" class="Field">y</a> <a id="10197" class="Symbol">=</a> <a id="10199" href="Cat.Functor.Adjoint.html#10139" class="Bound">x</a> <a id="10201" class="Symbol">;</a> <a data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" id="10203" href="Cat.Instances.Comma.html#1832" class="Field">map</a> <a id="10207" class="Symbol">=</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="10209" href="Cat.Base.html#2868" class="Function">C.id</a> <a id="10214" class="Symbol">}}</a>
</pre>
<p>The magic trick is that, if we pick <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, \mathrm{id})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathrm">id</span></span><span class="mclose">)</span></span></span></span> as the object of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>↙</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">R(x)\swarrow R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↙</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span> to map into, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span> in the diagram above must be <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>R</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>→</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">LR(x) \to x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>!</span> We choose this map as our adjunction counit. A tedious calculation shows that this assignment is natural, essentially because <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span> is unique.</p>
<pre class="Agda">  <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
universalMaps→L R₁ universal-map-for ⊣ R₁" id="10537" href="Cat.Functor.Adjoint.html#10537" class="Function">universalMaps→L⊣R</a> <a id="10555" class="Symbol">:</a> <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
Functor C D" id="10557" href="Cat.Functor.Adjoint.html#8509" class="Function">universalMaps→L</a> <a data-type="(L : Functor C D) (R₁ : Functor D C) → Type (C.o ⊔ C.h ⊔ D.o ⊔ D.h)" id="10573" href="Cat.Functor.Adjoint.html#1898" class="Record Operator">⊣</a> <a id="10575" href="Cat.Functor.Adjoint.html#5613" class="Bound">R</a>
  <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
universalMaps→L R₁ universal-map-for ⊣ R₁" id="10579" href="Cat.Functor.Adjoint.html#10537" class="Function">universalMaps→L⊣R</a> <a id="10597" class="Symbol">.</a><a data-type="L ⊣ R₁ → (L F∘ R₁) =&gt; Id" id="10598" href="Cat.Functor.Adjoint.html#2076" class="Field">counit</a> <a id="10605" class="Symbol">.</a><a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" id="10606" href="Cat.Base.html#11272" class="Field">η</a> <a id="10608" href="Cat.Functor.Adjoint.html#10608" class="Bound">x</a> <a id="10610" class="Symbol">=</a> <a id="10612" href="Cat.Functor.Adjoint.html#10081" class="Function">ε</a> <a id="10614" href="Cat.Functor.Adjoint.html#10608" class="Bound">x</a> <a id="10616" class="Symbol">.</a><a data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" id="10617" href="Cat.Instances.Comma.html#2621" class="Field">↓Hom.β</a>
  <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
universalMaps→L R₁ universal-map-for ⊣ R₁" id="10626" href="Cat.Functor.Adjoint.html#10537" class="Function">universalMaps→L⊣R</a> <a id="10644" class="Symbol">.</a><a data-type="L ⊣ R₁ → (L F∘ R₁) =&gt; Id" id="10645" href="Cat.Functor.Adjoint.html#2076" class="Field">counit</a> <a id="10652" class="Symbol">.</a><a data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" id="10653" href="Cat.Base.html#11850" class="Field">is-natural</a> <a id="10664" href="Cat.Functor.Adjoint.html#10664" class="Bound">x</a> <a id="10666" href="Cat.Functor.Adjoint.html#10666" class="Bound">y</a> <a id="10668" href="Cat.Functor.Adjoint.html#10668" class="Bound">f</a> <a id="10670" class="Symbol">=</a> 
    <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="10677" href="1Lab.Path.html#20807" class="Function">ap</a> <a data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" id="10680" href="Cat.Instances.Comma.html#2621" class="Field">↓Hom.β</a> <a id="10687" class="Symbol">(</a>
      <a data-type="(r : Initial C) (f g : Hom C (bot r) x) → f ≡ g" id="10695" href="Cat.Diagram.Initial.html#713" class="Function">¡-unique₂</a> <a id="10705" class="Symbol">(</a><a id="10706" href="Cat.Functor.Adjoint.html#5633" class="Bound">universal-map-for</a> <a id="10724" class="Symbol">(</a><a data-type="(r : Functor C D) → C .Ob → D .Ob" id="10725" href="Cat.Base.html#8129" class="Function">R.₀</a> <a id="10729" href="Cat.Functor.Adjoint.html#10664" class="Bound">x</a><a id="10730" class="Symbol">))</a> <a id="10733" class="Symbol">{</a><a id="10734" class="Keyword">record</a> <a id="10741" class="Symbol">{</a> <a data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" id="10743" href="Cat.Instances.Comma.html#1832" class="Field">map</a> <a id="10747" class="Symbol">=</a> <a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="10749" href="Cat.Base.html#8210" class="Function">R.₁</a> <a id="10753" href="Cat.Functor.Adjoint.html#10668" class="Bound">f</a> <a id="10755" class="Symbol">}}</a>
      <a id="10764" class="Symbol">(</a><a id="10765" class="Keyword">record</a> <a id="10772" class="Symbol">{</a> <a data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" id="10774" href="Cat.Instances.Comma.html#2646" class="Field">sq</a> <a id="10777" class="Symbol">=</a> 
        <a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="10788" href="Cat.Base.html#8210" class="Function">R.₁</a> <a id="10792" href="Cat.Functor.Adjoint.html#10668" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="10794" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="10798" href="Cat.Base.html#2868" class="Function">C.id</a>                                          <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="10844" href="1Lab.Path.html#46757" class="Function">≡⟨</a> <a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" id="10847" href="Cat.Base.html#3331" class="Function">C.idr</a> <a id="10853" class="Symbol">_</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="10855" href="1Lab.Path.html#46757" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="10865" href="Cat.Base.html#8210" class="Function">R.₁</a> <a id="10869" href="Cat.Functor.Adjoint.html#10668" class="Bound">f</a>                                                   <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" id="10921" href="1Lab.Path.html#46911" class="Function Operator">≡˘⟨</a> <a data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ h) ((C ∘ i) f) ≡ f" id="10925" href="Cat.Reasoning.html#2373" class="Function">C.cancell</a> <a id="10935" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="10936" href="1Lab.Path.html#10628" class="Function">sym</a> <a id="10940" class="Symbol">(</a><a id="10941" href="Cat.Functor.Adjoint.html#10081" class="Function">ε</a> <a id="10943" href="Cat.Functor.Adjoint.html#10666" class="Bound">y</a> <a id="10945" class="Symbol">.</a><a data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" id="10946" href="Cat.Instances.Comma.html#2646" class="Field">↓Hom.sq</a><a id="10953" class="Symbol">)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="10955" href="1Lab.Path.html#39580" class="Function Operator">∙</a> <a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" id="10957" href="Cat.Base.html#3331" class="Function">C.idr</a> <a id="10963" class="Symbol">_)</a> <a data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" id="10966" href="1Lab.Path.html#46911" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
        <a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="10976" href="Cat.Base.html#8210" class="Function">R.₁</a> <a id="10980" class="Symbol">(</a><a id="10981" href="Cat.Functor.Adjoint.html#10081" class="Function">ε</a> <a id="10983" href="Cat.Functor.Adjoint.html#10666" class="Bound">y</a> <a id="10985" class="Symbol">.</a><a data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" id="10986" href="Cat.Instances.Comma.html#2621" class="Field">β</a><a id="10987" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="10989" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a id="10993" class="Symbol">_</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="10995" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="10999" href="Cat.Base.html#8210" class="Function">R.₁</a> <a id="11003" href="Cat.Functor.Adjoint.html#10668" class="Bound">f</a>                            <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" id="11032" href="1Lab.Path.html#46911" class="Function Operator">≡˘⟨</a> <a data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" id="11036" href="1Lab.Path.html#21240" class="Function">ap₂</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="11040" href="Cat.Base.html#2898" class="Function Operator">C._∘_</a> <a data-type="x ≡ x" id="11046" href="1Lab.Path.html#3591" class="Function">refl</a> <a id="11051" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="11052" href="1Lab.Path.html#10628" class="Function">sym</a> <a id="11056" class="Symbol">(</a><a id="11057" href="Cat.Functor.Adjoint.html#6851" class="Function">lift↓</a> <a id="11063" class="Symbol">(</a><a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="11064" href="Cat.Base.html#8210" class="Function">R.₁</a> <a id="11068" href="Cat.Functor.Adjoint.html#10668" class="Bound">f</a><a id="11069" class="Symbol">)</a> <a id="11071" class="Symbol">.</a><a data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" id="11072" href="Cat.Instances.Comma.html#2646" class="Field">↓Hom.sq</a><a id="11079" class="Symbol">)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="11081" href="1Lab.Path.html#39580" class="Function Operator">∙</a> <a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" id="11083" href="Cat.Base.html#3331" class="Function">C.idr</a> <a id="11089" class="Symbol">_)</a> <a data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" id="11092" href="1Lab.Path.html#46911" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
        <a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="11102" href="Cat.Base.html#8210" class="Function">R.₁</a> <a id="11106" class="Symbol">(</a><a id="11107" href="Cat.Functor.Adjoint.html#10081" class="Function">ε</a> <a id="11109" href="Cat.Functor.Adjoint.html#10666" class="Bound">y</a> <a id="11111" class="Symbol">.</a><a data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" id="11112" href="Cat.Instances.Comma.html#2621" class="Field">β</a><a id="11113" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="11115" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="11119" href="Cat.Base.html#8210" class="Function">R.₁</a> <a id="11123" class="Symbol">(</a><a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom a b →
D .Hom (L₀ R₁ universal-map-for a) (L₀ R₁ universal-map-for b)" id="11124" href="Cat.Functor.Adjoint.html#7014" class="Function">L₁</a> <a id="11127" class="Symbol">(</a><a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="11128" href="Cat.Base.html#8210" class="Function">R.₁</a> <a id="11132" href="Cat.Functor.Adjoint.html#10668" class="Bound">f</a><a id="11133" class="Symbol">))</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="11136" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a id="11140" href="Cat.Functor.Adjoint.html#9263" class="Function">mapd</a> <a id="11145" class="Symbol">(</a><a data-type="(r : Functor C D) → C .Ob → D .Ob" id="11146" href="Cat.Base.html#8129" class="Function">R.₀</a> <a id="11150" href="Cat.Functor.Adjoint.html#10664" class="Bound">x</a><a id="11151" class="Symbol">)</a> <a id="11153" class="Symbol">.</a><a data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" id="11154" href="Cat.Instances.Comma.html#1832" class="Field">map</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="11158" href="1Lab.Path.html#46757" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ a) ((C ∘ b) f) ≡ (C ∘ c) f" id="11161" href="Cat.Reasoning.html#1554" class="Function">C.pulll</a> <a id="11169" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="11170" href="1Lab.Path.html#10628" class="Function">sym</a> <a id="11174" class="Symbol">(</a><a data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" id="11175" href="Cat.Base.html#7785" class="Function">R.F-∘</a> <a id="11181" class="Symbol">_</a> <a id="11183" class="Symbol">_))</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="11187" href="1Lab.Path.html#46757" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="11197" href="Cat.Base.html#8210" class="Function">R.₁</a> <a id="11201" class="Symbol">(</a><a id="11202" href="Cat.Functor.Adjoint.html#10081" class="Function">ε</a> <a id="11204" href="Cat.Functor.Adjoint.html#10666" class="Bound">y</a> <a id="11206" class="Symbol">.</a><a data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" id="11207" href="Cat.Instances.Comma.html#2621" class="Field">β</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="11209" href="Cat.Base.html#2898" class="Function Operator">D.∘</a> <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Hom a b →
D .Hom (L₀ R₁ universal-map-for a) (L₀ R₁ universal-map-for b)" id="11213" href="Cat.Functor.Adjoint.html#7014" class="Function">L₁</a> <a id="11216" class="Symbol">(</a><a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="11217" href="Cat.Base.html#8210" class="Function">R.₁</a> <a id="11221" href="Cat.Functor.Adjoint.html#10668" class="Bound">f</a><a id="11222" class="Symbol">))</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="11225" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a id="11229" href="Cat.Functor.Adjoint.html#9263" class="Function">mapd</a> <a id="11234" class="Symbol">(</a><a data-type="(r : Functor C D) → C .Ob → D .Ob" id="11235" href="Cat.Base.html#8129" class="Function">R.₀</a> <a id="11239" href="Cat.Functor.Adjoint.html#10664" class="Bound">x</a><a id="11240" class="Symbol">)</a> <a id="11242" class="Symbol">.</a><a data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" id="11243" href="Cat.Instances.Comma.html#1832" class="Field">map</a>       <a data-type="(x : A) → x ≡ x" id="11253" href="1Lab.Path.html#47085" class="Function Operator">∎</a> <a id="11255" class="Symbol">})</a> 
      <a id="11265" class="Symbol">(</a><a id="11266" class="Keyword">record</a> <a id="11273" class="Symbol">{</a> <a data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" id="11275" href="Cat.Instances.Comma.html#2646" class="Field">sq</a> <a id="11278" class="Symbol">=</a> 
        <a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="11289" href="Cat.Base.html#8210" class="Function">R.₁</a> <a id="11293" href="Cat.Functor.Adjoint.html#10668" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="11295" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="11299" href="Cat.Base.html#2868" class="Function">C.id</a>                               <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" id="11334" href="1Lab.Path.html#46911" class="Function Operator">≡˘⟨</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="11338" href="1Lab.Path.html#20807" class="Function">ap</a> <a id="11341" class="Symbol">(</a><a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="11342" href="Cat.Base.html#8210" class="Function">R.₁</a> <a id="11346" href="Cat.Functor.Adjoint.html#10668" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="11348" href="Cat.Base.html#2898" class="Function Operator">C.∘_</a><a id="11352" class="Symbol">)</a> <a id="11354" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="11355" href="1Lab.Path.html#10628" class="Function">sym</a> <a id="11359" class="Symbol">(</a><a id="11360" href="Cat.Functor.Adjoint.html#10081" class="Function">ε</a> <a id="11362" href="Cat.Functor.Adjoint.html#10664" class="Bound">x</a> <a id="11364" class="Symbol">.</a><a data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" id="11365" href="Cat.Instances.Comma.html#2646" class="Field">↓Hom.sq</a><a id="11372" class="Symbol">)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="11374" href="1Lab.Path.html#39580" class="Function Operator">∙</a> <a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" id="11376" href="Cat.Base.html#3331" class="Function">C.idr</a> <a id="11382" class="Symbol">_)</a> <a data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" id="11385" href="1Lab.Path.html#46911" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
        <a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="11395" href="Cat.Base.html#8210" class="Function">R.₁</a> <a id="11399" href="Cat.Functor.Adjoint.html#10668" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="11401" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="11405" href="Cat.Base.html#8210" class="Function">R.₁</a> <a id="11409" class="Symbol">(</a><a id="11410" href="Cat.Functor.Adjoint.html#10081" class="Function">ε</a> <a id="11412" href="Cat.Functor.Adjoint.html#10664" class="Bound">x</a> <a id="11414" class="Symbol">.</a><a data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" id="11415" href="Cat.Instances.Comma.html#2621" class="Field">β</a><a id="11416" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="11418" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a id="11422" href="Cat.Functor.Adjoint.html#9263" class="Function">mapd</a> <a id="11427" class="Symbol">(</a><a data-type="(r : Functor C D) → C .Ob → D .Ob" id="11428" href="Cat.Base.html#8129" class="Function">R.₀</a> <a id="11432" href="Cat.Functor.Adjoint.html#10664" class="Bound">x</a><a id="11433" class="Symbol">)</a> <a id="11435" class="Symbol">.</a><a data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" id="11436" href="Cat.Instances.Comma.html#1832" class="Field">map</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="11440" href="1Lab.Path.html#46757" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ a) ((C ∘ b) f) ≡ (C ∘ c) f" id="11443" href="Cat.Reasoning.html#1554" class="Function">C.pulll</a> <a id="11451" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="11452" href="1Lab.Path.html#10628" class="Function">sym</a> <a id="11456" class="Symbol">(</a><a data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" id="11457" href="Cat.Base.html#7785" class="Function">R.F-∘</a> <a id="11463" class="Symbol">_</a> <a id="11465" class="Symbol">_))</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="11469" href="1Lab.Path.html#46757" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="11479" href="Cat.Base.html#8210" class="Function">R.₁</a> <a id="11483" class="Symbol">(</a><a id="11484" href="Cat.Functor.Adjoint.html#10668" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="11486" href="Cat.Base.html#2898" class="Function Operator">D.∘</a> <a id="11490" href="Cat.Functor.Adjoint.html#10081" class="Function">ε</a> <a id="11492" href="Cat.Functor.Adjoint.html#10664" class="Bound">x</a> <a id="11494" class="Symbol">.</a><a data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" id="11495" href="Cat.Instances.Comma.html#2621" class="Field">β</a><a id="11496" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="11498" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a id="11502" href="Cat.Functor.Adjoint.html#9263" class="Function">mapd</a> <a id="11507" class="Symbol">(</a><a data-type="(r : Functor C D) → C .Ob → D .Ob" id="11508" href="Cat.Base.html#8129" class="Function">R.₀</a> <a id="11512" href="Cat.Functor.Adjoint.html#10664" class="Bound">x</a><a id="11513" class="Symbol">)</a> <a id="11515" class="Symbol">.</a><a data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" id="11516" href="Cat.Instances.Comma.html#1832" class="Field">map</a>     <a data-type="(x : A) → x ≡ x" id="11524" href="1Lab.Path.html#47085" class="Function Operator">∎</a> <a id="11526" class="Symbol">}))</a>
</pre>
<p>For the adjunction unit, the situation is a lot easier. Recall that we <em>defined</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> on objects (<span class="Agda"><a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Ob → D .Ob" href="Cat.Functor.Adjoint.html#6177" class="Function">L₀</a></span>) to be the codomain part of the initial object of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>↙</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">x \swarrow R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↙</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>;</span> The <em>map</em> part of that object then gives us a natural family of morphisms <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>→</mo><mi>R</mi><mo stretchy="false">(</mo><mi>L</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x \to R(L(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">))</span></span></span></span>.</span> By definition. It’s so “by definition” that Agda can figure out the components by itself:</p>
<pre class="Agda">  <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
universalMaps→L R₁ universal-map-for ⊣ R₁" id="11905" href="Cat.Functor.Adjoint.html#10537" class="Function">universalMaps→L⊣R</a> <a id="11923" class="Symbol">.</a><a data-type="L ⊣ R₁ → Id =&gt; (R₁ F∘ L)" id="11924" href="Cat.Functor.Adjoint.html#2048" class="Field">unit</a> <a id="11929" class="Symbol">.</a><a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" id="11930" href="Cat.Base.html#11272" class="Field">η</a> <a id="11932" href="Cat.Functor.Adjoint.html#11932" class="Bound">x</a>              <a id="11947" class="Symbol">=</a> <a id="11949" class="Symbol">_</a>
  <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
universalMaps→L R₁ universal-map-for ⊣ R₁" id="11953" href="Cat.Functor.Adjoint.html#10537" class="Function">universalMaps→L⊣R</a> <a id="11971" class="Symbol">.</a><a data-type="L ⊣ R₁ → Id =&gt; (R₁ F∘ L)" id="11972" href="Cat.Functor.Adjoint.html#2048" class="Field">unit</a> <a id="11977" class="Symbol">.</a><a data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" id="11978" href="Cat.Base.html#11850" class="Field">is-natural</a> <a id="11989" href="Cat.Functor.Adjoint.html#11989" class="Bound">x</a> <a id="11991" href="Cat.Functor.Adjoint.html#11991" class="Bound">y</a> <a id="11993" href="Cat.Functor.Adjoint.html#11993" class="Bound">f</a> <a id="11995" class="Symbol">=</a> <a data-type="x ≡ y → y ≡ x" id="11997" href="1Lab.Path.html#10628" class="Function">sym</a> <a id="12001" class="Symbol">(</a><a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" id="12002" href="Cat.Base.html#3331" class="Function">C.idr</a> <a id="12008" class="Symbol">_)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="12011" href="1Lab.Path.html#39580" class="Function Operator">∙</a> <a id="12013" href="Cat.Functor.Adjoint.html#6851" class="Function">lift↓</a> <a id="12019" href="Cat.Functor.Adjoint.html#11993" class="Bound">f</a> <a id="12021" class="Symbol">.</a><a data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" id="12022" href="Cat.Instances.Comma.html#2646" class="Field">↓Hom.sq</a>
</pre>
<p>If you think back to the adjunction counit, you’ll recall that it satisfied a triangle that looks like the one below, and that the top map (the map component of the initial object) is what we defined the adjunction unit to be, so.. It’s <span class="Agda"><a data-type="(r : L ⊣ R₁) →
C ._∘_ (F₁ R₁ (η (r .counit) B₁)) (r .unit .η (F₀ R₁ B₁)) ≡ C .id" href="Cat.Functor.Adjoint.html#2712" class="Field">zag</a></span>.</p>
<div class="diagram-container">
<img src="f00ec16e55a022fbcd87ad263d00b313540a1361.svg" title="commutative diagram" class="diagram quiver" />
</div>
<pre class="Agda">  <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
universalMaps→L R₁ universal-map-for ⊣ R₁" id="12506" href="Cat.Functor.Adjoint.html#10537" class="Function">universalMaps→L⊣R</a> <a id="12524" class="Symbol">.</a><a data-type="(r : L ⊣ R₁) →
C ._∘_ (F₁ R₁ (η (r .counit) B₁)) (r .unit .η (F₀ R₁ B₁)) ≡ C .id" id="12525" href="Cat.Functor.Adjoint.html#2712" class="Field">zag</a> <a id="12529" class="Symbol">{</a><a id="12530" href="Cat.Functor.Adjoint.html#12530" class="Bound">x</a><a id="12531" class="Symbol">}</a> <a id="12533" class="Symbol">=</a> <a data-type="x ≡ y → y ≡ x" id="12535" href="1Lab.Path.html#10628" class="Function">sym</a> <a id="12539" class="Symbol">(</a><a id="12540" href="Cat.Functor.Adjoint.html#10081" class="Function">ε</a> <a id="12542" href="Cat.Functor.Adjoint.html#12530" class="Bound">x</a> <a id="12544" class="Symbol">.</a><a data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" id="12545" href="Cat.Instances.Comma.html#2646" class="Field">↓Hom.sq</a><a id="12552" class="Symbol">)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="12554" href="1Lab.Path.html#39580" class="Function Operator">∙</a> <a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" id="12556" href="Cat.Base.html#3331" class="Function">C.idr</a> <a id="12562" class="Symbol">_</a>
</pre>
<p>The other triangle identity is slightly more annoying, but it works just as well. It follows from the uniqueness of maps out of the initial object:</p>
<pre class="Agda">  <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
universalMaps→L R₁ universal-map-for ⊣ R₁" id="12728" href="Cat.Functor.Adjoint.html#10537" class="Function">universalMaps→L⊣R</a> <a id="12746" class="Symbol">.</a><a data-type="(r : L ⊣ R₁) →
D ._∘_ (η (r .counit) (F₀ L A)) (F₁ L (r .unit .η A)) ≡ D .id" id="12747" href="Cat.Functor.Adjoint.html#2649" class="Field">zig</a> <a id="12751" class="Symbol">{</a><a id="12752" href="Cat.Functor.Adjoint.html#12752" class="Bound">x</a><a id="12753" class="Symbol">}</a> <a id="12755" class="Symbol">=</a> 
    <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="12762" href="1Lab.Path.html#20807" class="Function">ap</a> <a data-type="↓Hom F G a b → Hom B₁ (a .y) (y b)" id="12765" href="Cat.Instances.Comma.html#2621" class="Field">↓Hom.β</a> <a id="12772" class="Symbol">(</a>
      <a data-type="(r : Initial C) (f g : Hom C (bot r) x) → f ≡ g" id="12780" href="Cat.Diagram.Initial.html#713" class="Function">¡-unique₂</a> <a id="12790" class="Symbol">(</a><a id="12791" href="Cat.Functor.Adjoint.html#5633" class="Bound">universal-map-for</a> <a id="12809" href="Cat.Functor.Adjoint.html#12752" class="Bound">x</a><a id="12810" class="Symbol">)</a> <a id="12812" class="Symbol">{</a><a id="12813" class="Keyword">record</a> <a id="12820" class="Symbol">{</a> <a data-type="(r : ↓Obj F G) → Hom C (F₀ F (r .x)) (F₀ G (r .y))" id="12822" href="Cat.Instances.Comma.html#1832" class="Field">map</a> <a id="12826" class="Symbol">=</a> <a id="12828" href="Cat.Functor.Adjoint.html#13299" class="Function">α</a> <a id="12830" class="Symbol">}}</a>
        <a id="12841" class="Symbol">(</a><a id="12842" class="Keyword">record</a> <a id="12849" class="Symbol">{</a> <a data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" id="12851" href="Cat.Instances.Comma.html#2646" class="Field">sq</a> <a id="12854" class="Symbol">=</a> 
          <a id="12867" href="Cat.Functor.Adjoint.html#13299" class="Function">α</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="12869" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="12873" href="Cat.Base.html#2868" class="Function">C.id</a>                     <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="12898" href="1Lab.Path.html#46757" class="Function">≡⟨</a> <a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" id="12901" href="Cat.Base.html#3331" class="Function">C.idr</a> <a id="12907" class="Symbol">_</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="12909" href="1Lab.Path.html#46757" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a id="12921" href="Cat.Functor.Adjoint.html#13299" class="Function">α</a>                              <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" id="12952" href="1Lab.Path.html#46911" class="Function Operator">≡˘⟨</a> <a data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ h) ((C ∘ i) f) ≡ f" id="12956" href="Cat.Reasoning.html#2373" class="Function">C.cancell</a> <a id="12966" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="12967" href="1Lab.Path.html#10628" class="Function">sym</a> <a id="12971" class="Symbol">(</a><a id="12972" href="Cat.Functor.Adjoint.html#10081" class="Function">ε</a> <a id="12974" class="Symbol">(</a><a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
C .Ob → D .Ob" id="12975" href="Cat.Functor.Adjoint.html#6177" class="Function">L₀</a> <a id="12978" href="Cat.Functor.Adjoint.html#12752" class="Bound">x</a><a id="12979" class="Symbol">)</a> <a id="12981" class="Symbol">.</a><a data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" id="12982" href="Cat.Instances.Comma.html#2646" class="Field">↓Hom.sq</a><a id="12989" class="Symbol">)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="12991" href="1Lab.Path.html#39580" class="Function Operator">∙</a> <a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" id="12993" href="Cat.Base.html#3331" class="Function">C.idr</a> <a id="12999" class="Symbol">_)</a> <a data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" id="13002" href="1Lab.Path.html#46911" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
          <a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="13014" href="Cat.Base.html#8210" class="Function">R.₁</a> <a id="13018" class="Symbol">_</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="13020" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a id="13024" class="Symbol">_</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="13026" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a id="13030" href="Cat.Functor.Adjoint.html#13299" class="Function">α</a>              <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" id="13045" href="1Lab.Path.html#46911" class="Function Operator">≡˘⟨</a> <a data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" id="13049" href="Cat.Reasoning.html#1684" class="Function">C.pullr</a> <a id="13057" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="13058" href="1Lab.Path.html#10628" class="Function">sym</a> <a id="13062" class="Symbol">(</a><a id="13063" href="Cat.Functor.Adjoint.html#6851" class="Function">lift↓</a> <a id="13069" href="Cat.Functor.Adjoint.html#13299" class="Function">α</a> <a id="13071" class="Symbol">.</a><a data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" id="13072" href="Cat.Instances.Comma.html#2646" class="Field">↓Hom.sq</a><a id="13079" class="Symbol">)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="13081" href="1Lab.Path.html#39580" class="Function Operator">∙</a> <a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" id="13083" href="Cat.Base.html#3331" class="Function">C.idr</a> <a id="13089" class="Symbol">_)</a> <a data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" id="13092" href="1Lab.Path.html#46911" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
          <a id="13104" class="Symbol">(</a><a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="13105" href="Cat.Base.html#8210" class="Function">R.₁</a> <a id="13109" class="Symbol">_</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="13111" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="13115" href="Cat.Base.html#8210" class="Function">R.₁</a> <a id="13119" class="Symbol">(</a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="13120" href="Cat.Base.html#7411" class="Field">F₁</a> <a id="13123" href="Cat.Functor.Adjoint.html#13319" class="Function">L</a> <a id="13125" href="Cat.Functor.Adjoint.html#13299" class="Function">α</a><a id="13126" class="Symbol">))</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="13129" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a id="13133" href="Cat.Functor.Adjoint.html#13299" class="Function">α</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" id="13135" href="1Lab.Path.html#46911" class="Function Operator">≡˘⟨</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="13139" href="1Lab.Path.html#20807" class="Function">ap</a> <a id="13142" class="Symbol">(</a><a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="13143" href="Cat.Base.html#2898" class="Function Operator">C._∘</a> <a id="13148" href="Cat.Functor.Adjoint.html#13299" class="Function">α</a><a id="13149" class="Symbol">)</a> <a id="13151" class="Symbol">(</a><a data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" id="13152" href="Cat.Base.html#7785" class="Function">R.F-∘</a> <a id="13158" class="Symbol">_</a> <a id="13160" class="Symbol">_)</a> <a data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" id="13163" href="1Lab.Path.html#46911" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
          <a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="13175" href="Cat.Base.html#8210" class="Function">R.₁</a> <a id="13179" class="Symbol">(_</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="13182" href="Cat.Base.html#2898" class="Function Operator">D.∘</a> <a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="13186" href="Cat.Base.html#7411" class="Field">F₁</a> <a id="13189" href="Cat.Functor.Adjoint.html#13319" class="Function">L</a> <a id="13191" href="Cat.Functor.Adjoint.html#13299" class="Function">α</a><a id="13192" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="13194" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a id="13198" href="Cat.Functor.Adjoint.html#13299" class="Function">α</a>       <a data-type="(x : A) → x ≡ x" id="13206" href="1Lab.Path.html#47085" class="Function Operator">∎</a>
        <a id="13216" class="Symbol">})</a> 
        <a id="13228" class="Symbol">(</a><a id="13229" class="Keyword">record</a> <a id="13236" class="Symbol">{</a> <a data-type="(r : ↓Hom F G a b) →
C ._∘_ (map b) (F₁ F (r .α)) ≡ C ._∘_ (F₁ G (r .β)) (a .map)" id="13238" href="Cat.Instances.Comma.html#2646" class="Field">sq</a> <a id="13241" class="Symbol">=</a> <a data-type="(C : Precategory o ℓ) → (C ∘ f) (id C) ≡ (C ∘ id C) f" id="13243" href="Cat.Reasoning.html#795" class="Function">C.id-comm</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="13253" href="1Lab.Path.html#39580" class="Function Operator">∙</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="13255" href="1Lab.Path.html#20807" class="Function">ap</a> <a id="13258" class="Symbol">(</a><a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="13259" href="Cat.Base.html#2898" class="Function Operator">C._∘</a> <a id="13264" class="Symbol">_)</a> <a id="13267" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="13268" href="1Lab.Path.html#10628" class="Function">sym</a> <a data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" id="13272" href="Cat.Base.html#7745" class="Function">R.F-id</a><a id="13278" class="Symbol">)</a> <a id="13280" class="Symbol">})</a>
    <a id="13287" class="Symbol">)</a>
    <a id="13293" class="Keyword">where</a> <a id="13299" href="Cat.Functor.Adjoint.html#13299" class="Function">α</a> <a id="13301" class="Symbol">=</a> <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁)
(c : C .Ob) →
C .Hom c (₀ R₁ (L₀ R₁ universal-map-for c))" id="13303" href="Cat.Functor.Adjoint.html#6239" class="Function">L₀′</a> <a id="13307" href="Cat.Functor.Adjoint.html#12752" class="Bound">x</a>
          <a id="13319" href="Cat.Functor.Adjoint.html#13319" class="Function">L</a> <a id="13321" class="Symbol">=</a> <a data-type="(R₁ : Functor D C)
(universal-map-for : (c : C .Ob) → Universal-morphism c R₁) →
Functor C D" id="13323" href="Cat.Functor.Adjoint.html#8509" class="Function">universalMaps→L</a>
</pre>
<!-- TODO [Amy 2022-02-17]
Show that L⊣R implies x↙R has an initial object
-->
  </article>
</div>

</main>
</body>
</html>
