<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>1Lab.Path - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />
  <link rel="stylesheet" href="/css/agda-cats.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="1Lab.Path - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="1Lab.Path - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script src="/equations.js"></script>
  <script src="/highlight-hover.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>
</head>

<body>
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">1Lab.Path</a>
              </h3>

      <!-- Cube logo -->
      <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#the-interval"><a href="#the-interval" class="header-link">The Interval<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#raising-dimension"><a href="#raising-dimension" class="header-link">Raising Dimension<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#symmetry"><a href="#symmetry" class="header-link">Symmetry<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#paths"><a href="#paths" class="header-link">Paths<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#transport"><a href="#transport" class="header-link">Transport<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#computation"><a href="#computation" class="header-link">Computation<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#path-induction"><a href="#path-induction" class="header-link">Path Induction<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#functorial-action"><a href="#functorial-action" class="header-link">Functorial Action<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#composition"><a href="#composition" class="header-link">Composition<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#partial-elements"><a href="#partial-elements" class="header-link">Partial Elements<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#extensibility"><a href="#extensibility" class="header-link">Extensibility<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#uniqueness"><a href="#uniqueness" class="header-link">Uniqueness<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#syntax-sugar"><a href="#syntax-sugar" class="header-link">Syntax Sugar<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#dependent-paths"><a href="#dependent-paths" class="header-link">Dependent Paths<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#coercion"><a href="#coercion" class="header-link">Coercion<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#path-spaces"><a href="#path-spaces" class="header-link">Path Spaces<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#σ-types"><a href="#σ-types" class="header-link">Σ Types<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#π-types"><a href="#π-types" class="header-link">Π types<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#paths-1"><a href="#paths-1" class="header-link">Paths<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
              <a href="index.html">️back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/d7a63503d3c2173e3cd2519ab941eba36a59618e/src/1Lab/Path.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao, Astra Kolomatskaia, Jonathan Coates, Reed Mullanix and uni</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="index.html">️back to index</a>
      </div>
      
      <!-- Font toggle checkbox -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="1Lab.Type.html" class="Module">1Lab.Type</a>

<a id="32" class="Keyword">module</a> <a id="39" href="1Lab.Path.html" class="Module">1Lab.Path</a> <a id="49" class="Keyword">where</a>
</pre>
<h1 id="the-interval"><a href="#the-interval" class="header-link">The Interval<span class="header-link-emoji">🔗</span></a></h1>
<p>In HoTT, the inductively-defined identity type gets a new meaning explanation: continuous paths, in a topological sense. The “key idea” of cubical type theory — and thus, Cubical Agda — is that we can take this as a new <em>definition</em> of the identity type, where we interpret a <span class="Agda"><a data-type="(A : Type ℓ) → A → A → Type ℓ" href="1Lab.Path.html#2466" class="Function">Path</a></span> in a type by a function where the domain is the <em>interval type</em>.</p>
<details>
<summary>
<strong>Aside</strong>: A brief comment on the meanings of “equal”, “identical” and “identified”, and how we refer to inhabitants of path types.
</summary>
<p>Before getting started, it’s worth taking a second to point out the terminology that will be used in this module (and most of the other pages). In intensional type theory, there is both an external notion of “sameness” (definitional equality), and an internal notion of “sameness”, which goes by many names: identity type, equality type, propositional equality, path type, etc.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>In this module, we refer to the type <code>A ≡ B</code> as either (the type of) <em>paths from A to B</em> or (the type of) <em>identifications between A and B</em>, but <strong>never</strong> as “equalities between A and B”. In particular, the HoTT book comments that we may say “<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> are equal” when the type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≡</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \equiv b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> is inhabited, but in this development we refer this terminology for the case where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> inhabit a <a href="1Lab.HLevel.html">set</a>.</p>
<p>Instead, for general types, we use “<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> are <strong>identical</strong>” or “<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> are <strong>identified</strong>” (or even the wordier, and rather more literal, “there is a path between <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>”). Depending on the type, we might use more specific words: Paths are said to be <strong>homotopic</strong> when they’re connected by a path-of-paths, and types are said to be <strong>equivalent</strong> when they are connected by a path.</p>
</details>
<!--
<pre class="Agda"><a id="1960" class="Keyword">open</a> <a id="1965" class="Keyword">import</a> <a id="1972" href="Agda.Builtin.Cubical.Path.html" class="Module">Agda.Builtin.Cubical.Path</a> <a id="1998" class="Keyword">public</a>
<a id="2005" class="Keyword">open</a> <a id="2010" class="Keyword">import</a> <a id="2017" href="Agda.Builtin.Cubical.Sub.html" class="Module">Agda.Builtin.Cubical.Sub</a> <a id="2042" class="Keyword">public</a>
  <a id="2051" class="Keyword">renaming</a> <a id="2060" class="Symbol">(</a> <a id="2062" href="Agda.Builtin.Cubical.Sub.html#216" class="Postulate">inc</a> <a id="2066" class="Symbol">to</a> <a id="2069" class="Postulate">inS</a>
           <a id="2084" class="Symbol">;</a> <a id="2086" href="Agda.Builtin.Cubical.Sub.html#400" class="Primitive">primSubOut</a> <a id="2097" class="Symbol">to</a> <a id="2100" class="Primitive">outS</a>
           <a id="2116" class="Symbol">)</a>
<a id="2118" class="Keyword">open</a> <a id="2123" class="Keyword">import</a> <a id="2130" href="Agda.Primitive.Cubical.html" class="Module">Agda.Primitive.Cubical</a> <a id="2153" class="Keyword">public</a>
  <a id="2162" class="Keyword">renaming</a> <a id="2171" class="Symbol">(</a> <a id="2173" href="Agda.Primitive.Cubical.html#343" class="Primitive">primIMin</a>       <a id="2188" class="Symbol">to</a> <a id="2191" class="Primitive">_∧_</a>
           <a id="2206" class="Symbol">;</a> <a id="2208" href="Agda.Primitive.Cubical.html#368" class="Primitive">primIMax</a>       <a id="2223" class="Symbol">to</a> <a id="2226" class="Primitive">_∨_</a>
           <a id="2241" class="Symbol">;</a> <a id="2243" href="Agda.Primitive.Cubical.html#393" class="Primitive">primINeg</a>       <a id="2258" class="Symbol">to</a> <a id="2261" class="Primitive">~_</a>
           <a id="2275" class="Symbol">;</a> <a id="2277" href="Agda.Primitive.Cubical.html#1125" class="Postulate">isOneEmpty</a>     <a id="2292" class="Symbol">to</a> <a id="2295" class="Postulate">empty</a>
           <a id="2312" class="Symbol">;</a> <a id="2314" href="Agda.Primitive.Cubical.html#1647" class="Primitive">primComp</a>       <a id="2329" class="Symbol">to</a> <a id="2332" class="Primitive">comp</a>
           <a id="2348" class="Symbol">;</a> <a id="2350" href="Agda.Primitive.Cubical.html#1874" class="Primitive">primHComp</a>      <a id="2365" class="Symbol">to</a> <a id="2368" class="Primitive">hcomp</a>
           <a id="2385" class="Symbol">;</a> <a id="2387" href="Agda.Primitive.Cubical.html#1801" class="Primitive">primTransp</a>     <a id="2402" class="Symbol">to</a> <a id="2405" class="Primitive">transp</a>
           <a id="2423" class="Symbol">;</a> <a id="2425" href="Agda.Primitive.Cubical.html#479" class="Postulate">itIsOne</a>        <a id="2440" class="Symbol">to</a> <a id="2443" class="Postulate">1=1</a> <a id="2447" class="Symbol">)</a>
</pre>-->
<pre class="Agda"><a id="Path"></a><a data-type="(A : Type ℓ) → A → A → Type ℓ" id="2466" href="1Lab.Path.html#2466" class="Function">Path</a> <a id="2471" class="Symbol">:</a> <a id="2473" class="Symbol">∀</a> <a id="2475" class="Symbol">{</a><a id="2476" href="1Lab.Path.html#2476" class="Bound">ℓ</a><a id="2477" class="Symbol">}</a> <a id="2479" class="Symbol">(</a><a id="2480" href="1Lab.Path.html#2480" class="Bound">A</a> <a id="2482" class="Symbol">:</a> <a id="2484" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2489" href="1Lab.Path.html#2476" class="Bound">ℓ</a><a id="2490" class="Symbol">)</a> <a id="2492" class="Symbol">→</a> <a id="2494" href="1Lab.Path.html#2480" class="Bound">A</a> <a id="2496" class="Symbol">→</a> <a id="2498" href="1Lab.Path.html#2480" class="Bound">A</a> <a id="2500" class="Symbol">→</a> <a id="2502" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2507" href="1Lab.Path.html#2476" class="Bound">ℓ</a>
<a data-type="(A : Type ℓ) → A → A → Type ℓ" id="2509" href="1Lab.Path.html#2466" class="Function">Path</a> <a id="2514" href="1Lab.Path.html#2514" class="Bound">A</a> <a id="2516" class="Symbol">=</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="2518" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="2524" class="Symbol">(λ</a> <a id="2527" href="1Lab.Path.html#2527" class="Bound">i</a> <a id="2529" class="Symbol">→</a> <a id="2531" href="1Lab.Path.html#2514" class="Bound">A</a><a id="2532" class="Symbol">)</a>
</pre>
<p>The type <span class="Agda"><a href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a></span> is meant to represent the (real, closed) unit interval <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>,</span> the same unit interval used in the topological definition of path. Because the real unit interval has a least and greatest element — 0 and 1 — the interval <em>type</em> also has two global inhabitants, <span class="Agda"><a href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a></span> and <span class="Agda"><a href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a></span>. This is where the analogy with the reals breaks down: There’s no such thing as <code>i0.5</code> (much less <code>i1/π</code>). In reality, the interval type internalises an abstract interval <em>object</em>.</p>
<p>Regardless, since all functions definable in type theory are automatically continuous, we can take a path to be any value in the function type <code>I → A</code>. When working with paths, though, it’s useful to mention the endpoints of a path in its type — that is, the values the function takes when applied to <code>i0</code> and to <code>i1</code>. We can “upgrade” any function <code>f : I → A</code> to a <span class="Agda"><a data-type="(A : Type ℓ) → A → A → Type ℓ" href="1Lab.Path.html#2466" class="Function">Path</a></span>, using a definition that looks suspiciously like the identity function:</p>
<pre class="Agda"><a id="3496" class="Keyword">private</a>
  <a id="to-path"></a><a id="3506" href="1Lab.Path.html#3506" class="Function">to-path</a> <a id="3514" class="Symbol">:</a> <a id="3516" class="Symbol">∀</a> <a id="3518" class="Symbol">{</a><a id="3519" href="1Lab.Path.html#3519" class="Bound">ℓ</a><a id="3520" class="Symbol">}</a> <a id="3522" class="Symbol">{</a><a id="3523" href="1Lab.Path.html#3523" class="Bound">A</a> <a id="3525" class="Symbol">:</a> <a id="3527" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="3532" href="1Lab.Path.html#3519" class="Bound">ℓ</a><a id="3533" class="Symbol">}</a> <a id="3535" class="Symbol">→</a> <a id="3537" class="Symbol">(</a><a id="3538" href="1Lab.Path.html#3538" class="Bound">f</a> <a id="3540" class="Symbol">:</a> <a id="3542" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="3544" class="Symbol">→</a> <a id="3546" href="1Lab.Path.html#3523" class="Bound">A</a><a id="3547" class="Symbol">)</a> <a id="3549" class="Symbol">→</a> <a data-type="(A : Type ℓ) → A → A → Type ℓ" id="3551" href="1Lab.Path.html#2466" class="Function">Path</a> <a id="3556" href="1Lab.Path.html#3523" class="Bound">A</a> <a id="3558" class="Symbol">(</a><a id="3559" href="1Lab.Path.html#3538" class="Bound">f</a> <a id="3561" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="3563" class="Symbol">)</a> <a id="3565" class="Symbol">(</a><a id="3566" href="1Lab.Path.html#3538" class="Bound">f</a> <a id="3568" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="3570" class="Symbol">)</a>
  <a id="3574" href="1Lab.Path.html#3506" class="Function">to-path</a> <a id="3582" href="1Lab.Path.html#3582" class="Bound">f</a> <a id="3584" href="1Lab.Path.html#3584" class="Bound">i</a> <a id="3586" class="Symbol">=</a> <a id="3588" href="1Lab.Path.html#3582" class="Bound">f</a> <a id="3590" href="1Lab.Path.html#3584" class="Bound">i</a>

<a id="refl"></a><a data-type="x ≡ x" id="3593" href="1Lab.Path.html#3593" class="Function">refl</a> <a id="3598" class="Symbol">:</a> <a id="3600" class="Symbol">∀</a> <a id="3602" class="Symbol">{</a><a id="3603" href="1Lab.Path.html#3603" class="Bound">ℓ</a><a id="3604" class="Symbol">}</a> <a id="3606" class="Symbol">{</a><a id="3607" href="1Lab.Path.html#3607" class="Bound">A</a> <a id="3609" class="Symbol">:</a> <a id="3611" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="3616" href="1Lab.Path.html#3603" class="Bound">ℓ</a><a id="3617" class="Symbol">}</a> <a id="3619" class="Symbol">{</a><a id="3620" href="1Lab.Path.html#3620" class="Bound">x</a> <a id="3622" class="Symbol">:</a> <a id="3624" href="1Lab.Path.html#3607" class="Bound">A</a><a id="3625" class="Symbol">}</a> <a id="3627" class="Symbol">→</a> <a id="3629" href="1Lab.Path.html#3620" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="3631" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="3633" href="1Lab.Path.html#3620" class="Bound">x</a>
<a data-type="x ≡ x" id="3635" href="1Lab.Path.html#3593" class="Function">refl</a> <a id="3640" class="Symbol">{</a><a id="3641" class="Argument">x</a> <a id="3643" class="Symbol">=</a> <a id="3645" href="1Lab.Path.html#3645" class="Bound">x</a><a id="3646" class="Symbol">}</a> <a id="3648" class="Symbol">=</a> <a id="3650" href="1Lab.Path.html#3506" class="Function">to-path</a> <a id="3658" class="Symbol">(λ</a> <a id="3661" href="1Lab.Path.html#3661" class="Bound">i</a> <a id="3663" class="Symbol">→</a> <a id="3665" href="1Lab.Path.html#3645" class="Bound">x</a><a id="3666" class="Symbol">)</a>
</pre>
<p>The type <code>Path A x y</code> is also written <code>x ≡ y</code>, when <code>A</code> is not important - i.e. when it can be inferred from <code>x</code> and <code>y</code>. Under this interpretation, proof that identification is reflexive (i.e. that <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>)</span> is given by a <span class="Agda"><a data-type="(A : Type ℓ) → A → A → Type ℓ" href="1Lab.Path.html#2466" class="Function">Path</a></span> which yields the same element everywhere on <code>I</code>: The function that is constantly <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>.</span></p>
<p>If we have a <span class="Agda"><a data-type="(A : Type ℓ) → A → A → Type ℓ" href="1Lab.Path.html#2466" class="Function">Path</a></span>, we can apply it to a value of the interval type to get an element of the underlying type. When a path is applied to one of the endpoints, the result is the same as declared in its type — even when we’re applying a path we don’t know the definition of.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<pre class="Agda"><a id="4522" class="Keyword">module</a> <a id="4529" href="1Lab.Path.html#4529" class="Module">_</a> <a id="4531" class="Symbol">{</a><a id="4532" href="1Lab.Path.html#4532" class="Bound">ℓ</a><a id="4533" class="Symbol">}</a> <a id="4535" class="Symbol">{</a><a id="4536" href="1Lab.Path.html#4536" class="Bound">A</a> <a id="4538" class="Symbol">:</a> <a id="4540" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="4545" href="1Lab.Path.html#4532" class="Bound">ℓ</a><a id="4546" class="Symbol">}</a> <a id="4548" class="Symbol">{</a><a id="4549" href="1Lab.Path.html#4549" class="Bound">x</a> <a id="4551" href="1Lab.Path.html#4551" class="Bound">y</a> <a id="4553" class="Symbol">:</a> <a id="4555" href="1Lab.Path.html#4536" class="Bound">A</a><a id="4556" class="Symbol">}</a> <a id="4558" class="Symbol">{</a><a id="4559" href="1Lab.Path.html#4559" class="Bound">p</a> <a id="4561" class="Symbol">:</a> <a id="4563" href="1Lab.Path.html#4549" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="4565" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="4567" href="1Lab.Path.html#4551" class="Bound">y</a><a id="4568" class="Symbol">}</a> <a id="4570" class="Keyword">where</a>
  <a id="4578" class="Keyword">private</a>
    <a id="4590" href="1Lab.Path.html#4590" class="Function">left-endpoint</a> <a id="4604" class="Symbol">:</a> <a id="4606" href="1Lab.Path.html#4559" class="Bound">p</a> <a id="4608" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a data-type="A → A → Type ℓ" id="4611" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="4613" href="1Lab.Path.html#4549" class="Bound">x</a>
    <a id="4619" href="1Lab.Path.html#4590" class="Function">left-endpoint</a> <a id="4633" href="1Lab.Path.html#4633" class="Bound">i</a> <a id="4635" class="Symbol">=</a> <a id="4637" href="1Lab.Path.html#4549" class="Bound">x</a>

    <a id="4644" href="1Lab.Path.html#4644" class="Function">right-endpoint</a> <a id="4659" class="Symbol">:</a> <a id="4661" href="1Lab.Path.html#4559" class="Bound">p</a> <a id="4663" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a> <a data-type="A → A → Type ℓ" id="4666" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="4668" href="1Lab.Path.html#4551" class="Bound">y</a>
    <a id="4674" href="1Lab.Path.html#4644" class="Function">right-endpoint</a> <a id="4689" href="1Lab.Path.html#4689" class="Bound">i</a> <a id="4691" class="Symbol">=</a> <a id="4693" href="1Lab.Path.html#4551" class="Bound">y</a>
</pre>
<p>In addition to the two endpoints <span class="Agda"><a href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a></span> and <span class="Agda"><a href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a></span>, the interval has the structure of a De Morgan algebra. All the following equations are respected (definitionally), but they can not be expressed internally as a <span class="Agda"><a data-type="(A : Type ℓ) → A → A → Type ℓ" href="1Lab.Path.html#2466" class="Function">Path</a></span> because <span class="Agda"><a href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a></span> is not in <span class="Agda"><a href="1Lab.Type.html#391" class="Primitive">Type</a></span>.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<ul>
<li><span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∧</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">x \land \mathrm{i0} = \mathrm{i0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i0</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i0</span></span></span></span></span>,</span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∧</mo><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x \land \mathrm{i1} = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i1</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></li>
<li><span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∨</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x \lor \mathrm{i0} = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i0</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>,</span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∨</mo><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">x \lor \mathrm{i1} = \mathrm{i1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i1</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i1</span></span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mo stretchy="false">(</mo><mi>x</mi><mo>∧</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">¬</mi><mi>x</mi><mo>∨</mo><mi mathvariant="normal">¬</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">\neg(x \land y) = \neg x \lor \neg y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">¬</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord">¬</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></li>
<li><span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">\neg\mathrm{i0} = \mathrm{i1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord">¬</span><span class="mord"><span class="mord mathrm">i0</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i1</span></span></span></span></span>,</span> <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">\neg\mathrm{i1} = \mathrm{i0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord">¬</span><span class="mord"><span class="mord mathrm">i1</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i0</span></span></span></span></span>,</span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mi mathvariant="normal">¬</mi><mi>x</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\neg\neg x = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">¬¬</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∧</mo></mrow><annotation encoding="application/x-tex">\land</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∧</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∨</mo></mrow><annotation encoding="application/x-tex">\lor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∨</span></span></span></span> are both associative, commutative and idempotent, and distribute over eachother.</li>
</ul>
<p>Note that, in the formalisation, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\neg x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">¬</span><span class="mord mathnormal">x</span></span></span></span> is written <code>~ x</code>. As a more familiar description, a De Morgan algebra is a Boolean algebra that does not (necessarily) satisfy the law of excluded middle. This is necessary to maintain type safety.</p>
<h2 id="raising-dimension"><a href="#raising-dimension" class="header-link">Raising Dimension<span class="header-link-emoji">🔗</span></a></h2>
<p>To wit: In cubical type theory, a term in a context with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> interval variables expresses a way of mapping an <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-cube</span> into that type. One very important class of these maps are the <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>-cubes</span> — lines or <em><span class="Agda"><a data-type="(A : Type ℓ) → A → A → Type ℓ" href="1Lab.Path.html#2466" class="Function">paths</a></span></em> — which represent identifications between terms of that type.</p>
<p>Iterating this construction, a term in a context with 2 interval variables represents a square in the type, which can be read as saying that some <em>paths</em> (specialising one of the variables to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">i0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mord">0</span></span></span></span> or <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">i1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mord">1</span></span></span></span>)</span> in that space are identical: A path between paths, which we call a <em>homotopy</em>.</p>
<p>The structural operations on contexts, and the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∧</mo></mrow><annotation encoding="application/x-tex">\land</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∧</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∨</mo></mrow><annotation encoding="application/x-tex">\lor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∨</span></span></span></span> operations on the interval, give a way of extending from <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-dimensional</span> cubes to <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">n+k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>-dimensional</span> cubes. For instance, if we have a path like the one below, we can extend it to any of a bunch of different squares:</p>
<div class="diagram-container">
<img src="a55f1868a3dfecb4f407b250660329b427839692.svg" title="commutative diagram" class="diagram quiver short-2" />
</div>
<pre class="Agda"><a id="6838" class="Keyword">module</a> <a id="6845" href="1Lab.Path.html#6845" class="Module">_</a> <a id="6847" class="Symbol">{</a><a id="6848" href="1Lab.Path.html#6848" class="Bound">ℓ</a><a id="6849" class="Symbol">}</a> <a id="6851" class="Symbol">{</a><a id="6852" href="1Lab.Path.html#6852" class="Bound">A</a> <a id="6854" class="Symbol">:</a> <a id="6856" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="6861" href="1Lab.Path.html#6848" class="Bound">ℓ</a><a id="6862" class="Symbol">}</a> <a id="6864" class="Symbol">{</a><a id="6865" href="1Lab.Path.html#6865" class="Bound">a</a> <a id="6867" href="1Lab.Path.html#6867" class="Bound">b</a> <a id="6869" class="Symbol">:</a> <a id="6871" href="1Lab.Path.html#6852" class="Bound">A</a><a id="6872" class="Symbol">}</a> <a id="6874" class="Symbol">{</a><a id="6875" href="1Lab.Path.html#6875" class="Bound">p</a> <a id="6877" class="Symbol">:</a> <a data-type="(A : Type ℓ) → A → A → Type ℓ" id="6879" href="1Lab.Path.html#2466" class="Function">Path</a> <a id="6884" href="1Lab.Path.html#6852" class="Bound">A</a> <a id="6886" href="1Lab.Path.html#6865" class="Bound">a</a> <a id="6888" href="1Lab.Path.html#6867" class="Bound">b</a><a id="6889" class="Symbol">}</a> <a id="6891" class="Keyword">where</a>
</pre>
<p>The first thing we can do is introduce another interval variable and ignore it, varying the path over the non-ignored variable. These give us squares where either the top/bottom or left/right faces are the path <code>p</code>, and the other two are refl.</p>
<pre class="Agda">  <a id="7157" class="Keyword">private</a>
    <a id="7169" href="1Lab.Path.html#7169" class="Function">drop-j</a> <a id="7176" class="Symbol">:</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="7178" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="7184" class="Symbol">(λ</a> <a id="7187" href="1Lab.Path.html#7187" class="Bound">i</a> <a id="7189" class="Symbol">→</a> <a id="7191" href="1Lab.Path.html#6875" class="Bound">p</a> <a id="7193" href="1Lab.Path.html#7187" class="Bound">i</a> <a data-type="A → A → Type ℓ" id="7195" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="7197" href="1Lab.Path.html#6875" class="Bound">p</a> <a id="7199" href="1Lab.Path.html#7187" class="Bound">i</a><a id="7200" class="Symbol">)</a> <a data-type="x ≡ x" id="7202" href="1Lab.Path.html#3593" class="Function">refl</a> <a data-type="x ≡ x" id="7207" href="1Lab.Path.html#3593" class="Function">refl</a>
    <a id="7216" href="1Lab.Path.html#7169" class="Function">drop-j</a> <a id="7223" href="1Lab.Path.html#7223" class="Bound">i</a> <a id="7225" href="1Lab.Path.html#7225" class="Bound">j</a> <a id="7227" class="Symbol">=</a> <a id="7229" href="1Lab.Path.html#6875" class="Bound">p</a> <a id="7231" href="1Lab.Path.html#7223" class="Bound">i</a>

    <a id="7238" href="1Lab.Path.html#7238" class="Function">drop-i</a> <a id="7245" class="Symbol">:</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="7247" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="7253" class="Symbol">(λ</a> <a id="7256" href="1Lab.Path.html#7256" class="Bound">i</a> <a id="7258" class="Symbol">→</a> <a id="7260" href="1Lab.Path.html#6865" class="Bound">a</a> <a data-type="A → A → Type ℓ" id="7262" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="7264" href="1Lab.Path.html#6867" class="Bound">b</a><a id="7265" class="Symbol">)</a> <a id="7267" href="1Lab.Path.html#6875" class="Bound">p</a> <a id="7269" href="1Lab.Path.html#6875" class="Bound">p</a>
    <a id="7275" href="1Lab.Path.html#7238" class="Function">drop-i</a> <a id="7282" href="1Lab.Path.html#7282" class="Bound">i</a> <a id="7284" href="1Lab.Path.html#7284" class="Bound">j</a> <a id="7286" class="Symbol">=</a> <a id="7288" href="1Lab.Path.html#6875" class="Bound">p</a> <a id="7290" href="1Lab.Path.html#7284" class="Bound">j</a>
</pre>
<p>These squares can be drawn as below. Take a moment to appreciate how the <em>types</em> of <span class="Agda"><a href="1Lab.Path.html#7169" class="Function">drop-j</a></span> and <span class="Agda"><a href="1Lab.Path.html#7238" class="Function">drop-i</a></span> specify the <em>boundary</em> of the diagram — A <code>PathP (λ i → p i ≡ p i) refl refl</code> corresponds to a square whose top/bottom faces are both <code>p</code>, and whose left/right faces are both <span class="Agda"><a data-type="x ≡ x" href="1Lab.Path.html#3593" class="Function">refl</a></span> (by convention). Similarly, <code>PathP (λ i → a ≡ b) p p</code> has <span class="Agda"><a data-type="x ≡ x" href="1Lab.Path.html#3593" class="Function">refl</a></span> as top/bottom faces (recall that <span class="Agda"><a data-type="x ≡ x" href="1Lab.Path.html#3593" class="Function">refl</a></span> is the constant function regarded as a path), and <code>p</code> as both left/right faces.</p>
<div class="mathpar">
<div class="diagram-container">
<img src="453dd90ddecfddb7c19c0a8d0972753d8267d749.svg" title="commutative diagram" class="diagram quiver" />
</div>
<div class="diagram-container">
<img src="b4af5c24d5d788ef82b625ed4f1a15c303bcf1c2.svg" title="commutative diagram" class="diagram quiver" />
</div>
</div>
<p>The other thing we can do is use one of the binary operators on the interval to get squares called <em>connections</em>, where two adjacent faces are <code>p</code> and the other two are refl:</p>
<pre class="Agda">    <a id="8545" href="1Lab.Path.html#8545" class="Function">∧-conn</a> <a id="8552" class="Symbol">:</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="8554" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="8560" class="Symbol">(λ</a> <a id="8563" href="1Lab.Path.html#8563" class="Bound">i</a> <a id="8565" class="Symbol">→</a> <a id="8567" href="1Lab.Path.html#6865" class="Bound">a</a> <a data-type="A → A → Type ℓ" id="8569" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="8571" href="1Lab.Path.html#6875" class="Bound">p</a> <a id="8573" href="1Lab.Path.html#8563" class="Bound">i</a><a id="8574" class="Symbol">)</a> <a data-type="x ≡ x" id="8576" href="1Lab.Path.html#3593" class="Function">refl</a> <a id="8581" href="1Lab.Path.html#6875" class="Bound">p</a>
    <a id="8587" href="1Lab.Path.html#8545" class="Function">∧-conn</a> <a id="8594" href="1Lab.Path.html#8594" class="Bound">i</a> <a id="8596" href="1Lab.Path.html#8596" class="Bound">j</a> <a id="8598" class="Symbol">=</a> <a id="8600" href="1Lab.Path.html#6875" class="Bound">p</a> <a id="8602" class="Symbol">(</a><a id="8603" href="1Lab.Path.html#8594" class="Bound">i</a> <a id="8605" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="8607" href="1Lab.Path.html#8596" class="Bound">j</a><a id="8608" class="Symbol">)</a>

    <a id="8615" href="1Lab.Path.html#8615" class="Function">∨-conn</a> <a id="8622" class="Symbol">:</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="8624" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="8630" class="Symbol">(λ</a> <a id="8633" href="1Lab.Path.html#8633" class="Bound">i</a> <a id="8635" class="Symbol">→</a> <a id="8637" href="1Lab.Path.html#6875" class="Bound">p</a> <a id="8639" href="1Lab.Path.html#8633" class="Bound">i</a> <a data-type="A → A → Type ℓ" id="8641" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="8643" href="1Lab.Path.html#6867" class="Bound">b</a><a id="8644" class="Symbol">)</a> <a id="8646" href="1Lab.Path.html#6875" class="Bound">p</a> <a data-type="x ≡ x" id="8648" href="1Lab.Path.html#3593" class="Function">refl</a>
    <a id="8657" href="1Lab.Path.html#8615" class="Function">∨-conn</a> <a id="8664" href="1Lab.Path.html#8664" class="Bound">i</a> <a id="8666" href="1Lab.Path.html#8666" class="Bound">j</a> <a id="8668" class="Symbol">=</a> <a id="8670" href="1Lab.Path.html#6875" class="Bound">p</a> <a id="8672" class="Symbol">(</a><a id="8673" href="1Lab.Path.html#8664" class="Bound">i</a> <a id="8675" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="8677" href="1Lab.Path.html#8666" class="Bound">j</a><a id="8678" class="Symbol">)</a>
</pre>
<p>These correspond to the following two squares:</p>
<div class="mathpar">
<div class="diagram-container">
<img src="7e079588b1deef1566c3cf192315ffce70d570b4.svg" title="commutative diagram" class="diagram quiver" />
</div>
<div class="diagram-container">
<img src="b6ae802db144fbd9f113cb0a6f182fbb350fee7c.svg" title="commutative diagram" class="diagram quiver" />
</div>
</div>
<p>Since iterated paths are used <em>a lot</em> in homotopy type theory, we introduce a shorthand for 2D non-dependent paths. A <span class="Agda"><a data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" href="1Lab.Path.html#9481" class="Function">Square</a></span> in a type is exactly what it says on the tin: a square.</p>
<pre class="Agda"><a id="Square"></a><a data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" id="9481" href="1Lab.Path.html#9481" class="Function">Square</a> <a id="9488" class="Symbol">:</a> <a id="9490" class="Symbol">∀</a> <a id="9492" class="Symbol">{</a><a id="9493" href="1Lab.Path.html#9493" class="Bound">ℓ</a><a id="9494" class="Symbol">}</a> <a id="9496" class="Symbol">{</a><a id="9497" href="1Lab.Path.html#9497" class="Bound">A</a> <a id="9499" class="Symbol">:</a> <a id="9501" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="9506" href="1Lab.Path.html#9493" class="Bound">ℓ</a><a id="9507" class="Symbol">}</a> <a id="9509" class="Symbol">{</a><a id="9510" href="1Lab.Path.html#9510" class="Bound">a00</a> <a id="9514" href="1Lab.Path.html#9514" class="Bound">a01</a> <a id="9518" href="1Lab.Path.html#9518" class="Bound">a10</a> <a id="9522" href="1Lab.Path.html#9522" class="Bound">a11</a> <a id="9526" class="Symbol">:</a> <a id="9528" href="1Lab.Path.html#9497" class="Bound">A</a><a id="9529" class="Symbol">}</a>
       <a id="9538" class="Symbol">→</a> <a id="9540" class="Symbol">(</a><a id="9541" href="1Lab.Path.html#9541" class="Bound">p</a> <a id="9543" class="Symbol">:</a> <a id="9545" href="1Lab.Path.html#9510" class="Bound">a00</a> <a data-type="A → A → Type ℓ" id="9549" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="9551" href="1Lab.Path.html#9514" class="Bound">a01</a><a id="9554" class="Symbol">)</a>
       <a id="9563" class="Symbol">→</a> <a id="9565" class="Symbol">(</a><a id="9566" href="1Lab.Path.html#9566" class="Bound">q</a> <a id="9568" class="Symbol">:</a> <a id="9570" href="1Lab.Path.html#9510" class="Bound">a00</a> <a data-type="A → A → Type ℓ" id="9574" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="9576" href="1Lab.Path.html#9518" class="Bound">a10</a><a id="9579" class="Symbol">)</a>
       <a id="9588" class="Symbol">→</a> <a id="9590" class="Symbol">(</a><a id="9591" href="1Lab.Path.html#9591" class="Bound">s</a> <a id="9593" class="Symbol">:</a> <a id="9595" href="1Lab.Path.html#9514" class="Bound">a01</a> <a data-type="A → A → Type ℓ" id="9599" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="9601" href="1Lab.Path.html#9522" class="Bound">a11</a><a id="9604" class="Symbol">)</a>
       <a id="9613" class="Symbol">→</a> <a id="9615" class="Symbol">(</a><a id="9616" href="1Lab.Path.html#9616" class="Bound">r</a> <a id="9618" class="Symbol">:</a> <a id="9620" href="1Lab.Path.html#9518" class="Bound">a10</a> <a data-type="A → A → Type ℓ" id="9624" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="9626" href="1Lab.Path.html#9522" class="Bound">a11</a><a id="9629" class="Symbol">)</a>
       <a id="9638" class="Symbol">→</a> <a id="9640" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="9645" href="1Lab.Path.html#9493" class="Bound">ℓ</a>
<a data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" id="9647" href="1Lab.Path.html#9481" class="Function">Square</a> <a id="9654" href="1Lab.Path.html#9654" class="Bound">p</a> <a id="9656" href="1Lab.Path.html#9656" class="Bound">q</a> <a id="9658" href="1Lab.Path.html#9658" class="Bound">s</a> <a id="9660" href="1Lab.Path.html#9660" class="Bound">r</a> <a id="9662" class="Symbol">=</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="9664" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="9670" class="Symbol">(λ</a> <a id="9673" href="1Lab.Path.html#9673" class="Bound">i</a> <a id="9675" class="Symbol">→</a> <a id="9677" href="1Lab.Path.html#9654" class="Bound">p</a> <a id="9679" href="1Lab.Path.html#9673" class="Bound">i</a> <a data-type="A → A → Type ℓ" id="9681" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="9683" href="1Lab.Path.html#9660" class="Bound">r</a> <a id="9685" href="1Lab.Path.html#9673" class="Bound">i</a><a id="9686" class="Symbol">)</a> <a id="9688" href="1Lab.Path.html#9656" class="Bound">q</a> <a id="9690" href="1Lab.Path.html#9658" class="Bound">s</a>
</pre>
<p>The arguments to <span class="Agda"><a data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" href="1Lab.Path.html#9481" class="Function">Square</a></span> are as in the following diagram, listed in the order “PQSR”. This order is a bit unusual (it’s one off from being alphabetical, for instance) but it does have a significant benefit: If you imagine that the letters are laid out in a circle, <em>identical paths are adjacent</em>. Reading the square in the left-right direction, it says that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> are identical — these are adjacent if you “fold up” the sequence <code>p q s r</code>. Similarly, reading top-down, it says that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> are identical - these are directly adjacent.</p>
<div class="diagram-container">
<img src="380d66cf53cf641227cfd3fdfef852d7db284189.svg" title="commutative diagram" class="diagram quiver" />
</div>
<h2 id="symmetry"><a href="#symmetry" class="header-link">Symmetry<span class="header-link-emoji">🔗</span></a></h2>
<p>The involution <code class="sourceCode agda">~<span class="ot">_</span></code> on the interval type gives a way of inverting paths — a proof that identification is symmetric.</p>
<pre class="Agda"><a id="sym"></a><a data-type="x ≡ y → y ≡ x" id="10630" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="10634" class="Symbol">:</a> <a id="10636" class="Symbol">∀</a> <a id="10638" class="Symbol">{</a><a id="10639" href="1Lab.Path.html#10639" class="Bound">ℓ₁</a><a id="10641" class="Symbol">}</a> <a id="10643" class="Symbol">{</a><a id="10644" href="1Lab.Path.html#10644" class="Bound">A</a> <a id="10646" class="Symbol">:</a> <a id="10648" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="10653" href="1Lab.Path.html#10639" class="Bound">ℓ₁</a><a id="10655" class="Symbol">}</a> <a id="10657" class="Symbol">{</a><a id="10658" href="1Lab.Path.html#10658" class="Bound">x</a> <a id="10660" href="1Lab.Path.html#10660" class="Bound">y</a> <a id="10662" class="Symbol">:</a> <a id="10664" href="1Lab.Path.html#10644" class="Bound">A</a><a id="10665" class="Symbol">}</a>
    <a id="10671" class="Symbol">→</a> <a id="10673" href="1Lab.Path.html#10658" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="10675" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10677" href="1Lab.Path.html#10660" class="Bound">y</a> <a id="10679" class="Symbol">→</a> <a id="10681" href="1Lab.Path.html#10660" class="Bound">y</a> <a data-type="A → A → Type ℓ" id="10683" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10685" href="1Lab.Path.html#10658" class="Bound">x</a>
<a data-type="x ≡ y → y ≡ x" id="10687" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="10691" href="1Lab.Path.html#10691" class="Bound">p</a> <a id="10693" href="1Lab.Path.html#10693" class="Bound">i</a> <a id="10695" class="Symbol">=</a> <a id="10697" href="1Lab.Path.html#10691" class="Bound">p</a> <a id="10699" class="Symbol">(</a><a id="10700" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="10702" href="1Lab.Path.html#10693" class="Bound">i</a><a id="10703" class="Symbol">)</a>
</pre>
<!--
<pre class="Agda"><a id="symP"></a><a id="10719" href="1Lab.Path.html#10719" class="Function">symP</a> <a id="10724" class="Symbol">:</a> <a id="10726" class="Symbol">∀</a> <a id="10728" class="Symbol">{</a><a id="10729" href="1Lab.Path.html#10729" class="Bound">ℓ₁</a><a id="10731" class="Symbol">}</a> <a id="10733" class="Symbol">{</a><a id="10734" href="1Lab.Path.html#10734" class="Bound">A</a> <a id="10736" class="Symbol">:</a> <a id="10738" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="10740" class="Symbol">→</a> <a id="10742" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="10747" href="1Lab.Path.html#10729" class="Bound">ℓ₁</a><a id="10749" class="Symbol">}</a> <a id="10751" class="Symbol">{</a><a id="10752" href="1Lab.Path.html#10752" class="Bound">x</a> <a id="10754" class="Symbol">:</a> <a id="10756" href="1Lab.Path.html#10734" class="Bound">A</a> <a id="10758" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="10760" class="Symbol">}</a> <a id="10762" class="Symbol">{</a><a id="10763" href="1Lab.Path.html#10763" class="Bound">y</a> <a id="10765" class="Symbol">:</a> <a id="10767" href="1Lab.Path.html#10734" class="Bound">A</a> <a id="10769" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="10771" class="Symbol">}</a>
     <a id="10778" class="Symbol">→</a> <a id="10780" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="10786" href="1Lab.Path.html#10734" class="Bound">A</a> <a id="10788" href="1Lab.Path.html#10752" class="Bound">x</a> <a id="10790" href="1Lab.Path.html#10763" class="Bound">y</a> <a id="10792" class="Symbol">→</a> <a id="10794" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="10800" class="Symbol">(λ</a> <a id="10803" href="1Lab.Path.html#10803" class="Bound">i</a> <a id="10805" class="Symbol">→</a> <a id="10807" href="1Lab.Path.html#10734" class="Bound">A</a> <a id="10809" class="Symbol">(</a><a id="10810" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="10812" href="1Lab.Path.html#10803" class="Bound">i</a><a id="10813" class="Symbol">))</a> <a id="10816" href="1Lab.Path.html#10763" class="Bound">y</a> <a id="10818" href="1Lab.Path.html#10752" class="Bound">x</a>
<a id="10820" href="1Lab.Path.html#10719" class="Function">symP</a> <a id="10825" href="1Lab.Path.html#10825" class="Bound">p</a> <a id="10827" href="1Lab.Path.html#10827" class="Bound">i</a> <a id="10829" class="Symbol">=</a> <a id="10831" href="1Lab.Path.html#10825" class="Bound">p</a> <a id="10833" class="Symbol">(</a><a id="10834" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="10836" href="1Lab.Path.html#10827" class="Bound">i</a><a id="10837" class="Symbol">)</a>
</pre>-->
<p>As a minor improvement over “Book HoTT”, this operation is <em>definitionally</em> involutive:</p>
<pre class="Agda"><a id="10945" class="Keyword">module</a> <a id="10952" href="1Lab.Path.html#10952" class="Module">_</a> <a id="10954" class="Symbol">{</a><a id="10955" href="1Lab.Path.html#10955" class="Bound">ℓ</a><a id="10956" class="Symbol">}</a> <a id="10958" class="Symbol">{</a><a id="10959" href="1Lab.Path.html#10959" class="Bound">A</a> <a id="10961" class="Symbol">:</a> <a id="10963" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="10968" href="1Lab.Path.html#10955" class="Bound">ℓ</a><a id="10969" class="Symbol">}</a> <a id="10971" class="Symbol">{</a><a id="10972" href="1Lab.Path.html#10972" class="Bound">x</a> <a id="10974" href="1Lab.Path.html#10974" class="Bound">y</a> <a id="10976" class="Symbol">:</a> <a id="10978" href="1Lab.Path.html#10959" class="Bound">A</a><a id="10979" class="Symbol">}</a> <a id="10981" class="Symbol">{</a><a id="10982" href="1Lab.Path.html#10982" class="Bound">p</a> <a id="10984" class="Symbol">:</a> <a id="10986" href="1Lab.Path.html#10972" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="10988" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10990" href="1Lab.Path.html#10974" class="Bound">y</a><a id="10991" class="Symbol">}</a> <a id="10993" class="Keyword">where</a>
  <a id="11001" class="Keyword">private</a>
    <a id="11013" href="1Lab.Path.html#11013" class="Function">sym-invol</a> <a id="11023" class="Symbol">:</a> <a data-type="x ≡ y → y ≡ x" id="11025" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="11029" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="11030" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="11034" href="1Lab.Path.html#10982" class="Bound">p</a><a id="11035" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="11037" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="11039" href="1Lab.Path.html#10982" class="Bound">p</a>
    <a id="11045" href="1Lab.Path.html#11013" class="Function">sym-invol</a> <a id="11055" href="1Lab.Path.html#11055" class="Bound">i</a> <a id="11057" class="Symbol">=</a> <a id="11059" href="1Lab.Path.html#10982" class="Bound">p</a>
</pre>
<h1 id="paths"><a href="#paths" class="header-link">Paths<span class="header-link-emoji">🔗</span></a></h1>
<p>While the basic structure of the path type is inherited from its nature as functions out of an internal De Morgan algebra, the structure of <em>identifications</em> presented by paths is more complicated. For starters, let’s see how paths correspond to identifications in that they witness the logical principle of “indiscernibility of identicals”.</p>
<h2 id="transport"><a href="#transport" class="header-link">Transport<span class="header-link-emoji">🔗</span></a></h2>
<p>A basic principle of identity is that <em>identicals are indiscernible</em>: if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x = y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> holds, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> also holds, for any choice of predicate <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>.</span> In type theory, this is generalised, as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> can be not only a predicate, but any type family.</p>
<p>The way this is incarnated is by an operation called <span class="Agda"><a data-type="A ≡ B₁ → A → B₁" href="1Lab.Path.html#11848" class="Function">transport</a></span>, which says that every path between <code>A</code> and <code>B</code> gives rise to a <em>function</em> <code>A → B</code>.</p>
<pre class="Agda"><a id="transport"></a><a data-type="A ≡ B₁ → A → B₁" id="11848" href="1Lab.Path.html#11848" class="Function">transport</a> <a id="11858" class="Symbol">:</a> <a id="11860" class="Symbol">∀</a> <a id="11862" class="Symbol">{</a><a id="11863" href="1Lab.Path.html#11863" class="Bound">ℓ</a><a id="11864" class="Symbol">}</a> <a id="11866" class="Symbol">{</a><a id="11867" href="1Lab.Path.html#11867" class="Bound">A</a> <a id="11869" href="1Lab.Path.html#11869" class="Bound">B</a> <a id="11871" class="Symbol">:</a> <a id="11873" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="11878" href="1Lab.Path.html#11863" class="Bound">ℓ</a><a id="11879" class="Symbol">}</a> <a id="11881" class="Symbol">→</a> <a id="11883" href="1Lab.Path.html#11867" class="Bound">A</a> <a data-type="A → A → Type ℓ" id="11885" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="11887" href="1Lab.Path.html#11869" class="Bound">B</a> <a id="11889" class="Symbol">→</a> <a id="11891" href="1Lab.Path.html#11867" class="Bound">A</a> <a id="11893" class="Symbol">→</a> <a id="11895" href="1Lab.Path.html#11869" class="Bound">B</a>
<a data-type="A ≡ B₁ → A → B₁" id="11897" href="1Lab.Path.html#11848" class="Function">transport</a> <a id="11907" href="1Lab.Path.html#11907" class="Bound">p</a> <a id="11909" class="Symbol">=</a> <a id="11911" href="1Lab.Path.html#2405" class="Primitive">transp</a> <a id="11918" class="Symbol">(λ</a> <a id="11921" href="1Lab.Path.html#11921" class="Bound">i</a> <a id="11923" class="Symbol">→</a> <a id="11925" href="1Lab.Path.html#11907" class="Bound">p</a> <a id="11927" href="1Lab.Path.html#11921" class="Bound">i</a><a id="11928" class="Symbol">)</a> <a id="11930" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a>
</pre>
<p>The transport operation is the earliest case of when thinking of <code>p : A ≡ B</code> as merely saying “A and B are equal” goes seriously wrong. A path gives a <em>specific</em> identification of <code>A</code> and <code>B</code>, which can be highly non-trivial.</p>
<p>As a concrete example, it can be shown that the type <code>Bool ≡ Bool</code> has exactly two inhabitants (<a href="Data.Bool.html#Bool-aut≡2">see here</a>), which is something like saying “the set of booleans is equal to itself in two ways”. That phrase is nonsensical, which is why “there are two paths Bool → Bool” is preferred: it’s not nonsense.</p>
<p>In Cubical Agda, <span class="Agda"><a data-type="A ≡ B₁ → A → B₁" href="1Lab.Path.html#11848" class="Function">transport</a></span> is a derived notion, with the actual primitive being <span class="Agda"><a href="1Lab.Path.html#2405" class="Primitive">transp</a></span>. Unlike <span class="Agda"><a data-type="A ≡ B₁ → A → B₁" href="1Lab.Path.html#11848" class="Function">transport</a></span>, which has two arguments (the path, and the point to transport), <code>transp</code> has <em>three</em>:</p>
<ul>
<li><p>The first argument to <span class="Agda"><a href="1Lab.Path.html#2405" class="Primitive">transp</a></span> is a <em>line</em> of types, i.e. a function <code>A : I → Type</code>, just as for <span class="Agda"><a data-type="A ≡ B₁ → A → B₁" href="1Lab.Path.html#11848" class="Function">transport</a></span>.</p></li>
<li><p>The second argument to <span class="Agda"><a href="1Lab.Path.html#2405" class="Primitive">transp</a></span> has type <span class="Agda"><a href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a></span>, but it’s not playing the role of an endpoint of the interval. It’s playing the role of a <em>formula</em>, which specifies <em>where the transport is constant</em>: In <code>transp P i1</code>, <code>P</code> is required to be constant, and the transport is the identity function:</p>
<pre class="Agda"><a id="13168" href="1Lab.Path.html#13168" class="Function">_</a> <a id="13170" class="Symbol">:</a> <a id="13172" class="Symbol">∀</a> <a id="13174" class="Symbol">{</a><a id="13175" href="1Lab.Path.html#13175" class="Bound">ℓ</a><a id="13176" class="Symbol">}</a> <a id="13178" class="Symbol">{</a><a id="13179" href="1Lab.Path.html#13179" class="Bound">A</a> <a id="13181" class="Symbol">:</a> <a id="13183" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="13188" href="1Lab.Path.html#13175" class="Bound">ℓ</a><a id="13189" class="Symbol">}</a> <a id="13191" class="Symbol">→</a> <a id="13193" href="1Lab.Path.html#2405" class="Primitive">transp</a> <a id="13200" class="Symbol">(λ</a> <a id="13203" href="1Lab.Path.html#13203" class="Bound">i</a> <a id="13205" class="Symbol">→</a> <a id="13207" href="1Lab.Path.html#13179" class="Bound">A</a><a id="13208" class="Symbol">)</a> <a id="13210" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a> <a data-type="A → A → Type ℓ" id="13213" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="A → A" id="13215" href="1Lab.Type.html#2424" class="Function">id</a>
<a id="13218" class="Symbol">_</a> <a id="13220" class="Symbol">=</a> <a data-type="x ≡ x" id="13222" href="1Lab.Path.html#3593" class="Function">refl</a>
</pre></li>
<li><p>The third argument is an inhabitant of <code>A i0</code>, as for <span class="Agda"><a data-type="A ≡ B₁ → A → B₁" href="1Lab.Path.html#11848" class="Function">transport</a></span>.</p></li>
</ul>
<p>This second argument, which lets us control where <span class="Agda"><a href="1Lab.Path.html#2405" class="Primitive">transp</a></span> is constant, brings a lot of power to the table! For example, the proof that transporting along <span class="Agda"><a data-type="x ≡ x" href="1Lab.Path.html#3593" class="Function">refl</a></span> is <code class="sourceCode agda">id</code> is as follows:</p>
<pre class="Agda"><a id="transport-refl"></a><a data-type="(x : A) → transport (λ i → A) x ≡ x" id="13526" href="1Lab.Path.html#13526" class="Function">transport-refl</a> <a id="13541" class="Symbol">:</a> <a id="13543" class="Symbol">∀</a> <a id="13545" class="Symbol">{</a><a id="13546" href="1Lab.Path.html#13546" class="Bound">ℓ</a><a id="13547" class="Symbol">}</a> <a id="13549" class="Symbol">{</a><a id="13550" href="1Lab.Path.html#13550" class="Bound">A</a> <a id="13552" class="Symbol">:</a> <a id="13554" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="13559" href="1Lab.Path.html#13546" class="Bound">ℓ</a><a id="13560" class="Symbol">}</a> <a id="13562" class="Symbol">(</a><a id="13563" href="1Lab.Path.html#13563" class="Bound">x</a> <a id="13565" class="Symbol">:</a> <a id="13567" href="1Lab.Path.html#13550" class="Bound">A</a><a id="13568" class="Symbol">)</a>
               <a id="13585" class="Symbol">→</a> <a data-type="A ≡ B₁ → A → B₁" id="13587" href="1Lab.Path.html#11848" class="Function">transport</a> <a id="13597" class="Symbol">(λ</a> <a id="13600" href="1Lab.Path.html#13600" class="Bound">i</a> <a id="13602" class="Symbol">→</a> <a id="13604" href="1Lab.Path.html#13550" class="Bound">A</a><a id="13605" class="Symbol">)</a> <a id="13607" href="1Lab.Path.html#13563" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="13609" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="13611" href="1Lab.Path.html#13563" class="Bound">x</a>
<a data-type="(x : A) → transport (λ i → A) x ≡ x" id="13613" href="1Lab.Path.html#13526" class="Function">transport-refl</a> <a id="13628" class="Symbol">{</a><a id="13629" class="Argument">A</a> <a id="13631" class="Symbol">=</a> <a id="13633" href="1Lab.Path.html#13633" class="Bound">A</a><a id="13634" class="Symbol">}</a> <a id="13636" href="1Lab.Path.html#13636" class="Bound">x</a> <a id="13638" href="1Lab.Path.html#13638" class="Bound">i</a> <a id="13640" class="Symbol">=</a> <a id="13642" href="1Lab.Path.html#2405" class="Primitive">transp</a> <a id="13649" class="Symbol">(λ</a> <a id="13652" href="1Lab.Path.html#13652" class="Bound">_</a> <a id="13654" class="Symbol">→</a> <a id="13656" href="1Lab.Path.html#13633" class="Bound">A</a><a id="13657" class="Symbol">)</a> <a id="13659" href="1Lab.Path.html#13638" class="Bound">i</a> <a id="13661" href="1Lab.Path.html#13636" class="Bound">x</a>
</pre>
<p>Since <code>λ i → A</code> is a constant function, the definition of <span class="Agda"><a data-type="(x : A) → transport (λ i → A) x ≡ x" href="1Lab.Path.html#13526" class="Function">transport-refl</a></span> is well-typed, and it has the stated endpoints because <span class="Agda"><a data-type="A ≡ B₁ → A → B₁" href="1Lab.Path.html#11848" class="Function">transport</a></span> is defined to be <code>transp P i0</code>, and <code>transp P i1</code> is the identity function.</p>
<p>In fact, this generalises to something called the <em>filler</em> of <span class="Agda"><a data-type="A ≡ B₁ → A → B₁" href="1Lab.Path.html#11848" class="Function">transport</a></span>: <code>transport p x</code> and <code>x</code> <em>are</em> identical, but they’re identical <em>over</em> the given path:</p>
<pre class="Agda"><a id="transport-filler"></a><a data-type="(p : A ≡ B₁) (x : A) → PathP (λ i → p i) x (transport p x)" id="14078" href="1Lab.Path.html#14078" class="Function">transport-filler</a> <a id="14095" class="Symbol">:</a> <a id="14097" class="Symbol">∀</a> <a id="14099" class="Symbol">{</a><a id="14100" href="1Lab.Path.html#14100" class="Bound">ℓ</a><a id="14101" class="Symbol">}</a> <a id="14103" class="Symbol">{</a><a id="14104" href="1Lab.Path.html#14104" class="Bound">A</a> <a id="14106" href="1Lab.Path.html#14106" class="Bound">B</a> <a id="14108" class="Symbol">:</a> <a id="14110" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="14115" href="1Lab.Path.html#14100" class="Bound">ℓ</a><a id="14116" class="Symbol">}</a>
                 <a id="14135" class="Symbol">→</a> <a id="14137" class="Symbol">(</a><a id="14138" href="1Lab.Path.html#14138" class="Bound">p</a> <a id="14140" class="Symbol">:</a> <a id="14142" href="1Lab.Path.html#14104" class="Bound">A</a> <a data-type="A → A → Type ℓ" id="14144" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="14146" href="1Lab.Path.html#14106" class="Bound">B</a><a id="14147" class="Symbol">)</a> <a id="14149" class="Symbol">(</a><a id="14150" href="1Lab.Path.html#14150" class="Bound">x</a> <a id="14152" class="Symbol">:</a> <a id="14154" href="1Lab.Path.html#14104" class="Bound">A</a><a id="14155" class="Symbol">)</a>
                 <a id="14174" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="14176" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="14182" class="Symbol">(λ</a> <a id="14185" href="1Lab.Path.html#14185" class="Bound">i</a> <a id="14187" class="Symbol">→</a> <a id="14189" href="1Lab.Path.html#14138" class="Bound">p</a> <a id="14191" href="1Lab.Path.html#14185" class="Bound">i</a><a id="14192" class="Symbol">)</a> <a id="14194" href="1Lab.Path.html#14150" class="Bound">x</a> <a id="14196" class="Symbol">(</a><a data-type="A ≡ B₁ → A → B₁" id="14197" href="1Lab.Path.html#11848" class="Function">transport</a> <a id="14207" href="1Lab.Path.html#14138" class="Bound">p</a> <a id="14209" href="1Lab.Path.html#14150" class="Bound">x</a><a id="14210" class="Symbol">)</a>
<a data-type="(p : A ≡ B₁) (x : A) → PathP (λ i → p i) x (transport p x)" id="14212" href="1Lab.Path.html#14078" class="Function">transport-filler</a> <a id="14229" href="1Lab.Path.html#14229" class="Bound">p</a> <a id="14231" href="1Lab.Path.html#14231" class="Bound">x</a> <a id="14233" href="1Lab.Path.html#14233" class="Bound">i</a> <a id="14235" class="Symbol">=</a> <a id="14237" href="1Lab.Path.html#2405" class="Primitive">transp</a> <a id="14244" class="Symbol">(λ</a> <a id="14247" href="1Lab.Path.html#14247" class="Bound">j</a> <a id="14249" class="Symbol">→</a> <a id="14251" href="1Lab.Path.html#14229" class="Bound">p</a> <a id="14253" class="Symbol">(</a><a id="14254" href="1Lab.Path.html#14233" class="Bound">i</a> <a id="14256" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="14258" href="1Lab.Path.html#14247" class="Bound">j</a><a id="14259" class="Symbol">))</a> <a id="14262" class="Symbol">(</a><a id="14263" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="14265" href="1Lab.Path.html#14233" class="Bound">i</a><a id="14266" class="Symbol">)</a> <a id="14268" href="1Lab.Path.html#14231" class="Bound">x</a>
</pre>
<details>
<summary>
We also have some special cases of <span class="Agda"><a data-type="(p : A ≡ B₁) (x : A) → PathP (λ i → p i) x (transport p x)" href="1Lab.Path.html#14078" class="Function">transport-filler</a></span> which are very convenient when working with iterated transports.
</summary>
<pre class="Agda"><a id="transport-filler-ext"></a><a data-type="(p : A ≡ B₁) → PathP (λ i → A → p i) (λ x → x) (transport p)" id="14441" href="1Lab.Path.html#14441" class="Function">transport-filler-ext</a> <a id="14462" class="Symbol">:</a> <a id="14464" class="Symbol">∀</a> <a id="14466" class="Symbol">{</a><a id="14467" href="1Lab.Path.html#14467" class="Bound">ℓ</a><a id="14468" class="Symbol">}</a> <a id="14470" class="Symbol">{</a><a id="14471" href="1Lab.Path.html#14471" class="Bound">A</a> <a id="14473" href="1Lab.Path.html#14473" class="Bound">B</a> <a id="14475" class="Symbol">:</a> <a id="14477" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="14482" href="1Lab.Path.html#14467" class="Bound">ℓ</a><a id="14483" class="Symbol">}</a> <a id="14485" class="Symbol">(</a><a id="14486" href="1Lab.Path.html#14486" class="Bound">p</a> <a id="14488" class="Symbol">:</a> <a id="14490" href="1Lab.Path.html#14471" class="Bound">A</a> <a data-type="A → A → Type ℓ" id="14492" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="14494" href="1Lab.Path.html#14473" class="Bound">B</a><a id="14495" class="Symbol">)</a>
                     <a id="14518" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="14520" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="14526" class="Symbol">(λ</a> <a id="14529" href="1Lab.Path.html#14529" class="Bound">i</a> <a id="14531" class="Symbol">→</a> <a id="14533" href="1Lab.Path.html#14471" class="Bound">A</a> <a id="14535" class="Symbol">→</a> <a id="14537" href="1Lab.Path.html#14486" class="Bound">p</a> <a id="14539" href="1Lab.Path.html#14529" class="Bound">i</a><a id="14540" class="Symbol">)</a> <a id="14542" class="Symbol">(λ</a> <a id="14545" href="1Lab.Path.html#14545" class="Bound">x</a> <a id="14547" class="Symbol">→</a> <a id="14549" href="1Lab.Path.html#14545" class="Bound">x</a><a id="14550" class="Symbol">)</a> <a id="14552" class="Symbol">(</a><a data-type="A ≡ B₁ → A → B₁" id="14553" href="1Lab.Path.html#11848" class="Function">transport</a> <a id="14563" href="1Lab.Path.html#14486" class="Bound">p</a><a id="14564" class="Symbol">)</a>
<a data-type="(p : A ≡ B₁) → PathP (λ i → A → p i) (λ x → x) (transport p)" id="14566" href="1Lab.Path.html#14441" class="Function">transport-filler-ext</a> <a id="14587" href="1Lab.Path.html#14587" class="Bound">p</a> <a id="14589" href="1Lab.Path.html#14589" class="Bound">i</a> <a id="14591" href="1Lab.Path.html#14591" class="Bound">x</a> <a id="14593" class="Symbol">=</a> <a data-type="(p : A ≡ B₁) (x : A) → PathP (λ i → p i) x (transport p x)" id="14595" href="1Lab.Path.html#14078" class="Function">transport-filler</a> <a id="14612" href="1Lab.Path.html#14587" class="Bound">p</a> <a id="14614" href="1Lab.Path.html#14591" class="Bound">x</a> <a id="14616" href="1Lab.Path.html#14589" class="Bound">i</a>

<a id="transport⁻-filler-ext"></a><a data-type="(p : A ≡ B₁) → PathP (λ i → p i → A) (λ x → x) (transport (sym p))" id="14619" href="1Lab.Path.html#14619" class="Function">transport⁻-filler-ext</a> <a id="14641" class="Symbol">:</a> <a id="14643" class="Symbol">∀</a> <a id="14645" class="Symbol">{</a><a id="14646" href="1Lab.Path.html#14646" class="Bound">ℓ</a><a id="14647" class="Symbol">}</a> <a id="14649" class="Symbol">{</a><a id="14650" href="1Lab.Path.html#14650" class="Bound">A</a> <a id="14652" href="1Lab.Path.html#14652" class="Bound">B</a> <a id="14654" class="Symbol">:</a> <a id="14656" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="14661" href="1Lab.Path.html#14646" class="Bound">ℓ</a><a id="14662" class="Symbol">}</a> <a id="14664" class="Symbol">(</a><a id="14665" href="1Lab.Path.html#14665" class="Bound">p</a> <a id="14667" class="Symbol">:</a> <a id="14669" href="1Lab.Path.html#14650" class="Bound">A</a> <a data-type="A → A → Type ℓ" id="14671" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="14673" href="1Lab.Path.html#14652" class="Bound">B</a><a id="14674" class="Symbol">)</a>
                     <a id="14697" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="14699" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="14705" class="Symbol">(λ</a> <a id="14708" href="1Lab.Path.html#14708" class="Bound">i</a> <a id="14710" class="Symbol">→</a> <a id="14712" href="1Lab.Path.html#14665" class="Bound">p</a> <a id="14714" href="1Lab.Path.html#14708" class="Bound">i</a> <a id="14716" class="Symbol">→</a> <a id="14718" href="1Lab.Path.html#14650" class="Bound">A</a><a id="14719" class="Symbol">)</a> <a id="14721" class="Symbol">(λ</a> <a id="14724" href="1Lab.Path.html#14724" class="Bound">x</a> <a id="14726" class="Symbol">→</a> <a id="14728" href="1Lab.Path.html#14724" class="Bound">x</a><a id="14729" class="Symbol">)</a> <a id="14731" class="Symbol">(</a><a data-type="A ≡ B₁ → A → B₁" id="14732" href="1Lab.Path.html#11848" class="Function">transport</a> <a id="14742" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="14743" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="14747" href="1Lab.Path.html#14665" class="Bound">p</a><a id="14748" class="Symbol">))</a>
<a data-type="(p : A ≡ B₁) → PathP (λ i → p i → A) (λ x → x) (transport (sym p))" id="14751" href="1Lab.Path.html#14619" class="Function">transport⁻-filler-ext</a> <a id="14773" href="1Lab.Path.html#14773" class="Bound">p</a> <a id="14775" href="1Lab.Path.html#14775" class="Bound">i</a> <a id="14777" href="1Lab.Path.html#14777" class="Bound">x</a> <a id="14779" class="Symbol">=</a> <a id="14781" href="1Lab.Path.html#2405" class="Primitive">transp</a> <a id="14788" class="Symbol">(λ</a> <a id="14791" href="1Lab.Path.html#14791" class="Bound">j</a> <a id="14793" class="Symbol">→</a> <a id="14795" href="1Lab.Path.html#14773" class="Bound">p</a> <a id="14797" class="Symbol">(</a><a id="14798" href="1Lab.Path.html#14775" class="Bound">i</a> <a id="14800" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="14802" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="14804" href="1Lab.Path.html#14791" class="Bound">j</a><a id="14805" class="Symbol">))</a> <a id="14808" class="Symbol">(</a><a id="14809" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="14811" href="1Lab.Path.html#14775" class="Bound">i</a><a id="14812" class="Symbol">)</a> <a id="14814" href="1Lab.Path.html#14777" class="Bound">x</a>

<a id="transport⁻transport"></a><a data-type="(p : A ≡ B₁) (a : A) → transport (sym p) (transport p a) ≡ a" id="14817" href="1Lab.Path.html#14817" class="Function">transport⁻transport</a> <a id="14837" class="Symbol">:</a> <a id="14839" class="Symbol">∀</a> <a id="14841" class="Symbol">{</a><a id="14842" href="1Lab.Path.html#14842" class="Bound">ℓ</a><a id="14843" class="Symbol">}</a> <a id="14845" class="Symbol">{</a><a id="14846" href="1Lab.Path.html#14846" class="Bound">A</a> <a id="14848" href="1Lab.Path.html#14848" class="Bound">B</a> <a id="14850" class="Symbol">:</a> <a id="14852" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="14857" href="1Lab.Path.html#14842" class="Bound">ℓ</a><a id="14858" class="Symbol">}</a> <a id="14860" class="Symbol">(</a><a id="14861" href="1Lab.Path.html#14861" class="Bound">p</a> <a id="14863" class="Symbol">:</a> <a id="14865" href="1Lab.Path.html#14846" class="Bound">A</a> <a data-type="A → A → Type ℓ" id="14867" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="14869" href="1Lab.Path.html#14848" class="Bound">B</a><a id="14870" class="Symbol">)</a> <a id="14872" class="Symbol">(</a><a id="14873" href="1Lab.Path.html#14873" class="Bound">a</a> <a id="14875" class="Symbol">:</a> <a id="14877" href="1Lab.Path.html#14846" class="Bound">A</a><a id="14878" class="Symbol">)</a>
                    <a id="14900" class="Symbol">→</a> <a data-type="A ≡ B₁ → A → B₁" id="14902" href="1Lab.Path.html#11848" class="Function">transport</a> <a id="14912" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="14913" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="14917" href="1Lab.Path.html#14861" class="Bound">p</a><a id="14918" class="Symbol">)</a> <a id="14920" class="Symbol">(</a><a data-type="A ≡ B₁ → A → B₁" id="14921" href="1Lab.Path.html#11848" class="Function">transport</a> <a id="14931" href="1Lab.Path.html#14861" class="Bound">p</a> <a id="14933" href="1Lab.Path.html#14873" class="Bound">a</a><a id="14934" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="14936" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="14938" href="1Lab.Path.html#14873" class="Bound">a</a>
<a data-type="(p : A ≡ B₁) (a : A) → transport (sym p) (transport p a) ≡ a" id="14940" href="1Lab.Path.html#14817" class="Function">transport⁻transport</a> <a id="14960" href="1Lab.Path.html#14960" class="Bound">p</a> <a id="14962" href="1Lab.Path.html#14962" class="Bound">a</a> <a id="14964" href="1Lab.Path.html#14964" class="Bound">i</a> <a id="14966" class="Symbol">=</a>
  <a data-type="(p : A ≡ B₁) → PathP (λ i → p i → A) (λ x → x) (transport (sym p))" id="14970" href="1Lab.Path.html#14619" class="Function">transport⁻-filler-ext</a> <a id="14992" href="1Lab.Path.html#14960" class="Bound">p</a> <a id="14994" class="Symbol">(</a><a id="14995" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="14997" href="1Lab.Path.html#14964" class="Bound">i</a><a id="14998" class="Symbol">)</a> <a id="15000" class="Symbol">(</a><a data-type="(p : A ≡ B₁) → PathP (λ i → A → p i) (λ x → x) (transport p)" id="15001" href="1Lab.Path.html#14441" class="Function">transport-filler-ext</a> <a id="15022" href="1Lab.Path.html#14960" class="Bound">p</a> <a id="15024" class="Symbol">(</a><a id="15025" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="15027" href="1Lab.Path.html#14964" class="Bound">i</a><a id="15028" class="Symbol">)</a> <a id="15030" href="1Lab.Path.html#14962" class="Bound">a</a><a id="15031" class="Symbol">)</a>
</pre>
</details>
<p>The path is constant when <code>i = i1</code> because <code>(λ j → p (i1 ∧ j))</code> is <code>(λ j → p i1)</code> (by the reduction rules for <code class="sourceCode agda"><span class="ot">_</span>∧<span class="ot">_</span></code>). It has the stated endpoints, again, because <code>transp P i1</code> is the identity function.</p>
<p>By altering a path <code>p</code> using a predicate <code>P</code>, we get the promised principle of <em>indiscernibility of identicals</em>:</p>
<pre class="Agda"><a id="subst"></a><a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="15381" href="1Lab.Path.html#15381" class="Function">subst</a> <a id="15387" class="Symbol">:</a> <a id="15389" class="Symbol">∀</a> <a id="15391" class="Symbol">{</a><a id="15392" href="1Lab.Path.html#15392" class="Bound">ℓ₁</a> <a id="15395" href="1Lab.Path.html#15395" class="Bound">ℓ₂</a><a id="15397" class="Symbol">}</a> <a id="15399" class="Symbol">{</a><a id="15400" href="1Lab.Path.html#15400" class="Bound">A</a> <a id="15402" class="Symbol">:</a> <a id="15404" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="15409" href="1Lab.Path.html#15392" class="Bound">ℓ₁</a><a id="15411" class="Symbol">}</a> <a id="15413" class="Symbol">(</a><a id="15414" href="1Lab.Path.html#15414" class="Bound">P</a> <a id="15416" class="Symbol">:</a> <a id="15418" href="1Lab.Path.html#15400" class="Bound">A</a> <a id="15420" class="Symbol">→</a> <a id="15422" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="15427" href="1Lab.Path.html#15395" class="Bound">ℓ₂</a><a id="15429" class="Symbol">)</a> <a id="15431" class="Symbol">{</a><a id="15432" href="1Lab.Path.html#15432" class="Bound">x</a> <a id="15434" href="1Lab.Path.html#15434" class="Bound">y</a> <a id="15436" class="Symbol">:</a> <a id="15438" href="1Lab.Path.html#15400" class="Bound">A</a><a id="15439" class="Symbol">}</a>
      <a id="15447" class="Symbol">→</a> <a id="15449" href="1Lab.Path.html#15432" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="15451" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="15453" href="1Lab.Path.html#15434" class="Bound">y</a> <a id="15455" class="Symbol">→</a> <a id="15457" href="1Lab.Path.html#15414" class="Bound">P</a> <a id="15459" href="1Lab.Path.html#15432" class="Bound">x</a> <a id="15461" class="Symbol">→</a> <a id="15463" href="1Lab.Path.html#15414" class="Bound">P</a> <a id="15465" href="1Lab.Path.html#15434" class="Bound">y</a>
<a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="15467" href="1Lab.Path.html#15381" class="Function">subst</a> <a id="15473" href="1Lab.Path.html#15473" class="Bound">P</a> <a id="15475" href="1Lab.Path.html#15475" class="Bound">p</a> <a id="15477" href="1Lab.Path.html#15477" class="Bound">x</a> <a id="15479" class="Symbol">=</a> <a id="15481" href="1Lab.Path.html#2405" class="Primitive">transp</a> <a id="15488" class="Symbol">(λ</a> <a id="15491" href="1Lab.Path.html#15491" class="Bound">i</a> <a id="15493" class="Symbol">→</a> <a id="15495" href="1Lab.Path.html#15473" class="Bound">P</a> <a id="15497" class="Symbol">(</a><a id="15498" href="1Lab.Path.html#15475" class="Bound">p</a> <a id="15500" href="1Lab.Path.html#15491" class="Bound">i</a><a id="15501" class="Symbol">))</a> <a id="15504" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a id="15507" href="1Lab.Path.html#15477" class="Bound">x</a>
</pre>
<h3 id="computation"><a href="#computation" class="header-link">Computation<span class="header-link-emoji">🔗</span></a></h3>
<p>In “Book HoTT”, <span class="Agda"><a data-type="A ≡ B₁ → A → B₁" href="1Lab.Path.html#11848" class="Function">transport</a></span> is defined using path induction, and it computes definitionally on <span class="Agda"><a data-type="x ≡ x" href="1Lab.Path.html#3593" class="Function">refl</a></span>. We have already seen that this is not definitional in cubical type theory, which might lead you to ask: When does <span class="Agda"><a data-type="A ≡ B₁ → A → B₁" href="1Lab.Path.html#11848" class="Function">transport</a></span> compute? The answer is: By cases on the path. The structure of the path <code>P</code> is what guides reduction of <span class="Agda"><a data-type="A ≡ B₁ → A → B₁" href="1Lab.Path.html#11848" class="Function">transport</a></span>. Here are some reductions:</p>
<p>For the natural numbers, and other inductive types without parameters, transport is always the identity function. This is justified because there’s nothing to vary in <span class="Agda"><a data-type="Type" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a></span>, so we can just ignore the transport:</p>
<pre class="Agda"><a id="16159" href="1Lab.Path.html#16159" class="Function">_</a> <a id="16161" class="Symbol">:</a> <a id="16163" class="Symbol">{</a><a id="16164" href="1Lab.Path.html#16164" class="Bound">x</a> <a id="16166" class="Symbol">:</a> <a data-type="Type" id="16168" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a><a id="16171" class="Symbol">}</a> <a id="16173" class="Symbol">→</a> <a data-type="A ≡ B₁ → A → B₁" id="16175" href="1Lab.Path.html#11848" class="Function">transport</a> <a id="16185" class="Symbol">(λ</a> <a id="16188" href="1Lab.Path.html#16188" class="Bound">i</a> <a id="16190" class="Symbol">→</a> <a data-type="Type" id="16192" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a><a id="16195" class="Symbol">)</a> <a id="16197" href="1Lab.Path.html#16164" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="16199" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="16201" href="1Lab.Path.html#16164" class="Bound">x</a>
<a id="16203" class="Symbol">_</a> <a id="16205" class="Symbol">=</a> <a data-type="x ≡ x" id="16207" href="1Lab.Path.html#3593" class="Function">refl</a>
</pre>
<p>For other type formers, the definition is a bit more involved. Let’s assume that we have two lines, <code>A</code> and <code>B</code>, to see how transport reduces in types built out of <code>A</code> and <code>B</code>:</p>
<pre class="Agda"><a id="16403" class="Keyword">module</a> <a id="16410" href="1Lab.Path.html#16410" class="Module">_</a> <a id="16412" class="Symbol">{</a><a id="16413" href="1Lab.Path.html#16413" class="Bound">A</a> <a id="16415" class="Symbol">:</a> <a id="16417" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="16419" class="Symbol">→</a> <a id="16421" href="1Lab.Type.html#391" class="Primitive">Type</a><a id="16425" class="Symbol">}</a> <a id="16427" class="Symbol">{</a><a id="16428" href="1Lab.Path.html#16428" class="Bound">B</a> <a id="16430" class="Symbol">:</a> <a id="16432" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="16434" class="Symbol">→</a> <a id="16436" href="1Lab.Type.html#391" class="Primitive">Type</a><a id="16440" class="Symbol">}</a> <a id="16442" class="Keyword">where</a> <a id="16448" class="Keyword">private</a>
</pre>
<p>For non-dependent products, the reduction rule says that “<span class="Agda"><a data-type="A ≡ B₁ → A → B₁" href="1Lab.Path.html#11848" class="Function">transport</a></span> is homomorphic over forming products”:</p>
<pre class="Agda">  <a id="16588" href="1Lab.Path.html#16588" class="Function">_</a> <a id="16590" class="Symbol">:</a> <a id="16592" class="Symbol">{</a><a id="16593" href="1Lab.Path.html#16593" class="Bound">x</a> <a id="16595" class="Symbol">:</a> <a id="16597" href="1Lab.Path.html#16413" class="Bound">A</a> <a id="16599" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="16601" class="Symbol">}</a> <a id="16603" class="Symbol">{</a><a id="16604" href="1Lab.Path.html#16604" class="Bound">y</a> <a id="16606" class="Symbol">:</a> <a id="16608" href="1Lab.Path.html#16428" class="Bound">B</a> <a id="16610" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="16612" class="Symbol">}</a>
    <a id="16618" class="Symbol">→</a> <a data-type="A ≡ B₁ → A → B₁" id="16620" href="1Lab.Path.html#11848" class="Function">transport</a> <a id="16630" class="Symbol">(λ</a> <a id="16633" href="1Lab.Path.html#16633" class="Bound">i</a> <a id="16635" class="Symbol">→</a> <a id="16637" href="1Lab.Path.html#16413" class="Bound">A</a> <a id="16639" href="1Lab.Path.html#16633" class="Bound">i</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="16641" href="1Lab.Type.html#1846" class="Function Operator">×</a> <a id="16643" href="1Lab.Path.html#16428" class="Bound">B</a> <a id="16645" href="1Lab.Path.html#16633" class="Bound">i</a><a id="16646" class="Symbol">)</a> <a id="16648" class="Symbol">(</a><a id="16649" href="1Lab.Path.html#16593" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="16651" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="16653" href="1Lab.Path.html#16604" class="Bound">y</a><a id="16654" class="Symbol">)</a>
    <a data-type="A → A → Type ℓ" id="16660" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="16662" class="Symbol">(</a><a data-type="A ≡ B₁ → A → B₁" id="16663" href="1Lab.Path.html#11848" class="Function">transport</a> <a id="16673" class="Symbol">(λ</a> <a id="16676" href="1Lab.Path.html#16676" class="Bound">i</a> <a id="16678" class="Symbol">→</a> <a id="16680" href="1Lab.Path.html#16413" class="Bound">A</a> <a id="16682" href="1Lab.Path.html#16676" class="Bound">i</a><a id="16683" class="Symbol">)</a> <a id="16685" href="1Lab.Path.html#16593" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="16687" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="A ≡ B₁ → A → B₁" id="16689" href="1Lab.Path.html#11848" class="Function">transport</a> <a id="16699" class="Symbol">(λ</a> <a id="16702" href="1Lab.Path.html#16702" class="Bound">i</a> <a id="16704" class="Symbol">→</a> <a id="16706" href="1Lab.Path.html#16428" class="Bound">B</a> <a id="16708" href="1Lab.Path.html#16702" class="Bound">i</a><a id="16709" class="Symbol">)</a> <a id="16711" href="1Lab.Path.html#16604" class="Bound">y</a><a id="16712" class="Symbol">)</a>
  <a id="16716" class="Symbol">_</a> <a id="16718" class="Symbol">=</a> <a data-type="x ≡ x" id="16720" href="1Lab.Path.html#3593" class="Function">refl</a>
</pre>
<p>For non-dependent functions, we have a similar situation, except one the transports is <em>backwards</em>. This is because, given an <code>f : A i0 → B i0</code>, we have to turn an <code>A i1</code> into an <code>A i0</code> to apply f!</p>
<pre class="Agda">  <a id="16939" href="1Lab.Path.html#16939" class="Function">_</a> <a id="16941" class="Symbol">:</a> <a id="16943" class="Symbol">{</a><a id="16944" href="1Lab.Path.html#16944" class="Bound">f</a> <a id="16946" class="Symbol">:</a> <a id="16948" href="1Lab.Path.html#16413" class="Bound">A</a> <a id="16950" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a id="16953" class="Symbol">→</a> <a id="16955" href="1Lab.Path.html#16428" class="Bound">B</a> <a id="16957" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="16959" class="Symbol">}</a>
    <a id="16965" class="Symbol">→</a> <a data-type="A ≡ B₁ → A → B₁" id="16967" href="1Lab.Path.html#11848" class="Function">transport</a> <a id="16977" class="Symbol">(λ</a> <a id="16980" href="1Lab.Path.html#16980" class="Bound">i</a> <a id="16982" class="Symbol">→</a> <a id="16984" href="1Lab.Path.html#16413" class="Bound">A</a> <a id="16986" href="1Lab.Path.html#16980" class="Bound">i</a> <a id="16988" class="Symbol">→</a> <a id="16990" href="1Lab.Path.html#16428" class="Bound">B</a> <a id="16992" href="1Lab.Path.html#16980" class="Bound">i</a><a id="16993" class="Symbol">)</a> <a id="16995" href="1Lab.Path.html#16944" class="Bound">f</a>
    <a data-type="A → A → Type ℓ" id="17001" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="17003" class="Symbol">λ</a> <a id="17005" href="1Lab.Path.html#17005" class="Bound">x</a> <a id="17007" class="Symbol">→</a> <a data-type="A ≡ B₁ → A → B₁" id="17009" href="1Lab.Path.html#11848" class="Function">transport</a> <a id="17019" class="Symbol">(λ</a> <a id="17022" href="1Lab.Path.html#17022" class="Bound">i</a> <a id="17024" class="Symbol">→</a> <a id="17026" href="1Lab.Path.html#16428" class="Bound">B</a> <a id="17028" href="1Lab.Path.html#17022" class="Bound">i</a><a id="17029" class="Symbol">)</a> <a id="17031" class="Symbol">(</a><a id="17032" href="1Lab.Path.html#16944" class="Bound">f</a> <a id="17034" class="Symbol">(</a><a data-type="A ≡ B₁ → A → B₁" id="17035" href="1Lab.Path.html#11848" class="Function">transport</a> <a id="17045" class="Symbol">(λ</a> <a id="17048" href="1Lab.Path.html#17048" class="Bound">i</a> <a id="17050" class="Symbol">→</a> <a id="17052" href="1Lab.Path.html#16413" class="Bound">A</a> <a id="17054" class="Symbol">(</a><a id="17055" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="17057" href="1Lab.Path.html#17048" class="Bound">i</a><a id="17058" class="Symbol">))</a> <a id="17061" href="1Lab.Path.html#17005" class="Bound">x</a><a id="17062" class="Symbol">))</a>
  <a id="17067" class="Symbol">_</a> <a id="17069" class="Symbol">=</a> <a data-type="x ≡ x" id="17071" href="1Lab.Path.html#3593" class="Function">refl</a>

<a id="17077" class="Keyword">module</a> <a id="17084" href="1Lab.Path.html#17084" class="Module">_</a> <a id="17086" class="Symbol">{</a><a id="17087" href="1Lab.Path.html#17087" class="Bound">A</a> <a id="17089" class="Symbol">:</a> <a id="17091" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="17093" class="Symbol">→</a> <a id="17095" href="1Lab.Type.html#391" class="Primitive">Type</a><a id="17099" class="Symbol">}</a> <a id="17101" class="Symbol">{</a><a id="17102" href="1Lab.Path.html#17102" class="Bound">B</a> <a id="17104" class="Symbol">:</a> <a id="17106" class="Symbol">(</a><a id="17107" href="1Lab.Path.html#17107" class="Bound">i</a> <a id="17109" class="Symbol">:</a> <a id="17111" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="17112" class="Symbol">)</a> <a id="17114" class="Symbol">→</a> <a id="17116" href="1Lab.Path.html#17087" class="Bound">A</a> <a id="17118" href="1Lab.Path.html#17107" class="Bound">i</a> <a id="17120" class="Symbol">→</a> <a id="17122" href="1Lab.Type.html#391" class="Primitive">Type</a><a id="17126" class="Symbol">}</a> <a id="17128" class="Keyword">where</a> <a id="17134" class="Keyword">private</a>
</pre>
<p>In the dependent cases, we have slightly more work to do. Suppose that we have a line <code>A : I → Type ℓ</code> and a <em>dependent</em> line <code>B : (i : I) → A i → Type ℓ</code>. Let’s characterise <span class="Agda"><a data-type="A ≡ B₁ → A → B₁" href="1Lab.Path.html#11848" class="Function">transport</a></span> in the lines <code>(λ i → (x : A i) → B i x)</code>. A first attempt would be to repeat the non-dependent construction: Given an <code>f : (x : A i0) → B i0 x</code> and an argument <code>x : A i1</code>, we first get <code>x&#39; : A i0</code> by transporting along <code>λ i → A (~ i)</code>, compute <code>f x&#39; : B i0 x</code>, then transport along <code>(λ i → B i x&#39;)</code> to g- Wait.</p>
<pre class="Agda">  <a id="17663" href="1Lab.Path.html#17663" class="Function">_</a> <a id="17665" class="Symbol">:</a> <a id="17667" class="Symbol">{</a><a id="17668" href="1Lab.Path.html#17668" class="Bound">f</a> <a id="17670" class="Symbol">:</a> <a id="17672" class="Symbol">(</a><a id="17673" href="1Lab.Path.html#17673" class="Bound">x</a> <a id="17675" class="Symbol">:</a> <a id="17677" href="1Lab.Path.html#17087" class="Bound">A</a> <a id="17679" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="17681" class="Symbol">)</a> <a id="17683" class="Symbol">→</a> <a id="17685" href="1Lab.Path.html#17102" class="Bound">B</a> <a id="17687" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a id="17690" href="1Lab.Path.html#17673" class="Bound">x</a><a id="17691" class="Symbol">}</a>
    <a id="17697" class="Symbol">→</a> <a data-type="A ≡ B₁ → A → B₁" id="17699" href="1Lab.Path.html#11848" class="Function">transport</a> <a id="17709" class="Symbol">(λ</a> <a id="17712" href="1Lab.Path.html#17712" class="Bound">i</a> <a id="17714" class="Symbol">→</a> <a id="17716" class="Symbol">(</a><a id="17717" href="1Lab.Path.html#17717" class="Bound">x</a> <a id="17719" class="Symbol">:</a> <a id="17721" href="1Lab.Path.html#17087" class="Bound">A</a> <a id="17723" href="1Lab.Path.html#17712" class="Bound">i</a><a id="17724" class="Symbol">)</a> <a id="17726" class="Symbol">→</a> <a id="17728" href="1Lab.Path.html#17102" class="Bound">B</a> <a id="17730" href="1Lab.Path.html#17712" class="Bound">i</a> <a id="17732" href="1Lab.Path.html#17717" class="Bound">x</a><a id="17733" class="Symbol">)</a> <a id="17735" href="1Lab.Path.html#17668" class="Bound">f</a>
    <a data-type="A → A → Type ℓ" id="17741" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="17743" class="Symbol">λ</a> <a id="17745" class="Symbol">(</a><a id="17746" href="1Lab.Path.html#17746" class="Bound">x</a> <a id="17748" class="Symbol">:</a> <a id="17750" href="1Lab.Path.html#17087" class="Bound">A</a> <a id="17752" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="17754" class="Symbol">)</a> <a id="17756" class="Symbol">→</a>
        <a id="17766" class="Keyword">let</a>
          <a id="17780" href="1Lab.Path.html#17780" class="Bound">x&#39;</a> <a id="17783" class="Symbol">:</a> <a id="17785" href="1Lab.Path.html#17087" class="Bound">A</a> <a id="17787" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a>
          <a id="17800" href="1Lab.Path.html#17780" class="Bound">x&#39;</a> <a id="17803" class="Symbol">=</a> <a data-type="A ≡ B₁ → A → B₁" id="17805" href="1Lab.Path.html#11848" class="Function">transport</a> <a id="17815" class="Symbol">(λ</a> <a id="17818" href="1Lab.Path.html#17818" class="Bound">i</a> <a id="17820" class="Symbol">→</a> <a id="17822" href="1Lab.Path.html#17087" class="Bound">A</a> <a id="17824" class="Symbol">(</a><a id="17825" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="17827" href="1Lab.Path.html#17818" class="Bound">i</a><a id="17828" class="Symbol">))</a> <a id="17831" href="1Lab.Path.html#17746" class="Bound">x</a>
</pre>
<p>We can’t “transport along <code>(λ i → B i x&#39;)</code>”, that’s not even a well-formed type! Indeed, <code>B i : A i → Type</code>, but <code>x&#39; : A i1</code>. What we need is some way of connecting our original <code>x</code> and <code>x&#39;</code>, so that we may get a <code>B i1 x&#39;</code>. This is where <span class="Agda"><a data-type="(p : A ≡ B₁) (x : A) → PathP (λ i → p i) x (transport p x)" href="1Lab.Path.html#14078" class="Function">transport-filler</a></span> comes in:</p>
<pre class="Agda">          <a id="18131" href="1Lab.Path.html#18131" class="Bound">x≡x&#39;</a> <a id="18136" class="Symbol">:</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="18138" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="18144" class="Symbol">(λ</a> <a id="18147" href="1Lab.Path.html#18147" class="Bound">i</a> <a id="18149" class="Symbol">→</a> <a id="18151" href="1Lab.Path.html#17087" class="Bound">A</a> <a id="18153" class="Symbol">(</a><a id="18154" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="18156" href="1Lab.Path.html#18147" class="Bound">i</a><a id="18157" class="Symbol">))</a> <a id="18160" href="1Lab.Path.html#17746" class="Bound">x</a> <a id="18162" href="1Lab.Path.html#17780" class="Bound">x&#39;</a>
          <a id="18175" href="1Lab.Path.html#18131" class="Bound">x≡x&#39;</a> <a id="18180" class="Symbol">=</a> <a data-type="(p : A ≡ B₁) (x : A) → PathP (λ i → p i) x (transport p x)" id="18182" href="1Lab.Path.html#14078" class="Function">transport-filler</a> <a id="18199" class="Symbol">(λ</a> <a id="18202" href="1Lab.Path.html#18202" class="Bound">i</a> <a id="18204" class="Symbol">→</a> <a id="18206" href="1Lab.Path.html#17087" class="Bound">A</a> <a id="18208" class="Symbol">(</a><a id="18209" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="18211" href="1Lab.Path.html#18202" class="Bound">i</a><a id="18212" class="Symbol">))</a> <a id="18215" href="1Lab.Path.html#17746" class="Bound">x</a>
</pre>
<p>By using <code>λ i → B i (x≡x&#39; (~ i))</code> as our path, we a) get something type-correct, and b) get something with the right endpoints. <code>(λ i → B i (x≡x&#39; (~ i)))</code> connects <code>B i0 x</code> and <code>B i1 x&#39;</code>, which is what we wanted.</p>
<pre class="Agda">          <a id="18454" href="1Lab.Path.html#18454" class="Bound">fx&#39;</a> <a id="18458" class="Symbol">:</a> <a id="18460" href="1Lab.Path.html#17102" class="Bound">B</a> <a id="18462" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a id="18465" href="1Lab.Path.html#17780" class="Bound">x&#39;</a>
          <a id="18478" href="1Lab.Path.html#18454" class="Bound">fx&#39;</a> <a id="18482" class="Symbol">=</a> <a id="18484" href="1Lab.Path.html#17668" class="Bound">f</a> <a id="18486" href="1Lab.Path.html#17780" class="Bound">x&#39;</a>
        <a id="18497" class="Keyword">in</a> <a data-type="A ≡ B₁ → A → B₁" id="18500" href="1Lab.Path.html#11848" class="Function">transport</a> <a id="18510" class="Symbol">(λ</a> <a id="18513" href="1Lab.Path.html#18513" class="Bound">i</a> <a id="18515" class="Symbol">→</a> <a id="18517" href="1Lab.Path.html#17102" class="Bound">B</a> <a id="18519" href="1Lab.Path.html#18513" class="Bound">i</a> <a id="18521" class="Symbol">(</a><a id="18522" href="1Lab.Path.html#18131" class="Bound">x≡x&#39;</a> <a id="18527" class="Symbol">(</a><a id="18528" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="18530" href="1Lab.Path.html#18513" class="Bound">i</a><a id="18531" class="Symbol">)))</a> <a id="18535" href="1Lab.Path.html#18454" class="Bound">fx&#39;</a>
  <a id="18541" class="Symbol">_</a> <a id="18543" class="Symbol">=</a> <a data-type="x ≡ x" id="18545" href="1Lab.Path.html#3593" class="Function">refl</a>
</pre>
<p>The case for dependent products (i.e. general <span class="Agda"><a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" href="1Lab.Type.html#1573" class="Function">Σ</a></span> types) is analogous, but without any inverse transports.</p>
<h2 id="path-induction"><a href="#path-induction" class="header-link">Path Induction<span class="header-link-emoji">🔗</span></a></h2>
<p>The path induction principle, also known as “axiom J”, essentially breaks down as the following two statements:</p>
<ul>
<li><p>Identicals are indiscernible (<span class="Agda"><a data-type="A ≡ B₁ → A → B₁" href="1Lab.Path.html#11848" class="Function">transport</a></span>)</p></li>
<li><p>Singletons are contractible. The type <code>Singleton A x</code> is the “subtype of A of the elements identical to x”:</p></li>
</ul>
<pre class="Agda"><a id="Singleton"></a><a data-type="A → Type ℓ" id="18974" href="1Lab.Path.html#18974" class="Function">Singleton</a> <a id="18984" class="Symbol">:</a> <a id="18986" class="Symbol">∀</a> <a id="18988" class="Symbol">{</a><a id="18989" href="1Lab.Path.html#18989" class="Bound">ℓ</a><a id="18990" class="Symbol">}</a> <a id="18992" class="Symbol">{</a><a id="18993" href="1Lab.Path.html#18993" class="Bound">A</a> <a id="18995" class="Symbol">:</a> <a id="18997" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="19002" href="1Lab.Path.html#18989" class="Bound">ℓ</a><a id="19003" class="Symbol">}</a> <a id="19005" class="Symbol">→</a> <a id="19007" href="1Lab.Path.html#18993" class="Bound">A</a> <a id="19009" class="Symbol">→</a> <a id="19011" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="19016" class="Symbol">_</a>
<a data-type="A → Type ℓ" id="19018" href="1Lab.Path.html#18974" class="Function">Singleton</a> <a id="19028" href="1Lab.Path.html#19028" class="Bound">x</a> <a id="19030" class="Symbol">=</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="19032" href="1Lab.Type.html#1573" class="Function">Σ[</a> <a id="19035" href="1Lab.Path.html#19035" class="Bound">y</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="19037" href="1Lab.Type.html#1573" class="Function">∈</a> <a id="19039" class="Symbol">_</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="19041" href="1Lab.Type.html#1573" class="Function">]</a> <a id="19043" class="Symbol">(</a><a id="19044" href="1Lab.Path.html#19028" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="19046" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="19048" href="1Lab.Path.html#19035" class="Bound">y</a><a id="19049" class="Symbol">)</a>
</pre>
<p>There is a canonical inhabitant of <code>Singleton x</code>, namely <code>(x, refl)</code>. To say that <code class="sourceCode agda" data-ident="singleton">singletons</code> are contractible is to say that every other inhabitant has a path to <code>(x, refl)</code>:</p>
<pre class="Agda"><a id="Singleton-is-contr"></a><a data-type="(y : Singleton x) → Path (Singleton x) (x , refl) y" id="19265" href="1Lab.Path.html#19265" class="Function">Singleton-is-contr</a> <a id="19284" class="Symbol">:</a> <a id="19286" class="Symbol">∀</a> <a id="19288" class="Symbol">{</a><a id="19289" href="1Lab.Path.html#19289" class="Bound">ℓ</a><a id="19290" class="Symbol">}</a> <a id="19292" class="Symbol">{</a><a id="19293" href="1Lab.Path.html#19293" class="Bound">A</a> <a id="19295" class="Symbol">:</a> <a id="19297" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="19302" href="1Lab.Path.html#19289" class="Bound">ℓ</a><a id="19303" class="Symbol">}</a> <a id="19305" class="Symbol">{</a><a id="19306" href="1Lab.Path.html#19306" class="Bound">x</a> <a id="19308" class="Symbol">:</a> <a id="19310" href="1Lab.Path.html#19293" class="Bound">A</a><a id="19311" class="Symbol">}</a> <a id="19313" class="Symbol">(</a><a id="19314" href="1Lab.Path.html#19314" class="Bound">y</a> <a id="19316" class="Symbol">:</a> <a data-type="A → Type ℓ" id="19318" href="1Lab.Path.html#18974" class="Function">Singleton</a> <a id="19328" href="1Lab.Path.html#19306" class="Bound">x</a><a id="19329" class="Symbol">)</a>
                   <a id="19350" class="Symbol">→</a> <a data-type="(A : Type ℓ) → A → A → Type ℓ" id="19352" href="1Lab.Path.html#2466" class="Function">Path</a> <a id="19357" class="Symbol">(</a><a data-type="A → Type ℓ" id="19358" href="1Lab.Path.html#18974" class="Function">Singleton</a> <a id="19368" href="1Lab.Path.html#19306" class="Bound">x</a><a id="19369" class="Symbol">)</a> <a id="19371" class="Symbol">(</a><a id="19372" href="1Lab.Path.html#19306" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="19374" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="x ≡ x" id="19376" href="1Lab.Path.html#3593" class="Function">refl</a><a id="19380" class="Symbol">)</a> <a id="19382" href="1Lab.Path.html#19314" class="Bound">y</a>
<a data-type="(y : Singleton x) → Path (Singleton x) (x , refl) y" id="19384" href="1Lab.Path.html#19265" class="Function">Singleton-is-contr</a> <a id="19403" class="Symbol">{</a><a id="19404" class="Argument">x</a> <a id="19406" class="Symbol">=</a> <a id="19408" href="1Lab.Path.html#19408" class="Bound">x</a><a id="19409" class="Symbol">}</a> <a id="19411" class="Symbol">(</a><a id="19412" href="1Lab.Path.html#19412" class="Bound">y</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="19414" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="19416" href="1Lab.Path.html#19416" class="Bound">path</a><a id="19420" class="Symbol">)</a> <a id="19422" href="1Lab.Path.html#19422" class="Bound">i</a> <a id="19424" class="Symbol">=</a> <a id="19426" href="1Lab.Path.html#19416" class="Bound">path</a> <a id="19431" href="1Lab.Path.html#19422" class="Bound">i</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="19433" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="19435" href="1Lab.Path.html#19452" class="Function">square</a> <a id="19442" href="1Lab.Path.html#19422" class="Bound">i</a> <a id="19444" class="Keyword">where</a>
  <a id="19452" href="1Lab.Path.html#19452" class="Function">square</a> <a id="19459" class="Symbol">:</a> <a data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" id="19461" href="1Lab.Path.html#9481" class="Function">Square</a> <a data-type="x ≡ x" id="19468" href="1Lab.Path.html#3593" class="Function">refl</a> <a data-type="x ≡ x" id="19473" href="1Lab.Path.html#3593" class="Function">refl</a> <a id="19478" href="1Lab.Path.html#19416" class="Bound">path</a> <a id="19483" href="1Lab.Path.html#19416" class="Bound">path</a>
  <a id="19490" href="1Lab.Path.html#19452" class="Function">square</a> <a id="19497" href="1Lab.Path.html#19497" class="Bound">i</a> <a id="19499" href="1Lab.Path.html#19499" class="Bound">j</a> <a id="19501" class="Symbol">=</a> <a id="19503" href="1Lab.Path.html#19416" class="Bound">path</a> <a id="19508" class="Symbol">(</a><a id="19509" href="1Lab.Path.html#19497" class="Bound">i</a> <a id="19511" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="19513" href="1Lab.Path.html#19499" class="Bound">j</a><a id="19514" class="Symbol">)</a>
</pre>
<p>Thus, the definition of <span class="Agda"><a data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" href="1Lab.Path.html#19616" class="Function">J</a></span>: <span class="Agda"><a data-type="A ≡ B₁ → A → B₁" href="1Lab.Path.html#11848" class="Function">transport</a></span> + <span class="Agda"><a data-type="(y : Singleton x) → Path (Singleton x) (x , refl) y" href="1Lab.Path.html#19265" class="Function">Singleton-is-contr</a></span>.</p>
<pre class="Agda"><a id="J"></a><a data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" id="19616" href="1Lab.Path.html#19616" class="Function">J</a> <a id="19618" class="Symbol">:</a> <a id="19620" class="Symbol">∀</a> <a id="19622" class="Symbol">{</a><a id="19623" href="1Lab.Path.html#19623" class="Bound">ℓ₁</a> <a id="19626" href="1Lab.Path.html#19626" class="Bound">ℓ₂</a><a id="19628" class="Symbol">}</a> <a id="19630" class="Symbol">{</a><a id="19631" href="1Lab.Path.html#19631" class="Bound">A</a> <a id="19633" class="Symbol">:</a> <a id="19635" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="19640" href="1Lab.Path.html#19623" class="Bound">ℓ₁</a><a id="19642" class="Symbol">}</a> <a id="19644" class="Symbol">{</a><a id="19645" href="1Lab.Path.html#19645" class="Bound">x</a> <a id="19647" class="Symbol">:</a> <a id="19649" href="1Lab.Path.html#19631" class="Bound">A</a><a id="19650" class="Symbol">}</a>
    <a id="19656" class="Symbol">(</a><a id="19657" href="1Lab.Path.html#19657" class="Bound">P</a> <a id="19659" class="Symbol">:</a> <a id="19661" class="Symbol">(</a><a id="19662" href="1Lab.Path.html#19662" class="Bound">y</a> <a id="19664" class="Symbol">:</a> <a id="19666" href="1Lab.Path.html#19631" class="Bound">A</a><a id="19667" class="Symbol">)</a> <a id="19669" class="Symbol">→</a> <a id="19671" href="1Lab.Path.html#19645" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="19673" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="19675" href="1Lab.Path.html#19662" class="Bound">y</a> <a id="19677" class="Symbol">→</a> <a id="19679" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="19684" href="1Lab.Path.html#19626" class="Bound">ℓ₂</a><a id="19686" class="Symbol">)</a>
  <a id="19690" class="Symbol">→</a> <a id="19692" href="1Lab.Path.html#19657" class="Bound">P</a> <a id="19694" href="1Lab.Path.html#19645" class="Bound">x</a> <a data-type="x ≡ x" id="19696" href="1Lab.Path.html#3593" class="Function">refl</a>
  <a id="19703" class="Symbol">→</a> <a id="19705" class="Symbol">{</a><a id="19706" href="1Lab.Path.html#19706" class="Bound">y</a> <a id="19708" class="Symbol">:</a> <a id="19710" href="1Lab.Path.html#19631" class="Bound">A</a><a id="19711" class="Symbol">}</a> <a id="19713" class="Symbol">(</a><a id="19714" href="1Lab.Path.html#19714" class="Bound">p</a> <a id="19716" class="Symbol">:</a> <a id="19718" href="1Lab.Path.html#19645" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="19720" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="19722" href="1Lab.Path.html#19706" class="Bound">y</a><a id="19723" class="Symbol">)</a>
  <a id="19727" class="Symbol">→</a> <a id="19729" href="1Lab.Path.html#19657" class="Bound">P</a> <a id="19731" href="1Lab.Path.html#19706" class="Bound">y</a> <a id="19733" href="1Lab.Path.html#19714" class="Bound">p</a>
<a data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" id="19735" href="1Lab.Path.html#19616" class="Function">J</a> <a id="19737" class="Symbol">{</a><a id="19738" class="Argument">x</a> <a id="19740" class="Symbol">=</a> <a id="19742" href="1Lab.Path.html#19742" class="Bound">x</a><a id="19743" class="Symbol">}</a> <a id="19745" href="1Lab.Path.html#19745" class="Bound">P</a> <a id="19747" href="1Lab.Path.html#19747" class="Bound">prefl</a> <a id="19753" class="Symbol">{</a><a id="19754" href="1Lab.Path.html#19754" class="Bound">y</a><a id="19755" class="Symbol">}</a> <a id="19757" href="1Lab.Path.html#19757" class="Bound">p</a> <a id="19759" class="Symbol">=</a> <a data-type="A ≡ B₁ → A → B₁" id="19761" href="1Lab.Path.html#11848" class="Function">transport</a> <a id="19771" class="Symbol">(λ</a> <a id="19774" href="1Lab.Path.html#19774" class="Bound">i</a> <a id="19776" class="Symbol">→</a> <a id="19778" href="1Lab.Path.html#19745" class="Bound">P</a> <a id="19780" class="Symbol">(</a><a id="19781" href="1Lab.Path.html#19823" class="Function">path</a> <a id="19786" href="1Lab.Path.html#19774" class="Bound">i</a> <a id="19788" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="19789" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="19792" class="Symbol">)</a> <a id="19794" class="Symbol">(</a><a id="19795" href="1Lab.Path.html#19823" class="Function">path</a> <a id="19800" href="1Lab.Path.html#19774" class="Bound">i</a> <a id="19802" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="19803" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="19806" class="Symbol">))</a> <a id="19809" href="1Lab.Path.html#19747" class="Bound">prefl</a> <a id="19815" class="Keyword">where</a>
  <a id="19823" href="1Lab.Path.html#19823" class="Function">path</a> <a id="19828" class="Symbol">:</a> <a id="19830" class="Symbol">(</a><a id="19831" href="1Lab.Path.html#19742" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="19833" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="x ≡ x" id="19835" href="1Lab.Path.html#3593" class="Function">refl</a><a id="19839" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="19841" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="19843" class="Symbol">(</a><a id="19844" href="1Lab.Path.html#19754" class="Bound">y</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="19846" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="19848" href="1Lab.Path.html#19757" class="Bound">p</a><a id="19849" class="Symbol">)</a>
  <a id="19853" href="1Lab.Path.html#19823" class="Function">path</a> <a id="19858" class="Symbol">=</a> <a data-type="(y : Singleton x) → Path (Singleton x) (x , refl) y" id="19860" href="1Lab.Path.html#19265" class="Function">Singleton-is-contr</a> <a id="19879" class="Symbol">(</a><a id="19880" href="1Lab.Path.html#19754" class="Bound">y</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="19882" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="19884" href="1Lab.Path.html#19757" class="Bound">p</a><a id="19885" class="Symbol">)</a>
</pre>
<p>This eliminator <em>doesn’t</em> definitionally compute to <code>prefl</code> when <code>p</code> is <code>refl</code>, again since <code>transport (λ i → A)</code> isn’t definitionally the identity. However, since it <em>is</em> a transport, we can use the <span class="Agda"><a data-type="(p : A ≡ B₁) (x : A) → PathP (λ i → p i) x (transport p x)" href="1Lab.Path.html#14078" class="Function">transport-filler</a></span> to get a path expressing the computation rule.</p>
<pre class="Agda"><a id="J-refl"></a><a data-type="(P : (y : A) → x ≡ y → Type ℓ₂) (pxr : P x refl) →
J P pxr refl ≡ pxr" id="20175" href="1Lab.Path.html#20175" class="Function">J-refl</a> <a id="20182" class="Symbol">:</a> <a id="20184" class="Symbol">∀</a> <a id="20186" class="Symbol">{</a><a id="20187" href="1Lab.Path.html#20187" class="Bound">ℓ₁</a> <a id="20190" href="1Lab.Path.html#20190" class="Bound">ℓ₂</a><a id="20192" class="Symbol">}</a> <a id="20194" class="Symbol">{</a><a id="20195" href="1Lab.Path.html#20195" class="Bound">A</a> <a id="20197" class="Symbol">:</a> <a id="20199" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20204" href="1Lab.Path.html#20187" class="Bound">ℓ₁</a><a id="20206" class="Symbol">}</a> <a id="20208" class="Symbol">{</a><a id="20209" href="1Lab.Path.html#20209" class="Bound">x</a> <a id="20211" class="Symbol">:</a> <a id="20213" href="1Lab.Path.html#20195" class="Bound">A</a><a id="20214" class="Symbol">}</a>
           <a id="20227" class="Symbol">(</a><a id="20228" href="1Lab.Path.html#20228" class="Bound">P</a> <a id="20230" class="Symbol">:</a> <a id="20232" class="Symbol">(</a><a id="20233" href="1Lab.Path.html#20233" class="Bound">y</a> <a id="20235" class="Symbol">:</a> <a id="20237" href="1Lab.Path.html#20195" class="Bound">A</a><a id="20238" class="Symbol">)</a> <a id="20240" class="Symbol">→</a> <a id="20242" href="1Lab.Path.html#20209" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="20244" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="20246" href="1Lab.Path.html#20233" class="Bound">y</a> <a id="20248" class="Symbol">→</a> <a id="20250" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20255" href="1Lab.Path.html#20190" class="Bound">ℓ₂</a><a id="20257" class="Symbol">)</a>
       <a id="20266" class="Symbol">→</a> <a id="20268" class="Symbol">(</a><a id="20269" href="1Lab.Path.html#20269" class="Bound">pxr</a> <a id="20273" class="Symbol">:</a> <a id="20275" href="1Lab.Path.html#20228" class="Bound">P</a> <a id="20277" href="1Lab.Path.html#20209" class="Bound">x</a> <a data-type="x ≡ x" id="20279" href="1Lab.Path.html#3593" class="Function">refl</a><a id="20283" class="Symbol">)</a>
       <a id="20292" class="Symbol">→</a> <a data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" id="20294" href="1Lab.Path.html#19616" class="Function">J</a> <a id="20296" href="1Lab.Path.html#20228" class="Bound">P</a> <a id="20298" href="1Lab.Path.html#20269" class="Bound">pxr</a> <a data-type="x ≡ x" id="20302" href="1Lab.Path.html#3593" class="Function">refl</a> <a data-type="A → A → Type ℓ" id="20307" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="20309" href="1Lab.Path.html#20269" class="Bound">pxr</a>
<a data-type="(P : (y : A) → x ≡ y → Type ℓ₂) (pxr : P x refl) →
J P pxr refl ≡ pxr" id="20313" href="1Lab.Path.html#20175" class="Function">J-refl</a> <a id="20320" class="Symbol">{</a><a id="20321" class="Argument">x</a> <a id="20323" class="Symbol">=</a> <a id="20325" href="1Lab.Path.html#20325" class="Bound">x</a><a id="20326" class="Symbol">}</a> <a id="20328" href="1Lab.Path.html#20328" class="Bound">P</a> <a id="20330" href="1Lab.Path.html#20330" class="Bound">prefl</a> <a id="20336" href="1Lab.Path.html#20336" class="Bound">i</a> <a id="20338" class="Symbol">=</a> <a data-type="(p : A ≡ B₁) (x : A) → PathP (λ i → p i) x (transport p x)" id="20340" href="1Lab.Path.html#14078" class="Function">transport-filler</a> <a id="20357" class="Symbol">(λ</a> <a id="20360" href="1Lab.Path.html#20360" class="Bound">i</a> <a id="20362" class="Symbol">→</a> <a id="20364" href="1Lab.Path.html#20328" class="Bound">P</a> <a id="20366" class="Symbol">_</a> <a id="20368" class="Symbol">(λ</a> <a id="20371" href="1Lab.Path.html#20371" class="Bound">j</a> <a id="20373" class="Symbol">→</a> <a id="20375" href="1Lab.Path.html#20325" class="Bound">x</a><a id="20376" class="Symbol">))</a> <a id="20379" href="1Lab.Path.html#20330" class="Bound">prefl</a> <a id="20385" class="Symbol">(</a><a id="20386" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="20388" href="1Lab.Path.html#20336" class="Bound">i</a><a id="20389" class="Symbol">)</a>
</pre>
<!--
<pre class="Agda"><a id="inspect"></a><a id="20409" href="1Lab.Path.html#20409" class="Function">inspect</a> <a id="20417" class="Symbol">:</a> <a id="20419" class="Symbol">∀</a> <a id="20421" class="Symbol">{</a><a id="20422" href="1Lab.Path.html#20422" class="Bound">a</a><a id="20423" class="Symbol">}</a> <a id="20425" class="Symbol">{</a><a id="20426" href="1Lab.Path.html#20426" class="Bound">A</a> <a id="20428" class="Symbol">:</a> <a id="20430" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20435" href="1Lab.Path.html#20422" class="Bound">a</a><a id="20436" class="Symbol">}</a> <a id="20438" class="Symbol">(</a><a id="20439" href="1Lab.Path.html#20439" class="Bound">x</a> <a id="20441" class="Symbol">:</a> <a id="20443" href="1Lab.Path.html#20426" class="Bound">A</a><a id="20444" class="Symbol">)</a> <a id="20446" class="Symbol">→</a> <a id="20448" href="1Lab.Path.html#18974" class="Function">Singleton</a> <a id="20458" href="1Lab.Path.html#20439" class="Bound">x</a>
<a id="20460" href="1Lab.Path.html#20409" class="Function">inspect</a> <a id="20468" href="1Lab.Path.html#20468" class="Bound">x</a> <a id="20470" class="Symbol">=</a> <a id="20472" href="1Lab.Path.html#20468" class="Bound">x</a> <a id="20474" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="20476" href="1Lab.Path.html#3593" class="Function">refl</a>
</pre>-->
<h2 id="functorial-action"><a href="#functorial-action" class="header-link">Functorial Action<span class="header-link-emoji">🔗</span></a></h2>
<p>In HoTT, every function behaves like a funct<strong>or</strong>, in that it has an action on objects (the actual computational content of the function) and an action on <em>morphisms</em> — how that function acts on paths. Reading paths as identity, this is a proof that functions take identical inputs to identical outputs.</p>
<pre class="Agda"><a id="ap"></a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="20828" href="1Lab.Path.html#20828" class="Function">ap</a> <a id="20831" class="Symbol">:</a> <a id="20833" class="Symbol">∀</a> <a id="20835" class="Symbol">{</a><a id="20836" href="1Lab.Path.html#20836" class="Bound">a</a> <a id="20838" href="1Lab.Path.html#20838" class="Bound">b</a><a id="20839" class="Symbol">}</a> <a id="20841" class="Symbol">{</a><a id="20842" href="1Lab.Path.html#20842" class="Bound">A</a> <a id="20844" class="Symbol">:</a> <a id="20846" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20851" href="1Lab.Path.html#20836" class="Bound">a</a><a id="20852" class="Symbol">}</a> <a id="20854" class="Symbol">{</a><a id="20855" href="1Lab.Path.html#20855" class="Bound">B</a> <a id="20857" class="Symbol">:</a> <a id="20859" href="1Lab.Path.html#20842" class="Bound">A</a> <a id="20861" class="Symbol">→</a> <a id="20863" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20868" href="1Lab.Path.html#20838" class="Bound">b</a><a id="20869" class="Symbol">}</a> <a id="20871" class="Symbol">(</a><a id="20872" href="1Lab.Path.html#20872" class="Bound">f</a> <a id="20874" class="Symbol">:</a> <a id="20876" class="Symbol">(</a><a id="20877" href="1Lab.Path.html#20877" class="Bound">x</a> <a id="20879" class="Symbol">:</a> <a id="20881" href="1Lab.Path.html#20842" class="Bound">A</a><a id="20882" class="Symbol">)</a> <a id="20884" class="Symbol">→</a> <a id="20886" href="1Lab.Path.html#20855" class="Bound">B</a> <a id="20888" href="1Lab.Path.html#20877" class="Bound">x</a><a id="20889" class="Symbol">)</a> <a id="20891" class="Symbol">{</a><a id="20892" href="1Lab.Path.html#20892" class="Bound">x</a> <a id="20894" href="1Lab.Path.html#20894" class="Bound">y</a> <a id="20896" class="Symbol">:</a> <a id="20898" href="1Lab.Path.html#20842" class="Bound">A</a><a id="20899" class="Symbol">}</a>
   <a id="20904" class="Symbol">→</a> <a id="20906" class="Symbol">(</a><a id="20907" href="1Lab.Path.html#20907" class="Bound">p</a> <a id="20909" class="Symbol">:</a> <a id="20911" href="1Lab.Path.html#20892" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="20913" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="20915" href="1Lab.Path.html#20894" class="Bound">y</a><a id="20916" class="Symbol">)</a> <a id="20918" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="20920" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="20926" class="Symbol">(λ</a> <a id="20929" href="1Lab.Path.html#20929" class="Bound">i</a> <a id="20931" class="Symbol">→</a> <a id="20933" href="1Lab.Path.html#20855" class="Bound">B</a> <a id="20935" class="Symbol">(</a><a id="20936" href="1Lab.Path.html#20907" class="Bound">p</a> <a id="20938" href="1Lab.Path.html#20929" class="Bound">i</a><a id="20939" class="Symbol">))</a> <a id="20942" class="Symbol">(</a><a id="20943" href="1Lab.Path.html#20872" class="Bound">f</a> <a id="20945" href="1Lab.Path.html#20892" class="Bound">x</a><a id="20946" class="Symbol">)</a> <a id="20948" class="Symbol">(</a><a id="20949" href="1Lab.Path.html#20872" class="Bound">f</a> <a id="20951" href="1Lab.Path.html#20894" class="Bound">y</a><a id="20952" class="Symbol">)</a>
<a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="20954" href="1Lab.Path.html#20828" class="Function">ap</a> <a id="20957" href="1Lab.Path.html#20957" class="Bound">f</a> <a id="20959" href="1Lab.Path.html#20959" class="Bound">p</a> <a id="20961" href="1Lab.Path.html#20961" class="Bound">i</a> <a id="20963" class="Symbol">=</a> <a id="20965" href="1Lab.Path.html#20957" class="Bound">f</a> <a id="20967" class="Symbol">(</a><a id="20968" href="1Lab.Path.html#20959" class="Bound">p</a> <a id="20970" href="1Lab.Path.html#20961" class="Bound">i</a><a id="20971" class="Symbol">)</a>
</pre>
<p>The following function expresses the same thing as <span class="Agda"><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" href="1Lab.Path.html#20828" class="Function">ap</a></span>, but for binary functions. The type is huge! That’s because it applies to the most general type of 2-argument dependent function possible: <code>(x : A) (y : B x) → C x y</code>. Even then, the proof is beautifully short:</p>
<pre class="Agda"><a id="ap₂"></a><a data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" id="21261" href="1Lab.Path.html#21261" class="Function">ap₂</a> <a id="21265" class="Symbol">:</a> <a id="21267" class="Symbol">∀</a> <a id="21269" class="Symbol">{</a><a id="21270" href="1Lab.Path.html#21270" class="Bound">a</a> <a id="21272" href="1Lab.Path.html#21272" class="Bound">b</a> <a id="21274" href="1Lab.Path.html#21274" class="Bound">c</a><a id="21275" class="Symbol">}</a> <a id="21277" class="Symbol">{</a><a id="21278" href="1Lab.Path.html#21278" class="Bound">A</a> <a id="21280" class="Symbol">:</a> <a id="21282" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="21287" href="1Lab.Path.html#21270" class="Bound">a</a><a id="21288" class="Symbol">}</a> <a id="21290" class="Symbol">{</a><a id="21291" href="1Lab.Path.html#21291" class="Bound">B</a> <a id="21293" class="Symbol">:</a> <a id="21295" href="1Lab.Path.html#21278" class="Bound">A</a> <a id="21297" class="Symbol">→</a> <a id="21299" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="21304" href="1Lab.Path.html#21272" class="Bound">b</a><a id="21305" class="Symbol">}</a> <a id="21307" class="Symbol">{</a><a id="21308" href="1Lab.Path.html#21308" class="Bound">C</a> <a id="21310" class="Symbol">:</a> <a id="21312" class="Symbol">(</a><a id="21313" href="1Lab.Path.html#21313" class="Bound">x</a> <a id="21315" class="Symbol">:</a> <a id="21317" href="1Lab.Path.html#21278" class="Bound">A</a><a id="21318" class="Symbol">)</a> <a id="21320" class="Symbol">→</a> <a id="21322" href="1Lab.Path.html#21291" class="Bound">B</a> <a id="21324" href="1Lab.Path.html#21313" class="Bound">x</a> <a id="21326" class="Symbol">→</a> <a id="21328" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="21333" href="1Lab.Path.html#21274" class="Bound">c</a><a id="21334" class="Symbol">}</a>
      <a id="21342" class="Symbol">(</a><a id="21343" href="1Lab.Path.html#21343" class="Bound">f</a> <a id="21345" class="Symbol">:</a> <a id="21347" class="Symbol">(</a><a id="21348" href="1Lab.Path.html#21348" class="Bound">x</a> <a id="21350" class="Symbol">:</a> <a id="21352" href="1Lab.Path.html#21278" class="Bound">A</a><a id="21353" class="Symbol">)</a> <a id="21355" class="Symbol">(</a><a id="21356" href="1Lab.Path.html#21356" class="Bound">y</a> <a id="21358" class="Symbol">:</a> <a id="21360" href="1Lab.Path.html#21291" class="Bound">B</a> <a id="21362" href="1Lab.Path.html#21348" class="Bound">x</a><a id="21363" class="Symbol">)</a> <a id="21365" class="Symbol">→</a> <a id="21367" href="1Lab.Path.html#21308" class="Bound">C</a> <a id="21369" href="1Lab.Path.html#21348" class="Bound">x</a> <a id="21371" href="1Lab.Path.html#21356" class="Bound">y</a><a id="21372" class="Symbol">)</a>
      <a id="21380" class="Symbol">{</a><a id="21381" href="1Lab.Path.html#21381" class="Bound">x</a> <a id="21383" href="1Lab.Path.html#21383" class="Bound">y</a> <a id="21385" class="Symbol">:</a> <a id="21387" href="1Lab.Path.html#21278" class="Bound">A</a><a id="21388" class="Symbol">}</a> <a id="21390" class="Symbol">{</a><a id="21391" href="1Lab.Path.html#21391" class="Bound">α</a> <a id="21393" class="Symbol">:</a> <a id="21395" href="1Lab.Path.html#21291" class="Bound">B</a> <a id="21397" href="1Lab.Path.html#21381" class="Bound">x</a><a id="21398" class="Symbol">}</a> <a id="21400" class="Symbol">{</a><a id="21401" href="1Lab.Path.html#21401" class="Bound">β</a> <a id="21403" class="Symbol">:</a> <a id="21405" href="1Lab.Path.html#21291" class="Bound">B</a> <a id="21407" href="1Lab.Path.html#21383" class="Bound">y</a><a id="21408" class="Symbol">}</a>
    <a id="21414" class="Symbol">→</a> <a id="21416" class="Symbol">(</a><a id="21417" href="1Lab.Path.html#21417" class="Bound">p</a> <a id="21419" class="Symbol">:</a> <a id="21421" href="1Lab.Path.html#21381" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="21423" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="21425" href="1Lab.Path.html#21383" class="Bound">y</a><a id="21426" class="Symbol">)</a>
    <a id="21432" class="Symbol">→</a> <a id="21434" class="Symbol">(</a><a id="21435" href="1Lab.Path.html#21435" class="Bound">q</a> <a id="21437" class="Symbol">:</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="21439" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="21445" class="Symbol">(λ</a> <a id="21448" href="1Lab.Path.html#21448" class="Bound">i</a> <a id="21450" class="Symbol">→</a> <a id="21452" href="1Lab.Path.html#21291" class="Bound">B</a> <a id="21454" class="Symbol">(</a><a id="21455" href="1Lab.Path.html#21417" class="Bound">p</a> <a id="21457" href="1Lab.Path.html#21448" class="Bound">i</a><a id="21458" class="Symbol">))</a> <a id="21461" href="1Lab.Path.html#21391" class="Bound">α</a> <a id="21463" href="1Lab.Path.html#21401" class="Bound">β</a><a id="21464" class="Symbol">)</a>
    <a id="21470" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="21472" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="21478" class="Symbol">(λ</a> <a id="21481" href="1Lab.Path.html#21481" class="Bound">i</a> <a id="21483" class="Symbol">→</a> <a id="21485" href="1Lab.Path.html#21308" class="Bound">C</a> <a id="21487" class="Symbol">(</a><a id="21488" href="1Lab.Path.html#21417" class="Bound">p</a> <a id="21490" href="1Lab.Path.html#21481" class="Bound">i</a><a id="21491" class="Symbol">)</a> <a id="21493" class="Symbol">(</a><a id="21494" href="1Lab.Path.html#21435" class="Bound">q</a> <a id="21496" href="1Lab.Path.html#21481" class="Bound">i</a><a id="21497" class="Symbol">))</a>
            <a id="21512" class="Symbol">(</a><a id="21513" href="1Lab.Path.html#21343" class="Bound">f</a> <a id="21515" href="1Lab.Path.html#21381" class="Bound">x</a> <a id="21517" href="1Lab.Path.html#21391" class="Bound">α</a><a id="21518" class="Symbol">)</a>
            <a id="21532" class="Symbol">(</a><a id="21533" href="1Lab.Path.html#21343" class="Bound">f</a> <a id="21535" href="1Lab.Path.html#21383" class="Bound">y</a> <a id="21537" href="1Lab.Path.html#21401" class="Bound">β</a><a id="21538" class="Symbol">)</a>
<a data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" id="21540" href="1Lab.Path.html#21261" class="Function">ap₂</a> <a id="21544" href="1Lab.Path.html#21544" class="Bound">f</a> <a id="21546" href="1Lab.Path.html#21546" class="Bound">p</a> <a id="21548" href="1Lab.Path.html#21548" class="Bound">q</a> <a id="21550" href="1Lab.Path.html#21550" class="Bound">i</a> <a id="21552" class="Symbol">=</a> <a id="21554" href="1Lab.Path.html#21544" class="Bound">f</a> <a id="21556" class="Symbol">(</a><a id="21557" href="1Lab.Path.html#21546" class="Bound">p</a> <a id="21559" href="1Lab.Path.html#21550" class="Bound">i</a><a id="21560" class="Symbol">)</a> <a id="21562" class="Symbol">(</a><a id="21563" href="1Lab.Path.html#21548" class="Bound">q</a> <a id="21565" href="1Lab.Path.html#21550" class="Bound">i</a><a id="21566" class="Symbol">)</a>
</pre>
<p>This operation satisfies many identities definitionally that are only propositional when <span class="Agda"><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" href="1Lab.Path.html#20828" class="Function">ap</a></span> is defined in terms of <span class="Agda"><a data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" href="1Lab.Path.html#19616" class="Function">J</a></span>. For instance:</p>
<pre class="Agda"><a id="21732" class="Keyword">module</a> <a id="21739" href="1Lab.Path.html#21739" class="Module">_</a> <a id="21741" class="Symbol">{</a><a id="21742" href="1Lab.Path.html#21742" class="Bound">A</a> <a id="21744" href="1Lab.Path.html#21744" class="Bound">B</a> <a id="21746" href="1Lab.Path.html#21746" class="Bound">C</a> <a id="21748" class="Symbol">:</a> <a id="21750" href="1Lab.Type.html#391" class="Primitive">Type</a><a id="21754" class="Symbol">}</a> <a id="21756" class="Symbol">{</a><a id="21757" href="1Lab.Path.html#21757" class="Bound">f</a> <a id="21759" class="Symbol">:</a> <a id="21761" href="1Lab.Path.html#21742" class="Bound">A</a> <a id="21763" class="Symbol">→</a> <a id="21765" href="1Lab.Path.html#21744" class="Bound">B</a><a id="21766" class="Symbol">}</a> <a id="21768" class="Symbol">{</a><a id="21769" href="1Lab.Path.html#21769" class="Bound">g</a> <a id="21771" class="Symbol">:</a> <a id="21773" href="1Lab.Path.html#21744" class="Bound">B</a> <a id="21775" class="Symbol">→</a> <a id="21777" href="1Lab.Path.html#21746" class="Bound">C</a><a id="21778" class="Symbol">}</a> <a id="21780" class="Keyword">where</a>
  <a data-type="ap (λ x → g (f x)) p ≡ ap g (ap f p)" id="21788" href="1Lab.Path.html#21788" class="Function">ap-comp</a> <a id="21796" class="Symbol">:</a> <a id="21798" class="Symbol">{</a><a id="21799" href="1Lab.Path.html#21799" class="Bound">x</a> <a id="21801" href="1Lab.Path.html#21801" class="Bound">y</a> <a id="21803" class="Symbol">:</a> <a id="21805" href="1Lab.Path.html#21742" class="Bound">A</a><a id="21806" class="Symbol">}</a> <a id="21808" class="Symbol">{</a><a id="21809" href="1Lab.Path.html#21809" class="Bound">p</a> <a id="21811" class="Symbol">:</a> <a id="21813" href="1Lab.Path.html#21799" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="21815" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="21817" href="1Lab.Path.html#21801" class="Bound">y</a><a id="21818" class="Symbol">}</a>
          <a id="21830" class="Symbol">→</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="21832" href="1Lab.Path.html#20828" class="Function">ap</a> <a id="21835" class="Symbol">(λ</a> <a id="21838" href="1Lab.Path.html#21838" class="Bound">x</a> <a id="21840" class="Symbol">→</a> <a id="21842" href="1Lab.Path.html#21769" class="Bound">g</a> <a id="21844" class="Symbol">(</a><a id="21845" href="1Lab.Path.html#21757" class="Bound">f</a> <a id="21847" href="1Lab.Path.html#21838" class="Bound">x</a><a id="21848" class="Symbol">))</a> <a id="21851" href="1Lab.Path.html#21809" class="Bound">p</a> <a data-type="A → A → Type ℓ" id="21853" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="21855" href="1Lab.Path.html#20828" class="Function">ap</a> <a id="21858" href="1Lab.Path.html#21769" class="Bound">g</a> <a id="21860" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="21861" href="1Lab.Path.html#20828" class="Function">ap</a> <a id="21864" href="1Lab.Path.html#21757" class="Bound">f</a> <a id="21866" href="1Lab.Path.html#21809" class="Bound">p</a><a id="21867" class="Symbol">)</a>
  <a data-type="ap (λ x → g (f x)) p ≡ ap g (ap f p)" id="21871" href="1Lab.Path.html#21788" class="Function">ap-comp</a> <a id="21879" class="Symbol">=</a> <a data-type="x ≡ x" id="21881" href="1Lab.Path.html#3593" class="Function">refl</a>

  <a data-type="ap (λ x → x) p ≡ p" id="21889" href="1Lab.Path.html#21889" class="Function">ap-id</a> <a id="21895" class="Symbol">:</a> <a id="21897" class="Symbol">{</a><a id="21898" href="1Lab.Path.html#21898" class="Bound">x</a> <a id="21900" href="1Lab.Path.html#21900" class="Bound">y</a> <a id="21902" class="Symbol">:</a> <a id="21904" href="1Lab.Path.html#21742" class="Bound">A</a><a id="21905" class="Symbol">}</a> <a id="21907" class="Symbol">{</a><a id="21908" href="1Lab.Path.html#21908" class="Bound">p</a> <a id="21910" class="Symbol">:</a> <a id="21912" href="1Lab.Path.html#21898" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="21914" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="21916" href="1Lab.Path.html#21900" class="Bound">y</a><a id="21917" class="Symbol">}</a>
        <a id="21927" class="Symbol">→</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="21929" href="1Lab.Path.html#20828" class="Function">ap</a> <a id="21932" class="Symbol">(λ</a> <a id="21935" href="1Lab.Path.html#21935" class="Bound">x</a> <a id="21937" class="Symbol">→</a> <a id="21939" href="1Lab.Path.html#21935" class="Bound">x</a><a id="21940" class="Symbol">)</a> <a id="21942" href="1Lab.Path.html#21908" class="Bound">p</a> <a data-type="A → A → Type ℓ" id="21944" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="21946" href="1Lab.Path.html#21908" class="Bound">p</a>
  <a data-type="ap (λ x → x) p ≡ p" id="21950" href="1Lab.Path.html#21889" class="Function">ap-id</a> <a id="21956" class="Symbol">=</a> <a data-type="x ≡ x" id="21958" href="1Lab.Path.html#3593" class="Function">refl</a>

  <a data-type="sym (ap f p) ≡ ap f (sym p)" id="21966" href="1Lab.Path.html#21966" class="Function">ap-sym</a> <a id="21973" class="Symbol">:</a> <a id="21975" class="Symbol">{</a><a id="21976" href="1Lab.Path.html#21976" class="Bound">x</a> <a id="21978" href="1Lab.Path.html#21978" class="Bound">y</a> <a id="21980" class="Symbol">:</a> <a id="21982" href="1Lab.Path.html#21742" class="Bound">A</a><a id="21983" class="Symbol">}</a> <a id="21985" class="Symbol">{</a><a id="21986" href="1Lab.Path.html#21986" class="Bound">p</a> <a id="21988" class="Symbol">:</a> <a id="21990" href="1Lab.Path.html#21976" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="21992" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="21994" href="1Lab.Path.html#21978" class="Bound">y</a><a id="21995" class="Symbol">}</a>
          <a id="22007" class="Symbol">→</a> <a data-type="x ≡ y → y ≡ x" id="22009" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="22013" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="22014" href="1Lab.Path.html#20828" class="Function">ap</a> <a id="22017" href="1Lab.Path.html#21757" class="Bound">f</a> <a id="22019" href="1Lab.Path.html#21986" class="Bound">p</a><a id="22020" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="22022" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="22024" href="1Lab.Path.html#20828" class="Function">ap</a> <a id="22027" href="1Lab.Path.html#21757" class="Bound">f</a> <a id="22029" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="22030" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="22034" href="1Lab.Path.html#21986" class="Bound">p</a><a id="22035" class="Symbol">)</a>
  <a data-type="sym (ap f p) ≡ ap f (sym p)" id="22039" href="1Lab.Path.html#21966" class="Function">ap-sym</a> <a id="22046" class="Symbol">=</a> <a data-type="x ≡ x" id="22048" href="1Lab.Path.html#3593" class="Function">refl</a>

  <a data-type="ap f (λ i → x) ≡ (λ i → f x)" id="22056" href="1Lab.Path.html#22056" class="Function">ap-refl</a> <a id="22064" class="Symbol">:</a> <a id="22066" class="Symbol">{</a><a id="22067" href="1Lab.Path.html#22067" class="Bound">x</a> <a id="22069" class="Symbol">:</a> <a id="22071" href="1Lab.Path.html#21742" class="Bound">A</a><a id="22072" class="Symbol">}</a> <a id="22074" class="Symbol">→</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="22076" href="1Lab.Path.html#20828" class="Function">ap</a> <a id="22079" href="1Lab.Path.html#21757" class="Bound">f</a> <a id="22081" class="Symbol">(λ</a> <a id="22084" href="1Lab.Path.html#22084" class="Bound">i</a> <a id="22086" class="Symbol">→</a> <a id="22088" href="1Lab.Path.html#22067" class="Bound">x</a><a id="22089" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="22091" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="22093" class="Symbol">(λ</a> <a id="22096" href="1Lab.Path.html#22096" class="Bound">i</a> <a id="22098" class="Symbol">→</a> <a id="22100" href="1Lab.Path.html#21757" class="Bound">f</a> <a id="22102" href="1Lab.Path.html#22067" class="Bound">x</a><a id="22103" class="Symbol">)</a>
  <a data-type="ap f (λ i → x) ≡ (λ i → f x)" id="22107" href="1Lab.Path.html#22056" class="Function">ap-refl</a> <a id="22115" class="Symbol">=</a> <a data-type="x ≡ x" id="22117" href="1Lab.Path.html#3593" class="Function">refl</a>
</pre>
<p>The last lemma, that <code>ap</code> respects composition of <em>paths</em>, needs path induction, and the rest of the groupoid structure on type formers, so it’s in <a href="1Lab.Path.Groupoid.html#ap-comp-path">a different module</a>.</p>
<h1 id="composition"><a href="#composition" class="header-link">Composition<span class="header-link-emoji">🔗</span></a></h1>
<p>In “Book HoTT”, the primitive operation from which the higher-dimensional structure of types is derived is the <span class="Agda"><a data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" href="1Lab.Path.html#19616" class="Function">J</a></span> eliminator, with <span class="Agda"><a data-type="(P : (y : A) → x ≡ y → Type ℓ₂) (pxr : P x refl) →
J P pxr refl ≡ pxr" href="1Lab.Path.html#20175" class="Function">J-refl</a></span> as a <em>definitional</em> computation rule. This has the benefit of being very elegant: This one elimination rule generates an infinite amount of coherent data. However, it’s very hard to make compute in the presence of higher inductive types and univalence, so much so that, in the book, univalence and HITs only compute up to paths.</p>
<p>In Cubical Agda, types are interpreted as objects called <em>cubical Kan complexes</em><a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>, which are a <em>geometric</em> description description of spaces as “sets we can probe by cubes”. In Agda, this “probing” is reflected by mapping the interval into a type: A “probe” of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> by an <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-cube</span> is a term of type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> in a context with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> variables of type <span class="Agda"><a href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a></span> — points, lines, squares, cubes, etc. This structure lets us “explore” the higher dimensional structure of a type, but it does not specify how this structure behaves.</p>
<p>That’s where the “Kan” part of “cubical Kan complex” comes in: Semantically, <em>every open box extends to a cube</em>. The concept of “open box” might make even less sense than the concept of “cube in a type” initially, so it helps to picture them! Suppose we have three paths <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>:</mo><mi>w</mi><mo>≡</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">p : w ≡ x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>,</span> <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>:</mo><mi>x</mi><mo>≡</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">q : x ≡ y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>,</span> and <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>:</mo><mi>y</mi><mo>≡</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">r : y ≡ z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>.</span> We can pictorially arrange them into an open box like in the diagram below, by joining the paths by their common endpoints:</p>
<figure>
<div class="diagram-container">
<img src="fb29914884666398c6d33030b05008b29b5629d4.svg" title="commutative diagram" class="diagram quiver" />
</div>
</figure>
<p>In the diagram above, we have a square assembled of three lines <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>≡</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">w ≡ x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>,</span> <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≡</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x ≡ y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>,</span> and <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>≡</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">y ≡ z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>.</span> Note that in the left face of the diagram, the path was inverted; This is because while we have a path <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>≡</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">w ≡ x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>,</span> we need a path <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≡</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">x ≡ w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>,</span> and all parallel faces of a cube must “point” in the same direction. The way the diagram is drawn strongly implies that there is a face missing — the line <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>≡</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">w ≡ z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>.</span> The interpretation of types as <em>Kan</em> cubical sets guarantees that the open box above extends to a complete square, and thus the line <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>≡</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">w ≡ z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span> exists.</p>
<h2 id="partial-elements"><a href="#partial-elements" class="header-link">Partial Elements<span class="header-link-emoji">🔗</span></a></h2>
<p>The definition of Kan cubical sets as those having fillers for all open boxes is all well and good, but to use this from within type theory we need a way of reflecting the idea of “open box” as syntax. This is done is by using the <span class="Agda"><a href="Agda.Primitive.Cubical.html#1065" class="Primitive">Partial</a></span> type former.</p>
<p>The <span class="Agda"><a href="Agda.Primitive.Cubical.html#1065" class="Primitive">Partial</a></span> type former takes two arguments: A <em>formula</em> <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span></span></span></span>,</span> and a <em>type</em> <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>.</span> The idea is that a term of type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">P</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">l</mi></mrow><mtext> </mtext><mi>φ</mi><mtext> </mtext><mi>A</mi></mrow><annotation encoding="application/x-tex">\mathrm{Partial}\ \varphi\ A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">Partial</span></span><span class="mspace"> </span><span class="mord mathnormal">φ</span><span class="mspace"> </span><span class="mord mathnormal">A</span></span></span></span> in a context with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> <span class="Agda"><a href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a></span>-typed variables is a <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-cube</span> that is only defined when <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span></span></span></span> “is true”. In Agda, formulas are represented using the De Morgan structure of the interval, and they are “true” when they are equal to 1. The predicate <code class="sourceCode agda">IsOne</code> represents truth of a formula, and there is a canonical inhabitant <span class="Agda"><a href="1Lab.Path.html#2443" class="Postulate">1=1</a></span> which says <span class="Agda"><a href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a></span> is <span class="Agda"><a href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a></span>.</p>
<p>For instance, if we have a variable <code>i : I</code> of interval type, we can represent <em>disjoint endpoints</em> of a <span class="Agda"><a data-type="(A : Type ℓ) → A → A → Type ℓ" href="1Lab.Path.html#2466" class="Function">Path</a></span> by a partial element with formula <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mi>i</mi><mo>∨</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">\neg i \lor i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord">¬</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>.</span> Note that this is not the same thing as <span class="Agda"><a href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a></span>! Since elements of <code>I</code> are meant to represent real numbers <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">r \in [0,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>,</span> it suffices to find one for which <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mn>1</mn><mo>−</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\max(x, 1 - x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> is not <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> — like 0.5.</p>
<pre class="Agda"><a id="25949" class="Keyword">private</a>
  <a id="not-a-path"></a><a id="25959" href="1Lab.Path.html#25959" class="Function">not-a-path</a> <a id="25970" class="Symbol">:</a> <a id="25972" class="Symbol">(</a><a id="25973" href="1Lab.Path.html#25973" class="Bound">i</a> <a id="25975" class="Symbol">:</a> <a id="25977" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="25978" class="Symbol">)</a> <a id="25980" class="Symbol">→</a> <a id="25982" href="Agda.Primitive.Cubical.html#1065" class="Primitive">Partial</a> <a id="25990" class="Symbol">(</a><a id="25991" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="25993" href="1Lab.Path.html#25973" class="Bound">i</a> <a id="25995" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="25997" href="1Lab.Path.html#25973" class="Bound">i</a><a id="25998" class="Symbol">)</a> <a data-type="Type" id="26000" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="26007" href="1Lab.Path.html#25959" class="Function">not-a-path</a> <a id="26018" href="1Lab.Path.html#26018" class="Bound">i</a> <a id="26020" class="Symbol">(</a><a id="26021" href="1Lab.Path.html#26018" class="Bound">i</a> <a id="26023" class="Symbol">=</a> <a id="26025" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="26027" class="Symbol">)</a> <a id="26029" class="Symbol">=</a> <a data-type="Bool" id="26031" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
  <a id="26038" href="1Lab.Path.html#25959" class="Function">not-a-path</a> <a id="26049" href="1Lab.Path.html#26049" class="Bound">i</a> <a id="26051" class="Symbol">(</a><a id="26052" href="1Lab.Path.html#26049" class="Bound">i</a> <a id="26054" class="Symbol">=</a> <a id="26056" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="26058" class="Symbol">)</a> <a id="26060" class="Symbol">=</a> <a data-type="Bool" id="26062" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
</pre>
<p>This represents the following shape: Two disconnected points, with completely unrelated values at each endpoint of the interval.</p>
<div class="diagram-container">
<img src="3d413244fb9f2082f2c1bdb1d899a233bed95585.svg" title="commutative diagram" class="diagram quiver short-2" />
</div>
<p>More concretely, an element of <span class="Agda"><a href="Agda.Primitive.Cubical.html#1065" class="Primitive">Partial</a></span> can be understood as a function where the domain is the predicate <code class="sourceCode agda">IsOne</code>, which has an inhabitant <span class="Agda"><a href="1Lab.Path.html#2443" class="Postulate">1=1</a></span>, stating that one is one. Indeed, we can <em>apply</em> a <span class="Agda"><a href="Agda.Primitive.Cubical.html#1065" class="Primitive">Partial</a></span> to an argument of type <code class="sourceCode agda">IsOne</code> to get a value of the underlying type.</p>
<pre class="Agda">  <a id="26623" href="1Lab.Path.html#26623" class="Function">_</a> <a id="26625" class="Symbol">:</a> <a id="26627" href="1Lab.Path.html#25959" class="Function">not-a-path</a> <a id="26638" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a id="26641" href="1Lab.Path.html#2443" class="Postulate">1=1</a> <a data-type="A → A → Type ℓ" id="26645" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Bool" id="26647" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
  <a id="26654" class="Symbol">_</a> <a id="26656" class="Symbol">=</a> <a data-type="x ≡ x" id="26658" href="1Lab.Path.html#3593" class="Function">refl</a>
</pre>
<p>Note that if we <em>did</em> have <code>(~i ∨ i) = i1</code> (i.e. our De Morgan algebra was a Boolean algebra), the partial element above would give us a contradiction, since any <code>I → Partial i1 T</code> extends to a path:</p>
<pre class="Agda">  <a id="26875" href="1Lab.Path.html#26875" class="Function">_</a> <a id="26877" class="Symbol">:</a> <a id="26879" class="Symbol">(</a><a id="26880" href="1Lab.Path.html#26880" class="Bound">f</a> <a id="26882" class="Symbol">:</a> <a id="26884" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="26886" class="Symbol">→</a> <a id="26888" href="Agda.Primitive.Cubical.html#1065" class="Primitive">Partial</a> <a id="26896" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a> <a data-type="Type" id="26899" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="26903" class="Symbol">)</a> <a id="26905" class="Symbol">→</a> <a data-type="(A : Type ℓ) → A → A → Type ℓ" id="26907" href="1Lab.Path.html#2466" class="Function">Path</a> <a data-type="Type" id="26912" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a> <a id="26917" class="Symbol">(</a><a id="26918" href="1Lab.Path.html#26880" class="Bound">f</a> <a id="26920" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a id="26923" href="1Lab.Path.html#2443" class="Postulate">1=1</a><a id="26926" class="Symbol">)</a> <a id="26928" class="Symbol">(</a><a id="26929" href="1Lab.Path.html#26880" class="Bound">f</a> <a id="26931" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a> <a id="26934" href="1Lab.Path.html#2443" class="Postulate">1=1</a><a id="26937" class="Symbol">)</a>
  <a id="26941" class="Symbol">_</a> <a id="26943" class="Symbol">=</a> <a id="26945" class="Symbol">λ</a> <a id="26947" href="1Lab.Path.html#26947" class="Bound">f</a> <a id="26949" href="1Lab.Path.html#26949" class="Bound">i</a> <a id="26951" class="Symbol">→</a> <a id="26953" href="1Lab.Path.html#26947" class="Bound">f</a> <a id="26955" href="1Lab.Path.html#26949" class="Bound">i</a> <a id="26957" href="1Lab.Path.html#2443" class="Postulate">1=1</a>
</pre>
<h2 id="extensibility"><a href="#extensibility" class="header-link">Extensibility<span class="header-link-emoji">🔗</span></a></h2>
<p>A partial element in a context with <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-variables</span> gives us a way of mapping some subobject of the <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-cube</span> into a type. A natural question to ask, then, is: Given a partial element <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>,</span> can we extend that to a honest-to-god <em>element</em> of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>,</span> which agrees with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> where it is defined?</p>
<p>Specifically, when this is the case, we say that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">x : A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> <em>extends</em> <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>:</mo><mrow><mi mathvariant="normal">P</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">l</mi></mrow><mtext> </mtext><mi>φ</mi><mtext> </mtext><mi>A</mi></mrow><annotation encoding="application/x-tex">e : \mathrm{Partial}\ \varphi\ A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">Partial</span></span><span class="mspace"> </span><span class="mord mathnormal">φ</span><span class="mspace"> </span><span class="mord mathnormal">A</span></span></span></span>.</span> We could represent this very generically as a <em>lifting problem</em>, i.e. trying to find a map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">□</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\square^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.675em;"></span><span class="mord"><span class="mord amsrm">□</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> which agrees with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> when restricted to <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span></span></span></span>,</span> but I believe a specific example will be more helpful.</p>
<p>Suppose we have a partial element of <span class="Agda"><a data-type="Type" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a></span> which is <span class="Agda"><a data-type="Bool" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a></span> on the left endpoint of the interval, and undefined elsewhere. This is a partial element with one interval variable, so it would be extended by a <em>path</em> — a 1-dimensional cube. The reflexivity path is a line in <code>Bool</code>, which is <span class="Agda"><a data-type="Bool" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a></span> on the left endpoint of the interval (in fact, it is <span class="Agda"><a data-type="Bool" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a></span> everywhere), so we say that <span class="Agda"><a data-type="x ≡ x" href="1Lab.Path.html#3593" class="Function">refl</a></span> <em>extends</em> the partial element.</p>
<div class="diagram-container">
<img src="c1f02419d28f3ff7e9aced970f365b67e9cad425.svg" title="commutative diagram" class="diagram quiver short-1" />
</div>
<p>In the diagram, we draw the specific partial element being extended in red, and the total path extending it in black. In Agda, extensions are represented by the type former <span class="Agda"><a data-type="(A : Type a) (φ : I) → Partial φ A → SSet a" href="Agda.Builtin.Cubical.Sub.html#191" class="Postulate">Sub</a></span>, which we abbreviate by <span class="Agda"><a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" href="1Lab.Path.html#28690" class="Function Operator">_[_↦_]</a></span>. Fully applied, that operator looks like <code>A [ φ → u ]</code>.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<pre class="Agda"><a id="_[_↦_]"></a><a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="28690" href="1Lab.Path.html#28690" class="Function Operator">_[_↦_]</a> <a id="28697" class="Symbol">:</a> <a id="28699" class="Symbol">∀</a> <a id="28701" class="Symbol">{</a><a id="28702" href="1Lab.Path.html#28702" class="Bound">ℓ</a><a id="28703" class="Symbol">}</a> <a id="28705" class="Symbol">(</a><a id="28706" href="1Lab.Path.html#28706" class="Bound">A</a> <a id="28708" class="Symbol">:</a> <a id="28710" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="28715" href="1Lab.Path.html#28702" class="Bound">ℓ</a><a id="28716" class="Symbol">)</a> <a id="28718" class="Symbol">(</a><a id="28719" href="1Lab.Path.html#28719" class="Bound">φ</a> <a id="28721" class="Symbol">:</a> <a id="28723" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="28724" class="Symbol">)</a> <a id="28726" class="Symbol">(</a><a id="28727" href="1Lab.Path.html#28727" class="Bound">u</a> <a id="28729" class="Symbol">:</a> <a id="28731" href="Agda.Primitive.Cubical.html#1065" class="Primitive">Partial</a> <a id="28739" href="1Lab.Path.html#28719" class="Bound">φ</a> <a id="28741" href="1Lab.Path.html#28706" class="Bound">A</a><a id="28742" class="Symbol">)</a> <a id="28744" class="Symbol">→</a> <a id="28746" class="Symbol">_</a>
<a id="28748" href="1Lab.Path.html#28748" class="Bound">A</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="28750" href="1Lab.Path.html#28690" class="Function Operator">[</a> <a id="28752" href="1Lab.Path.html#28752" class="Bound">φ</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="28754" href="1Lab.Path.html#28690" class="Function Operator">↦</a> <a id="28756" href="1Lab.Path.html#28756" class="Bound">u</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="28758" href="1Lab.Path.html#28690" class="Function Operator">]</a> <a id="28760" class="Symbol">=</a> <a data-type="(A : Type a) (φ : I) → Partial φ A → SSet a" id="28762" href="Agda.Builtin.Cubical.Sub.html#191" class="Postulate">Sub</a> <a id="28766" href="1Lab.Path.html#28748" class="Bound">A</a> <a id="28768" href="1Lab.Path.html#28752" class="Bound">φ</a> <a id="28770" href="1Lab.Path.html#28756" class="Bound">u</a>
</pre>
<p>We can formalise the red-black extensibility diagram above by defining the partial element <span class="Agda"><a href="1Lab.Path.html#28985" class="Function">left-true</a></span> and giving <span class="Agda"><a data-type="x ≡ x" href="1Lab.Path.html#3593" class="Function">refl</a></span> to <span class="Agda"><a href="1Lab.Path.html#2069" class="Postulate">inS</a></span>, the constructor for <span class="Agda"><a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" href="1Lab.Path.html#28690" class="Function Operator">_[_↦_]</a></span>.</p>
<pre class="Agda"><a id="28975" class="Keyword">private</a>
  <a id="left-true"></a><a id="28985" href="1Lab.Path.html#28985" class="Function">left-true</a> <a id="28995" class="Symbol">:</a> <a id="28997" class="Symbol">(</a><a id="28998" href="1Lab.Path.html#28998" class="Bound">i</a> <a id="29000" class="Symbol">:</a> <a id="29002" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="29003" class="Symbol">)</a> <a id="29005" class="Symbol">→</a> <a id="29007" href="Agda.Primitive.Cubical.html#1065" class="Primitive">Partial</a> <a id="29015" class="Symbol">(</a><a id="29016" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="29018" href="1Lab.Path.html#28998" class="Bound">i</a><a id="29019" class="Symbol">)</a> <a data-type="Type" id="29021" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="29028" href="1Lab.Path.html#28985" class="Function">left-true</a> <a id="29038" href="1Lab.Path.html#29038" class="Bound">i</a> <a id="29040" class="Symbol">(</a><a id="29041" href="1Lab.Path.html#29038" class="Bound">i</a> <a id="29043" class="Symbol">=</a> <a id="29045" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="29047" class="Symbol">)</a> <a id="29049" class="Symbol">=</a> <a data-type="Bool" id="29051" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>

  <a id="refl-extends"></a><a id="29059" href="1Lab.Path.html#29059" class="Function">refl-extends</a> <a id="29072" class="Symbol">:</a> <a id="29074" class="Symbol">(</a><a id="29075" href="1Lab.Path.html#29075" class="Bound">i</a> <a id="29077" class="Symbol">:</a> <a id="29079" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="29080" class="Symbol">)</a> <a id="29082" class="Symbol">→</a> <a data-type="Type" id="29084" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="29089" href="1Lab.Path.html#28690" class="Function Operator">[</a> <a id="29091" class="Symbol">(</a><a id="29092" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="29094" href="1Lab.Path.html#29075" class="Bound">i</a><a id="29095" class="Symbol">)</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="29097" href="1Lab.Path.html#28690" class="Function Operator">↦</a> <a id="29099" href="1Lab.Path.html#28985" class="Function">left-true</a> <a id="29109" href="1Lab.Path.html#29075" class="Bound">i</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="29111" href="1Lab.Path.html#28690" class="Function Operator">]</a>
  <a id="29115" href="1Lab.Path.html#29059" class="Function">refl-extends</a> <a id="29128" href="1Lab.Path.html#29128" class="Bound">i</a> <a id="29130" class="Symbol">=</a> <a id="29132" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="29136" class="Symbol">(</a><a data-type="x ≡ x" id="29137" href="1Lab.Path.html#3593" class="Function">refl</a> <a id="29142" class="Symbol">{</a><a id="29143" class="Argument">x</a> <a id="29145" class="Symbol">=</a> <a data-type="Bool" id="29147" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a><a id="29151" class="Symbol">}</a> <a id="29153" href="1Lab.Path.html#29128" class="Bound">i</a><a id="29154" class="Symbol">)</a>
</pre>
<p>The constructor <code>inS</code> expresses that <em>any</em> totally-defined cube <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span> can be seen as a partial cube, one that agrees with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span> for any choice of formula <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span></span></span></span>.</span> This might be a bit abstract, so let’s diagram the case where we have some square <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>,</span> and the partial element has formula <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>∧</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i \land j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>.</span> This extension can be drawn as in the diagram below: The red “backwards L” shape is the partial element, which is “extended by” the black lines to make a complete square.</p>
<div class="diagram-container">
<img src="09793c4c4587fb5157ddad8e04975301c309a266.svg" title="commutative diagram" class="diagram quiver" />
</div>
<pre class="Agda">  <a id="30084" href="1Lab.Path.html#30084" class="Function">_</a> <a id="30086" class="Symbol">:</a> <a id="30088" class="Symbol">∀</a> <a id="30090" class="Symbol">{</a><a id="30091" href="1Lab.Path.html#30091" class="Bound">ℓ</a><a id="30092" class="Symbol">}</a> <a id="30094" class="Symbol">{</a><a id="30095" href="1Lab.Path.html#30095" class="Bound">A</a> <a id="30097" class="Symbol">:</a> <a id="30099" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="30104" href="1Lab.Path.html#30091" class="Bound">ℓ</a><a id="30105" class="Symbol">}</a> <a id="30107" class="Symbol">{</a><a id="30108" href="1Lab.Path.html#30108" class="Bound">φ</a> <a id="30110" class="Symbol">:</a> <a id="30112" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="30113" class="Symbol">}</a> <a id="30115" class="Symbol">(</a><a id="30116" href="1Lab.Path.html#30116" class="Bound">u</a> <a id="30118" class="Symbol">:</a> <a id="30120" href="1Lab.Path.html#30095" class="Bound">A</a><a id="30121" class="Symbol">)</a> <a id="30123" class="Symbol">→</a> <a id="30125" href="1Lab.Path.html#30095" class="Bound">A</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="30127" href="1Lab.Path.html#28690" class="Function Operator">[</a> <a id="30129" href="1Lab.Path.html#30108" class="Bound">φ</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="30131" href="1Lab.Path.html#28690" class="Function Operator">↦</a> <a id="30133" class="Symbol">(λ</a> <a id="30136" href="1Lab.Path.html#30136" class="Bound">_</a> <a id="30138" class="Symbol">→</a> <a id="30140" href="1Lab.Path.html#30116" class="Bound">u</a><a id="30141" class="Symbol">)</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="30143" href="1Lab.Path.html#28690" class="Function Operator">]</a>
  <a id="30147" class="Symbol">_</a> <a id="30149" class="Symbol">=</a> <a id="30151" href="1Lab.Path.html#2069" class="Postulate">inS</a>
</pre>
<p>Note that since an extension must agree with the partial element <em>everywhere</em>, there are elements that can not be extended at all. Take <code class="sourceCode agda">notAPath</code> from before — since there is no path that is <span class="Agda"><a data-type="Bool" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a></span> at <span class="Agda"><a href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a></span> and <span class="Agda"><a data-type="Bool" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a></span> at <span class="Agda"><a href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a></span>, it is not extensible. If it were extensible, we would have <code>true ≡ false</code> — a contradiction.<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<pre class="Agda">  <a id="not-extensible"></a><a id="30685" href="1Lab.Path.html#30685" class="Function">not-extensible</a> <a id="30700" class="Symbol">:</a> <a id="30702" class="Symbol">((</a><a id="30704" href="1Lab.Path.html#30704" class="Bound">i</a> <a id="30706" class="Symbol">:</a> <a id="30708" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="30709" class="Symbol">)</a> <a id="30711" class="Symbol">→</a> <a data-type="Type" id="30713" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="30718" href="1Lab.Path.html#28690" class="Function Operator">[</a> <a id="30720" class="Symbol">(</a><a id="30721" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="30723" href="1Lab.Path.html#30704" class="Bound">i</a> <a id="30725" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="30727" href="1Lab.Path.html#30704" class="Bound">i</a><a id="30728" class="Symbol">)</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="30730" href="1Lab.Path.html#28690" class="Function Operator">↦</a> <a id="30732" href="1Lab.Path.html#25959" class="Function">not-a-path</a> <a id="30743" href="1Lab.Path.html#30704" class="Bound">i</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="30745" href="1Lab.Path.html#28690" class="Function Operator">]</a><a id="30746" class="Symbol">)</a> <a id="30748" class="Symbol">→</a> <a data-type="Bool" id="30750" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="A → A → Type ℓ" id="30755" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Bool" id="30757" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="30765" href="1Lab.Path.html#30685" class="Function">not-extensible</a> <a id="30780" href="1Lab.Path.html#30780" class="Bound">ext</a> <a id="30784" href="1Lab.Path.html#30784" class="Bound">i</a> <a id="30786" class="Symbol">=</a> <a id="30788" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="30793" class="Symbol">(</a><a id="30794" href="1Lab.Path.html#30780" class="Bound">ext</a> <a id="30798" href="1Lab.Path.html#30784" class="Bound">i</a><a id="30799" class="Symbol">)</a>
</pre>
<p>This counterexample demonstrates the eliminator for <span class="Agda"><a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" href="1Lab.Path.html#28690" class="Function Operator">_[_↦_]</a></span>, <span class="Agda"><a href="1Lab.Path.html#2100" class="Primitive">outS</a></span>, which turns an <code>A [ φ ↦ u ]</code> to <code>A</code>, with a computation rule saying that, for <code>x : A [ i1 ↦ u ]</code>, <code>outS x</code> computes to <code>u 1=1</code>:</p>
<pre class="Agda">  <a id="31029" href="1Lab.Path.html#31029" class="Function">_</a> <a id="31031" class="Symbol">:</a> <a id="31033" class="Symbol">∀</a> <a id="31035" class="Symbol">{</a><a id="31036" href="1Lab.Path.html#31036" class="Bound">A</a> <a id="31038" class="Symbol">:</a> <a id="31040" href="1Lab.Type.html#391" class="Primitive">Type</a><a id="31044" class="Symbol">}</a> <a id="31046" class="Symbol">{</a><a id="31047" href="1Lab.Path.html#31047" class="Bound">u</a> <a id="31049" class="Symbol">:</a> <a id="31051" href="Agda.Primitive.Cubical.html#1065" class="Primitive">Partial</a> <a id="31059" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a> <a id="31062" href="1Lab.Path.html#31036" class="Bound">A</a><a id="31063" class="Symbol">}</a> <a id="31065" class="Symbol">{</a><a id="31066" href="1Lab.Path.html#31066" class="Bound">x</a> <a id="31068" class="Symbol">:</a> <a id="31070" href="1Lab.Path.html#31036" class="Bound">A</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="31072" href="1Lab.Path.html#28690" class="Function Operator">[</a> <a id="31074" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="31077" href="1Lab.Path.html#28690" class="Function Operator">↦</a> <a id="31079" href="1Lab.Path.html#31047" class="Bound">u</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="31081" href="1Lab.Path.html#28690" class="Function Operator">]</a><a id="31082" class="Symbol">}</a>
    <a id="31088" class="Symbol">→</a> <a id="31090" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="31095" href="1Lab.Path.html#31066" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="31097" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="31099" href="1Lab.Path.html#31047" class="Bound">u</a> <a id="31101" href="1Lab.Path.html#2443" class="Postulate">1=1</a>
  <a id="31107" class="Symbol">_</a> <a id="31109" class="Symbol">=</a> <a data-type="x ≡ x" id="31111" href="1Lab.Path.html#3593" class="Function">refl</a>
</pre>
<p>The notion of partial elements and extensibility captures the specific interface of the Kan operations, which can be summed up in the following sentence: <em>If a partial path is extensible at <span class="Agda"><a href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a></span>, then it is extensible at <span class="Agda"><a href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a></span></em>. Let’s unpack that a bit:</p>
<p>A <em>partial path</em> is anything of type <code>I → Partial φ A</code> – let’s say we have an <code>f</code> in that type. It takes a value at <span class="Agda"><a href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a></span> (that’s <code>f i0</code>), and a value at <span class="Agda"><a href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a></span>. The Kan condition expresses that, if there exists an <code>A [ φ → f i0 ]</code>, then we also have an <code>A [ φ → f i1 ]</code>. In other words: Extensibility is preserved by paths.</p>
<p>Recall the open box we drew by gluing paths together at the start of the section (on the left). It has a <em>top face</em> <code>q</code>, and it has a <em>tube</em> — its left/right faces, which can be considered as a partial (in the left-right direction) path going in the top-down direction.</p>
<div class="mathpar" style="gap: 2em;">
<div style="display: flex; flex-flow: column nowrap; align-items: center;">
<div class="diagram-container">
<img src="66ff21d1472b5db3e989d459cf3bccd59da619a9.svg" title="commutative diagram" class="diagram quiver" />
</div>
<figcaption>
The complete “open box”.
</figcaption>
</div>
<div style="display: flex; flex-flow: column nowrap; align-items: center;">
<div class="diagram-container">
<img src="6294b4b58a94dca8a03e46970ada4e0104344570.svg" title="commutative diagram" class="diagram quiver" />
</div>
<figcaption>
The partially-defined “tube”.
</figcaption>
</div>
</div>
<p>We can make this the construction of this “tube” formal by giving a <span class="Agda"><a href="Agda.Primitive.Cubical.html#1065" class="Primitive">Partial</a></span> element of <code>A</code>, which is defined on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mi>i</mi><mo>∨</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">\neg i \lor i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord">¬</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> (that is: only the left/right faces of a square), as is done below. Since it is a tube of a <em>square</em>, it has <em>two</em> interval variables: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> gives the top-down direction.<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
<pre class="Agda"><a id="33283" class="Keyword">module</a> <a id="33290" href="1Lab.Path.html#33290" class="Module">_</a> <a id="33292" class="Symbol">{</a><a id="33293" href="1Lab.Path.html#33293" class="Bound">A</a> <a id="33295" class="Symbol">:</a> <a id="33297" href="1Lab.Type.html#391" class="Primitive">Type</a><a id="33301" class="Symbol">}</a> <a id="33303" class="Symbol">{</a><a id="33304" href="1Lab.Path.html#33304" class="Bound">w</a> <a id="33306" href="1Lab.Path.html#33306" class="Bound">x</a> <a id="33308" href="1Lab.Path.html#33308" class="Bound">y</a> <a id="33310" href="1Lab.Path.html#33310" class="Bound">z</a> <a id="33312" class="Symbol">:</a> <a id="33314" href="1Lab.Path.html#33293" class="Bound">A</a><a id="33315" class="Symbol">}</a> <a id="33317" class="Symbol">{</a><a id="33318" href="1Lab.Path.html#33318" class="Bound">p</a> <a id="33320" class="Symbol">:</a> <a id="33322" href="1Lab.Path.html#33304" class="Bound">w</a> <a data-type="A → A → Type ℓ" id="33324" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="33326" href="1Lab.Path.html#33306" class="Bound">x</a><a id="33327" class="Symbol">}</a> <a id="33329" class="Symbol">{</a><a id="33330" href="1Lab.Path.html#33330" class="Bound">q</a> <a id="33332" class="Symbol">:</a> <a id="33334" href="1Lab.Path.html#33306" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="33336" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="33338" href="1Lab.Path.html#33308" class="Bound">y</a><a id="33339" class="Symbol">}</a> <a id="33341" class="Symbol">{</a><a id="33342" href="1Lab.Path.html#33342" class="Bound">r</a> <a id="33344" class="Symbol">:</a> <a id="33346" href="1Lab.Path.html#33308" class="Bound">y</a> <a data-type="A → A → Type ℓ" id="33348" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="33350" href="1Lab.Path.html#33310" class="Bound">z</a><a id="33351" class="Symbol">}</a> <a id="33353" class="Keyword">where</a> <a id="33359" class="Keyword">private</a>
  <a id="33369" href="1Lab.Path.html#33369" class="Function">double-comp-tube</a> <a id="33386" class="Symbol">:</a> <a id="33388" class="Symbol">(</a><a id="33389" href="1Lab.Path.html#33389" class="Bound">i</a> <a id="33391" class="Symbol">:</a> <a id="33393" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="33394" class="Symbol">)</a> <a id="33396" class="Symbol">→</a> <a id="33398" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="33400" class="Symbol">→</a> <a id="33402" href="Agda.Primitive.Cubical.html#1065" class="Primitive">Partial</a> <a id="33410" class="Symbol">(</a><a id="33411" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="33413" href="1Lab.Path.html#33389" class="Bound">i</a> <a id="33415" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="33417" href="1Lab.Path.html#33389" class="Bound">i</a><a id="33418" class="Symbol">)</a> <a id="33420" href="1Lab.Path.html#33293" class="Bound">A</a>
  <a id="33424" href="1Lab.Path.html#33369" class="Function">double-comp-tube</a> <a id="33441" href="1Lab.Path.html#33441" class="Bound">i</a> <a id="33443" href="1Lab.Path.html#33443" class="Bound">j</a> <a id="33445" class="Symbol">(</a><a id="33446" href="1Lab.Path.html#33441" class="Bound">i</a> <a id="33448" class="Symbol">=</a> <a id="33450" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="33452" class="Symbol">)</a> <a id="33454" class="Symbol">=</a> <a data-type="x ≡ y → y ≡ x" id="33456" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="33460" href="1Lab.Path.html#33318" class="Bound">p</a> <a id="33462" href="1Lab.Path.html#33443" class="Bound">j</a>
  <a id="33466" href="1Lab.Path.html#33369" class="Function">double-comp-tube</a> <a id="33483" href="1Lab.Path.html#33483" class="Bound">i</a> <a id="33485" href="1Lab.Path.html#33485" class="Bound">j</a> <a id="33487" class="Symbol">(</a><a id="33488" href="1Lab.Path.html#33483" class="Bound">i</a> <a id="33490" class="Symbol">=</a> <a id="33492" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="33494" class="Symbol">)</a> <a id="33496" class="Symbol">=</a> <a id="33498" href="1Lab.Path.html#33342" class="Bound">r</a> <a id="33500" href="1Lab.Path.html#33485" class="Bound">j</a>
</pre>
<p>When given <span class="Agda"><a href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a></span> as <code>j</code>, <span class="Agda"><a href="1Lab.Path.html#33369" class="Function">double-comp-tube</a></span> has boundary <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mtext> </mtext><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow><mo>→</mo><mi>r</mi><mtext> </mtext><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">p\ \mathrm{i1} \to r\ \mathrm{i0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8623em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace"> </span><span class="mord"><span class="mord mathrm">i1</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace"> </span><span class="mord"><span class="mord mathrm">i0</span></span></span></span></span>,</span> which computes to <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \to y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>.</span> This means that for this path to be extensible at <span class="Agda"><a href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a></span>, we need a path with that boundary. By assumption, <code>q</code> extends <span class="Agda"><a href="1Lab.Path.html#33369" class="Function">double-comp-tube</a></span> at <span class="Agda"><a href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a></span>.</p>
<pre class="Agda">  <a id="33821" href="1Lab.Path.html#33821" class="Function">extensible-at-i0</a> <a id="33838" class="Symbol">:</a> <a id="33840" class="Symbol">(</a><a id="33841" href="1Lab.Path.html#33841" class="Bound">i</a> <a id="33843" class="Symbol">:</a> <a id="33845" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="33846" class="Symbol">)</a> <a id="33848" class="Symbol">→</a> <a id="33850" href="1Lab.Path.html#33293" class="Bound">A</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="33852" href="1Lab.Path.html#28690" class="Function Operator">[</a> <a id="33854" class="Symbol">(</a><a id="33855" href="1Lab.Path.html#33841" class="Bound">i</a> <a id="33857" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="33859" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="33861" href="1Lab.Path.html#33841" class="Bound">i</a><a id="33862" class="Symbol">)</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="33864" href="1Lab.Path.html#28690" class="Function Operator">↦</a> <a id="33866" href="1Lab.Path.html#33369" class="Function">double-comp-tube</a> <a id="33883" href="1Lab.Path.html#33841" class="Bound">i</a> <a id="33885" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="33888" href="1Lab.Path.html#28690" class="Function Operator">]</a>
  <a id="33892" href="1Lab.Path.html#33821" class="Function">extensible-at-i0</a> <a id="33909" href="1Lab.Path.html#33909" class="Bound">i</a> <a id="33911" class="Symbol">=</a> <a id="33913" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="33917" class="Symbol">(</a><a id="33918" href="1Lab.Path.html#33330" class="Bound">q</a> <a id="33920" href="1Lab.Path.html#33909" class="Bound">i</a><a id="33921" class="Symbol">)</a>
</pre>
<p>We can draw this as one of our red-black extensibility diagrams colouring the left/right faces in red — since that is the partial element — and colouring the top face black, since that is a totally-defined cube.</p>
<div class="diagram-container">
<img src="8e25035524ebaf25af9a245ee5ac78dde54a9bb6.svg" title="commutative diagram" class="diagram quiver" />
</div>
<p>The Kan condition says that this path is then extensible at <code>i1</code>, i.e. there is some inhabitant of <code>A [ (i ∨ ~ i) ↦ double-comp-tube i i1 ]</code>. This element is written using the operator <span class="Agda"><a href="1Lab.Path.html#2368" class="Primitive">hcomp</a></span>:</p>
<pre class="Agda">  <a id="34827" href="1Lab.Path.html#34827" class="Function">extensible-at-i1</a> <a id="34844" class="Symbol">:</a> <a id="34846" class="Symbol">(</a><a id="34847" href="1Lab.Path.html#34847" class="Bound">i</a> <a id="34849" class="Symbol">:</a> <a id="34851" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="34852" class="Symbol">)</a> <a id="34854" class="Symbol">→</a> <a id="34856" href="1Lab.Path.html#33293" class="Bound">A</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="34858" href="1Lab.Path.html#28690" class="Function Operator">[</a> <a id="34860" class="Symbol">(</a><a id="34861" href="1Lab.Path.html#34847" class="Bound">i</a> <a id="34863" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="34865" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="34867" href="1Lab.Path.html#34847" class="Bound">i</a><a id="34868" class="Symbol">)</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="34870" href="1Lab.Path.html#28690" class="Function Operator">↦</a> <a id="34872" href="1Lab.Path.html#33369" class="Function">double-comp-tube</a> <a id="34889" href="1Lab.Path.html#34847" class="Bound">i</a> <a id="34891" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="34894" href="1Lab.Path.html#28690" class="Function Operator">]</a>
  <a id="34898" href="1Lab.Path.html#34827" class="Function">extensible-at-i1</a> <a id="34915" href="1Lab.Path.html#34915" class="Bound">i</a> <a id="34917" class="Symbol">=</a>
    <a id="34923" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="34927" class="Symbol">(</a><a id="34928" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="34934" class="Symbol">{</a><a id="34935" class="Argument">φ</a> <a id="34937" class="Symbol">=</a> <a id="34939" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="34941" href="1Lab.Path.html#34915" class="Bound">i</a> <a id="34943" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="34945" href="1Lab.Path.html#34915" class="Bound">i</a><a id="34946" class="Symbol">}</a> <a id="34948" class="Symbol">(λ</a> <a id="34951" href="1Lab.Path.html#34951" class="Bound">k</a> <a id="34953" href="1Lab.Path.html#34953" class="Bound">is1</a> <a id="34957" class="Symbol">→</a> <a id="34959" href="1Lab.Path.html#33369" class="Function">double-comp-tube</a> <a id="34976" href="1Lab.Path.html#34915" class="Bound">i</a> <a id="34978" href="1Lab.Path.html#34951" class="Bound">k</a> <a id="34980" href="1Lab.Path.html#34953" class="Bound">is1</a><a id="34983" class="Symbol">)</a> <a id="34985" class="Symbol">(</a><a id="34986" href="1Lab.Path.html#33330" class="Bound">q</a> <a id="34988" href="1Lab.Path.html#34915" class="Bound">i</a><a id="34989" class="Symbol">))</a>
</pre>
<p>Unwinding what it means for this element to exist, we see that the <span class="Agda"><a href="1Lab.Path.html#2368" class="Primitive">hcomp</a></span> operation guarantees the existence of a path <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>→</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">w \to z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span>.</span> It is the face that is hinted at by completing the open box above to a complete square.</p>
<pre class="Agda">  <a id="35234" href="1Lab.Path.html#35234" class="Function">double-comp</a> <a id="35246" class="Symbol">:</a> <a id="35248" href="1Lab.Path.html#33304" class="Bound">w</a> <a data-type="A → A → Type ℓ" id="35250" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="35252" href="1Lab.Path.html#33310" class="Bound">z</a>
  <a id="35256" href="1Lab.Path.html#35234" class="Function">double-comp</a> <a id="35268" href="1Lab.Path.html#35268" class="Bound">i</a> <a id="35270" class="Symbol">=</a> <a id="35272" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="35277" class="Symbol">(</a><a id="35278" href="1Lab.Path.html#34827" class="Function">extensible-at-i1</a> <a id="35295" href="1Lab.Path.html#35268" class="Bound">i</a><a id="35296" class="Symbol">)</a>
</pre>
<p>Note that <span class="Agda"><a href="1Lab.Path.html#2368" class="Primitive">hcomp</a></span> gives us the missing face of the open box, but the semantics guarantees the existence of the box itself, as a <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-cube.</span> From the De Morgan structure on the interval, we can derive the existence of the cubes themselves (called <strong>fillers</strong>) from the existence of the missing faces:</p>
<pre class="Agda"><a id="hfill"></a><a data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ]) →
outS u0 ≡ hcomp u (outS u0)" id="35617" href="1Lab.Path.html#35617" class="Function">hfill</a> <a id="35623" class="Symbol">:</a> <a id="35625" class="Symbol">∀</a> <a id="35627" class="Symbol">{</a><a id="35628" href="1Lab.Path.html#35628" class="Bound">ℓ</a><a id="35629" class="Symbol">}</a> <a id="35631" class="Symbol">{</a><a id="35632" href="1Lab.Path.html#35632" class="Bound">A</a> <a id="35634" class="Symbol">:</a> <a id="35636" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="35641" href="1Lab.Path.html#35628" class="Bound">ℓ</a><a id="35642" class="Symbol">}</a> <a id="35644" class="Symbol">{</a><a id="35645" href="1Lab.Path.html#35645" class="Bound">φ</a> <a id="35647" class="Symbol">:</a> <a id="35649" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="35650" class="Symbol">}</a>
        <a id="35660" class="Symbol">(</a><a id="35661" href="1Lab.Path.html#35661" class="Bound">u</a> <a id="35663" class="Symbol">:</a> <a id="35665" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="35667" class="Symbol">→</a> <a id="35669" href="Agda.Primitive.Cubical.html#1065" class="Primitive">Partial</a> <a id="35677" href="1Lab.Path.html#35645" class="Bound">φ</a> <a id="35679" href="1Lab.Path.html#35632" class="Bound">A</a><a id="35680" class="Symbol">)</a>
        <a id="35690" class="Symbol">(</a><a id="35691" href="1Lab.Path.html#35691" class="Bound">u0</a> <a id="35694" class="Symbol">:</a> <a id="35696" href="1Lab.Path.html#35632" class="Bound">A</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="35698" href="1Lab.Path.html#28690" class="Function Operator">[</a> <a id="35700" href="1Lab.Path.html#35645" class="Bound">φ</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="35702" href="1Lab.Path.html#28690" class="Function Operator">↦</a> <a id="35704" href="1Lab.Path.html#35661" class="Bound">u</a> <a id="35706" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="35709" href="1Lab.Path.html#28690" class="Function Operator">]</a><a id="35710" class="Symbol">)</a>
      <a id="35718" class="Symbol">→</a> <a id="35720" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="35725" href="1Lab.Path.html#35691" class="Bound">u0</a> <a data-type="A → A → Type ℓ" id="35728" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="35730" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="35736" href="1Lab.Path.html#35661" class="Bound">u</a> <a id="35738" class="Symbol">(</a><a id="35739" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="35744" href="1Lab.Path.html#35691" class="Bound">u0</a><a id="35746" class="Symbol">)</a>
<a data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ]) →
outS u0 ≡ hcomp u (outS u0)" id="35748" href="1Lab.Path.html#35617" class="Function">hfill</a> <a id="35754" class="Symbol">{</a><a id="35755" class="Argument">φ</a> <a id="35757" class="Symbol">=</a> <a id="35759" href="1Lab.Path.html#35759" class="Bound">φ</a><a id="35760" class="Symbol">}</a> <a id="35762" href="1Lab.Path.html#35762" class="Bound">u</a> <a id="35764" href="1Lab.Path.html#35764" class="Bound">u0</a> <a id="35767" href="1Lab.Path.html#35767" class="Bound">i</a> <a id="35769" class="Symbol">=</a>
  <a id="35773" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="35779" class="Symbol">(λ</a> <a id="35782" href="1Lab.Path.html#35782" class="Bound">j</a> <a id="35784" class="Symbol">→</a> <a id="35786" class="Symbol">λ</a> <a id="35788" class="Symbol">{</a> <a id="35790" class="Symbol">(</a><a id="35791" href="1Lab.Path.html#35759" class="Bound">φ</a> <a id="35793" class="Symbol">=</a> <a id="35795" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="35797" class="Symbol">)</a> <a id="35799" class="Symbol">→</a> <a id="35801" href="1Lab.Path.html#35762" class="Bound">u</a> <a id="35803" class="Symbol">(</a><a id="35804" href="1Lab.Path.html#35767" class="Bound">i</a> <a id="35806" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="35808" href="1Lab.Path.html#35782" class="Bound">j</a><a id="35809" class="Symbol">)</a> <a id="35811" href="1Lab.Path.html#2443" class="Postulate">1=1</a>
                 <a id="35832" class="Symbol">;</a> <a id="35834" class="Symbol">(</a><a id="35835" href="1Lab.Path.html#35767" class="Bound">i</a> <a id="35837" class="Symbol">=</a> <a id="35839" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="35841" class="Symbol">)</a> <a id="35843" class="Symbol">→</a> <a id="35845" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="35850" href="1Lab.Path.html#35764" class="Bound">u0</a> <a id="35853" class="Symbol">})</a>
        <a id="35864" class="Symbol">(</a><a id="35865" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="35870" href="1Lab.Path.html#35764" class="Bound">u0</a><a id="35872" class="Symbol">)</a>
</pre>
<p><strong>Note</strong>: While every inhabitant of <span class="Agda"><a href="1Lab.Type.html#391" class="Primitive">Type</a></span> has a composition operation, not every <em>type</em> (something that can be on the right of type signature <code>e : T</code>) does. We call the types that <em>do</em> have a composition operation “fibrant”, since these are semantically the cubical sets which are Kan complices. Examples of types which are <em>not</em> fibrant include the interval <span class="Agda"><a href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a></span>, the partial elements <span class="Agda"><a href="Agda.Primitive.Cubical.html#1065" class="Primitive">Partial</a></span>, and the extensions <code>_[_↦_]</code><a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>.</p>
<blockquote>
<p><a id="fibrant"><strong>Definition</strong></a>: A type is <em>fibrant</em> if it supports <span class="Agda"><a href="1Lab.Path.html#2368" class="Primitive">hcomp</a></span>. This word comes up a lot when discussing not only the semantics of Cubical type theory, but also its practice! For instance, the fibrancy of <span class="Agda"><a href="1Lab.Type.html#391" class="Primitive">Type</a></span> is what powers <a href="1Lab.Univalence.html">univalence</a>.</p>
</blockquote>
<p>Agda also provides a <em>heterogeneous</em> version of composition (also called CCHM composition), called <span class="Agda"><a href="1Lab.Path.html#2332" class="Primitive">comp</a></span>. It too has a corresponding filler, called <span class="Agda"><a data-type="(A : I → Type ℓ) (u : (i : I) → Partial φ (A i))
(u0 : A i0 [ φ ↦ u i0 ]) →
PathP A (outS u0) (comp A u (outS u0))" href="1Lab.Path.html#37676" class="Function">fill</a></span>. The idea behind CCHM composition is — by analogy with <span class="Agda"><a href="1Lab.Path.html#2368" class="Primitive">hcomp</a></span> expressing that “paths preserve extensibility” — that <span class="Agda"><a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a></span>s preserve extensibility. Thus we have:</p>
<pre class="Agda"><a id="37428" class="Keyword">private</a>
  <a id="comp-verbose"></a><a id="37438" href="1Lab.Path.html#37438" class="Function">comp-verbose</a> <a id="37451" class="Symbol">:</a> <a id="37453" class="Symbol">∀</a> <a id="37455" class="Symbol">{</a><a id="37456" href="1Lab.Path.html#37456" class="Bound">ℓ</a><a id="37457" class="Symbol">}</a> <a id="37459" class="Symbol">(</a><a id="37460" href="1Lab.Path.html#37460" class="Bound">A</a> <a id="37462" class="Symbol">:</a> <a id="37464" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="37466" class="Symbol">→</a> <a id="37468" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="37473" href="1Lab.Path.html#37456" class="Bound">ℓ</a><a id="37474" class="Symbol">)</a>
                   <a id="37495" class="Symbol">{</a><a id="37496" href="1Lab.Path.html#37496" class="Bound">φ</a> <a id="37498" class="Symbol">:</a> <a id="37500" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="37501" class="Symbol">}</a>
               <a id="37518" class="Symbol">→</a> <a id="37520" class="Symbol">(</a><a id="37521" href="1Lab.Path.html#37521" class="Bound">u</a> <a id="37523" class="Symbol">:</a> <a id="37525" class="Symbol">∀</a> <a id="37527" href="1Lab.Path.html#37527" class="Bound">i</a> <a id="37529" class="Symbol">→</a> <a id="37531" href="Agda.Primitive.Cubical.html#1065" class="Primitive">Partial</a> <a id="37539" href="1Lab.Path.html#37496" class="Bound">φ</a> <a id="37541" class="Symbol">(</a><a id="37542" href="1Lab.Path.html#37460" class="Bound">A</a> <a id="37544" href="1Lab.Path.html#37527" class="Bound">i</a><a id="37545" class="Symbol">))</a>
               <a id="37563" class="Symbol">→</a> <a id="37565" class="Symbol">(</a><a id="37566" href="1Lab.Path.html#37566" class="Bound">u0</a> <a id="37569" class="Symbol">:</a> <a id="37571" href="1Lab.Path.html#37460" class="Bound">A</a> <a id="37573" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="37576" href="1Lab.Path.html#28690" class="Function Operator">[</a> <a id="37578" href="1Lab.Path.html#37496" class="Bound">φ</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="37580" href="1Lab.Path.html#28690" class="Function Operator">↦</a> <a id="37582" href="1Lab.Path.html#37521" class="Bound">u</a> <a id="37584" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="37587" href="1Lab.Path.html#28690" class="Function Operator">]</a> <a id="37589" class="Symbol">)</a>
               <a id="37606" class="Symbol">→</a> <a id="37608" href="1Lab.Path.html#37460" class="Bound">A</a> <a id="37610" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="37613" href="1Lab.Path.html#28690" class="Function Operator">[</a> <a id="37615" href="1Lab.Path.html#37496" class="Bound">φ</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="37617" href="1Lab.Path.html#28690" class="Function Operator">↦</a> <a id="37619" href="1Lab.Path.html#37521" class="Bound">u</a> <a id="37621" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="37624" href="1Lab.Path.html#28690" class="Function Operator">]</a>
  <a id="37628" href="1Lab.Path.html#37438" class="Function">comp-verbose</a> <a id="37641" href="1Lab.Path.html#37641" class="Bound">A</a> <a id="37643" href="1Lab.Path.html#37643" class="Bound">u</a> <a id="37645" href="1Lab.Path.html#37645" class="Bound">u0</a> <a id="37648" class="Symbol">=</a> <a id="37650" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="37654" class="Symbol">(</a><a id="37655" href="1Lab.Path.html#2332" class="Primitive">comp</a> <a id="37660" href="1Lab.Path.html#37641" class="Bound">A</a> <a id="37662" href="1Lab.Path.html#37643" class="Bound">u</a> <a id="37664" class="Symbol">(</a><a id="37665" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="37670" href="1Lab.Path.html#37645" class="Bound">u0</a><a id="37672" class="Symbol">))</a>

<a id="fill"></a><a data-type="(A : I → Type ℓ) (u : (i : I) → Partial φ (A i))
(u0 : A i0 [ φ ↦ u i0 ]) →
PathP A (outS u0) (comp A u (outS u0))" id="37676" href="1Lab.Path.html#37676" class="Function">fill</a> <a id="37681" class="Symbol">:</a> <a id="37683" class="Symbol">∀</a> <a id="37685" class="Symbol">{</a><a id="37686" href="1Lab.Path.html#37686" class="Bound">ℓ</a><a id="37687" class="Symbol">}</a> <a id="37689" class="Symbol">(</a><a id="37690" href="1Lab.Path.html#37690" class="Bound">A</a> <a id="37692" class="Symbol">:</a> <a id="37694" class="Symbol">∀</a> <a id="37696" href="1Lab.Path.html#37696" class="Bound">i</a> <a id="37698" class="Symbol">→</a> <a id="37700" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="37705" href="1Lab.Path.html#37686" class="Bound">ℓ</a><a id="37706" class="Symbol">)</a>
       <a id="37715" class="Symbol">{</a><a id="37716" href="1Lab.Path.html#37716" class="Bound">φ</a> <a id="37718" class="Symbol">:</a> <a id="37720" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="37721" class="Symbol">}</a>
     <a id="37728" class="Symbol">→</a> <a id="37730" class="Symbol">(</a><a id="37731" href="1Lab.Path.html#37731" class="Bound">u</a> <a id="37733" class="Symbol">:</a> <a id="37735" class="Symbol">∀</a> <a id="37737" href="1Lab.Path.html#37737" class="Bound">i</a> <a id="37739" class="Symbol">→</a> <a id="37741" href="Agda.Primitive.Cubical.html#1065" class="Primitive">Partial</a> <a id="37749" href="1Lab.Path.html#37716" class="Bound">φ</a> <a id="37751" class="Symbol">(</a><a id="37752" href="1Lab.Path.html#37690" class="Bound">A</a> <a id="37754" href="1Lab.Path.html#37737" class="Bound">i</a><a id="37755" class="Symbol">))</a>
     <a id="37763" class="Symbol">→</a> <a id="37765" class="Symbol">(</a><a id="37766" href="1Lab.Path.html#37766" class="Bound">u0</a> <a id="37769" class="Symbol">:</a> <a id="37771" href="1Lab.Path.html#37690" class="Bound">A</a> <a id="37773" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="37776" href="1Lab.Path.html#28690" class="Function Operator">[</a> <a id="37778" href="1Lab.Path.html#37716" class="Bound">φ</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="37780" href="1Lab.Path.html#28690" class="Function Operator">↦</a> <a id="37782" href="1Lab.Path.html#37731" class="Bound">u</a> <a id="37784" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="37787" href="1Lab.Path.html#28690" class="Function Operator">]</a><a id="37788" class="Symbol">)</a>
     <a id="37795" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="37797" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="37803" href="1Lab.Path.html#37690" class="Bound">A</a> <a id="37805" class="Symbol">(</a><a id="37806" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="37811" href="1Lab.Path.html#37766" class="Bound">u0</a><a id="37813" class="Symbol">)</a> <a id="37815" class="Symbol">(</a><a id="37816" href="1Lab.Path.html#2332" class="Primitive">comp</a> <a id="37821" href="1Lab.Path.html#37690" class="Bound">A</a> <a id="37823" href="1Lab.Path.html#37731" class="Bound">u</a> <a id="37825" class="Symbol">(</a><a id="37826" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="37831" href="1Lab.Path.html#37766" class="Bound">u0</a><a id="37833" class="Symbol">))</a>
<a data-type="(A : I → Type ℓ) (u : (i : I) → Partial φ (A i))
(u0 : A i0 [ φ ↦ u i0 ]) →
PathP A (outS u0) (comp A u (outS u0))" id="37836" href="1Lab.Path.html#37676" class="Function">fill</a> <a id="37841" href="1Lab.Path.html#37841" class="Bound">A</a> <a id="37843" class="Symbol">{</a><a id="37844" class="Argument">φ</a> <a id="37846" class="Symbol">=</a> <a id="37848" href="1Lab.Path.html#37848" class="Bound">φ</a><a id="37849" class="Symbol">}</a> <a id="37851" href="1Lab.Path.html#37851" class="Bound">u</a> <a id="37853" href="1Lab.Path.html#37853" class="Bound">u0</a> <a id="37856" href="1Lab.Path.html#37856" class="Bound">i</a> <a id="37858" class="Symbol">=</a>
  <a id="37862" href="1Lab.Path.html#2332" class="Primitive">comp</a> <a id="37867" class="Symbol">(λ</a> <a id="37870" href="1Lab.Path.html#37870" class="Bound">j</a> <a id="37872" class="Symbol">→</a> <a id="37874" href="1Lab.Path.html#37841" class="Bound">A</a> <a id="37876" class="Symbol">(</a><a id="37877" href="1Lab.Path.html#37856" class="Bound">i</a> <a id="37879" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="37881" href="1Lab.Path.html#37870" class="Bound">j</a><a id="37882" class="Symbol">))</a>
       <a id="37892" class="Symbol">(λ</a> <a id="37895" href="1Lab.Path.html#37895" class="Bound">j</a> <a id="37897" class="Symbol">→</a> <a id="37899" class="Symbol">λ</a> <a id="37901" class="Symbol">{</a> <a id="37903" class="Symbol">(</a><a id="37904" href="1Lab.Path.html#37848" class="Bound">φ</a> <a id="37906" class="Symbol">=</a> <a id="37908" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="37910" class="Symbol">)</a> <a id="37912" class="Symbol">→</a> <a id="37914" href="1Lab.Path.html#37851" class="Bound">u</a> <a id="37916" class="Symbol">(</a><a id="37917" href="1Lab.Path.html#37856" class="Bound">i</a> <a id="37919" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="37921" href="1Lab.Path.html#37895" class="Bound">j</a><a id="37922" class="Symbol">)</a> <a id="37924" href="1Lab.Path.html#2443" class="Postulate">1=1</a>
                <a id="37944" class="Symbol">;</a> <a id="37946" class="Symbol">(</a><a id="37947" href="1Lab.Path.html#37856" class="Bound">i</a> <a id="37949" class="Symbol">=</a> <a id="37951" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="37953" class="Symbol">)</a> <a id="37955" class="Symbol">→</a> <a id="37957" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="37962" href="1Lab.Path.html#37853" class="Bound">u0</a> <a id="37965" class="Symbol">})</a>
       <a id="37975" class="Symbol">(</a><a id="37976" href="1Lab.Path.html#2100" class="Primitive">outS</a> <a id="37981" href="1Lab.Path.html#37853" class="Bound">u0</a><a id="37983" class="Symbol">)</a>
</pre>
<p>Given the inputs to a composition — a family of partial paths <code>u</code> and a base <code>u0</code> — <span class="Agda"><a data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ]) →
outS u0 ≡ hcomp u (outS u0)" href="1Lab.Path.html#35617" class="Function">hfill</a></span> connects the input of the composition (<code>u0</code>) and the output. The cubical shape of iterated identifications causes a slight oddity: The only unbiased definition of path composition we can give is <em>double composition</em>, which corresponds to the missing face for the <a href="1Lab.Path.html#composition">square</a> at the start of this section.</p>
<pre class="Agda"><a id="_··_··_"></a><a data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" id="38442" href="1Lab.Path.html#38442" class="Function Operator">_··_··_</a> <a id="38450" class="Symbol">:</a> <a id="38452" class="Symbol">∀</a> <a id="38454" class="Symbol">{</a><a id="38455" href="1Lab.Path.html#38455" class="Bound">ℓ</a><a id="38456" class="Symbol">}</a> <a id="38458" class="Symbol">{</a><a id="38459" href="1Lab.Path.html#38459" class="Bound">A</a> <a id="38461" class="Symbol">:</a> <a id="38463" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="38468" href="1Lab.Path.html#38455" class="Bound">ℓ</a><a id="38469" class="Symbol">}</a> <a id="38471" class="Symbol">{</a><a id="38472" href="1Lab.Path.html#38472" class="Bound">w</a> <a id="38474" href="1Lab.Path.html#38474" class="Bound">x</a> <a id="38476" href="1Lab.Path.html#38476" class="Bound">y</a> <a id="38478" href="1Lab.Path.html#38478" class="Bound">z</a> <a id="38480" class="Symbol">:</a> <a id="38482" href="1Lab.Path.html#38459" class="Bound">A</a><a id="38483" class="Symbol">}</a>
        <a id="38493" class="Symbol">→</a> <a id="38495" href="1Lab.Path.html#38472" class="Bound">w</a> <a data-type="A → A → Type ℓ" id="38497" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="38499" href="1Lab.Path.html#38474" class="Bound">x</a> <a id="38501" class="Symbol">→</a> <a id="38503" href="1Lab.Path.html#38474" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="38505" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="38507" href="1Lab.Path.html#38476" class="Bound">y</a> <a id="38509" class="Symbol">→</a> <a id="38511" href="1Lab.Path.html#38476" class="Bound">y</a> <a data-type="A → A → Type ℓ" id="38513" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="38515" href="1Lab.Path.html#38478" class="Bound">z</a>
        <a id="38525" class="Symbol">→</a> <a id="38527" href="1Lab.Path.html#38472" class="Bound">w</a> <a data-type="A → A → Type ℓ" id="38529" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="38531" href="1Lab.Path.html#38478" class="Bound">z</a>
<a id="38533" class="Symbol">(</a><a id="38534" href="1Lab.Path.html#38534" class="Bound">p</a> <a data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" id="38536" href="1Lab.Path.html#38442" class="Function Operator">··</a> <a id="38539" href="1Lab.Path.html#38539" class="Bound">q</a> <a data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" id="38541" href="1Lab.Path.html#38442" class="Function Operator">··</a> <a id="38544" href="1Lab.Path.html#38544" class="Bound">r</a><a id="38545" class="Symbol">)</a> <a id="38547" href="1Lab.Path.html#38547" class="Bound">i</a> <a id="38549" class="Symbol">=</a>
  <a id="38553" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="38559" class="Symbol">(λ</a> <a id="38562" href="1Lab.Path.html#38562" class="Bound">j</a> <a id="38564" class="Symbol">→</a> <a id="38566" class="Symbol">λ</a> <a id="38568" class="Symbol">{</a> <a id="38570" class="Symbol">(</a><a id="38571" href="1Lab.Path.html#38547" class="Bound">i</a> <a id="38573" class="Symbol">=</a> <a id="38575" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="38577" class="Symbol">)</a> <a id="38579" class="Symbol">→</a> <a id="38581" href="1Lab.Path.html#38534" class="Bound">p</a> <a id="38583" class="Symbol">(</a><a id="38584" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="38586" href="1Lab.Path.html#38562" class="Bound">j</a><a id="38587" class="Symbol">)</a>
                 <a id="38606" class="Symbol">;</a> <a id="38608" class="Symbol">(</a><a id="38609" href="1Lab.Path.html#38547" class="Bound">i</a> <a id="38611" class="Symbol">=</a> <a id="38613" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="38615" class="Symbol">)</a> <a id="38617" class="Symbol">→</a> <a id="38619" href="1Lab.Path.html#38544" class="Bound">r</a> <a id="38621" href="1Lab.Path.html#38562" class="Bound">j</a> <a id="38623" class="Symbol">})</a>
        <a id="38634" class="Symbol">(</a><a id="38635" href="1Lab.Path.html#38539" class="Bound">q</a> <a id="38637" href="1Lab.Path.html#38547" class="Bound">i</a><a id="38638" class="Symbol">)</a>
</pre>
<p>Since it will be useful later, we also give an explicit name for the filler of the double composition square.</p>
<pre class="Agda"><a id="··-filler"></a><a data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z) →
Square (sym p) q (p ·· q ·· r) r" id="38760" href="1Lab.Path.html#38760" class="Function">··-filler</a> <a id="38770" class="Symbol">:</a> <a id="38772" class="Symbol">∀</a> <a id="38774" class="Symbol">{</a><a id="38775" href="1Lab.Path.html#38775" class="Bound">ℓ</a><a id="38776" class="Symbol">}</a> <a id="38778" class="Symbol">{</a><a id="38779" href="1Lab.Path.html#38779" class="Bound">A</a> <a id="38781" class="Symbol">:</a> <a id="38783" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="38788" href="1Lab.Path.html#38775" class="Bound">ℓ</a><a id="38789" class="Symbol">}</a> <a id="38791" class="Symbol">{</a><a id="38792" href="1Lab.Path.html#38792" class="Bound">w</a> <a id="38794" href="1Lab.Path.html#38794" class="Bound">x</a> <a id="38796" href="1Lab.Path.html#38796" class="Bound">y</a> <a id="38798" href="1Lab.Path.html#38798" class="Bound">z</a> <a id="38800" class="Symbol">:</a> <a id="38802" href="1Lab.Path.html#38779" class="Bound">A</a><a id="38803" class="Symbol">}</a>
          <a id="38815" class="Symbol">→</a> <a id="38817" class="Symbol">(</a><a id="38818" href="1Lab.Path.html#38818" class="Bound">p</a> <a id="38820" class="Symbol">:</a> <a id="38822" href="1Lab.Path.html#38792" class="Bound">w</a> <a data-type="A → A → Type ℓ" id="38824" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="38826" href="1Lab.Path.html#38794" class="Bound">x</a><a id="38827" class="Symbol">)</a> <a id="38829" class="Symbol">(</a><a id="38830" href="1Lab.Path.html#38830" class="Bound">q</a> <a id="38832" class="Symbol">:</a> <a id="38834" href="1Lab.Path.html#38794" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="38836" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="38838" href="1Lab.Path.html#38796" class="Bound">y</a><a id="38839" class="Symbol">)</a> <a id="38841" class="Symbol">(</a><a id="38842" href="1Lab.Path.html#38842" class="Bound">r</a> <a id="38844" class="Symbol">:</a> <a id="38846" href="1Lab.Path.html#38796" class="Bound">y</a> <a data-type="A → A → Type ℓ" id="38848" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="38850" href="1Lab.Path.html#38798" class="Bound">z</a><a id="38851" class="Symbol">)</a>
          <a id="38863" class="Symbol">→</a> <a data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" id="38865" href="1Lab.Path.html#9481" class="Function">Square</a> <a id="38872" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="38873" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="38877" href="1Lab.Path.html#38818" class="Bound">p</a><a id="38878" class="Symbol">)</a> <a id="38880" href="1Lab.Path.html#38830" class="Bound">q</a> <a id="38882" class="Symbol">(</a><a id="38883" href="1Lab.Path.html#38818" class="Bound">p</a> <a data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" id="38885" href="1Lab.Path.html#38442" class="Function Operator">··</a> <a id="38888" href="1Lab.Path.html#38830" class="Bound">q</a> <a data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" id="38890" href="1Lab.Path.html#38442" class="Function Operator">··</a> <a id="38893" href="1Lab.Path.html#38842" class="Bound">r</a><a id="38894" class="Symbol">)</a> <a id="38896" href="1Lab.Path.html#38842" class="Bound">r</a>
<a data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z) →
Square (sym p) q (p ·· q ·· r) r" id="38898" href="1Lab.Path.html#38760" class="Function">··-filler</a> <a id="38908" href="1Lab.Path.html#38908" class="Bound">p</a> <a id="38910" href="1Lab.Path.html#38910" class="Bound">q</a> <a id="38912" href="1Lab.Path.html#38912" class="Bound">r</a> <a id="38914" href="1Lab.Path.html#38914" class="Bound">i</a> <a id="38916" href="1Lab.Path.html#38916" class="Bound">j</a> <a id="38918" class="Symbol">=</a>
  <a data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ]) →
outS u0 ≡ hcomp u (outS u0)" id="38922" href="1Lab.Path.html#35617" class="Function">hfill</a> <a id="38928" class="Symbol">(λ</a> <a id="38931" href="1Lab.Path.html#38931" class="Bound">k</a> <a id="38933" class="Symbol">→</a> <a id="38935" class="Symbol">λ</a> <a id="38937" class="Symbol">{</a> <a id="38939" class="Symbol">(</a><a id="38940" href="1Lab.Path.html#38916" class="Bound">j</a> <a id="38942" class="Symbol">=</a> <a id="38944" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="38946" class="Symbol">)</a> <a id="38948" class="Symbol">→</a> <a id="38950" href="1Lab.Path.html#38908" class="Bound">p</a> <a id="38952" class="Symbol">(</a><a id="38953" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="38955" href="1Lab.Path.html#38931" class="Bound">k</a><a id="38956" class="Symbol">)</a>
                 <a id="38975" class="Symbol">;</a> <a id="38977" class="Symbol">(</a><a id="38978" href="1Lab.Path.html#38916" class="Bound">j</a> <a id="38980" class="Symbol">=</a> <a id="38982" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="38984" class="Symbol">)</a> <a id="38986" class="Symbol">→</a> <a id="38988" href="1Lab.Path.html#38912" class="Bound">r</a> <a id="38990" href="1Lab.Path.html#38931" class="Bound">k</a> <a id="38992" class="Symbol">})</a>
        <a id="39003" class="Symbol">(</a><a id="39004" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="39008" class="Symbol">(</a><a id="39009" href="1Lab.Path.html#38910" class="Bound">q</a> <a id="39011" href="1Lab.Path.html#38916" class="Bound">j</a><a id="39012" class="Symbol">))</a> <a id="39015" href="1Lab.Path.html#38914" class="Bound">i</a>
</pre>
<p>We can define the ordinary, single composition by taking <code>p = refl</code>, as is done below. The square associated with the binary composition operation is obtained as the same open box at the start of the section, the same <span class="Agda"><a href="1Lab.Path.html#33369" class="Function">double-comp-tube</a></span>, but by setting any of the faces to be reflexivity. For definiteness, we chose the left face:</p>
<div class="diagram-container">
<img src="1baa73551bb004637d2d984a025914570ddc642a.svg" title="commutative diagram" class="diagram quiver" />
</div>
<pre class="Agda"><a id="_∙_"></a><a data-type="x ≡ y → y ≡ z → x ≡ z" id="39613" href="1Lab.Path.html#39613" class="Function Operator">_∙_</a> <a id="39617" class="Symbol">:</a> <a id="39619" class="Symbol">∀</a> <a id="39621" class="Symbol">{</a><a id="39622" href="1Lab.Path.html#39622" class="Bound">ℓ</a><a id="39623" class="Symbol">}</a> <a id="39625" class="Symbol">{</a><a id="39626" href="1Lab.Path.html#39626" class="Bound">A</a> <a id="39628" class="Symbol">:</a> <a id="39630" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="39635" href="1Lab.Path.html#39622" class="Bound">ℓ</a><a id="39636" class="Symbol">}</a> <a id="39638" class="Symbol">{</a><a id="39639" href="1Lab.Path.html#39639" class="Bound">x</a> <a id="39641" href="1Lab.Path.html#39641" class="Bound">y</a> <a id="39643" href="1Lab.Path.html#39643" class="Bound">z</a> <a id="39645" class="Symbol">:</a> <a id="39647" href="1Lab.Path.html#39626" class="Bound">A</a><a id="39648" class="Symbol">}</a>
    <a id="39654" class="Symbol">→</a> <a id="39656" href="1Lab.Path.html#39639" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="39658" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="39660" href="1Lab.Path.html#39641" class="Bound">y</a> <a id="39662" class="Symbol">→</a> <a id="39664" href="1Lab.Path.html#39641" class="Bound">y</a> <a data-type="A → A → Type ℓ" id="39666" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="39668" href="1Lab.Path.html#39643" class="Bound">z</a> <a id="39670" class="Symbol">→</a> <a id="39672" href="1Lab.Path.html#39639" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="39674" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="39676" href="1Lab.Path.html#39643" class="Bound">z</a>
<a id="39678" href="1Lab.Path.html#39678" class="Bound">p</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="39680" href="1Lab.Path.html#39613" class="Function Operator">∙</a> <a id="39682" href="1Lab.Path.html#39682" class="Bound">q</a> <a id="39684" class="Symbol">=</a> <a data-type="x ≡ x" id="39686" href="1Lab.Path.html#3593" class="Function">refl</a> <a data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" id="39691" href="1Lab.Path.html#38442" class="Function Operator">··</a> <a id="39694" href="1Lab.Path.html#39678" class="Bound">p</a> <a data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" id="39696" href="1Lab.Path.html#38442" class="Function Operator">··</a> <a id="39699" href="1Lab.Path.html#39682" class="Bound">q</a>
</pre>
<p>The ordinary, “single composite” of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> is the dashed face in the diagram above. Since we bound <span class="Agda"><a data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z) →
Square (sym p) q (p ·· q ·· r) r" href="1Lab.Path.html#38760" class="Function">··-filler</a></span> above, and defined <span class="Agda"><a data-type="x ≡ y → y ≡ z → x ≡ z" href="1Lab.Path.html#39613" class="Function Operator">_∙_</a></span> in terms of <span class="Agda"><a data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" href="1Lab.Path.html#38442" class="Function Operator">_··_··_</a></span>, we can reuse the latter’s filler to get one for the former:</p>
<pre class="Agda"><a id="∙-filler"></a><a data-type="(p : x ≡ y) (q : y ≡ z) → Square refl p (p ∙ q) q" id="39961" href="1Lab.Path.html#39961" class="Function">∙-filler</a> <a id="39970" class="Symbol">:</a> <a id="39972" class="Symbol">∀</a> <a id="39974" class="Symbol">{</a><a id="39975" href="1Lab.Path.html#39975" class="Bound">ℓ</a><a id="39976" class="Symbol">}</a> <a id="39978" class="Symbol">{</a><a id="39979" href="1Lab.Path.html#39979" class="Bound">A</a> <a id="39981" class="Symbol">:</a> <a id="39983" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="39988" href="1Lab.Path.html#39975" class="Bound">ℓ</a><a id="39989" class="Symbol">}</a> <a id="39991" class="Symbol">{</a><a id="39992" href="1Lab.Path.html#39992" class="Bound">x</a> <a id="39994" href="1Lab.Path.html#39994" class="Bound">y</a> <a id="39996" href="1Lab.Path.html#39996" class="Bound">z</a> <a id="39998" class="Symbol">:</a> <a id="40000" href="1Lab.Path.html#39979" class="Bound">A</a><a id="40001" class="Symbol">}</a>
         <a id="40012" class="Symbol">→</a> <a id="40014" class="Symbol">(</a><a id="40015" href="1Lab.Path.html#40015" class="Bound">p</a> <a id="40017" class="Symbol">:</a> <a id="40019" href="1Lab.Path.html#39992" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="40021" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="40023" href="1Lab.Path.html#39994" class="Bound">y</a><a id="40024" class="Symbol">)</a> <a id="40026" class="Symbol">(</a><a id="40027" href="1Lab.Path.html#40027" class="Bound">q</a> <a id="40029" class="Symbol">:</a> <a id="40031" href="1Lab.Path.html#39994" class="Bound">y</a> <a data-type="A → A → Type ℓ" id="40033" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="40035" href="1Lab.Path.html#39996" class="Bound">z</a><a id="40036" class="Symbol">)</a>
         <a id="40047" class="Symbol">→</a> <a data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" id="40049" href="1Lab.Path.html#9481" class="Function">Square</a> <a data-type="x ≡ x" id="40056" href="1Lab.Path.html#3593" class="Function">refl</a> <a id="40061" href="1Lab.Path.html#40015" class="Bound">p</a> <a id="40063" class="Symbol">(</a><a id="40064" href="1Lab.Path.html#40015" class="Bound">p</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="40066" href="1Lab.Path.html#39613" class="Function Operator">∙</a> <a id="40068" href="1Lab.Path.html#40027" class="Bound">q</a><a id="40069" class="Symbol">)</a> <a id="40071" href="1Lab.Path.html#40027" class="Bound">q</a>
<a data-type="(p : x ≡ y) (q : y ≡ z) → Square refl p (p ∙ q) q" id="40073" href="1Lab.Path.html#39961" class="Function">∙-filler</a> <a id="40082" class="Symbol">{</a><a id="40083" class="Argument">x</a> <a id="40085" class="Symbol">=</a> <a id="40087" href="1Lab.Path.html#40087" class="Bound">x</a><a id="40088" class="Symbol">}</a> <a id="40090" class="Symbol">{</a><a id="40091" href="1Lab.Path.html#40091" class="Bound">y</a><a id="40092" class="Symbol">}</a> <a id="40094" class="Symbol">{</a><a id="40095" href="1Lab.Path.html#40095" class="Bound">z</a><a id="40096" class="Symbol">}</a> <a id="40098" href="1Lab.Path.html#40098" class="Bound">p</a> <a id="40100" href="1Lab.Path.html#40100" class="Bound">q</a> <a id="40102" class="Symbol">=</a> <a data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z) →
Square (sym p) q (p ·· q ·· r) r" id="40104" href="1Lab.Path.html#38760" class="Function">··-filler</a> <a data-type="x ≡ x" id="40114" href="1Lab.Path.html#3593" class="Function">refl</a> <a id="40119" href="1Lab.Path.html#40098" class="Bound">p</a> <a id="40121" href="1Lab.Path.html#40100" class="Bound">q</a>
</pre>
<p>The single composition has a filler “in the other direction”, which connects <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span> and <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>∙</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">p \bullet q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∙</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>.</span> This is, essentially, because the choice of setting the left face to <span class="Agda"><a data-type="x ≡ x" href="1Lab.Path.html#3593" class="Function">refl</a></span> was completely arbitrary in the definition of <span class="Agda"><a data-type="x ≡ y → y ≡ z → x ≡ z" href="1Lab.Path.html#39613" class="Function Operator">_∙_</a></span>: we could just as well have gone with setting the <em>right</em> face to <span class="Agda"><a data-type="x ≡ x" href="1Lab.Path.html#3593" class="Function">refl</a></span>.</p>
<pre class="Agda"><a id="∙-filler&#39;"></a><a data-type="(p : x ≡ y) (q : y ≡ z) → Square (sym p) q (p ∙ q) refl" id="40460" href="1Lab.Path.html#40460" class="Function">∙-filler&#39;</a> <a id="40470" class="Symbol">:</a> <a id="40472" class="Symbol">∀</a> <a id="40474" class="Symbol">{</a><a id="40475" href="1Lab.Path.html#40475" class="Bound">ℓ</a><a id="40476" class="Symbol">}</a> <a id="40478" class="Symbol">{</a><a id="40479" href="1Lab.Path.html#40479" class="Bound">A</a> <a id="40481" class="Symbol">:</a> <a id="40483" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="40488" href="1Lab.Path.html#40475" class="Bound">ℓ</a><a id="40489" class="Symbol">}</a> <a id="40491" class="Symbol">{</a><a id="40492" href="1Lab.Path.html#40492" class="Bound">x</a> <a id="40494" href="1Lab.Path.html#40494" class="Bound">y</a> <a id="40496" href="1Lab.Path.html#40496" class="Bound">z</a> <a id="40498" class="Symbol">:</a> <a id="40500" href="1Lab.Path.html#40479" class="Bound">A</a><a id="40501" class="Symbol">}</a>
          <a id="40513" class="Symbol">→</a> <a id="40515" class="Symbol">(</a><a id="40516" href="1Lab.Path.html#40516" class="Bound">p</a> <a id="40518" class="Symbol">:</a> <a id="40520" href="1Lab.Path.html#40492" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="40522" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="40524" href="1Lab.Path.html#40494" class="Bound">y</a><a id="40525" class="Symbol">)</a> <a id="40527" class="Symbol">(</a><a id="40528" href="1Lab.Path.html#40528" class="Bound">q</a> <a id="40530" class="Symbol">:</a> <a id="40532" href="1Lab.Path.html#40494" class="Bound">y</a> <a data-type="A → A → Type ℓ" id="40534" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="40536" href="1Lab.Path.html#40496" class="Bound">z</a><a id="40537" class="Symbol">)</a>
          <a id="40549" class="Symbol">→</a> <a data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" id="40551" href="1Lab.Path.html#9481" class="Function">Square</a> <a id="40558" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="40559" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="40563" href="1Lab.Path.html#40516" class="Bound">p</a><a id="40564" class="Symbol">)</a> <a id="40566" href="1Lab.Path.html#40528" class="Bound">q</a> <a id="40568" class="Symbol">(</a><a id="40569" href="1Lab.Path.html#40516" class="Bound">p</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="40571" href="1Lab.Path.html#39613" class="Function Operator">∙</a> <a id="40573" href="1Lab.Path.html#40528" class="Bound">q</a><a id="40574" class="Symbol">)</a> <a data-type="x ≡ x" id="40576" href="1Lab.Path.html#3593" class="Function">refl</a>
<a data-type="(p : x ≡ y) (q : y ≡ z) → Square (sym p) q (p ∙ q) refl" id="40581" href="1Lab.Path.html#40460" class="Function">∙-filler&#39;</a> <a id="40591" class="Symbol">{</a><a id="40592" class="Argument">x</a> <a id="40594" class="Symbol">=</a> <a id="40596" href="1Lab.Path.html#40596" class="Bound">x</a><a id="40597" class="Symbol">}</a> <a id="40599" class="Symbol">{</a><a id="40600" href="1Lab.Path.html#40600" class="Bound">y</a><a id="40601" class="Symbol">}</a> <a id="40603" class="Symbol">{</a><a id="40604" href="1Lab.Path.html#40604" class="Bound">z</a><a id="40605" class="Symbol">}</a> <a id="40607" href="1Lab.Path.html#40607" class="Bound">p</a> <a id="40609" href="1Lab.Path.html#40609" class="Bound">q</a> <a id="40611" href="1Lab.Path.html#40611" class="Bound">j</a> <a id="40613" href="1Lab.Path.html#40613" class="Bound">i</a> <a id="40615" class="Symbol">=</a>
  <a id="40619" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="40625" class="Symbol">(λ</a> <a id="40628" href="1Lab.Path.html#40628" class="Bound">k</a> <a id="40630" class="Symbol">→</a> <a id="40632" class="Symbol">λ</a> <a id="40634" class="Symbol">{</a> <a id="40636" class="Symbol">(</a><a id="40637" href="1Lab.Path.html#40613" class="Bound">i</a> <a id="40639" class="Symbol">=</a> <a id="40641" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="40643" class="Symbol">)</a> <a id="40645" class="Symbol">→</a> <a id="40647" href="1Lab.Path.html#40607" class="Bound">p</a> <a id="40649" class="Symbol">(</a><a id="40650" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="40652" href="1Lab.Path.html#40611" class="Bound">j</a><a id="40653" class="Symbol">)</a>
                 <a id="40672" class="Symbol">;</a> <a id="40674" class="Symbol">(</a><a id="40675" href="1Lab.Path.html#40613" class="Bound">i</a> <a id="40677" class="Symbol">=</a> <a id="40679" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="40681" class="Symbol">)</a> <a id="40683" class="Symbol">→</a> <a id="40685" href="1Lab.Path.html#40609" class="Bound">q</a> <a id="40687" href="1Lab.Path.html#40628" class="Bound">k</a>
                 <a id="40706" class="Symbol">;</a> <a id="40708" class="Symbol">(</a><a id="40709" href="1Lab.Path.html#40611" class="Bound">j</a> <a id="40711" class="Symbol">=</a> <a id="40713" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="40715" class="Symbol">)</a> <a id="40717" class="Symbol">→</a> <a id="40719" href="1Lab.Path.html#40609" class="Bound">q</a> <a id="40721" class="Symbol">(</a><a id="40722" href="1Lab.Path.html#40613" class="Bound">i</a> <a id="40724" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="40726" href="1Lab.Path.html#40628" class="Bound">k</a><a id="40727" class="Symbol">)</a> <a id="40729" class="Symbol">})</a>
        <a id="40740" class="Symbol">(</a><a id="40741" href="1Lab.Path.html#40607" class="Bound">p</a> <a id="40743" class="Symbol">(</a><a id="40744" href="1Lab.Path.html#40613" class="Bound">i</a> <a id="40746" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="40748" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="40750" href="1Lab.Path.html#40611" class="Bound">j</a><a id="40751" class="Symbol">))</a>
</pre>
<h2 id="uniqueness"><a href="#uniqueness" class="header-link">Uniqueness<span class="header-link-emoji">🔗</span></a></h2>
<p>A common characteristic of <em>geometric</em> interpretations of higher categories — like the one we have here — when compared to algebraic definitions is that there is no prescription in general for how to find composites of morphisms. Instead, we have that each triple of morphism has a <em>contractible space</em> of composites. We call the proof of this fact <span class="Agda"><a data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z)
(α β : Σ (λ s → Square (sym p) q s r)) →
α ≡ β" href="1Lab.Path.html#41156" class="Function">··-unique</a></span>:</p>
<pre class="Agda"><a id="··-unique"></a><a data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z)
(α β : Σ (λ s → Square (sym p) q s r)) →
α ≡ β" id="41156" href="1Lab.Path.html#41156" class="Function">··-unique</a> <a id="41166" class="Symbol">:</a> <a id="41168" class="Symbol">∀</a> <a id="41170" class="Symbol">{</a><a id="41171" href="1Lab.Path.html#41171" class="Bound">ℓ</a><a id="41172" class="Symbol">}</a> <a id="41174" class="Symbol">{</a><a id="41175" href="1Lab.Path.html#41175" class="Bound">A</a> <a id="41177" class="Symbol">:</a> <a id="41179" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="41184" href="1Lab.Path.html#41171" class="Bound">ℓ</a><a id="41185" class="Symbol">}</a> <a id="41187" class="Symbol">{</a><a id="41188" href="1Lab.Path.html#41188" class="Bound">w</a> <a id="41190" href="1Lab.Path.html#41190" class="Bound">x</a> <a id="41192" href="1Lab.Path.html#41192" class="Bound">y</a> <a id="41194" href="1Lab.Path.html#41194" class="Bound">z</a> <a id="41196" class="Symbol">:</a> <a id="41198" href="1Lab.Path.html#41175" class="Bound">A</a><a id="41199" class="Symbol">}</a>
          <a id="41211" class="Symbol">→</a> <a id="41213" class="Symbol">(</a><a id="41214" href="1Lab.Path.html#41214" class="Bound">p</a> <a id="41216" class="Symbol">:</a> <a id="41218" href="1Lab.Path.html#41188" class="Bound">w</a> <a data-type="A → A → Type ℓ" id="41220" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="41222" href="1Lab.Path.html#41190" class="Bound">x</a><a id="41223" class="Symbol">)</a> <a id="41225" class="Symbol">(</a><a id="41226" href="1Lab.Path.html#41226" class="Bound">q</a> <a id="41228" class="Symbol">:</a> <a id="41230" href="1Lab.Path.html#41190" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="41232" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="41234" href="1Lab.Path.html#41192" class="Bound">y</a><a id="41235" class="Symbol">)</a> <a id="41237" class="Symbol">(</a><a id="41238" href="1Lab.Path.html#41238" class="Bound">r</a> <a id="41240" class="Symbol">:</a> <a id="41242" href="1Lab.Path.html#41192" class="Bound">y</a> <a data-type="A → A → Type ℓ" id="41244" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="41246" href="1Lab.Path.html#41194" class="Bound">z</a><a id="41247" class="Symbol">)</a>
          <a id="41259" class="Symbol">→</a> <a id="41261" class="Symbol">(</a><a id="41262" href="1Lab.Path.html#41262" class="Bound">α</a> <a id="41264" href="1Lab.Path.html#41264" class="Bound">β</a> <a id="41266" class="Symbol">:</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="41268" href="1Lab.Type.html#1573" class="Function">Σ[</a> <a id="41271" href="1Lab.Path.html#41271" class="Bound">s</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="41273" href="1Lab.Type.html#1573" class="Function">∈</a> <a id="41275" class="Symbol">(</a><a id="41276" href="1Lab.Path.html#41188" class="Bound">w</a> <a data-type="A → A → Type ℓ" id="41278" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="41280" href="1Lab.Path.html#41194" class="Bound">z</a><a id="41281" class="Symbol">)</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="41283" href="1Lab.Type.html#1573" class="Function">]</a> <a data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" id="41285" href="1Lab.Path.html#9481" class="Function">Square</a> <a id="41292" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="41293" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="41297" href="1Lab.Path.html#41214" class="Bound">p</a><a id="41298" class="Symbol">)</a> <a id="41300" href="1Lab.Path.html#41226" class="Bound">q</a> <a id="41302" href="1Lab.Path.html#41271" class="Bound">s</a> <a id="41304" href="1Lab.Path.html#41238" class="Bound">r</a><a id="41305" class="Symbol">)</a>
          <a id="41317" class="Symbol">→</a> <a id="41319" href="1Lab.Path.html#41262" class="Bound">α</a> <a data-type="A → A → Type ℓ" id="41321" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="41323" href="1Lab.Path.html#41264" class="Bound">β</a>
</pre>
<p>Note that the type of <code>α</code> and <code>β</code> asks for a path <code>w ≡ z</code> which <em>specifically</em> completes the open box for double composition. We would not in general expect that <code>w ≡ z</code> is contractible for an arbitrary <code>a</code>! Note that the proof of this involves filling a cube in a context that <em>already</em> has an interval variable in scope - a hypercube!</p>
<pre class="Agda"><a data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z)
(α β : Σ (λ s → Square (sym p) q s r)) →
α ≡ β" id="41676" href="1Lab.Path.html#41156" class="Function">··-unique</a> <a id="41686" class="Symbol">{</a><a id="41687" class="Argument">w</a> <a id="41689" class="Symbol">=</a> <a id="41691" href="1Lab.Path.html#41691" class="Bound">w</a><a id="41692" class="Symbol">}</a> <a id="41694" class="Symbol">{</a><a id="41695" href="1Lab.Path.html#41695" class="Bound">x</a><a id="41696" class="Symbol">}</a> <a id="41698" class="Symbol">{</a><a id="41699" href="1Lab.Path.html#41699" class="Bound">y</a><a id="41700" class="Symbol">}</a> <a id="41702" class="Symbol">{</a><a id="41703" href="1Lab.Path.html#41703" class="Bound">z</a><a id="41704" class="Symbol">}</a> <a id="41706" href="1Lab.Path.html#41706" class="Bound">p</a> <a id="41708" href="1Lab.Path.html#41708" class="Bound">q</a> <a id="41710" href="1Lab.Path.html#41710" class="Bound">r</a> <a id="41712" class="Symbol">(</a><a id="41713" href="1Lab.Path.html#41713" class="Bound">α</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="41715" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="41717" href="1Lab.Path.html#41717" class="Bound">α-fill</a><a id="41723" class="Symbol">)</a> <a id="41725" class="Symbol">(</a><a id="41726" href="1Lab.Path.html#41726" class="Bound">β</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="41728" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="41730" href="1Lab.Path.html#41730" class="Bound">β-fill</a><a id="41736" class="Symbol">)</a> <a id="41738" class="Symbol">=</a>
  <a id="41742" class="Symbol">λ</a> <a id="41744" href="1Lab.Path.html#41744" class="Bound">i</a> <a id="41746" class="Symbol">→</a> <a id="41748" class="Symbol">(λ</a> <a id="41751" href="1Lab.Path.html#41751" class="Bound">j</a> <a id="41753" class="Symbol">→</a> <a id="41755" href="1Lab.Path.html#42077" class="Function">square</a> <a id="41762" href="1Lab.Path.html#41744" class="Bound">i</a> <a id="41764" href="1Lab.Path.html#41751" class="Bound">j</a><a id="41765" class="Symbol">)</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="41767" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="41769" class="Symbol">(λ</a> <a id="41772" href="1Lab.Path.html#41772" class="Bound">j</a> <a id="41774" href="1Lab.Path.html#41774" class="Bound">k</a> <a id="41776" class="Symbol">→</a> <a id="41778" href="1Lab.Path.html#41802" class="Function">cube</a> <a id="41783" href="1Lab.Path.html#41744" class="Bound">i</a> <a id="41785" href="1Lab.Path.html#41772" class="Bound">j</a> <a id="41787" href="1Lab.Path.html#41774" class="Bound">k</a><a id="41788" class="Symbol">)</a>
  <a id="41792" class="Keyword">where</a>
    <a id="41802" href="1Lab.Path.html#41802" class="Function">cube</a> <a id="41807" class="Symbol">:</a> <a id="41809" class="Symbol">(</a><a id="41810" href="1Lab.Path.html#41810" class="Bound">i</a> <a id="41812" href="1Lab.Path.html#41812" class="Bound">j</a> <a id="41814" class="Symbol">:</a> <a id="41816" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="41817" class="Symbol">)</a> <a id="41819" class="Symbol">→</a> <a id="41821" href="1Lab.Path.html#41706" class="Bound">p</a> <a id="41823" class="Symbol">(</a><a id="41824" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="41826" href="1Lab.Path.html#41812" class="Bound">j</a><a id="41827" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="41829" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="41831" href="1Lab.Path.html#41710" class="Bound">r</a> <a id="41833" href="1Lab.Path.html#41812" class="Bound">j</a>
    <a id="41839" href="1Lab.Path.html#41802" class="Function">cube</a> <a id="41844" href="1Lab.Path.html#41844" class="Bound">i</a> <a id="41846" href="1Lab.Path.html#41846" class="Bound">j</a> <a id="41848" href="1Lab.Path.html#41848" class="Bound">k</a> <a id="41850" class="Symbol">=</a>
      <a data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ]) →
outS u0 ≡ hcomp u (outS u0)" id="41858" href="1Lab.Path.html#35617" class="Function">hfill</a> <a id="41864" class="Symbol">(λ</a> <a id="41867" href="1Lab.Path.html#41867" class="Bound">l</a> <a id="41869" class="Symbol">→</a> <a id="41871" class="Symbol">λ</a> <a id="41873" class="Symbol">{</a> <a id="41875" class="Symbol">(</a><a id="41876" href="1Lab.Path.html#41844" class="Bound">i</a> <a id="41878" class="Symbol">=</a> <a id="41880" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="41882" class="Symbol">)</a> <a id="41884" class="Symbol">→</a> <a id="41886" href="1Lab.Path.html#41717" class="Bound">α-fill</a> <a id="41893" href="1Lab.Path.html#41867" class="Bound">l</a> <a id="41895" href="1Lab.Path.html#41848" class="Bound">k</a>
                     <a id="41918" class="Symbol">;</a> <a id="41920" class="Symbol">(</a><a id="41921" href="1Lab.Path.html#41844" class="Bound">i</a> <a id="41923" class="Symbol">=</a> <a id="41925" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="41927" class="Symbol">)</a> <a id="41929" class="Symbol">→</a> <a id="41931" href="1Lab.Path.html#41730" class="Bound">β-fill</a> <a id="41938" href="1Lab.Path.html#41867" class="Bound">l</a> <a id="41940" href="1Lab.Path.html#41848" class="Bound">k</a>
                     <a id="41963" class="Symbol">;</a> <a id="41965" class="Symbol">(</a><a id="41966" href="1Lab.Path.html#41848" class="Bound">k</a> <a id="41968" class="Symbol">=</a> <a id="41970" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="41972" class="Symbol">)</a> <a id="41974" class="Symbol">→</a> <a id="41976" href="1Lab.Path.html#41706" class="Bound">p</a> <a id="41978" class="Symbol">(</a><a id="41979" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="41981" href="1Lab.Path.html#41867" class="Bound">l</a><a id="41982" class="Symbol">)</a>
                     <a id="42005" class="Symbol">;</a> <a id="42007" class="Symbol">(</a><a id="42008" href="1Lab.Path.html#41848" class="Bound">k</a> <a id="42010" class="Symbol">=</a> <a id="42012" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="42014" class="Symbol">)</a> <a id="42016" class="Symbol">→</a> <a id="42018" href="1Lab.Path.html#41710" class="Bound">r</a> <a id="42020" href="1Lab.Path.html#41867" class="Bound">l</a>
                     <a id="42043" class="Symbol">})</a>
            <a id="42058" class="Symbol">(</a><a id="42059" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="42063" class="Symbol">(</a><a id="42064" href="1Lab.Path.html#41708" class="Bound">q</a> <a id="42066" href="1Lab.Path.html#41848" class="Bound">k</a><a id="42067" class="Symbol">))</a> <a id="42070" href="1Lab.Path.html#41846" class="Bound">j</a>

    <a id="42077" href="1Lab.Path.html#42077" class="Function">square</a> <a id="42084" class="Symbol">:</a> <a id="42086" href="1Lab.Path.html#41713" class="Bound">α</a> <a data-type="A → A → Type ℓ" id="42088" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="42090" href="1Lab.Path.html#41726" class="Bound">β</a>
    <a id="42096" href="1Lab.Path.html#42077" class="Function">square</a> <a id="42103" href="1Lab.Path.html#42103" class="Bound">i</a> <a id="42105" href="1Lab.Path.html#42105" class="Bound">j</a> <a id="42107" class="Symbol">=</a> <a id="42109" href="1Lab.Path.html#41802" class="Function">cube</a> <a id="42114" href="1Lab.Path.html#42103" class="Bound">i</a> <a id="42116" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a> <a id="42119" href="1Lab.Path.html#42105" class="Bound">j</a>
</pre>
<p>The term <code>cube</code> above has the following cube as a boundary. Since it is a filler, there is a missing face at the bottom which has no name, so we denote it by <code>hcomp...</code> in the diagram.</p>
<div class="diagram-container">
<img src="d2affe5ceba60124660e20c639d03936b5f13ed7.svg" title="commutative diagram" class="diagram quiver tall-2" />
</div>
<p>This diagram is quite busy because it is a 3D commutative diagram, but it could be busier: all of the unimportant edges were not annotated. By the way, the lavender face (including the lavender <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mtext> </mtext><mi mathvariant="normal">¬</mi><mi>j</mi></mrow><annotation encoding="application/x-tex">p\ \neg j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace"> </span><span class="mord">¬</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>)</span> is the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">k = \mathrm{i0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i0</span></span></span></span></span> face, and the red face is the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">k = \mathrm{i1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i1</span></span></span></span></span> face.</p>
<p>However, even though the diagram is very busy, most of the detail it contains can be ignored. Reading it in the left-right direction, it expresses an identification between <code>α-filler j k</code> and <code>β-filler j k</code>, lying over a homotopy <code>α = β</code>. That homotopy is what you get when you read the bottom square of the diagram in the left-right direction. Explicitly, here is that bottom square:</p>
<div class="diagram-container">
<img src="a40fe0166453c4795e397e49cbbc54f867beba47.svg" title="commutative diagram" class="diagram quiver" />
</div>
<p>Note that, exceptionally, this diagram is drawn with the left/right edges going up rather than down. This is to match the direction of the 3D diagram above. The colours are also matching.</p>
<p>Readers who are already familiar with the notion of h-level will have noticed that the proof <span class="Agda"><a data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z)
(α β : Σ (λ s → Square (sym p) q s r)) →
α ≡ β" href="1Lab.Path.html#41156" class="Function">··-unique</a></span> expresses that the type of double composites <code>p ·· q ·· r</code> is a <em>proposition</em>, not that it is contractible. However, since it is inhabited (by <span class="Agda"><a data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" href="1Lab.Path.html#38442" class="Function Operator">_··_··_</a></span> and its filler), it is contractible:</p>
<pre class="Agda"><a id="··-contract"></a><a data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z)
(β : Σ (λ s → Square (sym p) q s r)) →
((p ·· q ·· r) , ··-filler p q r) ≡ β" id="46266" href="1Lab.Path.html#46266" class="Function">··-contract</a> <a id="46278" class="Symbol">:</a> <a id="46280" class="Symbol">∀</a> <a id="46282" class="Symbol">{</a><a id="46283" href="1Lab.Path.html#46283" class="Bound">ℓ</a><a id="46284" class="Symbol">}</a> <a id="46286" class="Symbol">{</a><a id="46287" href="1Lab.Path.html#46287" class="Bound">A</a> <a id="46289" class="Symbol">:</a> <a id="46291" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="46296" href="1Lab.Path.html#46283" class="Bound">ℓ</a><a id="46297" class="Symbol">}</a> <a id="46299" class="Symbol">{</a><a id="46300" href="1Lab.Path.html#46300" class="Bound">w</a> <a id="46302" href="1Lab.Path.html#46302" class="Bound">x</a> <a id="46304" href="1Lab.Path.html#46304" class="Bound">y</a> <a id="46306" href="1Lab.Path.html#46306" class="Bound">z</a> <a id="46308" class="Symbol">:</a> <a id="46310" href="1Lab.Path.html#46287" class="Bound">A</a><a id="46311" class="Symbol">}</a>
            <a id="46325" class="Symbol">→</a> <a id="46327" class="Symbol">(</a><a id="46328" href="1Lab.Path.html#46328" class="Bound">p</a> <a id="46330" class="Symbol">:</a> <a id="46332" href="1Lab.Path.html#46300" class="Bound">w</a> <a data-type="A → A → Type ℓ" id="46334" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="46336" href="1Lab.Path.html#46302" class="Bound">x</a><a id="46337" class="Symbol">)</a> <a id="46339" class="Symbol">(</a><a id="46340" href="1Lab.Path.html#46340" class="Bound">q</a> <a id="46342" class="Symbol">:</a> <a id="46344" href="1Lab.Path.html#46302" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="46346" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="46348" href="1Lab.Path.html#46304" class="Bound">y</a><a id="46349" class="Symbol">)</a> <a id="46351" class="Symbol">(</a><a id="46352" href="1Lab.Path.html#46352" class="Bound">r</a> <a id="46354" class="Symbol">:</a> <a id="46356" href="1Lab.Path.html#46304" class="Bound">y</a> <a data-type="A → A → Type ℓ" id="46358" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="46360" href="1Lab.Path.html#46306" class="Bound">z</a><a id="46361" class="Symbol">)</a>
            <a id="46375" class="Symbol">→</a> <a id="46377" class="Symbol">(</a><a id="46378" href="1Lab.Path.html#46378" class="Bound">β</a> <a id="46380" class="Symbol">:</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="46382" href="1Lab.Type.html#1573" class="Function">Σ[</a> <a id="46385" href="1Lab.Path.html#46385" class="Bound">s</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="46387" href="1Lab.Type.html#1573" class="Function">∈</a> <a id="46389" class="Symbol">(</a><a id="46390" href="1Lab.Path.html#46300" class="Bound">w</a> <a data-type="A → A → Type ℓ" id="46392" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="46394" href="1Lab.Path.html#46306" class="Bound">z</a><a id="46395" class="Symbol">)</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="46397" href="1Lab.Type.html#1573" class="Function">]</a> <a data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" id="46399" href="1Lab.Path.html#9481" class="Function">Square</a> <a id="46406" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="46407" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="46411" href="1Lab.Path.html#46328" class="Bound">p</a><a id="46412" class="Symbol">)</a> <a id="46414" href="1Lab.Path.html#46340" class="Bound">q</a> <a id="46416" href="1Lab.Path.html#46385" class="Bound">s</a> <a id="46418" href="1Lab.Path.html#46352" class="Bound">r</a><a id="46419" class="Symbol">)</a>
            <a id="46433" class="Symbol">→</a> <a id="46435" class="Symbol">(</a><a id="46436" href="1Lab.Path.html#46328" class="Bound">p</a> <a data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" id="46438" href="1Lab.Path.html#38442" class="Function Operator">··</a> <a id="46441" href="1Lab.Path.html#46340" class="Bound">q</a> <a data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" id="46443" href="1Lab.Path.html#38442" class="Function Operator">··</a> <a id="46446" href="1Lab.Path.html#46352" class="Bound">r</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="46448" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z) →
Square (sym p) q (p ·· q ·· r) r" id="46450" href="1Lab.Path.html#38760" class="Function">··-filler</a> <a id="46460" href="1Lab.Path.html#46328" class="Bound">p</a> <a id="46462" href="1Lab.Path.html#46340" class="Bound">q</a> <a id="46464" href="1Lab.Path.html#46352" class="Bound">r</a><a id="46465" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="46467" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="46469" href="1Lab.Path.html#46378" class="Bound">β</a>
<a data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z)
(β : Σ (λ s → Square (sym p) q s r)) →
((p ·· q ·· r) , ··-filler p q r) ≡ β" id="46471" href="1Lab.Path.html#46266" class="Function">··-contract</a> <a id="46483" href="1Lab.Path.html#46483" class="Bound">p</a> <a id="46485" href="1Lab.Path.html#46485" class="Bound">q</a> <a id="46487" href="1Lab.Path.html#46487" class="Bound">r</a> <a id="46489" href="1Lab.Path.html#46489" class="Bound">β</a> <a id="46491" class="Symbol">=</a> <a data-type="(p : w ≡ x) (q : x ≡ y) (r : y ≡ z)
(α β : Σ (λ s → Square (sym p) q s r)) →
α ≡ β" id="46493" href="1Lab.Path.html#41156" class="Function">··-unique</a> <a id="46503" href="1Lab.Path.html#46483" class="Bound">p</a> <a id="46505" href="1Lab.Path.html#46485" class="Bound">q</a> <a id="46507" href="1Lab.Path.html#46487" class="Bound">r</a> <a id="46509" class="Symbol">_</a> <a id="46511" href="1Lab.Path.html#46489" class="Bound">β</a>
</pre>
<h2 id="syntax-sugar"><a href="#syntax-sugar" class="header-link">Syntax Sugar<span class="header-link-emoji">🔗</span></a></h2>
<p>When constructing long chains of identifications, it’s rather helpful to be able to visualise <em>what</em> is being identified with more “priority” than <em>how</em> it is being identified. For this, a handful of combinators with weird names are defined:</p>
<pre class="Agda"><a id="≡⟨⟩-syntax"></a><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="46786" href="1Lab.Path.html#46786" class="Function">≡⟨⟩-syntax</a> <a id="46797" class="Symbol">:</a> <a id="46799" class="Symbol">∀</a> <a id="46801" class="Symbol">{</a><a id="46802" href="1Lab.Path.html#46802" class="Bound">ℓ</a><a id="46803" class="Symbol">}</a> <a id="46805" class="Symbol">{</a><a id="46806" href="1Lab.Path.html#46806" class="Bound">A</a> <a id="46808" class="Symbol">:</a> <a id="46810" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="46815" href="1Lab.Path.html#46802" class="Bound">ℓ</a><a id="46816" class="Symbol">}</a> <a id="46818" class="Symbol">(</a><a id="46819" href="1Lab.Path.html#46819" class="Bound">x</a> <a id="46821" class="Symbol">:</a> <a id="46823" href="1Lab.Path.html#46806" class="Bound">A</a><a id="46824" class="Symbol">)</a> <a id="46826" class="Symbol">{</a><a id="46827" href="1Lab.Path.html#46827" class="Bound">y</a> <a id="46829" href="1Lab.Path.html#46829" class="Bound">z</a><a id="46830" class="Symbol">}</a> <a id="46832" class="Symbol">→</a> <a id="46834" href="1Lab.Path.html#46827" class="Bound">y</a> <a data-type="A → A → Type ℓ" id="46836" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="46838" href="1Lab.Path.html#46829" class="Bound">z</a> <a id="46840" class="Symbol">→</a> <a id="46842" href="1Lab.Path.html#46819" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="46844" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="46846" href="1Lab.Path.html#46827" class="Bound">y</a> <a id="46848" class="Symbol">→</a> <a id="46850" href="1Lab.Path.html#46819" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="46852" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="46854" href="1Lab.Path.html#46829" class="Bound">z</a>
<a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="46856" href="1Lab.Path.html#46786" class="Function">≡⟨⟩-syntax</a> <a id="46867" href="1Lab.Path.html#46867" class="Bound">x</a> <a id="46869" href="1Lab.Path.html#46869" class="Bound">q</a> <a id="46871" href="1Lab.Path.html#46871" class="Bound">p</a> <a id="46873" class="Symbol">=</a> <a id="46875" href="1Lab.Path.html#46871" class="Bound">p</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="46877" href="1Lab.Path.html#39613" class="Function Operator">∙</a> <a id="46879" href="1Lab.Path.html#46869" class="Bound">q</a>

<a id="46882" class="Keyword">infixr</a> <a id="46889" class="Number">2</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="46891" href="1Lab.Path.html#46786" class="Function">≡⟨⟩-syntax</a>
<a id="46902" class="Keyword">syntax</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="46909" href="1Lab.Path.html#46786" class="Function">≡⟨⟩-syntax</a> <a id="46920" class="Bound">x</a> <a id="46922" class="Bound">q</a> <a id="46924" class="Bound">p</a> <a id="46926" class="Symbol">=</a> <a id="46928" class="Bound">x</a> <a id="46930" class="Function">≡⟨</a> <a id="46933" class="Bound">p</a> <a id="46935" class="Function">⟩</a> <a id="46937" class="Bound">q</a>

<a id="_≡˘⟨_⟩_"></a><a data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" id="46940" href="1Lab.Path.html#46940" class="Function Operator">_≡˘⟨_⟩_</a> <a id="46948" class="Symbol">:</a> <a id="46950" class="Symbol">∀</a> <a id="46952" class="Symbol">{</a><a id="46953" href="1Lab.Path.html#46953" class="Bound">ℓ</a><a id="46954" class="Symbol">}</a> <a id="46956" class="Symbol">{</a><a id="46957" href="1Lab.Path.html#46957" class="Bound">A</a> <a id="46959" class="Symbol">:</a> <a id="46961" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="46966" href="1Lab.Path.html#46953" class="Bound">ℓ</a><a id="46967" class="Symbol">}</a> <a id="46969" class="Symbol">(</a><a id="46970" href="1Lab.Path.html#46970" class="Bound">x</a> <a id="46972" class="Symbol">:</a> <a id="46974" href="1Lab.Path.html#46957" class="Bound">A</a><a id="46975" class="Symbol">)</a> <a id="46977" class="Symbol">{</a><a id="46978" href="1Lab.Path.html#46978" class="Bound">y</a> <a id="46980" href="1Lab.Path.html#46980" class="Bound">z</a> <a id="46982" class="Symbol">:</a> <a id="46984" href="1Lab.Path.html#46957" class="Bound">A</a><a id="46985" class="Symbol">}</a> <a id="46987" class="Symbol">→</a> <a id="46989" href="1Lab.Path.html#46978" class="Bound">y</a> <a data-type="A → A → Type ℓ" id="46991" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="46993" href="1Lab.Path.html#46970" class="Bound">x</a> <a id="46995" class="Symbol">→</a> <a id="46997" href="1Lab.Path.html#46978" class="Bound">y</a> <a data-type="A → A → Type ℓ" id="46999" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="47001" href="1Lab.Path.html#46980" class="Bound">z</a> <a id="47003" class="Symbol">→</a> <a id="47005" href="1Lab.Path.html#46970" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="47007" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="47009" href="1Lab.Path.html#46980" class="Bound">z</a>
<a id="47011" href="1Lab.Path.html#47011" class="Bound">x</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" id="47013" href="1Lab.Path.html#46940" class="Function Operator">≡˘⟨</a> <a id="47017" href="1Lab.Path.html#47017" class="Bound">p</a> <a data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" id="47019" href="1Lab.Path.html#46940" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span> <a id="47021" href="1Lab.Path.html#47021" class="Bound">q</a> <a id="47023" class="Symbol">=</a> <a id="47025" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="47026" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="47030" href="1Lab.Path.html#47017" class="Bound">p</a><a id="47031" class="Symbol">)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="47033" href="1Lab.Path.html#39613" class="Function Operator">∙</a> <a id="47035" href="1Lab.Path.html#47021" class="Bound">q</a>

<a id="_≡⟨⟩_"></a><a data-type="(x : A) → x ≡ y → x ≡ y" id="47038" href="1Lab.Path.html#47038" class="Function Operator">_≡⟨⟩_</a> <a id="47044" class="Symbol">:</a> <a id="47046" class="Symbol">∀</a> <a id="47048" class="Symbol">{</a><a id="47049" href="1Lab.Path.html#47049" class="Bound">ℓ</a><a id="47050" class="Symbol">}</a> <a id="47052" class="Symbol">{</a><a id="47053" href="1Lab.Path.html#47053" class="Bound">A</a> <a id="47055" class="Symbol">:</a> <a id="47057" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="47062" href="1Lab.Path.html#47049" class="Bound">ℓ</a><a id="47063" class="Symbol">}</a> <a id="47065" class="Symbol">(</a><a id="47066" href="1Lab.Path.html#47066" class="Bound">x</a> <a id="47068" class="Symbol">:</a> <a id="47070" href="1Lab.Path.html#47053" class="Bound">A</a><a id="47071" class="Symbol">)</a> <a id="47073" class="Symbol">{</a><a id="47074" href="1Lab.Path.html#47074" class="Bound">y</a> <a id="47076" class="Symbol">:</a> <a id="47078" href="1Lab.Path.html#47053" class="Bound">A</a><a id="47079" class="Symbol">}</a> <a id="47081" class="Symbol">→</a> <a id="47083" href="1Lab.Path.html#47066" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="47085" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="47087" href="1Lab.Path.html#47074" class="Bound">y</a> <a id="47089" class="Symbol">→</a> <a id="47091" href="1Lab.Path.html#47066" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="47093" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="47095" href="1Lab.Path.html#47074" class="Bound">y</a>
<a id="47097" href="1Lab.Path.html#47097" class="Bound">x</a> <a data-type="(x : A) → x ≡ y → x ≡ y" id="47099" href="1Lab.Path.html#47038" class="Function Operator">≡⟨⟩</a> <a id="47103" href="1Lab.Path.html#47103" class="Bound">x≡y</a> <a id="47107" class="Symbol">=</a> <a id="47109" href="1Lab.Path.html#47103" class="Bound">x≡y</a>

<a id="_∎"></a><a data-type="(x : A) → x ≡ x" id="47114" href="1Lab.Path.html#47114" class="Function Operator">_∎</a> <a id="47117" class="Symbol">:</a> <a id="47119" class="Symbol">∀</a> <a id="47121" class="Symbol">{</a><a id="47122" href="1Lab.Path.html#47122" class="Bound">ℓ</a><a id="47123" class="Symbol">}</a> <a id="47125" class="Symbol">{</a><a id="47126" href="1Lab.Path.html#47126" class="Bound">A</a> <a id="47128" class="Symbol">:</a> <a id="47130" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="47135" href="1Lab.Path.html#47122" class="Bound">ℓ</a><a id="47136" class="Symbol">}</a> <a id="47138" class="Symbol">(</a><a id="47139" href="1Lab.Path.html#47139" class="Bound">x</a> <a id="47141" class="Symbol">:</a> <a id="47143" href="1Lab.Path.html#47126" class="Bound">A</a><a id="47144" class="Symbol">)</a> <a id="47146" class="Symbol">→</a> <a id="47148" href="1Lab.Path.html#47139" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="47150" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="47152" href="1Lab.Path.html#47139" class="Bound">x</a>
<a id="47154" href="1Lab.Path.html#47154" class="Bound">x</a> <a data-type="(x : A) → x ≡ x" id="47156" href="1Lab.Path.html#47114" class="Function Operator">∎</a> <a id="47158" class="Symbol">=</a> <a data-type="x ≡ x" id="47160" href="1Lab.Path.html#3593" class="Function">refl</a>

<a id="47166" class="Keyword">infixr</a> <a id="47173" class="Number">30</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="47176" href="1Lab.Path.html#39613" class="Function Operator">_∙_</a>
<a id="47180" class="Keyword">infixr</a> <a id="47187" class="Number">2</a> <a data-type="(x : A) → x ≡ y → x ≡ y" id="47189" href="1Lab.Path.html#47038" class="Function Operator">_≡⟨⟩_</a> <a data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" id="47195" href="1Lab.Path.html#46940" class="Function Operator">_≡˘⟨_⟩_</a>
<a id="47203" class="Keyword">infix</a>  <a id="47210" class="Number">3</a> <a data-type="(x : A) → x ≡ x" id="47212" href="1Lab.Path.html#47114" class="Function Operator">_∎</a>
</pre>
<p>These functions are used to make <em>equational reasoning chains</em>. For instance, the following proof that addition of naturals is associative is done in equational reasoning style:</p>
<pre class="Agda"><a id="47407" class="Keyword">private</a>
  <a id="+-associative"></a><a id="47417" href="1Lab.Path.html#47417" class="Function">+-associative</a> <a id="47431" class="Symbol">:</a> <a id="47433" class="Symbol">(</a><a id="47434" href="1Lab.Path.html#47434" class="Bound">x</a> <a id="47436" href="1Lab.Path.html#47436" class="Bound">y</a> <a id="47438" href="1Lab.Path.html#47438" class="Bound">z</a> <a id="47440" class="Symbol">:</a> <a data-type="Type" id="47442" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a><a id="47445" class="Symbol">)</a> <a id="47447" class="Symbol">→</a> <a id="47449" class="Symbol">(</a><a id="47450" href="1Lab.Path.html#47434" class="Bound">x</a> <a data-type="Nat → Nat → Nat" id="47452" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="47454" href="1Lab.Path.html#47436" class="Bound">y</a><a id="47455" class="Symbol">)</a> <a data-type="Nat → Nat → Nat" id="47457" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="47459" href="1Lab.Path.html#47438" class="Bound">z</a> <a data-type="A → A → Type ℓ" id="47461" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="47463" href="1Lab.Path.html#47434" class="Bound">x</a> <a data-type="Nat → Nat → Nat" id="47465" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="47467" class="Symbol">(</a><a id="47468" href="1Lab.Path.html#47436" class="Bound">y</a> <a data-type="Nat → Nat → Nat" id="47470" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="47472" href="1Lab.Path.html#47438" class="Bound">z</a><a id="47473" class="Symbol">)</a>
  <a id="47477" href="1Lab.Path.html#47417" class="Function">+-associative</a> <a data-type="Nat" id="47491" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="47496" href="1Lab.Path.html#47496" class="Bound">y</a> <a id="47498" href="1Lab.Path.html#47498" class="Bound">z</a> <a id="47500" class="Symbol">=</a> <a data-type="x ≡ x" id="47502" href="1Lab.Path.html#3593" class="Function">refl</a>
  <a id="47509" href="1Lab.Path.html#47417" class="Function">+-associative</a> <a id="47523" class="Symbol">(</a><a data-type="Nat → Nat" id="47524" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="47528" href="1Lab.Path.html#47528" class="Bound">x</a><a id="47529" class="Symbol">)</a> <a id="47531" href="1Lab.Path.html#47531" class="Bound">y</a> <a id="47533" href="1Lab.Path.html#47533" class="Bound">z</a> <a id="47535" class="Symbol">=</a>
    <a data-type="Nat → Nat" id="47541" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="47545" class="Symbol">((</a><a id="47547" href="1Lab.Path.html#47528" class="Bound">x</a> <a data-type="Nat → Nat → Nat" id="47549" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="47551" href="1Lab.Path.html#47531" class="Bound">y</a><a id="47552" class="Symbol">)</a> <a data-type="Nat → Nat → Nat" id="47554" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="47556" href="1Lab.Path.html#47533" class="Bound">z</a><a id="47557" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="47559" href="1Lab.Path.html#46786" class="Function">≡⟨</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="47562" href="1Lab.Path.html#20828" class="Function">ap</a> <a data-type="Nat → Nat" id="47565" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="47569" class="Symbol">(</a><a id="47570" href="1Lab.Path.html#47417" class="Function">+-associative</a> <a id="47584" href="1Lab.Path.html#47528" class="Bound">x</a> <a id="47586" href="1Lab.Path.html#47531" class="Bound">y</a> <a id="47588" href="1Lab.Path.html#47533" class="Bound">z</a><a id="47589" class="Symbol">)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="47591" href="1Lab.Path.html#46786" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a data-type="Nat → Nat" id="47597" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="47601" class="Symbol">(</a><a id="47602" href="1Lab.Path.html#47528" class="Bound">x</a> <a data-type="Nat → Nat → Nat" id="47604" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="47606" class="Symbol">(</a><a id="47607" href="1Lab.Path.html#47531" class="Bound">y</a> <a data-type="Nat → Nat → Nat" id="47609" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="47611" href="1Lab.Path.html#47533" class="Bound">z</a><a id="47612" class="Symbol">))</a> <a data-type="(x : A) → x ≡ x" id="47615" href="1Lab.Path.html#47114" class="Function Operator">∎</a>
</pre>
<p>If your browser runs JavaScript, these equational reasoning chains, by default, render with the <em>justifications</em> (the argument written between <code>⟨ ⟩</code>) hidden; There is a checkbox to display them, either on the sidebar or on the top bar depending on how narrow your screen is. For your convenience, it’s here too:</p>
<div style="display: flex; flex-direction: column; align-items: center;">
<p><span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;"> <input name="body-eqns" type="checkbox" class="equations" id="body-eqns"> <label for="body-eqns">Equations</label> </span></p>
</div>
<p>Try pressing it!</p>
<!--
<pre class="Agda"><a id="SquareP"></a><a id="48253" href="1Lab.Path.html#48253" class="Function">SquareP</a> <a id="48261" class="Symbol">:</a> <a id="48263" class="Symbol">∀</a> <a id="48265" class="Symbol">{</a><a id="48266" href="1Lab.Path.html#48266" class="Bound">ℓ</a><a id="48267" class="Symbol">}</a>
  <a id="48271" class="Symbol">(</a><a id="48272" href="1Lab.Path.html#48272" class="Bound">A</a> <a id="48274" class="Symbol">:</a> <a id="48276" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="48278" class="Symbol">→</a> <a id="48280" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="48282" class="Symbol">→</a> <a id="48284" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="48289" href="1Lab.Path.html#48266" class="Bound">ℓ</a><a id="48290" class="Symbol">)</a>
  <a id="48294" class="Symbol">{</a><a id="48295" href="1Lab.Path.html#48295" class="Bound">a₀₀</a> <a id="48299" class="Symbol">:</a> <a id="48301" href="1Lab.Path.html#48272" class="Bound">A</a> <a id="48303" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a id="48306" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="48308" class="Symbol">}</a> <a id="48310" class="Symbol">{</a><a id="48311" href="1Lab.Path.html#48311" class="Bound">a₀₁</a> <a id="48315" class="Symbol">:</a> <a id="48317" href="1Lab.Path.html#48272" class="Bound">A</a> <a id="48319" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a id="48322" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="48324" class="Symbol">}</a>
  <a id="48328" class="Symbol">{</a><a id="48329" href="1Lab.Path.html#48329" class="Bound">a₁₀</a> <a id="48333" class="Symbol">:</a> <a id="48335" href="1Lab.Path.html#48272" class="Bound">A</a> <a id="48337" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a> <a id="48340" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="48342" class="Symbol">}</a> <a id="48344" class="Symbol">{</a><a id="48345" href="1Lab.Path.html#48345" class="Bound">a₁₁</a> <a id="48349" class="Symbol">:</a> <a id="48351" href="1Lab.Path.html#48272" class="Bound">A</a> <a id="48353" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a> <a id="48356" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="48358" class="Symbol">}</a>
  <a id="48362" class="Symbol">(</a><a id="48363" href="1Lab.Path.html#48363" class="Bound">p</a> <a id="48365" class="Symbol">:</a> <a id="48367" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="48373" class="Symbol">(λ</a> <a id="48376" href="1Lab.Path.html#48376" class="Bound">i</a> <a id="48378" class="Symbol">→</a> <a id="48380" href="1Lab.Path.html#48272" class="Bound">A</a> <a id="48382" href="1Lab.Path.html#48376" class="Bound">i</a> <a id="48384" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="48386" class="Symbol">)</a> <a id="48388" href="1Lab.Path.html#48295" class="Bound">a₀₀</a> <a id="48392" href="1Lab.Path.html#48329" class="Bound">a₁₀</a><a id="48395" class="Symbol">)</a>
  <a id="48399" class="Symbol">(</a><a id="48400" href="1Lab.Path.html#48400" class="Bound">q</a> <a id="48402" class="Symbol">:</a> <a id="48404" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="48410" class="Symbol">(λ</a> <a id="48413" href="1Lab.Path.html#48413" class="Bound">j</a> <a id="48415" class="Symbol">→</a> <a id="48417" href="1Lab.Path.html#48272" class="Bound">A</a> <a id="48419" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a id="48422" href="1Lab.Path.html#48413" class="Bound">j</a><a id="48423" class="Symbol">)</a> <a id="48425" href="1Lab.Path.html#48295" class="Bound">a₀₀</a> <a id="48429" href="1Lab.Path.html#48311" class="Bound">a₀₁</a><a id="48432" class="Symbol">)</a>
  <a id="48436" class="Symbol">(</a><a id="48437" href="1Lab.Path.html#48437" class="Bound">s</a> <a id="48439" class="Symbol">:</a> <a id="48441" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="48447" class="Symbol">(λ</a> <a id="48450" href="1Lab.Path.html#48450" class="Bound">j</a> <a id="48452" class="Symbol">→</a> <a id="48454" href="1Lab.Path.html#48272" class="Bound">A</a> <a id="48456" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a> <a id="48459" href="1Lab.Path.html#48450" class="Bound">j</a><a id="48460" class="Symbol">)</a> <a id="48462" href="1Lab.Path.html#48329" class="Bound">a₁₀</a> <a id="48466" href="1Lab.Path.html#48345" class="Bound">a₁₁</a><a id="48469" class="Symbol">)</a>
  <a id="48473" class="Symbol">(</a><a id="48474" href="1Lab.Path.html#48474" class="Bound">r</a> <a id="48476" class="Symbol">:</a> <a id="48478" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="48484" class="Symbol">(λ</a> <a id="48487" href="1Lab.Path.html#48487" class="Bound">i</a> <a id="48489" class="Symbol">→</a> <a id="48491" href="1Lab.Path.html#48272" class="Bound">A</a> <a id="48493" href="1Lab.Path.html#48487" class="Bound">i</a> <a id="48495" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="48497" class="Symbol">)</a> <a id="48499" href="1Lab.Path.html#48311" class="Bound">a₀₁</a> <a id="48503" href="1Lab.Path.html#48345" class="Bound">a₁₁</a><a id="48506" class="Symbol">)</a>
  <a id="48510" class="Symbol">→</a> <a id="48512" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="48517" href="1Lab.Path.html#48266" class="Bound">ℓ</a>
<a id="48519" href="1Lab.Path.html#48253" class="Function">SquareP</a> <a id="48527" href="1Lab.Path.html#48527" class="Bound">A</a> <a id="48529" href="1Lab.Path.html#48529" class="Bound">p</a> <a id="48531" href="1Lab.Path.html#48531" class="Bound">q</a> <a id="48533" href="1Lab.Path.html#48533" class="Bound">s</a> <a id="48535" href="1Lab.Path.html#48535" class="Bound">r</a> <a id="48537" class="Symbol">=</a> <a id="48539" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="48545" class="Symbol">(λ</a> <a id="48548" href="1Lab.Path.html#48548" class="Bound">i</a> <a id="48550" class="Symbol">→</a> <a id="48552" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="48558" class="Symbol">(λ</a> <a id="48561" href="1Lab.Path.html#48561" class="Bound">j</a> <a id="48563" class="Symbol">→</a> <a id="48565" href="1Lab.Path.html#48527" class="Bound">A</a> <a id="48567" href="1Lab.Path.html#48548" class="Bound">i</a> <a id="48569" href="1Lab.Path.html#48561" class="Bound">j</a><a id="48570" class="Symbol">)</a> <a id="48572" class="Symbol">(</a><a id="48573" href="1Lab.Path.html#48529" class="Bound">p</a> <a id="48575" href="1Lab.Path.html#48548" class="Bound">i</a><a id="48576" class="Symbol">)</a> <a id="48578" class="Symbol">(</a><a id="48579" href="1Lab.Path.html#48535" class="Bound">r</a> <a id="48581" href="1Lab.Path.html#48548" class="Bound">i</a><a id="48582" class="Symbol">))</a> <a id="48585" href="1Lab.Path.html#48531" class="Bound">q</a> <a id="48587" href="1Lab.Path.html#48533" class="Bound">s</a>
</pre>-->
<h1 id="dependent-paths"><a href="#dependent-paths" class="header-link">Dependent Paths<span class="header-link-emoji">🔗</span></a></h1>
<p>Surprisingly often, we want to compare inhabitants <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a : A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>:</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">b : B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> where the types <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> are not <em>definitionally</em> equal, but only identified in some specified way. We call these “<strong>paths</strong> over <strong>p</strong>paths”, or <span class="Agda"><a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a></span> for short. In the same way that a <span class="Agda"><a data-type="(A : Type ℓ) → A → A → Type ℓ" href="1Lab.Path.html#2466" class="Function">Path</a></span> can be understood as a function <code>I → A</code> with specified endpoints, a <span class="Agda"><a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a></span> (<em>path</em> over <em>p</em>ath) can be understood as a <em>dependent</em> function <code>(i : I) → A i</code>.</p>
<p>In the Book, paths over paths are implemented in terms of the <span class="Agda"><a data-type="A ≡ B₁ → A → B₁" href="1Lab.Path.html#11848" class="Function">transport</a></span> operation: A path <code>x ≡ y</code> over <code>p</code> is a path <code>transport p x ≡ y</code>, thus defining dependent identifications using non-dependent ones. Fortunately, a cubical argument shows us that these notions coincide:</p>
<pre class="Agda"><a id="PathP≡Path"></a><a data-type="(P : I → Type ℓ) (p : P i0) (q : P i1) →
PathP P p q ≡ Path (P i1) (transport P p) q" id="49358" href="1Lab.Path.html#49358" class="Function">PathP≡Path</a> <a id="49369" class="Symbol">:</a> <a id="49371" class="Symbol">∀</a> <a id="49373" class="Symbol">{</a><a id="49374" href="1Lab.Path.html#49374" class="Bound">ℓ</a><a id="49375" class="Symbol">}</a> <a id="49377" class="Symbol">(</a><a id="49378" href="1Lab.Path.html#49378" class="Bound">P</a> <a id="49380" class="Symbol">:</a> <a id="49382" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="49384" class="Symbol">→</a> <a id="49386" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="49391" href="1Lab.Path.html#49374" class="Bound">ℓ</a><a id="49392" class="Symbol">)</a> <a id="49394" class="Symbol">(</a><a id="49395" href="1Lab.Path.html#49395" class="Bound">p</a> <a id="49397" class="Symbol">:</a> <a id="49399" href="1Lab.Path.html#49378" class="Bound">P</a> <a id="49401" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="49403" class="Symbol">)</a> <a id="49405" class="Symbol">(</a><a id="49406" href="1Lab.Path.html#49406" class="Bound">q</a> <a id="49408" class="Symbol">:</a> <a id="49410" href="1Lab.Path.html#49378" class="Bound">P</a> <a id="49412" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="49414" class="Symbol">)</a>
           <a id="49427" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="49429" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="49435" href="1Lab.Path.html#49378" class="Bound">P</a> <a id="49437" href="1Lab.Path.html#49395" class="Bound">p</a> <a id="49439" href="1Lab.Path.html#49406" class="Bound">q</a> <a data-type="A → A → Type ℓ" id="49441" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(A : Type ℓ) → A → A → Type ℓ" id="49443" href="1Lab.Path.html#2466" class="Function">Path</a> <a id="49448" class="Symbol">(</a><a id="49449" href="1Lab.Path.html#49378" class="Bound">P</a> <a id="49451" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="49453" class="Symbol">)</a> <a id="49455" class="Symbol">(</a><a data-type="A ≡ B₁ → A → B₁" id="49456" href="1Lab.Path.html#11848" class="Function">transport</a> <a id="49466" class="Symbol">(λ</a> <a id="49469" href="1Lab.Path.html#49469" class="Bound">i</a> <a id="49471" class="Symbol">→</a> <a id="49473" href="1Lab.Path.html#49378" class="Bound">P</a> <a id="49475" href="1Lab.Path.html#49469" class="Bound">i</a><a id="49476" class="Symbol">)</a> <a id="49478" href="1Lab.Path.html#49395" class="Bound">p</a><a id="49479" class="Symbol">)</a> <a id="49481" href="1Lab.Path.html#49406" class="Bound">q</a>
<a data-type="(P : I → Type ℓ) (p : P i0) (q : P i1) →
PathP P p q ≡ Path (P i1) (transport P p) q" id="49483" href="1Lab.Path.html#49358" class="Function">PathP≡Path</a> <a id="49494" href="1Lab.Path.html#49494" class="Bound">P</a> <a id="49496" href="1Lab.Path.html#49496" class="Bound">p</a> <a id="49498" href="1Lab.Path.html#49498" class="Bound">q</a> <a id="49500" href="1Lab.Path.html#49500" class="Bound">i</a> <a id="49502" class="Symbol">=</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="49504" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="49510" class="Symbol">(λ</a> <a id="49513" href="1Lab.Path.html#49513" class="Bound">j</a> <a id="49515" class="Symbol">→</a> <a id="49517" href="1Lab.Path.html#49494" class="Bound">P</a> <a id="49519" class="Symbol">(</a><a id="49520" href="1Lab.Path.html#49500" class="Bound">i</a> <a id="49522" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="49524" href="1Lab.Path.html#49513" class="Bound">j</a><a id="49525" class="Symbol">))</a> <a id="49528" class="Symbol">(</a><a data-type="(p : A ≡ B₁) (x : A) → PathP (λ i → p i) x (transport p x)" id="49529" href="1Lab.Path.html#14078" class="Function">transport-filler</a> <a id="49546" class="Symbol">(λ</a> <a id="49549" href="1Lab.Path.html#49549" class="Bound">j</a> <a id="49551" class="Symbol">→</a> <a id="49553" href="1Lab.Path.html#49494" class="Bound">P</a> <a id="49555" href="1Lab.Path.html#49549" class="Bound">j</a><a id="49556" class="Symbol">)</a> <a id="49558" href="1Lab.Path.html#49496" class="Bound">p</a> <a id="49560" href="1Lab.Path.html#49500" class="Bound">i</a><a id="49561" class="Symbol">)</a> <a id="49563" href="1Lab.Path.html#49498" class="Bound">q</a>

<a id="PathP≡Path⁻"></a><a data-type="(P : I → Type ℓ) (p : P i0) (q : P i1) →
PathP P p q ≡ Path (P i0) p (transport (λ i → P (~ i)) q)" id="49566" href="1Lab.Path.html#49566" class="Function">PathP≡Path⁻</a> <a id="49578" class="Symbol">:</a> <a id="49580" class="Symbol">∀</a> <a id="49582" class="Symbol">{</a><a id="49583" href="1Lab.Path.html#49583" class="Bound">ℓ</a><a id="49584" class="Symbol">}</a> <a id="49586" class="Symbol">(</a><a id="49587" href="1Lab.Path.html#49587" class="Bound">P</a> <a id="49589" class="Symbol">:</a> <a id="49591" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="49593" class="Symbol">→</a> <a id="49595" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="49600" href="1Lab.Path.html#49583" class="Bound">ℓ</a><a id="49601" class="Symbol">)</a> <a id="49603" class="Symbol">(</a><a id="49604" href="1Lab.Path.html#49604" class="Bound">p</a> <a id="49606" class="Symbol">:</a> <a id="49608" href="1Lab.Path.html#49587" class="Bound">P</a> <a id="49610" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="49612" class="Symbol">)</a> <a id="49614" class="Symbol">(</a><a id="49615" href="1Lab.Path.html#49615" class="Bound">q</a> <a id="49617" class="Symbol">:</a> <a id="49619" href="1Lab.Path.html#49587" class="Bound">P</a> <a id="49621" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="49623" class="Symbol">)</a>
            <a id="49637" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="49639" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="49645" href="1Lab.Path.html#49587" class="Bound">P</a> <a id="49647" href="1Lab.Path.html#49604" class="Bound">p</a> <a id="49649" href="1Lab.Path.html#49615" class="Bound">q</a> <a data-type="A → A → Type ℓ" id="49651" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(A : Type ℓ) → A → A → Type ℓ" id="49653" href="1Lab.Path.html#2466" class="Function">Path</a> <a id="49658" class="Symbol">(</a><a id="49659" href="1Lab.Path.html#49587" class="Bound">P</a> <a id="49661" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="49663" class="Symbol">)</a> <a id="49665" href="1Lab.Path.html#49604" class="Bound">p</a> <a id="49667" class="Symbol">(</a><a data-type="A ≡ B₁ → A → B₁" id="49668" href="1Lab.Path.html#11848" class="Function">transport</a> <a id="49678" class="Symbol">(λ</a> <a id="49681" href="1Lab.Path.html#49681" class="Bound">i</a> <a id="49683" class="Symbol">→</a> <a id="49685" href="1Lab.Path.html#49587" class="Bound">P</a> <a id="49687" class="Symbol">(</a><a id="49688" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="49690" href="1Lab.Path.html#49681" class="Bound">i</a><a id="49691" class="Symbol">))</a> <a id="49694" href="1Lab.Path.html#49615" class="Bound">q</a><a id="49695" class="Symbol">)</a>
<a data-type="(P : I → Type ℓ) (p : P i0) (q : P i1) →
PathP P p q ≡ Path (P i0) p (transport (λ i → P (~ i)) q)" id="49697" href="1Lab.Path.html#49566" class="Function">PathP≡Path⁻</a> <a id="49709" href="1Lab.Path.html#49709" class="Bound">P</a> <a id="49711" href="1Lab.Path.html#49711" class="Bound">p</a> <a id="49713" href="1Lab.Path.html#49713" class="Bound">q</a> <a id="49715" href="1Lab.Path.html#49715" class="Bound">i</a> <a id="49717" class="Symbol">=</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="49719" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="49725" class="Symbol">(λ</a> <a id="49728" href="1Lab.Path.html#49728" class="Bound">j</a> <a id="49730" class="Symbol">→</a> <a id="49732" href="1Lab.Path.html#49709" class="Bound">P</a> <a id="49734" class="Symbol">(</a><a id="49735" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="49737" href="1Lab.Path.html#49715" class="Bound">i</a> <a id="49739" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="49741" href="1Lab.Path.html#49728" class="Bound">j</a><a id="49742" class="Symbol">))</a> <a id="49745" href="1Lab.Path.html#49711" class="Bound">p</a>
                            <a id="49775" class="Symbol">(</a><a data-type="(p : A ≡ B₁) (x : A) → PathP (λ i → p i) x (transport p x)" id="49776" href="1Lab.Path.html#14078" class="Function">transport-filler</a> <a id="49793" class="Symbol">(λ</a> <a id="49796" href="1Lab.Path.html#49796" class="Bound">j</a> <a id="49798" class="Symbol">→</a> <a id="49800" href="1Lab.Path.html#49709" class="Bound">P</a> <a id="49802" class="Symbol">(</a><a id="49803" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="49805" href="1Lab.Path.html#49796" class="Bound">j</a><a id="49806" class="Symbol">))</a> <a id="49809" href="1Lab.Path.html#49713" class="Bound">q</a> <a id="49811" href="1Lab.Path.html#49715" class="Bound">i</a><a id="49812" class="Symbol">)</a>
</pre>
<p>We can see this by substituting either <code>i0</code> or <code>i1</code> for the variable <code>i</code>.</p>
<ul>
<li><p>When <code>i = i0</code>, we have <code>PathP (λ j → P j) p q</code>, by the endpoint rule for <span class="Agda"><a data-type="(p : A ≡ B₁) (x : A) → PathP (λ i → p i) x (transport p x)" href="1Lab.Path.html#14078" class="Function">transport-filler</a></span>.</p></li>
<li><p>When <code>i = i1</code>, we have <code>PathP (λ j → P i1) (transport P p) q</code>, again by the endpoint rule for <span class="Agda"><a data-type="(p : A ≡ B₁) (x : A) → PathP (λ i → p i) x (transport p x)" href="1Lab.Path.html#14078" class="Function">transport-filler</a></span>.</p></li>
</ul>
<p>The existence of paths over paths gives another “counterexample” to thinking of paths as <em>equality</em>. For instance, it’s hard to imagine a world in which <code>true</code> and <code>false</code> can be equal in any interesting sense of the word <em>equal</em> — but over the identification <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">B</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">l</mi></mrow><mo>≡</mo><mrow><mi mathvariant="normal">B</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">l</mi></mrow></mrow><annotation encoding="application/x-tex">\mathrm{Bool} \equiv \mathrm{Bool}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">Bool</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">Bool</span></span></span></span></span> that switches the points around, <code>true</code> and <code>false</code> can be identified!</p>
<h2 id="coercion"><a href="#coercion" class="header-link">Coercion<span class="header-link-emoji">🔗</span></a></h2>
<p>In Cubical Agda, the interval is given the structure of a De Morgan algebra. This is not the only choice of structure on the interval that gives a model of univalent type theory: We could also subject the interval to <em>no</em> additional structure other than what comes from the structural rules of type theory (introducing variables, ignoring variables, swapping variables, etc). This is a different cubical type theory, called <em>Cartesian cubical type theory</em>.</p>
<p>In Cartesian cubical type theory, instead of having a <span class="Agda"><a href="1Lab.Path.html#2405" class="Primitive">transp</a></span> operation which takes <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow><mo stretchy="false">)</mo><mo>→</mo><mi>A</mi><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(\mathrm{i0}) \to A(\mathrm{i1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">i0</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">i1</span></span><span class="mclose">)</span></span></span></span>,</span> there is a “more powerful” <em>coercion</em> operation, written <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">e</mi></mrow><mrow><mi>i</mi><mo>→</mo><mi>j</mi></mrow><mi>A</mi></msubsup></mrow><annotation encoding="application/x-tex">\mathrm{coe}^A_{i \to j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2361em;vertical-align:-0.3948em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">coe</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-2.4413em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">→</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3948em;"><span></span></span></span></span></span></span></span></span></span>,</span> which takes <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>→</mo><mi>A</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(i) \to A(j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>,</span> as in the subscript. However, despite the seeming added power, the coercion operation can be implemented in Cubical Agda: First, we introduce alternative names for several uses of <span class="Agda"><a href="1Lab.Path.html#2405" class="Primitive">transp</a></span>.</p>
<pre class="Agda"><a id="coe0→1"></a><a data-type="(A : I → Type ℓ) → A i0 → A i1" id="51412" href="1Lab.Path.html#51412" class="Function">coe0→1</a> <a id="51419" class="Symbol">:</a> <a id="51421" class="Symbol">∀</a> <a id="51423" class="Symbol">{</a><a id="51424" href="1Lab.Path.html#51424" class="Bound">ℓ</a><a id="51425" class="Symbol">}</a> <a id="51427" class="Symbol">(</a><a id="51428" href="1Lab.Path.html#51428" class="Bound">A</a> <a id="51430" class="Symbol">:</a> <a id="51432" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="51434" class="Symbol">→</a> <a id="51436" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="51441" href="1Lab.Path.html#51424" class="Bound">ℓ</a><a id="51442" class="Symbol">)</a> <a id="51444" class="Symbol">→</a> <a id="51446" href="1Lab.Path.html#51428" class="Bound">A</a> <a id="51448" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a id="51451" class="Symbol">→</a> <a id="51453" href="1Lab.Path.html#51428" class="Bound">A</a> <a id="51455" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a>
<a data-type="(A : I → Type ℓ) → A i0 → A i1" id="51458" href="1Lab.Path.html#51412" class="Function">coe0→1</a> <a id="51465" href="1Lab.Path.html#51465" class="Bound">A</a> <a id="51467" href="1Lab.Path.html#51467" class="Bound">a</a> <a id="51469" class="Symbol">=</a> <a id="51471" href="1Lab.Path.html#2405" class="Primitive">transp</a> <a id="51478" class="Symbol">(λ</a> <a id="51481" href="1Lab.Path.html#51481" class="Bound">i</a> <a id="51483" class="Symbol">→</a> <a id="51485" href="1Lab.Path.html#51465" class="Bound">A</a> <a id="51487" href="1Lab.Path.html#51481" class="Bound">i</a><a id="51488" class="Symbol">)</a> <a id="51490" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a id="51493" href="1Lab.Path.html#51467" class="Bound">a</a>
<a id="51495" class="Comment">-- ^ This is another name for transport</a>

<a id="coe1→0"></a><a data-type="(A : I → Type ℓ) → A i1 → A i0" id="51536" href="1Lab.Path.html#51536" class="Function">coe1→0</a> <a id="51543" class="Symbol">:</a> <a id="51545" class="Symbol">∀</a> <a id="51547" class="Symbol">{</a><a id="51548" href="1Lab.Path.html#51548" class="Bound">ℓ</a><a id="51549" class="Symbol">}</a> <a id="51551" class="Symbol">(</a><a id="51552" href="1Lab.Path.html#51552" class="Bound">A</a> <a id="51554" class="Symbol">:</a> <a id="51556" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="51558" class="Symbol">→</a> <a id="51560" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="51565" href="1Lab.Path.html#51548" class="Bound">ℓ</a><a id="51566" class="Symbol">)</a> <a id="51568" class="Symbol">→</a> <a id="51570" href="1Lab.Path.html#51552" class="Bound">A</a> <a id="51572" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a> <a id="51575" class="Symbol">→</a> <a id="51577" href="1Lab.Path.html#51552" class="Bound">A</a> <a id="51579" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a>
<a data-type="(A : I → Type ℓ) → A i1 → A i0" id="51582" href="1Lab.Path.html#51536" class="Function">coe1→0</a> <a id="51589" href="1Lab.Path.html#51589" class="Bound">A</a> <a id="51591" href="1Lab.Path.html#51591" class="Bound">a</a> <a id="51593" class="Symbol">=</a> <a id="51595" href="1Lab.Path.html#2405" class="Primitive">transp</a> <a id="51602" class="Symbol">(λ</a> <a id="51605" href="1Lab.Path.html#51605" class="Bound">i</a> <a id="51607" class="Symbol">→</a> <a id="51609" href="1Lab.Path.html#51589" class="Bound">A</a> <a id="51611" class="Symbol">(</a><a id="51612" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="51614" href="1Lab.Path.html#51605" class="Bound">i</a><a id="51615" class="Symbol">))</a> <a id="51618" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a id="51621" href="1Lab.Path.html#51591" class="Bound">a</a>
<a id="51623" class="Comment">-- ^ This is equivalent to transport ∘ sym</a>
</pre>
<p>There are also “more exciting” operations, which transport from one of the endpoints to a path which can vary over the interval. These generalise the <span class="Agda"><a data-type="(p : A ≡ B₁) (x : A) → PathP (λ i → p i) x (transport p x)" href="1Lab.Path.html#14078" class="Function">transport-filler</a></span> operation.</p>
<pre class="Agda"><a id="coe0→i"></a><a data-type="(A : I → Type ℓ) (i : I) → A i0 → A i" id="51867" href="1Lab.Path.html#51867" class="Function">coe0→i</a> <a id="51874" class="Symbol">:</a> <a id="51876" class="Symbol">∀</a> <a id="51878" class="Symbol">{</a><a id="51879" href="1Lab.Path.html#51879" class="Bound">ℓ</a><a id="51880" class="Symbol">}</a> <a id="51882" class="Symbol">(</a><a id="51883" href="1Lab.Path.html#51883" class="Bound">A</a> <a id="51885" class="Symbol">:</a> <a id="51887" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="51889" class="Symbol">→</a> <a id="51891" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="51896" href="1Lab.Path.html#51879" class="Bound">ℓ</a><a id="51897" class="Symbol">)</a> <a id="51899" class="Symbol">(</a><a id="51900" href="1Lab.Path.html#51900" class="Bound">i</a> <a id="51902" class="Symbol">:</a> <a id="51904" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="51905" class="Symbol">)</a> <a id="51907" class="Symbol">→</a> <a id="51909" href="1Lab.Path.html#51883" class="Bound">A</a> <a id="51911" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a id="51914" class="Symbol">→</a> <a id="51916" href="1Lab.Path.html#51883" class="Bound">A</a> <a id="51918" href="1Lab.Path.html#51900" class="Bound">i</a>
<a data-type="(A : I → Type ℓ) (i : I) → A i0 → A i" id="51920" href="1Lab.Path.html#51867" class="Function">coe0→i</a> <a id="51927" href="1Lab.Path.html#51927" class="Bound">A</a> <a id="51929" href="1Lab.Path.html#51929" class="Bound">i</a> <a id="51931" href="1Lab.Path.html#51931" class="Bound">a</a> <a id="51933" class="Symbol">=</a> <a id="51935" href="1Lab.Path.html#2405" class="Primitive">transp</a> <a id="51942" class="Symbol">(λ</a> <a id="51945" href="1Lab.Path.html#51945" class="Bound">j</a> <a id="51947" class="Symbol">→</a> <a id="51949" href="1Lab.Path.html#51927" class="Bound">A</a> <a id="51951" class="Symbol">(</a><a id="51952" href="1Lab.Path.html#51929" class="Bound">i</a> <a id="51954" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="51956" href="1Lab.Path.html#51945" class="Bound">j</a><a id="51957" class="Symbol">))</a> <a id="51960" class="Symbol">(</a><a id="51961" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="51963" href="1Lab.Path.html#51929" class="Bound">i</a><a id="51964" class="Symbol">)</a> <a id="51966" href="1Lab.Path.html#51931" class="Bound">a</a>

<a id="coe1→i"></a><a data-type="(A : I → Type ℓ) (i : I) → A i1 → A i" id="51969" href="1Lab.Path.html#51969" class="Function">coe1→i</a> <a id="51976" class="Symbol">:</a> <a id="51978" class="Symbol">∀</a> <a id="51980" class="Symbol">{</a><a id="51981" href="1Lab.Path.html#51981" class="Bound">ℓ</a><a id="51982" class="Symbol">}</a> <a id="51984" class="Symbol">(</a><a id="51985" href="1Lab.Path.html#51985" class="Bound">A</a> <a id="51987" class="Symbol">:</a> <a id="51989" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="51991" class="Symbol">→</a> <a id="51993" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="51998" href="1Lab.Path.html#51981" class="Bound">ℓ</a><a id="51999" class="Symbol">)</a> <a id="52001" class="Symbol">(</a><a id="52002" href="1Lab.Path.html#52002" class="Bound">i</a> <a id="52004" class="Symbol">:</a> <a id="52006" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="52007" class="Symbol">)</a> <a id="52009" class="Symbol">→</a> <a id="52011" href="1Lab.Path.html#51985" class="Bound">A</a> <a id="52013" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a> <a id="52016" class="Symbol">→</a> <a id="52018" href="1Lab.Path.html#51985" class="Bound">A</a> <a id="52020" href="1Lab.Path.html#52002" class="Bound">i</a>
<a data-type="(A : I → Type ℓ) (i : I) → A i1 → A i" id="52022" href="1Lab.Path.html#51969" class="Function">coe1→i</a> <a id="52029" href="1Lab.Path.html#52029" class="Bound">A</a> <a id="52031" href="1Lab.Path.html#52031" class="Bound">i</a> <a id="52033" href="1Lab.Path.html#52033" class="Bound">a</a> <a id="52035" class="Symbol">=</a> <a id="52037" href="1Lab.Path.html#2405" class="Primitive">transp</a> <a id="52044" class="Symbol">(λ</a> <a id="52047" href="1Lab.Path.html#52047" class="Bound">j</a> <a id="52049" class="Symbol">→</a> <a id="52051" href="1Lab.Path.html#52029" class="Bound">A</a> <a id="52053" class="Symbol">(</a><a id="52054" href="1Lab.Path.html#52031" class="Bound">i</a> <a id="52056" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="52058" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="52060" href="1Lab.Path.html#52047" class="Bound">j</a><a id="52061" class="Symbol">))</a> <a id="52064" href="1Lab.Path.html#52031" class="Bound">i</a> <a id="52066" href="1Lab.Path.html#52033" class="Bound">a</a>
</pre>
<p>We visualise <span class="Agda"><a data-type="(A : I → Type ℓ) (i : I) → A i0 → A i" href="1Lab.Path.html#51867" class="Function">coe0→i</a></span> and <span class="Agda"><a data-type="(A : I → Type ℓ) (i : I) → A i1 → A i" href="1Lab.Path.html#51969" class="Function">coe1→i</a></span> as being “spread” operations, since they take a value from one endpoint of the interval (0 or 1, respectively) and “spread it” to a line varying over the variable <code>i</code>. Similarly, we have “squeeze” operations, which take a line varying over <code>i</code> to one of the endpoints:</p>
<pre class="Agda"><a id="coei→0"></a><a data-type="(A : I → Type ℓ) (i : I) → A i → A i0" id="52396" href="1Lab.Path.html#52396" class="Function">coei→0</a> <a id="52403" class="Symbol">:</a> <a id="52405" class="Symbol">∀</a> <a id="52407" class="Symbol">{</a><a id="52408" href="1Lab.Path.html#52408" class="Bound">ℓ</a><a id="52409" class="Symbol">}</a> <a id="52411" class="Symbol">(</a><a id="52412" href="1Lab.Path.html#52412" class="Bound">A</a> <a id="52414" class="Symbol">:</a> <a id="52416" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="52418" class="Symbol">→</a> <a id="52420" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="52425" href="1Lab.Path.html#52408" class="Bound">ℓ</a><a id="52426" class="Symbol">)</a> <a id="52428" class="Symbol">(</a><a id="52429" href="1Lab.Path.html#52429" class="Bound">i</a> <a id="52431" class="Symbol">:</a> <a id="52433" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="52434" class="Symbol">)</a> <a id="52436" class="Symbol">→</a> <a id="52438" href="1Lab.Path.html#52412" class="Bound">A</a> <a id="52440" href="1Lab.Path.html#52429" class="Bound">i</a> <a id="52442" class="Symbol">→</a> <a id="52444" href="1Lab.Path.html#52412" class="Bound">A</a> <a id="52446" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a>
<a data-type="(A : I → Type ℓ) (i : I) → A i → A i0" id="52449" href="1Lab.Path.html#52396" class="Function">coei→0</a> <a id="52456" href="1Lab.Path.html#52456" class="Bound">A</a> <a id="52458" href="1Lab.Path.html#52458" class="Bound">i</a> <a id="52460" href="1Lab.Path.html#52460" class="Bound">a</a> <a id="52462" class="Symbol">=</a> <a id="52464" href="1Lab.Path.html#2405" class="Primitive">transp</a> <a id="52471" class="Symbol">(λ</a> <a id="52474" href="1Lab.Path.html#52474" class="Bound">j</a> <a id="52476" class="Symbol">→</a> <a id="52478" href="1Lab.Path.html#52456" class="Bound">A</a> <a id="52480" class="Symbol">(</a><a id="52481" href="1Lab.Path.html#52458" class="Bound">i</a> <a id="52483" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="52485" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="52487" href="1Lab.Path.html#52474" class="Bound">j</a><a id="52488" class="Symbol">))</a> <a id="52491" class="Symbol">(</a><a id="52492" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="52494" href="1Lab.Path.html#52458" class="Bound">i</a><a id="52495" class="Symbol">)</a> <a id="52497" href="1Lab.Path.html#52460" class="Bound">a</a>
</pre>
<p>Using the filler of a square, we can put together the <code>0→i</code> and <code>1→i</code> coercions to get the “master coercion” operation. That square is drawn as the diagram below, where the edges are more important than the corners, and the dashed line is <code>coe A i i1</code>.</p>
<div class="diagram-container">
<img src="b6120e35df5dc48b93c4f4b27447f9ce75d30ba9.svg" title="commutative diagram" class="diagram quiver" />
</div>
<pre class="Agda"><a id="coe"></a><a data-type="(A : I → Type ℓ) (i j : I) → A i → A j" id="53313" href="1Lab.Path.html#53313" class="Function">coe</a> <a id="53317" class="Symbol">:</a> <a id="53319" class="Symbol">∀</a> <a id="53321" class="Symbol">{</a><a id="53322" href="1Lab.Path.html#53322" class="Bound">ℓ</a><a id="53323" class="Symbol">}</a> <a id="53325" class="Symbol">(</a><a id="53326" href="1Lab.Path.html#53326" class="Bound">A</a> <a id="53328" class="Symbol">:</a> <a id="53330" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="53332" class="Symbol">→</a> <a id="53334" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="53339" href="1Lab.Path.html#53322" class="Bound">ℓ</a><a id="53340" class="Symbol">)</a> <a id="53342" class="Symbol">(</a><a id="53343" href="1Lab.Path.html#53343" class="Bound">i</a> <a id="53345" href="1Lab.Path.html#53345" class="Bound">j</a> <a id="53347" class="Symbol">:</a> <a id="53349" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="53350" class="Symbol">)</a> <a id="53352" class="Symbol">→</a> <a id="53354" href="1Lab.Path.html#53326" class="Bound">A</a> <a id="53356" href="1Lab.Path.html#53343" class="Bound">i</a> <a id="53358" class="Symbol">→</a> <a id="53360" href="1Lab.Path.html#53326" class="Bound">A</a> <a id="53362" href="1Lab.Path.html#53345" class="Bound">j</a>
<a data-type="(A : I → Type ℓ) (i j : I) → A i → A j" id="53364" href="1Lab.Path.html#53313" class="Function">coe</a> <a id="53368" href="1Lab.Path.html#53368" class="Bound">A</a> <a id="53370" href="1Lab.Path.html#53370" class="Bound">i</a> <a id="53372" href="1Lab.Path.html#53372" class="Bound">j</a> <a id="53374" href="1Lab.Path.html#53374" class="Bound">a</a> <a id="53376" class="Symbol">=</a>
  <a data-type="(A : I → Type ℓ) (u : (i : I) → Partial φ (A i))
(u0 : A i0 [ φ ↦ u i0 ]) →
PathP A (outS u0) (comp A u (outS u0))" id="53380" href="1Lab.Path.html#37676" class="Function">fill</a> <a id="53385" href="1Lab.Path.html#53368" class="Bound">A</a> <a id="53387" class="Symbol">(λ</a> <a id="53390" href="1Lab.Path.html#53390" class="Bound">j</a> <a id="53392" class="Symbol">→</a> <a id="53394" class="Symbol">λ</a> <a id="53396" class="Symbol">{</a> <a id="53398" class="Symbol">(</a><a id="53399" href="1Lab.Path.html#53370" class="Bound">i</a> <a id="53401" class="Symbol">=</a> <a id="53403" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="53405" class="Symbol">)</a> <a id="53407" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) (i : I) → A i0 → A i" id="53409" href="1Lab.Path.html#51867" class="Function">coe0→i</a> <a id="53416" href="1Lab.Path.html#53368" class="Bound">A</a> <a id="53418" href="1Lab.Path.html#53390" class="Bound">j</a> <a id="53420" href="1Lab.Path.html#53374" class="Bound">a</a>
                  <a id="53440" class="Symbol">;</a> <a id="53442" class="Symbol">(</a><a id="53443" href="1Lab.Path.html#53370" class="Bound">i</a> <a id="53445" class="Symbol">=</a> <a id="53447" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="53449" class="Symbol">)</a> <a id="53451" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) (i : I) → A i1 → A i" id="53453" href="1Lab.Path.html#51969" class="Function">coe1→i</a> <a id="53460" href="1Lab.Path.html#53368" class="Bound">A</a> <a id="53462" href="1Lab.Path.html#53390" class="Bound">j</a> <a id="53464" href="1Lab.Path.html#53374" class="Bound">a</a>
                  <a id="53484" class="Symbol">})</a>
    <a id="53491" class="Symbol">(</a><a id="53492" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="53496" class="Symbol">(</a><a data-type="(A : I → Type ℓ) (i : I) → A i → A i0" id="53497" href="1Lab.Path.html#52396" class="Function">coei→0</a> <a id="53504" href="1Lab.Path.html#53368" class="Bound">A</a> <a id="53506" href="1Lab.Path.html#53370" class="Bound">i</a> <a id="53508" href="1Lab.Path.html#53374" class="Bound">a</a><a id="53509" class="Symbol">))</a> <a id="53512" href="1Lab.Path.html#53372" class="Bound">j</a>
</pre>
<p>As the square implies, when <code>j = i1</code>, we have the squeeze operation opposite to <span class="Agda"><a data-type="(A : I → Type ℓ) (i : I) → A i → A i0" href="1Lab.Path.html#52396" class="Function">coei→0</a></span>, which we call <span class="Agda"><a data-type="(A : I → Type ℓ) (i : I) → A i → A i1" href="1Lab.Path.html#53652" class="Function">coei→1</a></span>.</p>
<pre class="Agda"><a id="coei→1"></a><a data-type="(A : I → Type ℓ) (i : I) → A i → A i1" id="53652" href="1Lab.Path.html#53652" class="Function">coei→1</a> <a id="53659" class="Symbol">:</a> <a id="53661" class="Symbol">∀</a> <a id="53663" class="Symbol">{</a><a id="53664" href="1Lab.Path.html#53664" class="Bound">ℓ</a><a id="53665" class="Symbol">}</a> <a id="53667" class="Symbol">(</a><a id="53668" href="1Lab.Path.html#53668" class="Bound">A</a> <a id="53670" class="Symbol">:</a> <a id="53672" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="53674" class="Symbol">→</a> <a id="53676" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="53681" href="1Lab.Path.html#53664" class="Bound">ℓ</a><a id="53682" class="Symbol">)</a> <a id="53684" class="Symbol">(</a><a id="53685" href="1Lab.Path.html#53685" class="Bound">i</a> <a id="53687" class="Symbol">:</a> <a id="53689" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="53690" class="Symbol">)</a> <a id="53692" class="Symbol">→</a> <a id="53694" href="1Lab.Path.html#53668" class="Bound">A</a> <a id="53696" href="1Lab.Path.html#53685" class="Bound">i</a> <a id="53698" class="Symbol">→</a> <a id="53700" href="1Lab.Path.html#53668" class="Bound">A</a> <a id="53702" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a>
<a data-type="(A : I → Type ℓ) (i : I) → A i → A i1" id="53705" href="1Lab.Path.html#53652" class="Function">coei→1</a> <a id="53712" href="1Lab.Path.html#53712" class="Bound">A</a> <a id="53714" href="1Lab.Path.html#53714" class="Bound">i</a> <a id="53716" href="1Lab.Path.html#53716" class="Bound">a</a> <a id="53718" class="Symbol">=</a> <a data-type="(A : I → Type ℓ) (i j : I) → A i → A j" id="53720" href="1Lab.Path.html#53313" class="Function">coe</a> <a id="53724" href="1Lab.Path.html#53712" class="Bound">A</a> <a id="53726" href="1Lab.Path.html#53714" class="Bound">i</a> <a id="53728" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a> <a id="53731" href="1Lab.Path.html#53716" class="Bound">a</a>
</pre>
<p><strong>Sidenote</strong>: The boundary for the square implies that we can give a more verbose type for <span class="Agda"><a data-type="(A : I → Type ℓ) (i j : I) → A i → A j" href="1Lab.Path.html#53313" class="Function">coe</a></span>, one which mentions all of the spreads and squeezes. Note that this is a <em>dependent path between functions <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mtext> </mtext><mi>i</mi><mo>→</mo><mi>A</mi><mtext> </mtext><mi>j</mi></mrow><annotation encoding="application/x-tex">A\ i \to A\ j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace"> </span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span></em>, a very complicated construction indeed!</p>
<pre class="Agda"><a id="54016" class="Keyword">private</a>
  <a id="coe-verbose"></a><a id="54026" href="1Lab.Path.html#54026" class="Function">coe-verbose</a> <a id="54038" class="Symbol">:</a> <a id="54040" class="Symbol">∀</a> <a id="54042" class="Symbol">{</a><a id="54043" href="1Lab.Path.html#54043" class="Bound">ℓ</a><a id="54044" class="Symbol">}</a> <a id="54046" class="Symbol">(</a><a id="54047" href="1Lab.Path.html#54047" class="Bound">A</a> <a id="54049" class="Symbol">:</a> <a id="54051" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="54053" class="Symbol">→</a> <a id="54055" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="54060" href="1Lab.Path.html#54043" class="Bound">ℓ</a><a id="54061" class="Symbol">)</a>
              <a id="54077" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="54079" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="54085" class="Symbol">(λ</a> <a id="54088" href="1Lab.Path.html#54088" class="Bound">i</a> <a id="54090" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="54092" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="54098" class="Symbol">(λ</a> <a id="54101" href="1Lab.Path.html#54101" class="Bound">j</a> <a id="54103" class="Symbol">→</a> <a id="54105" href="1Lab.Path.html#54047" class="Bound">A</a> <a id="54107" href="1Lab.Path.html#54088" class="Bound">i</a> <a id="54109" class="Symbol">→</a> <a id="54111" href="1Lab.Path.html#54047" class="Bound">A</a> <a id="54113" href="1Lab.Path.html#54101" class="Bound">j</a><a id="54114" class="Symbol">)</a>
                                <a id="54148" class="Symbol">(</a><a data-type="(A : I → Type ℓ) (i : I) → A i → A i0" id="54149" href="1Lab.Path.html#52396" class="Function">coei→0</a> <a id="54156" href="1Lab.Path.html#54047" class="Bound">A</a> <a id="54158" href="1Lab.Path.html#54088" class="Bound">i</a><a id="54159" class="Symbol">)</a>
                                <a id="54193" class="Symbol">(</a><a data-type="(A : I → Type ℓ) (i : I) → A i → A i1" id="54194" href="1Lab.Path.html#53652" class="Function">coei→1</a> <a id="54201" href="1Lab.Path.html#54047" class="Bound">A</a> <a id="54203" href="1Lab.Path.html#54088" class="Bound">i</a><a id="54204" class="Symbol">))</a>
                      <a id="54229" class="Symbol">(λ</a> <a id="54232" href="1Lab.Path.html#54232" class="Bound">j</a> <a id="54234" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) (i : I) → A i0 → A i" id="54236" href="1Lab.Path.html#51867" class="Function">coe0→i</a> <a id="54243" href="1Lab.Path.html#54047" class="Bound">A</a> <a id="54245" href="1Lab.Path.html#54232" class="Bound">j</a><a id="54246" class="Symbol">)</a>
                      <a id="54270" class="Symbol">(λ</a> <a id="54273" href="1Lab.Path.html#54273" class="Bound">j</a> <a id="54275" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) (i : I) → A i1 → A i" id="54277" href="1Lab.Path.html#51969" class="Function">coe1→i</a> <a id="54284" href="1Lab.Path.html#54047" class="Bound">A</a> <a id="54286" href="1Lab.Path.html#54273" class="Bound">j</a><a id="54287" class="Symbol">)</a>
  <a id="54291" href="1Lab.Path.html#54026" class="Function">coe-verbose</a> <a id="54303" href="1Lab.Path.html#54303" class="Bound">A</a> <a id="54305" href="1Lab.Path.html#54305" class="Bound">i</a> <a id="54307" href="1Lab.Path.html#54307" class="Bound">j</a> <a id="54309" class="Symbol">=</a> <a data-type="(A : I → Type ℓ) (i j : I) → A i → A j" id="54311" href="1Lab.Path.html#53313" class="Function">coe</a> <a id="54315" href="1Lab.Path.html#54303" class="Bound">A</a> <a id="54317" href="1Lab.Path.html#54305" class="Bound">i</a> <a id="54319" href="1Lab.Path.html#54307" class="Bound">j</a>
</pre>
<p>This operation satisfies, <em>definitionally</em>, a whole host of equations. For starters, we have that the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mrow><mi mathvariant="normal">c</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">e</mi></mrow><mrow><mi>i</mi><mo>→</mo><mn>1</mn></mrow><mi>A</mi></msubsup></mrow><annotation encoding="application/x-tex">\mathrm{coe}^A_{i\to1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1em;vertical-align:-0.2587em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">coe</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-2.4413em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">→</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2587em;"><span></span></span></span></span></span></span></span></span></span> (resp <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>→</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i \to 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>)</span> specialises to transport when <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> (resp. <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>),</span> and to the identity when <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> (resp. <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>):</span></p>
<pre class="Agda"><a id="coei0→1"></a><a data-type="(A : I → Type ℓ) (a : A i0) → coei→1 A i0 a ≡ coe0→1 A a" id="54584" href="1Lab.Path.html#54584" class="Function">coei0→1</a> <a id="54592" class="Symbol">:</a> <a id="54594" class="Symbol">∀</a> <a id="54596" class="Symbol">{</a><a id="54597" href="1Lab.Path.html#54597" class="Bound">ℓ</a><a id="54598" class="Symbol">}</a> <a id="54600" class="Symbol">(</a><a id="54601" href="1Lab.Path.html#54601" class="Bound">A</a> <a id="54603" class="Symbol">:</a> <a id="54605" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="54607" class="Symbol">→</a> <a id="54609" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="54614" href="1Lab.Path.html#54597" class="Bound">ℓ</a><a id="54615" class="Symbol">)</a> <a id="54617" class="Symbol">(</a><a id="54618" href="1Lab.Path.html#54618" class="Bound">a</a> <a id="54620" class="Symbol">:</a> <a id="54622" href="1Lab.Path.html#54601" class="Bound">A</a> <a id="54624" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="54626" class="Symbol">)</a> <a id="54628" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) (i : I) → A i → A i1" id="54630" href="1Lab.Path.html#53652" class="Function">coei→1</a> <a id="54637" href="1Lab.Path.html#54601" class="Bound">A</a> <a id="54639" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a id="54642" href="1Lab.Path.html#54618" class="Bound">a</a> <a data-type="A → A → Type ℓ" id="54644" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1" id="54646" href="1Lab.Path.html#51412" class="Function">coe0→1</a> <a id="54653" href="1Lab.Path.html#54601" class="Bound">A</a> <a id="54655" href="1Lab.Path.html#54618" class="Bound">a</a>
<a data-type="(A : I → Type ℓ) (a : A i0) → coei→1 A i0 a ≡ coe0→1 A a" id="54657" href="1Lab.Path.html#54584" class="Function">coei0→1</a> <a id="54665" href="1Lab.Path.html#54665" class="Bound">A</a> <a id="54667" href="1Lab.Path.html#54667" class="Bound">a</a> <a id="54669" class="Symbol">=</a> <a data-type="x ≡ x" id="54671" href="1Lab.Path.html#3593" class="Function">refl</a>

<a id="coei1→1"></a><a data-type="(A : I → Type ℓ) (a : A i1) → coei→1 A i1 a ≡ a" id="54677" href="1Lab.Path.html#54677" class="Function">coei1→1</a> <a id="54685" class="Symbol">:</a> <a id="54687" class="Symbol">∀</a> <a id="54689" class="Symbol">{</a><a id="54690" href="1Lab.Path.html#54690" class="Bound">ℓ</a><a id="54691" class="Symbol">}</a> <a id="54693" class="Symbol">(</a><a id="54694" href="1Lab.Path.html#54694" class="Bound">A</a> <a id="54696" class="Symbol">:</a> <a id="54698" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="54700" class="Symbol">→</a> <a id="54702" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="54707" href="1Lab.Path.html#54690" class="Bound">ℓ</a><a id="54708" class="Symbol">)</a> <a id="54710" class="Symbol">(</a><a id="54711" href="1Lab.Path.html#54711" class="Bound">a</a> <a id="54713" class="Symbol">:</a> <a id="54715" href="1Lab.Path.html#54694" class="Bound">A</a> <a id="54717" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="54719" class="Symbol">)</a> <a id="54721" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) (i : I) → A i → A i1" id="54723" href="1Lab.Path.html#53652" class="Function">coei→1</a> <a id="54730" href="1Lab.Path.html#54694" class="Bound">A</a> <a id="54732" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a> <a id="54735" href="1Lab.Path.html#54711" class="Bound">a</a> <a data-type="A → A → Type ℓ" id="54737" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="54739" href="1Lab.Path.html#54711" class="Bound">a</a>
<a data-type="(A : I → Type ℓ) (a : A i1) → coei→1 A i1 a ≡ a" id="54741" href="1Lab.Path.html#54677" class="Function">coei1→1</a> <a id="54749" href="1Lab.Path.html#54749" class="Bound">A</a> <a id="54751" href="1Lab.Path.html#54751" class="Bound">a</a> <a id="54753" class="Symbol">=</a> <a data-type="x ≡ x" id="54755" href="1Lab.Path.html#3593" class="Function">refl</a>

<a id="coei1→0"></a><a data-type="(A : I → Type ℓ) (a : A i1) → coei→0 A i1 a ≡ coe1→0 A a" id="54761" href="1Lab.Path.html#54761" class="Function">coei1→0</a> <a id="54769" class="Symbol">:</a> <a id="54771" class="Symbol">∀</a> <a id="54773" class="Symbol">{</a><a id="54774" href="1Lab.Path.html#54774" class="Bound">ℓ</a><a id="54775" class="Symbol">}</a> <a id="54777" class="Symbol">(</a><a id="54778" href="1Lab.Path.html#54778" class="Bound">A</a> <a id="54780" class="Symbol">:</a> <a id="54782" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="54784" class="Symbol">→</a> <a id="54786" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="54791" href="1Lab.Path.html#54774" class="Bound">ℓ</a><a id="54792" class="Symbol">)</a> <a id="54794" class="Symbol">(</a><a id="54795" href="1Lab.Path.html#54795" class="Bound">a</a> <a id="54797" class="Symbol">:</a> <a id="54799" href="1Lab.Path.html#54778" class="Bound">A</a> <a id="54801" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="54803" class="Symbol">)</a> <a id="54805" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) (i : I) → A i → A i0" id="54807" href="1Lab.Path.html#52396" class="Function">coei→0</a> <a id="54814" href="1Lab.Path.html#54778" class="Bound">A</a> <a id="54816" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a> <a id="54819" href="1Lab.Path.html#54795" class="Bound">a</a> <a data-type="A → A → Type ℓ" id="54821" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(A : I → Type ℓ) → A i1 → A i0" id="54823" href="1Lab.Path.html#51536" class="Function">coe1→0</a> <a id="54830" href="1Lab.Path.html#54778" class="Bound">A</a> <a id="54832" href="1Lab.Path.html#54795" class="Bound">a</a>
<a data-type="(A : I → Type ℓ) (a : A i1) → coei→0 A i1 a ≡ coe1→0 A a" id="54834" href="1Lab.Path.html#54761" class="Function">coei1→0</a> <a id="54842" href="1Lab.Path.html#54842" class="Bound">A</a> <a id="54844" href="1Lab.Path.html#54844" class="Bound">a</a> <a id="54846" class="Symbol">=</a> <a data-type="x ≡ x" id="54848" href="1Lab.Path.html#3593" class="Function">refl</a>

<a id="coei0→0"></a><a data-type="(A : I → Type ℓ) (a : A i0) → coei→0 A i0 a ≡ a" id="54854" href="1Lab.Path.html#54854" class="Function">coei0→0</a> <a id="54862" class="Symbol">:</a> <a id="54864" class="Symbol">∀</a> <a id="54866" class="Symbol">{</a><a id="54867" href="1Lab.Path.html#54867" class="Bound">ℓ</a><a id="54868" class="Symbol">}</a> <a id="54870" class="Symbol">(</a><a id="54871" href="1Lab.Path.html#54871" class="Bound">A</a> <a id="54873" class="Symbol">:</a> <a id="54875" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="54877" class="Symbol">→</a> <a id="54879" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="54884" href="1Lab.Path.html#54867" class="Bound">ℓ</a><a id="54885" class="Symbol">)</a> <a id="54887" class="Symbol">(</a><a id="54888" href="1Lab.Path.html#54888" class="Bound">a</a> <a id="54890" class="Symbol">:</a> <a id="54892" href="1Lab.Path.html#54871" class="Bound">A</a> <a id="54894" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="54896" class="Symbol">)</a> <a id="54898" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) (i : I) → A i → A i0" id="54900" href="1Lab.Path.html#52396" class="Function">coei→0</a> <a id="54907" href="1Lab.Path.html#54871" class="Bound">A</a> <a id="54909" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a id="54912" href="1Lab.Path.html#54888" class="Bound">a</a> <a data-type="A → A → Type ℓ" id="54914" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="54916" href="1Lab.Path.html#54888" class="Bound">a</a>
<a data-type="(A : I → Type ℓ) (a : A i0) → coei→0 A i0 a ≡ a" id="54918" href="1Lab.Path.html#54854" class="Function">coei0→0</a> <a id="54926" href="1Lab.Path.html#54926" class="Bound">A</a> <a id="54928" href="1Lab.Path.html#54928" class="Bound">a</a> <a id="54930" class="Symbol">=</a> <a data-type="x ≡ x" id="54932" href="1Lab.Path.html#3593" class="Function">refl</a>
</pre>
<p>Then we have paths connecting the “master coercion” <span class="Agda"><a data-type="(A : I → Type ℓ) (i j : I) → A i → A j" href="1Lab.Path.html#53313" class="Function">coe</a></span> and its several faces:</p>
<pre class="Agda"><a id="coei→i0"></a><a data-type="(A : I → Type ℓ) (i : I) (a : A i) → coe A i i0 a ≡ coei→0 A i a" id="55035" href="1Lab.Path.html#55035" class="Function">coei→i0</a> <a id="55043" class="Symbol">:</a> <a id="55045" class="Symbol">∀</a> <a id="55047" class="Symbol">{</a><a id="55048" href="1Lab.Path.html#55048" class="Bound">ℓ</a><a id="55049" class="Symbol">}</a> <a id="55051" class="Symbol">(</a><a id="55052" href="1Lab.Path.html#55052" class="Bound">A</a> <a id="55054" class="Symbol">:</a> <a id="55056" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="55058" class="Symbol">→</a> <a id="55060" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="55065" href="1Lab.Path.html#55048" class="Bound">ℓ</a><a id="55066" class="Symbol">)</a> <a id="55068" class="Symbol">(</a><a id="55069" href="1Lab.Path.html#55069" class="Bound">i</a> <a id="55071" class="Symbol">:</a> <a id="55073" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="55074" class="Symbol">)</a> <a id="55076" class="Symbol">(</a><a id="55077" href="1Lab.Path.html#55077" class="Bound">a</a> <a id="55079" class="Symbol">:</a> <a id="55081" href="1Lab.Path.html#55052" class="Bound">A</a> <a id="55083" href="1Lab.Path.html#55069" class="Bound">i</a><a id="55084" class="Symbol">)</a>
        <a id="55094" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) (i j : I) → A i → A j" id="55096" href="1Lab.Path.html#53313" class="Function">coe</a> <a id="55100" href="1Lab.Path.html#55052" class="Bound">A</a> <a id="55102" href="1Lab.Path.html#55069" class="Bound">i</a> <a id="55104" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a id="55107" href="1Lab.Path.html#55077" class="Bound">a</a> <a data-type="A → A → Type ℓ" id="55109" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(A : I → Type ℓ) (i : I) → A i → A i0" id="55111" href="1Lab.Path.html#52396" class="Function">coei→0</a> <a id="55118" href="1Lab.Path.html#55052" class="Bound">A</a> <a id="55120" href="1Lab.Path.html#55069" class="Bound">i</a> <a id="55122" href="1Lab.Path.html#55077" class="Bound">a</a>
<a data-type="(A : I → Type ℓ) (i : I) (a : A i) → coe A i i0 a ≡ coei→0 A i a" id="55124" href="1Lab.Path.html#55035" class="Function">coei→i0</a> <a id="55132" href="1Lab.Path.html#55132" class="Bound">A</a> <a id="55134" href="1Lab.Path.html#55134" class="Bound">i</a> <a id="55136" href="1Lab.Path.html#55136" class="Bound">a</a> <a id="55138" class="Symbol">=</a> <a data-type="x ≡ x" id="55140" href="1Lab.Path.html#3593" class="Function">refl</a>

<a id="coei0→i"></a><a data-type="(A : I → Type ℓ) (i : I) (a : A i0) → coe A i0 i a ≡ coe0→i A i a" id="55146" href="1Lab.Path.html#55146" class="Function">coei0→i</a> <a id="55154" class="Symbol">:</a> <a id="55156" class="Symbol">∀</a> <a id="55158" class="Symbol">{</a><a id="55159" href="1Lab.Path.html#55159" class="Bound">ℓ</a><a id="55160" class="Symbol">}</a> <a id="55162" class="Symbol">(</a><a id="55163" href="1Lab.Path.html#55163" class="Bound">A</a> <a id="55165" class="Symbol">:</a> <a id="55167" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="55169" class="Symbol">→</a> <a id="55171" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="55176" href="1Lab.Path.html#55159" class="Bound">ℓ</a><a id="55177" class="Symbol">)</a> <a id="55179" class="Symbol">(</a><a id="55180" href="1Lab.Path.html#55180" class="Bound">i</a> <a id="55182" class="Symbol">:</a> <a id="55184" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="55185" class="Symbol">)</a> <a id="55187" class="Symbol">(</a><a id="55188" href="1Lab.Path.html#55188" class="Bound">a</a> <a id="55190" class="Symbol">:</a> <a id="55192" href="1Lab.Path.html#55163" class="Bound">A</a> <a id="55194" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="55196" class="Symbol">)</a>
        <a id="55206" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) (i j : I) → A i → A j" id="55208" href="1Lab.Path.html#53313" class="Function">coe</a> <a id="55212" href="1Lab.Path.html#55163" class="Bound">A</a> <a id="55214" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a id="55217" href="1Lab.Path.html#55180" class="Bound">i</a> <a id="55219" href="1Lab.Path.html#55188" class="Bound">a</a> <a data-type="A → A → Type ℓ" id="55221" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(A : I → Type ℓ) (i : I) → A i0 → A i" id="55223" href="1Lab.Path.html#51867" class="Function">coe0→i</a> <a id="55230" href="1Lab.Path.html#55163" class="Bound">A</a> <a id="55232" href="1Lab.Path.html#55180" class="Bound">i</a> <a id="55234" href="1Lab.Path.html#55188" class="Bound">a</a>
<a data-type="(A : I → Type ℓ) (i : I) (a : A i0) → coe A i0 i a ≡ coe0→i A i a" id="55236" href="1Lab.Path.html#55146" class="Function">coei0→i</a> <a id="55244" href="1Lab.Path.html#55244" class="Bound">A</a> <a id="55246" href="1Lab.Path.html#55246" class="Bound">i</a> <a id="55248" href="1Lab.Path.html#55248" class="Bound">a</a> <a id="55250" class="Symbol">=</a> <a data-type="x ≡ x" id="55252" href="1Lab.Path.html#3593" class="Function">refl</a>

<a id="coei→i1"></a><a data-type="(A : I → Type ℓ) (i : I) (a : A i) → coe A i i1 a ≡ coei→1 A i a" id="55258" href="1Lab.Path.html#55258" class="Function">coei→i1</a> <a id="55266" class="Symbol">:</a> <a id="55268" class="Symbol">∀</a> <a id="55270" class="Symbol">{</a><a id="55271" href="1Lab.Path.html#55271" class="Bound">ℓ</a><a id="55272" class="Symbol">}</a> <a id="55274" class="Symbol">(</a><a id="55275" href="1Lab.Path.html#55275" class="Bound">A</a> <a id="55277" class="Symbol">:</a> <a id="55279" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="55281" class="Symbol">→</a> <a id="55283" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="55288" href="1Lab.Path.html#55271" class="Bound">ℓ</a><a id="55289" class="Symbol">)</a> <a id="55291" class="Symbol">(</a><a id="55292" href="1Lab.Path.html#55292" class="Bound">i</a> <a id="55294" class="Symbol">:</a> <a id="55296" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="55297" class="Symbol">)</a> <a id="55299" class="Symbol">(</a><a id="55300" href="1Lab.Path.html#55300" class="Bound">a</a> <a id="55302" class="Symbol">:</a> <a id="55304" href="1Lab.Path.html#55275" class="Bound">A</a> <a id="55306" href="1Lab.Path.html#55292" class="Bound">i</a><a id="55307" class="Symbol">)</a>
        <a id="55317" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) (i j : I) → A i → A j" id="55319" href="1Lab.Path.html#53313" class="Function">coe</a> <a id="55323" href="1Lab.Path.html#55275" class="Bound">A</a> <a id="55325" href="1Lab.Path.html#55292" class="Bound">i</a> <a id="55327" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a> <a id="55330" href="1Lab.Path.html#55300" class="Bound">a</a> <a data-type="A → A → Type ℓ" id="55332" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(A : I → Type ℓ) (i : I) → A i → A i1" id="55334" href="1Lab.Path.html#53652" class="Function">coei→1</a> <a id="55341" href="1Lab.Path.html#55275" class="Bound">A</a> <a id="55343" href="1Lab.Path.html#55292" class="Bound">i</a> <a id="55345" href="1Lab.Path.html#55300" class="Bound">a</a>
<a data-type="(A : I → Type ℓ) (i : I) (a : A i) → coe A i i1 a ≡ coei→1 A i a" id="55347" href="1Lab.Path.html#55258" class="Function">coei→i1</a> <a id="55355" href="1Lab.Path.html#55355" class="Bound">A</a> <a id="55357" href="1Lab.Path.html#55357" class="Bound">i</a> <a id="55359" href="1Lab.Path.html#55359" class="Bound">a</a> <a id="55361" class="Symbol">=</a> <a data-type="x ≡ x" id="55363" href="1Lab.Path.html#3593" class="Function">refl</a>

<a id="coei1→i"></a><a data-type="(A : I → Type ℓ) (i : I) (a : A i1) → coe A i1 i a ≡ coe1→i A i a" id="55369" href="1Lab.Path.html#55369" class="Function">coei1→i</a> <a id="55377" class="Symbol">:</a> <a id="55379" class="Symbol">∀</a> <a id="55381" class="Symbol">{</a><a id="55382" href="1Lab.Path.html#55382" class="Bound">ℓ</a><a id="55383" class="Symbol">}</a> <a id="55385" class="Symbol">(</a><a id="55386" href="1Lab.Path.html#55386" class="Bound">A</a> <a id="55388" class="Symbol">:</a> <a id="55390" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="55392" class="Symbol">→</a> <a id="55394" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="55399" href="1Lab.Path.html#55382" class="Bound">ℓ</a><a id="55400" class="Symbol">)</a> <a id="55402" class="Symbol">(</a><a id="55403" href="1Lab.Path.html#55403" class="Bound">i</a> <a id="55405" class="Symbol">:</a> <a id="55407" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="55408" class="Symbol">)</a> <a id="55410" class="Symbol">(</a><a id="55411" href="1Lab.Path.html#55411" class="Bound">a</a> <a id="55413" class="Symbol">:</a> <a id="55415" href="1Lab.Path.html#55386" class="Bound">A</a> <a id="55417" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="55419" class="Symbol">)</a>
        <a id="55429" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) (i j : I) → A i → A j" id="55431" href="1Lab.Path.html#53313" class="Function">coe</a> <a id="55435" href="1Lab.Path.html#55386" class="Bound">A</a> <a id="55437" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a> <a id="55440" href="1Lab.Path.html#55403" class="Bound">i</a> <a id="55442" href="1Lab.Path.html#55411" class="Bound">a</a> <a data-type="A → A → Type ℓ" id="55444" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(A : I → Type ℓ) (i : I) → A i1 → A i" id="55446" href="1Lab.Path.html#51969" class="Function">coe1→i</a> <a id="55453" href="1Lab.Path.html#55386" class="Bound">A</a> <a id="55455" href="1Lab.Path.html#55403" class="Bound">i</a> <a id="55457" href="1Lab.Path.html#55411" class="Bound">a</a>
<a data-type="(A : I → Type ℓ) (i : I) (a : A i1) → coe A i1 i a ≡ coe1→i A i a" id="55459" href="1Lab.Path.html#55369" class="Function">coei1→i</a> <a id="55467" href="1Lab.Path.html#55467" class="Bound">A</a> <a id="55469" href="1Lab.Path.html#55469" class="Bound">i</a> <a id="55471" href="1Lab.Path.html#55471" class="Bound">a</a> <a id="55473" class="Symbol">=</a> <a data-type="x ≡ x" id="55475" href="1Lab.Path.html#3593" class="Function">refl</a>
</pre>
<p>In Cartesian cubical type theory, the following equation is definitional. It says that the top right and bottom left corners of the diagram are indeed what I said they were! However, in Cubical Agda, it is only propositional:</p>
<pre class="Agda"><a id="coei→i"></a><a data-type="(A : I → Type ℓ) (i : I) (a : A i) → coe A i i a ≡ a" id="55720" href="1Lab.Path.html#55720" class="Function">coei→i</a> <a id="55727" class="Symbol">:</a> <a id="55729" class="Symbol">∀</a> <a id="55731" class="Symbol">{</a><a id="55732" href="1Lab.Path.html#55732" class="Bound">ℓ</a><a id="55733" class="Symbol">}</a> <a id="55735" class="Symbol">(</a><a id="55736" href="1Lab.Path.html#55736" class="Bound">A</a> <a id="55738" class="Symbol">:</a> <a id="55740" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="55742" class="Symbol">→</a> <a id="55744" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="55749" href="1Lab.Path.html#55732" class="Bound">ℓ</a><a id="55750" class="Symbol">)</a> <a id="55752" class="Symbol">(</a><a id="55753" href="1Lab.Path.html#55753" class="Bound">i</a> <a id="55755" class="Symbol">:</a> <a id="55757" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="55758" class="Symbol">)</a> <a id="55760" class="Symbol">(</a><a id="55761" href="1Lab.Path.html#55761" class="Bound">a</a> <a id="55763" class="Symbol">:</a> <a id="55765" href="1Lab.Path.html#55736" class="Bound">A</a> <a id="55767" href="1Lab.Path.html#55753" class="Bound">i</a><a id="55768" class="Symbol">)</a> <a id="55770" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) (i j : I) → A i → A j" id="55772" href="1Lab.Path.html#53313" class="Function">coe</a> <a id="55776" href="1Lab.Path.html#55736" class="Bound">A</a> <a id="55778" href="1Lab.Path.html#55753" class="Bound">i</a> <a id="55780" href="1Lab.Path.html#55753" class="Bound">i</a> <a id="55782" href="1Lab.Path.html#55761" class="Bound">a</a> <a data-type="A → A → Type ℓ" id="55784" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="55786" href="1Lab.Path.html#55761" class="Bound">a</a>
<a data-type="(A : I → Type ℓ) (i : I) (a : A i) → coe A i i a ≡ a" id="55788" href="1Lab.Path.html#55720" class="Function">coei→i</a> <a id="55795" href="1Lab.Path.html#55795" class="Bound">A</a> <a id="55797" href="1Lab.Path.html#55797" class="Bound">i</a> <a id="55799" class="Symbol">=</a> <a data-type="(A : I → Type ℓ) (i : I) → A i0 → A i" id="55801" href="1Lab.Path.html#51867" class="Function">coe0→i</a> <a id="55808" class="Symbol">(λ</a> <a id="55811" href="1Lab.Path.html#55811" class="Bound">i</a> <a id="55813" class="Symbol">→</a> <a id="55815" class="Symbol">(</a><a id="55816" href="1Lab.Path.html#55816" class="Bound">a</a> <a id="55818" class="Symbol">:</a> <a id="55820" href="1Lab.Path.html#55795" class="Bound">A</a> <a id="55822" href="1Lab.Path.html#55811" class="Bound">i</a><a id="55823" class="Symbol">)</a> <a id="55825" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) (i j : I) → A i → A j" id="55827" href="1Lab.Path.html#53313" class="Function">coe</a> <a id="55831" href="1Lab.Path.html#55795" class="Bound">A</a> <a id="55833" href="1Lab.Path.html#55811" class="Bound">i</a> <a id="55835" href="1Lab.Path.html#55811" class="Bound">i</a> <a id="55837" href="1Lab.Path.html#55816" class="Bound">a</a> <a data-type="A → A → Type ℓ" id="55839" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="55841" href="1Lab.Path.html#55816" class="Bound">a</a><a id="55842" class="Symbol">)</a> <a id="55844" href="1Lab.Path.html#55797" class="Bound">i</a> <a id="55846" class="Symbol">(λ</a> <a id="55849" href="1Lab.Path.html#55849" class="Bound">_</a> <a id="55851" class="Symbol">→</a> <a data-type="x ≡ x" id="55853" href="1Lab.Path.html#3593" class="Function">refl</a><a id="55857" class="Symbol">)</a>
</pre>
<p>Using the Cartesian coercions, we define maps that convert between <span class="Agda"><a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a></span>s and Book dependent paths. These maps could also be defined in terms of <span class="Agda"><a href="1Lab.Path.html#2405" class="Primitive">transp</a></span> and <span class="Agda"><a data-type="(P : I → Type ℓ) (p : P i0) (q : P i1) →
PathP P p q ≡ Path (P i1) (transport P p) q" href="1Lab.Path.html#49358" class="Function">PathP≡Path</a></span>, but this definition is more efficient.</p>
<pre class="Agda"><a id="to-pathp"></a><a data-type="coe0→1 A x ≡ y → PathP A x y" id="56107" href="1Lab.Path.html#56107" class="Function">to-pathp</a> <a id="56116" class="Symbol">:</a> <a id="56118" class="Symbol">∀</a> <a id="56120" class="Symbol">{</a><a id="56121" href="1Lab.Path.html#56121" class="Bound">ℓ</a><a id="56122" class="Symbol">}</a> <a id="56124" class="Symbol">{</a><a id="56125" href="1Lab.Path.html#56125" class="Bound">A</a> <a id="56127" class="Symbol">:</a> <a id="56129" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="56131" class="Symbol">→</a> <a id="56133" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="56138" href="1Lab.Path.html#56121" class="Bound">ℓ</a><a id="56139" class="Symbol">}</a> <a id="56141" class="Symbol">{</a><a id="56142" href="1Lab.Path.html#56142" class="Bound">x</a> <a id="56144" class="Symbol">:</a> <a id="56146" href="1Lab.Path.html#56125" class="Bound">A</a> <a id="56148" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="56150" class="Symbol">}</a> <a id="56152" class="Symbol">{</a><a id="56153" href="1Lab.Path.html#56153" class="Bound">y</a> <a id="56155" class="Symbol">:</a> <a id="56157" href="1Lab.Path.html#56125" class="Bound">A</a> <a id="56159" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="56161" class="Symbol">}</a>
         <a id="56172" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1" id="56174" href="1Lab.Path.html#51412" class="Function">coe0→1</a> <a id="56181" href="1Lab.Path.html#56125" class="Bound">A</a> <a id="56183" href="1Lab.Path.html#56142" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="56185" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="56187" href="1Lab.Path.html#56153" class="Bound">y</a>
         <a id="56198" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="56200" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="56206" href="1Lab.Path.html#56125" class="Bound">A</a> <a id="56208" href="1Lab.Path.html#56142" class="Bound">x</a> <a id="56210" href="1Lab.Path.html#56153" class="Bound">y</a>
<a data-type="coe0→1 A x ≡ y → PathP A x y" id="56212" href="1Lab.Path.html#56107" class="Function">to-pathp</a> <a id="56221" class="Symbol">{</a><a id="56222" class="Argument">A</a> <a id="56224" class="Symbol">=</a> <a id="56226" href="1Lab.Path.html#56226" class="Bound">A</a><a id="56227" class="Symbol">}</a> <a id="56229" class="Symbol">{</a><a id="56230" href="1Lab.Path.html#56230" class="Bound">x</a><a id="56231" class="Symbol">}</a> <a id="56233" href="1Lab.Path.html#56233" class="Bound">p</a> <a id="56235" href="1Lab.Path.html#56235" class="Bound">i</a> <a id="56237" class="Symbol">=</a>
  <a id="56241" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="56247" class="Symbol">(λ</a> <a id="56250" href="1Lab.Path.html#56250" class="Bound">j</a> <a id="56252" class="Symbol">→</a> <a id="56254" class="Symbol">λ</a> <a id="56256" class="Symbol">{</a> <a id="56258" class="Symbol">(</a><a id="56259" href="1Lab.Path.html#56235" class="Bound">i</a> <a id="56261" class="Symbol">=</a> <a id="56263" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="56265" class="Symbol">)</a> <a id="56267" class="Symbol">→</a> <a id="56269" href="1Lab.Path.html#56230" class="Bound">x</a>
                 <a id="56288" class="Symbol">;</a> <a id="56290" class="Symbol">(</a><a id="56291" href="1Lab.Path.html#56235" class="Bound">i</a> <a id="56293" class="Symbol">=</a> <a id="56295" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="56297" class="Symbol">)</a> <a id="56299" class="Symbol">→</a> <a id="56301" href="1Lab.Path.html#56233" class="Bound">p</a> <a id="56303" href="1Lab.Path.html#56250" class="Bound">j</a> <a id="56305" class="Symbol">})</a>
        <a id="56316" class="Symbol">(</a><a data-type="(A : I → Type ℓ) (i : I) → A i0 → A i" id="56317" href="1Lab.Path.html#51867" class="Function">coe0→i</a> <a id="56324" href="1Lab.Path.html#56226" class="Bound">A</a> <a id="56326" href="1Lab.Path.html#56235" class="Bound">i</a> <a id="56328" href="1Lab.Path.html#56230" class="Bound">x</a><a id="56329" class="Symbol">)</a>

<a id="from-pathp"></a><a data-type="PathP A x y → coe0→1 A x ≡ y" id="56332" href="1Lab.Path.html#56332" class="Function">from-pathp</a> <a id="56343" class="Symbol">:</a> <a id="56345" class="Symbol">∀</a> <a id="56347" class="Symbol">{</a><a id="56348" href="1Lab.Path.html#56348" class="Bound">ℓ</a><a id="56349" class="Symbol">}</a> <a id="56351" class="Symbol">{</a><a id="56352" href="1Lab.Path.html#56352" class="Bound">A</a> <a id="56354" class="Symbol">:</a> <a id="56356" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="56358" class="Symbol">→</a> <a id="56360" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="56365" href="1Lab.Path.html#56348" class="Bound">ℓ</a><a id="56366" class="Symbol">}</a> <a id="56368" class="Symbol">{</a><a id="56369" href="1Lab.Path.html#56369" class="Bound">x</a> <a id="56371" class="Symbol">:</a> <a id="56373" href="1Lab.Path.html#56352" class="Bound">A</a> <a id="56375" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="56377" class="Symbol">}</a> <a id="56379" class="Symbol">{</a><a id="56380" href="1Lab.Path.html#56380" class="Bound">y</a> <a id="56382" class="Symbol">:</a> <a id="56384" href="1Lab.Path.html#56352" class="Bound">A</a> <a id="56386" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="56388" class="Symbol">}</a>
           <a id="56401" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="56403" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="56409" href="1Lab.Path.html#56352" class="Bound">A</a> <a id="56411" href="1Lab.Path.html#56369" class="Bound">x</a> <a id="56413" href="1Lab.Path.html#56380" class="Bound">y</a>
           <a id="56426" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1" id="56428" href="1Lab.Path.html#51412" class="Function">coe0→1</a> <a id="56435" href="1Lab.Path.html#56352" class="Bound">A</a> <a id="56437" href="1Lab.Path.html#56369" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="56439" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="56441" href="1Lab.Path.html#56380" class="Bound">y</a>
<a data-type="PathP A x y → coe0→1 A x ≡ y" id="56443" href="1Lab.Path.html#56332" class="Function">from-pathp</a> <a id="56454" class="Symbol">{</a><a id="56455" class="Argument">A</a> <a id="56457" class="Symbol">=</a> <a id="56459" href="1Lab.Path.html#56459" class="Bound">A</a><a id="56460" class="Symbol">}</a> <a id="56462" href="1Lab.Path.html#56462" class="Bound">p</a> <a id="56464" href="1Lab.Path.html#56464" class="Bound">i</a> <a id="56466" class="Symbol">=</a> <a data-type="(A : I → Type ℓ) (i : I) → A i → A i1" id="56468" href="1Lab.Path.html#53652" class="Function">coei→1</a> <a id="56475" href="1Lab.Path.html#56459" class="Bound">A</a> <a id="56477" href="1Lab.Path.html#56464" class="Bound">i</a> <a id="56479" class="Symbol">(</a><a id="56480" href="1Lab.Path.html#56462" class="Bound">p</a> <a id="56482" href="1Lab.Path.html#56464" class="Bound">i</a><a id="56483" class="Symbol">)</a>
</pre>
<p>These definitions illustrate how using the named squeezes and spreads — <span class="Agda"><a data-type="(A : I → Type ℓ) (i : I) → A i0 → A i" href="1Lab.Path.html#51867" class="Function">coe0→i</a></span>, <span class="Agda"><a data-type="(A : I → Type ℓ) (i : I) → A i → A i1" href="1Lab.Path.html#53652" class="Function">coei→1</a></span> — can be a lot more elegant than trying to work out what composition to use in a <span class="Agda"><a href="1Lab.Path.html#2405" class="Primitive">transp</a></span>.</p>
<h1 id="path-spaces"><a href="#path-spaces" class="header-link">Path Spaces<span class="header-link-emoji">🔗</span></a></h1>
<p>A large part of the study of HoTT is the <em>characterisation of path spaces</em>. Given a type <code>A</code>, what does <code>Path A x y</code> look like? <a href="1Lab.HLevel.Sets.html">Hedberg’s theorem</a> says that for types with decidable equality, it’s boring. For <a href="1Lab.HIT.S1.html">the circle</a>, we can prove its loop space is the integers — we have <code>Path S¹ base base ≡ Int</code>.</p>
<p>Most of these characterisations need machinery that is not in this module to be properly stated. Even then, we can begin to outline a few simple cases:</p>
<h2 id="σ-types"><a href="#σ-types" class="header-link">Σ Types<span class="header-link-emoji">🔗</span></a></h2>
<p>For <span class="Agda"><a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" href="1Lab.Type.html#1573" class="Function">Σ</a></span> types, a path between <code>(a , b) ≡ (x , y)</code> consists of a path <code>p : a ≡ x</code>, and a path between <code>b</code> and <code>y</code> laying over <code>p</code>.</p>
<pre class="Agda"><a id="Σ-pathp"></a><a data-type="(p : x .fst ≡ y .fst) →
PathP (λ i → B₁ (p i)) (x .snd) (y .snd) → x ≡ y" id="57407" href="1Lab.Path.html#57407" class="Function">Σ-pathp</a> <a id="57415" class="Symbol">:</a> <a id="57417" class="Symbol">∀</a> <a id="57419" class="Symbol">{</a><a id="57420" href="1Lab.Path.html#57420" class="Bound">a</a> <a id="57422" href="1Lab.Path.html#57422" class="Bound">b</a><a id="57423" class="Symbol">}</a> <a id="57425" class="Symbol">{</a><a id="57426" href="1Lab.Path.html#57426" class="Bound">A</a> <a id="57428" class="Symbol">:</a> <a id="57430" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="57435" href="1Lab.Path.html#57420" class="Bound">a</a><a id="57436" class="Symbol">}</a> <a id="57438" class="Symbol">{</a><a id="57439" href="1Lab.Path.html#57439" class="Bound">B</a> <a id="57441" class="Symbol">:</a> <a id="57443" href="1Lab.Path.html#57426" class="Bound">A</a> <a id="57445" class="Symbol">→</a> <a id="57447" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="57452" href="1Lab.Path.html#57422" class="Bound">b</a><a id="57453" class="Symbol">}</a>
        <a id="57463" class="Symbol">→</a> <a id="57465" class="Symbol">{</a><a id="57466" href="1Lab.Path.html#57466" class="Bound">x</a> <a id="57468" href="1Lab.Path.html#57468" class="Bound">y</a> <a id="57470" class="Symbol">:</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="57472" href="1Lab.Type.html#1573" class="Function">Σ</a> <a id="57474" href="1Lab.Path.html#57439" class="Bound">B</a><a id="57475" class="Symbol">}</a>
        <a id="57485" class="Symbol">→</a> <a id="57487" class="Symbol">(</a><a id="57488" href="1Lab.Path.html#57488" class="Bound">p</a> <a id="57490" class="Symbol">:</a> <a id="57492" href="1Lab.Path.html#57466" class="Bound">x</a> <a id="57494" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="57495" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="A → A → Type ℓ" id="57499" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="57501" href="1Lab.Path.html#57468" class="Bound">y</a> <a id="57503" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="57504" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="57507" class="Symbol">)</a>
        <a id="57517" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="57519" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="57525" class="Symbol">(λ</a> <a id="57528" href="1Lab.Path.html#57528" class="Bound">i</a> <a id="57530" class="Symbol">→</a> <a id="57532" href="1Lab.Path.html#57439" class="Bound">B</a> <a id="57534" class="Symbol">(</a><a id="57535" href="1Lab.Path.html#57488" class="Bound">p</a> <a id="57537" href="1Lab.Path.html#57528" class="Bound">i</a><a id="57538" class="Symbol">))</a> <a id="57541" class="Symbol">(</a><a id="57542" href="1Lab.Path.html#57466" class="Bound">x</a> <a id="57544" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="57545" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="57548" class="Symbol">)</a> <a id="57550" class="Symbol">(</a><a id="57551" href="1Lab.Path.html#57468" class="Bound">y</a> <a id="57553" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="57554" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="57557" class="Symbol">)</a>
        <a id="57567" class="Symbol">→</a> <a id="57569" href="1Lab.Path.html#57466" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="57571" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="57573" href="1Lab.Path.html#57468" class="Bound">y</a>
<a data-type="(p : x .fst ≡ y .fst) →
PathP (λ i → B₁ (p i)) (x .snd) (y .snd) → x ≡ y" id="57575" href="1Lab.Path.html#57407" class="Function">Σ-pathp</a> <a id="57583" href="1Lab.Path.html#57583" class="Bound">p</a> <a id="57585" href="1Lab.Path.html#57585" class="Bound">q</a> <a id="57587" href="1Lab.Path.html#57587" class="Bound">i</a> <a id="57589" class="Symbol">=</a> <a id="57591" href="1Lab.Path.html#57583" class="Bound">p</a> <a id="57593" href="1Lab.Path.html#57587" class="Bound">i</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="57595" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="57597" href="1Lab.Path.html#57585" class="Bound">q</a> <a id="57599" href="1Lab.Path.html#57587" class="Bound">i</a>
</pre>
<p>We can also use the book characterisation of dependent paths, which is simpler in the case where the <span class="Agda"><a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" href="1Lab.Type.html#1573" class="Function">Σ</a></span> represents a subset — i.e., <code>B</code> is a family of propositions.</p>
<pre class="Agda"><a id="Σ-path"></a><a data-type="(p : x .fst ≡ y .fst) → subst B₁ p (x .snd) ≡ y .snd → x ≡ y" id="57790" href="1Lab.Path.html#57790" class="Function">Σ-path</a> <a id="57797" class="Symbol">:</a> <a id="57799" class="Symbol">∀</a> <a id="57801" class="Symbol">{</a><a id="57802" href="1Lab.Path.html#57802" class="Bound">a</a> <a id="57804" href="1Lab.Path.html#57804" class="Bound">b</a><a id="57805" class="Symbol">}</a> <a id="57807" class="Symbol">{</a><a id="57808" href="1Lab.Path.html#57808" class="Bound">A</a> <a id="57810" class="Symbol">:</a> <a id="57812" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="57817" href="1Lab.Path.html#57802" class="Bound">a</a><a id="57818" class="Symbol">}</a> <a id="57820" class="Symbol">{</a><a id="57821" href="1Lab.Path.html#57821" class="Bound">B</a> <a id="57823" class="Symbol">:</a> <a id="57825" href="1Lab.Path.html#57808" class="Bound">A</a> <a id="57827" class="Symbol">→</a> <a id="57829" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="57834" href="1Lab.Path.html#57804" class="Bound">b</a><a id="57835" class="Symbol">}</a>
       <a id="57844" class="Symbol">→</a> <a id="57846" class="Symbol">{</a><a id="57847" href="1Lab.Path.html#57847" class="Bound">x</a> <a id="57849" href="1Lab.Path.html#57849" class="Bound">y</a> <a id="57851" class="Symbol">:</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="57853" href="1Lab.Type.html#1573" class="Function">Σ</a> <a id="57855" href="1Lab.Path.html#57821" class="Bound">B</a><a id="57856" class="Symbol">}</a>
       <a id="57865" class="Symbol">→</a> <a id="57867" class="Symbol">(</a><a id="57868" href="1Lab.Path.html#57868" class="Bound">p</a> <a id="57870" class="Symbol">:</a> <a id="57872" href="1Lab.Path.html#57847" class="Bound">x</a> <a id="57874" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="57875" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="A → A → Type ℓ" id="57879" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="57881" href="1Lab.Path.html#57849" class="Bound">y</a> <a id="57883" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="57884" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="57887" class="Symbol">)</a>
       <a id="57896" class="Symbol">→</a> <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="57898" href="1Lab.Path.html#15381" class="Function">subst</a> <a id="57904" href="1Lab.Path.html#57821" class="Bound">B</a> <a id="57906" href="1Lab.Path.html#57868" class="Bound">p</a> <a id="57908" class="Symbol">(</a><a id="57909" href="1Lab.Path.html#57847" class="Bound">x</a> <a id="57911" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="57912" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="57915" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="57917" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="57919" class="Symbol">(</a><a id="57920" href="1Lab.Path.html#57849" class="Bound">y</a> <a id="57922" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="57923" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="57926" class="Symbol">)</a>
       <a id="57935" class="Symbol">→</a> <a id="57937" href="1Lab.Path.html#57847" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="57939" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="57941" href="1Lab.Path.html#57849" class="Bound">y</a>
<a data-type="(p : x .fst ≡ y .fst) → subst B₁ p (x .snd) ≡ y .snd → x ≡ y" id="57943" href="1Lab.Path.html#57790" class="Function">Σ-path</a> <a id="57950" class="Symbol">{</a><a id="57951" class="Argument">A</a> <a id="57953" class="Symbol">=</a> <a id="57955" href="1Lab.Path.html#57955" class="Bound">A</a><a id="57956" class="Symbol">}</a> <a id="57958" class="Symbol">{</a><a id="57959" href="1Lab.Path.html#57959" class="Bound">B</a><a id="57960" class="Symbol">}</a> <a id="57962" class="Symbol">{</a><a id="57963" href="1Lab.Path.html#57963" class="Bound">x</a><a id="57964" class="Symbol">}</a> <a id="57966" class="Symbol">{</a><a id="57967" href="1Lab.Path.html#57967" class="Bound">y</a><a id="57968" class="Symbol">}</a> <a id="57970" href="1Lab.Path.html#57970" class="Bound">p</a> <a id="57972" href="1Lab.Path.html#57972" class="Bound">q</a> <a id="57974" class="Symbol">=</a> <a data-type="(p : x .fst ≡ y .fst) →
PathP (λ i → B₁ (p i)) (x .snd) (y .snd) → x ≡ y" id="57976" href="1Lab.Path.html#57407" class="Function">Σ-pathp</a> <a id="57984" href="1Lab.Path.html#57970" class="Bound">p</a> <a id="57986" class="Symbol">(</a><a data-type="coe0→1 A x ≡ y → PathP A x y" id="57987" href="1Lab.Path.html#56107" class="Function">to-pathp</a> <a id="57996" href="1Lab.Path.html#57972" class="Bound">q</a><a id="57997" class="Symbol">)</a>
</pre>
<h2 id="π-types"><a href="#π-types" class="header-link">Π types<span class="header-link-emoji">🔗</span></a></h2>
<p>For dependent functions, the paths are <em>homotopies</em>, in the topological sense: <code>Path ((x : A) → B x) f g</code> is the same thing as a function <code>I → (x : A) → B x</code> — which we could turn into a product if we really wanted to.</p>
<pre class="Agda"><a id="happly"></a><a data-type="f ≡ g → (x : A) → f x ≡ g x" id="58246" href="1Lab.Path.html#58246" class="Function">happly</a> <a id="58253" class="Symbol">:</a> <a id="58255" class="Symbol">∀</a> <a id="58257" class="Symbol">{</a><a id="58258" href="1Lab.Path.html#58258" class="Bound">a</a> <a id="58260" href="1Lab.Path.html#58260" class="Bound">b</a><a id="58261" class="Symbol">}</a> <a id="58263" class="Symbol">{</a><a id="58264" href="1Lab.Path.html#58264" class="Bound">A</a> <a id="58266" class="Symbol">:</a> <a id="58268" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="58273" href="1Lab.Path.html#58258" class="Bound">a</a><a id="58274" class="Symbol">}</a> <a id="58276" class="Symbol">{</a><a id="58277" href="1Lab.Path.html#58277" class="Bound">B</a> <a id="58279" class="Symbol">:</a> <a id="58281" href="1Lab.Path.html#58264" class="Bound">A</a> <a id="58283" class="Symbol">→</a> <a id="58285" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="58290" href="1Lab.Path.html#58260" class="Bound">b</a><a id="58291" class="Symbol">}</a>
         <a id="58302" class="Symbol">{</a><a id="58303" href="1Lab.Path.html#58303" class="Bound">f</a> <a id="58305" href="1Lab.Path.html#58305" class="Bound">g</a> <a id="58307" class="Symbol">:</a> <a id="58309" class="Symbol">(</a><a id="58310" href="1Lab.Path.html#58310" class="Bound">x</a> <a id="58312" class="Symbol">:</a> <a id="58314" href="1Lab.Path.html#58264" class="Bound">A</a><a id="58315" class="Symbol">)</a> <a id="58317" class="Symbol">→</a> <a id="58319" href="1Lab.Path.html#58277" class="Bound">B</a> <a id="58321" href="1Lab.Path.html#58310" class="Bound">x</a><a id="58322" class="Symbol">}</a>
       <a id="58331" class="Symbol">→</a> <a id="58333" href="1Lab.Path.html#58303" class="Bound">f</a> <a data-type="A → A → Type ℓ" id="58335" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="58337" href="1Lab.Path.html#58305" class="Bound">g</a> <a id="58339" class="Symbol">→</a> <a id="58341" class="Symbol">(</a><a id="58342" href="1Lab.Path.html#58342" class="Bound">x</a> <a id="58344" class="Symbol">:</a> <a id="58346" href="1Lab.Path.html#58264" class="Bound">A</a><a id="58347" class="Symbol">)</a> <a id="58349" class="Symbol">→</a> <a id="58351" href="1Lab.Path.html#58303" class="Bound">f</a> <a id="58353" href="1Lab.Path.html#58342" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="58355" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="58357" href="1Lab.Path.html#58305" class="Bound">g</a> <a id="58359" href="1Lab.Path.html#58342" class="Bound">x</a>
<a data-type="f ≡ g → (x : A) → f x ≡ g x" id="58361" href="1Lab.Path.html#58246" class="Function">happly</a> <a id="58368" href="1Lab.Path.html#58368" class="Bound">p</a> <a id="58370" href="1Lab.Path.html#58370" class="Bound">x</a> <a id="58372" href="1Lab.Path.html#58372" class="Bound">i</a> <a id="58374" class="Symbol">=</a> <a id="58376" href="1Lab.Path.html#58368" class="Bound">p</a> <a id="58378" href="1Lab.Path.html#58372" class="Bound">i</a> <a id="58380" href="1Lab.Path.html#58370" class="Bound">x</a>
</pre>
<p>With this, we have made definitional yet another principle which is propositional in the HoTT book: <em>function extensionality</em>. Functions are identical precisely if they assign the same outputs to every input.</p>
<pre class="Agda"><a id="funext"></a><a data-type="((x : A) → f x ≡ g x) → f ≡ g" id="58605" href="1Lab.Path.html#58605" class="Function">funext</a> <a id="58612" class="Symbol">:</a> <a id="58614" class="Symbol">∀</a> <a id="58616" class="Symbol">{</a><a id="58617" href="1Lab.Path.html#58617" class="Bound">a</a> <a id="58619" href="1Lab.Path.html#58619" class="Bound">b</a><a id="58620" class="Symbol">}</a> <a id="58622" class="Symbol">{</a><a id="58623" href="1Lab.Path.html#58623" class="Bound">A</a> <a id="58625" class="Symbol">:</a> <a id="58627" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="58632" href="1Lab.Path.html#58617" class="Bound">a</a><a id="58633" class="Symbol">}</a> <a id="58635" class="Symbol">{</a><a id="58636" href="1Lab.Path.html#58636" class="Bound">B</a> <a id="58638" class="Symbol">:</a> <a id="58640" href="1Lab.Path.html#58623" class="Bound">A</a> <a id="58642" class="Symbol">→</a> <a id="58644" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="58649" href="1Lab.Path.html#58619" class="Bound">b</a><a id="58650" class="Symbol">}</a>
         <a id="58661" class="Symbol">{</a><a id="58662" href="1Lab.Path.html#58662" class="Bound">f</a> <a id="58664" href="1Lab.Path.html#58664" class="Bound">g</a> <a id="58666" class="Symbol">:</a> <a id="58668" class="Symbol">(</a><a id="58669" href="1Lab.Path.html#58669" class="Bound">x</a> <a id="58671" class="Symbol">:</a> <a id="58673" href="1Lab.Path.html#58623" class="Bound">A</a><a id="58674" class="Symbol">)</a> <a id="58676" class="Symbol">→</a> <a id="58678" href="1Lab.Path.html#58636" class="Bound">B</a> <a id="58680" href="1Lab.Path.html#58669" class="Bound">x</a><a id="58681" class="Symbol">}</a>
       <a id="58690" class="Symbol">→</a> <a id="58692" class="Symbol">((</a><a id="58694" href="1Lab.Path.html#58694" class="Bound">x</a> <a id="58696" class="Symbol">:</a> <a id="58698" href="1Lab.Path.html#58623" class="Bound">A</a><a id="58699" class="Symbol">)</a> <a id="58701" class="Symbol">→</a> <a id="58703" href="1Lab.Path.html#58662" class="Bound">f</a> <a id="58705" href="1Lab.Path.html#58694" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="58707" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="58709" href="1Lab.Path.html#58664" class="Bound">g</a> <a id="58711" href="1Lab.Path.html#58694" class="Bound">x</a><a id="58712" class="Symbol">)</a> <a id="58714" class="Symbol">→</a> <a id="58716" href="1Lab.Path.html#58662" class="Bound">f</a> <a data-type="A → A → Type ℓ" id="58718" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="58720" href="1Lab.Path.html#58664" class="Bound">g</a>
<a data-type="((x : A) → f x ≡ g x) → f ≡ g" id="58722" href="1Lab.Path.html#58605" class="Function">funext</a> <a id="58729" href="1Lab.Path.html#58729" class="Bound">p</a> <a id="58731" href="1Lab.Path.html#58731" class="Bound">i</a> <a id="58733" href="1Lab.Path.html#58733" class="Bound">x</a> <a id="58735" class="Symbol">=</a> <a id="58737" href="1Lab.Path.html#58729" class="Bound">p</a> <a id="58739" href="1Lab.Path.html#58733" class="Bound">x</a> <a id="58741" href="1Lab.Path.html#58731" class="Bound">i</a>
</pre>
<p>Furthermore, we know (since types are groupoids, and functions are functors) that, by analogy with 1-category theory, paths in a function type should behave like natural transformations (because they are arrows in a functor category). This is indeed the case:</p>
<pre class="Agda"><a id="homotopy-natural"></a><a data-type="(H : (x : A) → f x ≡ g x) (p : x ≡ y) → H x ∙ ap g p ≡ ap f p ∙ H y" id="59017" href="1Lab.Path.html#59017" class="Function">homotopy-natural</a> <a id="59034" class="Symbol">:</a> <a id="59036" class="Symbol">∀</a> <a id="59038" class="Symbol">{</a><a id="59039" href="1Lab.Path.html#59039" class="Bound">a</a> <a id="59041" href="1Lab.Path.html#59041" class="Bound">b</a><a id="59042" class="Symbol">}</a> <a id="59044" class="Symbol">{</a><a id="59045" href="1Lab.Path.html#59045" class="Bound">A</a> <a id="59047" class="Symbol">:</a> <a id="59049" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="59054" href="1Lab.Path.html#59039" class="Bound">a</a><a id="59055" class="Symbol">}</a> <a id="59057" class="Symbol">{</a><a id="59058" href="1Lab.Path.html#59058" class="Bound">B</a> <a id="59060" class="Symbol">:</a> <a id="59062" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="59067" href="1Lab.Path.html#59041" class="Bound">b</a><a id="59068" class="Symbol">}</a>
                 <a id="59087" class="Symbol">→</a> <a id="59089" class="Symbol">{</a><a id="59090" href="1Lab.Path.html#59090" class="Bound">f</a> <a id="59092" href="1Lab.Path.html#59092" class="Bound">g</a> <a id="59094" class="Symbol">:</a> <a id="59096" href="1Lab.Path.html#59045" class="Bound">A</a> <a id="59098" class="Symbol">→</a> <a id="59100" href="1Lab.Path.html#59058" class="Bound">B</a><a id="59101" class="Symbol">}</a>
                 <a id="59120" class="Symbol">→</a> <a id="59122" class="Symbol">(</a><a id="59123" href="1Lab.Path.html#59123" class="Bound">H</a> <a id="59125" class="Symbol">:</a> <a id="59127" class="Symbol">(</a><a id="59128" href="1Lab.Path.html#59128" class="Bound">x</a> <a id="59130" class="Symbol">:</a> <a id="59132" href="1Lab.Path.html#59045" class="Bound">A</a><a id="59133" class="Symbol">)</a> <a id="59135" class="Symbol">→</a> <a id="59137" href="1Lab.Path.html#59090" class="Bound">f</a> <a id="59139" href="1Lab.Path.html#59128" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="59141" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="59143" href="1Lab.Path.html#59092" class="Bound">g</a> <a id="59145" href="1Lab.Path.html#59128" class="Bound">x</a><a id="59146" class="Symbol">)</a>
                 <a id="59165" class="Symbol">→</a> <a id="59167" class="Symbol">{</a><a id="59168" href="1Lab.Path.html#59168" class="Bound">x</a> <a id="59170" href="1Lab.Path.html#59170" class="Bound">y</a> <a id="59172" class="Symbol">:</a> <a id="59174" href="1Lab.Path.html#59045" class="Bound">A</a><a id="59175" class="Symbol">}</a> <a id="59177" class="Symbol">(</a><a id="59178" href="1Lab.Path.html#59178" class="Bound">p</a> <a id="59180" class="Symbol">:</a> <a id="59182" href="1Lab.Path.html#59168" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="59184" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="59186" href="1Lab.Path.html#59170" class="Bound">y</a><a id="59187" class="Symbol">)</a>
                 <a id="59206" class="Symbol">→</a> <a id="59208" href="1Lab.Path.html#59123" class="Bound">H</a> <a id="59210" href="1Lab.Path.html#59168" class="Bound">x</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="59212" href="1Lab.Path.html#39613" class="Function Operator">∙</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="59214" href="1Lab.Path.html#20828" class="Function">ap</a> <a id="59217" href="1Lab.Path.html#59092" class="Bound">g</a> <a id="59219" href="1Lab.Path.html#59178" class="Bound">p</a> <a data-type="A → A → Type ℓ" id="59221" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="59223" href="1Lab.Path.html#20828" class="Function">ap</a> <a id="59226" href="1Lab.Path.html#59090" class="Bound">f</a> <a id="59228" href="1Lab.Path.html#59178" class="Bound">p</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="59230" href="1Lab.Path.html#39613" class="Function Operator">∙</a> <a id="59232" href="1Lab.Path.html#59123" class="Bound">H</a> <a id="59234" href="1Lab.Path.html#59170" class="Bound">y</a>
<a data-type="(H : (x : A) → f x ≡ g x) (p : x ≡ y) → H x ∙ ap g p ≡ ap f p ∙ H y" id="59236" href="1Lab.Path.html#59017" class="Function">homotopy-natural</a> <a id="59253" class="Symbol">{</a><a id="59254" class="Argument">f</a> <a id="59256" class="Symbol">=</a> <a id="59258" href="1Lab.Path.html#59258" class="Bound">f</a><a id="59259" class="Symbol">}</a> <a id="59261" class="Symbol">{</a><a id="59262" class="Argument">g</a> <a id="59264" class="Symbol">=</a> <a id="59266" href="1Lab.Path.html#59266" class="Bound">g</a><a id="59267" class="Symbol">}</a> <a id="59269" href="1Lab.Path.html#59269" class="Bound">H</a> <a id="59271" href="1Lab.Path.html#59271" class="Bound">p</a> <a id="59273" class="Symbol">=</a>
  <a data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" id="59277" href="1Lab.Path.html#19616" class="Function">J</a> <a id="59279" class="Symbol">(λ</a> <a id="59282" href="1Lab.Path.html#59282" class="Bound">_</a> <a id="59284" href="1Lab.Path.html#59284" class="Bound">p</a> <a id="59286" class="Symbol">→</a> <a id="59288" href="1Lab.Path.html#59269" class="Bound">H</a> <a id="59290" class="Symbol">_</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="59292" href="1Lab.Path.html#39613" class="Function Operator">∙</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="59294" href="1Lab.Path.html#20828" class="Function">ap</a> <a id="59297" href="1Lab.Path.html#59266" class="Bound">g</a> <a id="59299" href="1Lab.Path.html#59284" class="Bound">p</a> <a data-type="A → A → Type ℓ" id="59301" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="59303" href="1Lab.Path.html#20828" class="Function">ap</a> <a id="59306" href="1Lab.Path.html#59258" class="Bound">f</a> <a id="59308" href="1Lab.Path.html#59284" class="Bound">p</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="59310" href="1Lab.Path.html#39613" class="Function Operator">∙</a> <a id="59312" href="1Lab.Path.html#59269" class="Bound">H</a> <a id="59314" class="Symbol">_)</a>
    <a id="59321" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="59322" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="59326" class="Symbol">(</a><a data-type="(p : x ≡ y) (q : y ≡ z) → Square refl p (p ∙ q) q" id="59327" href="1Lab.Path.html#39961" class="Function">∙-filler</a> <a id="59336" class="Symbol">(</a><a id="59337" href="1Lab.Path.html#59269" class="Bound">H</a> <a id="59339" class="Symbol">_)</a> <a data-type="x ≡ x" id="59342" href="1Lab.Path.html#3593" class="Function">refl</a><a id="59346" class="Symbol">)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="59348" href="1Lab.Path.html#39613" class="Function Operator">∙</a> <a data-type="(p : x ≡ y) (q : y ≡ z) → Square (sym p) q (p ∙ q) refl" id="59350" href="1Lab.Path.html#40460" class="Function">∙-filler&#39;</a> <a data-type="x ≡ x" id="59360" href="1Lab.Path.html#3593" class="Function">refl</a> <a id="59365" class="Symbol">(</a><a id="59366" href="1Lab.Path.html#59269" class="Bound">H</a> <a id="59368" class="Symbol">_))</a>
    <a id="59376" href="1Lab.Path.html#59271" class="Bound">p</a>
</pre>
<h2 id="paths-1"><a href="#paths-1" class="header-link">Paths<span class="header-link-emoji">🔗</span></a></h2>
<p>The groupoid structure of <em>paths</em> is also interesting. While the characterisation of <code>Path (Path A x y) p q</code> is fundamentally tied to the characterisation of <code>A</code>, there are general theorems that can be proven about <em>transport</em> in path spaces. For example, substituting on both endpoints of a path is equivalent to a ternary composition:</p>
<pre class="Agda"><a id="subst-path-both"></a><a data-type="(loop₁ : x ≡ x) (adj : x ≡ y) →
subst (λ x → x ≡ x) adj loop₁ ≡ sym adj ∙ loop₁ ∙ adj" id="59739" href="1Lab.Path.html#59739" class="Function">subst-path-both</a> <a id="59755" class="Symbol">:</a> <a id="59757" class="Symbol">∀</a> <a id="59759" class="Symbol">{</a><a id="59760" href="1Lab.Path.html#59760" class="Bound">ℓ</a><a id="59761" class="Symbol">}</a> <a id="59763" class="Symbol">{</a><a id="59764" href="1Lab.Path.html#59764" class="Bound">A</a> <a id="59766" class="Symbol">:</a> <a id="59768" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="59773" href="1Lab.Path.html#59760" class="Bound">ℓ</a><a id="59774" class="Symbol">}</a> <a id="59776" class="Symbol">{</a><a id="59777" href="1Lab.Path.html#59777" class="Bound">x</a> <a id="59779" href="1Lab.Path.html#59779" class="Bound">y</a> <a id="59781" class="Symbol">:</a> <a id="59783" href="1Lab.Path.html#59764" class="Bound">A</a><a id="59784" class="Symbol">}</a>
                <a id="59802" class="Symbol">→</a> <a id="59804" class="Symbol">(</a><a id="59805" href="1Lab.Path.html#59805" class="Bound">loop</a> <a id="59810" class="Symbol">:</a> <a id="59812" href="1Lab.Path.html#59777" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="59814" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="59816" href="1Lab.Path.html#59777" class="Bound">x</a><a id="59817" class="Symbol">)</a>
                <a id="59835" class="Symbol">→</a> <a id="59837" class="Symbol">(</a><a id="59838" href="1Lab.Path.html#59838" class="Bound">adj</a> <a id="59842" class="Symbol">:</a> <a id="59844" href="1Lab.Path.html#59777" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="59846" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="59848" href="1Lab.Path.html#59779" class="Bound">y</a><a id="59849" class="Symbol">)</a>
                <a id="59867" class="Symbol">→</a> <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="59869" href="1Lab.Path.html#15381" class="Function">subst</a> <a id="59875" class="Symbol">(λ</a> <a id="59878" href="1Lab.Path.html#59878" class="Bound">x</a> <a id="59880" class="Symbol">→</a> <a id="59882" href="1Lab.Path.html#59878" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="59884" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="59886" href="1Lab.Path.html#59878" class="Bound">x</a><a id="59887" class="Symbol">)</a> <a id="59889" href="1Lab.Path.html#59838" class="Bound">adj</a> <a id="59893" href="1Lab.Path.html#59805" class="Bound">loop</a> <a data-type="A → A → Type ℓ" id="59898" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="x ≡ y → y ≡ x" id="59900" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="59904" href="1Lab.Path.html#59838" class="Bound">adj</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="59908" href="1Lab.Path.html#39613" class="Function Operator">∙</a> <a id="59910" href="1Lab.Path.html#59805" class="Bound">loop</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="59915" href="1Lab.Path.html#39613" class="Function Operator">∙</a> <a id="59917" href="1Lab.Path.html#59838" class="Bound">adj</a>
<a data-type="(loop₁ : x ≡ x) (adj : x ≡ y) →
subst (λ x → x ≡ x) adj loop₁ ≡ sym adj ∙ loop₁ ∙ adj" id="59921" href="1Lab.Path.html#59739" class="Function">subst-path-both</a> <a id="59937" href="1Lab.Path.html#59937" class="Bound">loop</a> <a id="59942" href="1Lab.Path.html#59942" class="Bound">adj</a> <a id="59946" class="Symbol">=</a>
  <a data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" id="59950" href="1Lab.Path.html#19616" class="Function">J</a> <a id="59952" class="Symbol">(λ</a> <a id="59955" href="1Lab.Path.html#59955" class="Bound">_</a> <a id="59957" href="1Lab.Path.html#59957" class="Bound">adj</a> <a id="59961" class="Symbol">→</a> <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="59963" href="1Lab.Path.html#15381" class="Function">subst</a> <a id="59969" class="Symbol">(λ</a> <a id="59972" href="1Lab.Path.html#59972" class="Bound">x</a> <a id="59974" class="Symbol">→</a> <a id="59976" href="1Lab.Path.html#59972" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="59978" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="59980" href="1Lab.Path.html#59972" class="Bound">x</a><a id="59981" class="Symbol">)</a> <a id="59983" href="1Lab.Path.html#59957" class="Bound">adj</a> <a id="59987" href="1Lab.Path.html#59937" class="Bound">loop</a> <a data-type="A → A → Type ℓ" id="59992" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="x ≡ y → y ≡ x" id="59994" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="59998" href="1Lab.Path.html#59957" class="Bound">adj</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="60002" href="1Lab.Path.html#39613" class="Function Operator">∙</a> <a id="60004" href="1Lab.Path.html#59937" class="Bound">loop</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="60009" href="1Lab.Path.html#39613" class="Function Operator">∙</a> <a id="60011" href="1Lab.Path.html#59957" class="Bound">adj</a><a id="60014" class="Symbol">)</a>
    <a id="60020" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="60021" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="60025" href="1Lab.Path.html#60309" class="Function">lemma</a><a id="60030" class="Symbol">)</a>
    <a id="60036" href="1Lab.Path.html#59942" class="Bound">adj</a>
  <a id="60042" class="Keyword">where</a>
</pre>
<p>The proof is by induction on the path <code>adj</code> (for <code>adjustment</code>): It suffices to consider the case where it is <code>refl</code>. In that case, it becomes an application of the <a href="1Lab.Path.Groupoid.html">groupoid laws for types</a>.</p>
<pre class="Agda">    <a id="60309" href="1Lab.Path.html#60309" class="Function">lemma</a> <a id="60315" class="Symbol">:</a> <a data-type="x ≡ y → y ≡ x" id="60317" href="1Lab.Path.html#10630" class="Function">sym</a> <a data-type="x ≡ x" id="60321" href="1Lab.Path.html#3593" class="Function">refl</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="60326" href="1Lab.Path.html#39613" class="Function Operator">∙</a> <a id="60328" href="1Lab.Path.html#59937" class="Bound">loop</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="60333" href="1Lab.Path.html#39613" class="Function Operator">∙</a> <a data-type="x ≡ x" id="60335" href="1Lab.Path.html#3593" class="Function">refl</a> <a data-type="A → A → Type ℓ" id="60340" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="60342" href="1Lab.Path.html#15381" class="Function">subst</a> <a id="60348" class="Symbol">(λ</a> <a id="60351" href="1Lab.Path.html#60351" class="Bound">x</a> <a id="60353" class="Symbol">→</a> <a id="60355" href="1Lab.Path.html#60351" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="60357" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="60359" href="1Lab.Path.html#60351" class="Bound">x</a><a id="60360" class="Symbol">)</a> <a data-type="x ≡ x" id="60362" href="1Lab.Path.html#3593" class="Function">refl</a> <a id="60367" href="1Lab.Path.html#59937" class="Bound">loop</a>
    <a id="60376" href="1Lab.Path.html#60309" class="Function">lemma</a> <a id="60382" class="Symbol">=</a>
      <a data-type="x ≡ y → y ≡ x" id="60390" href="1Lab.Path.html#10630" class="Function">sym</a> <a data-type="x ≡ x" id="60394" href="1Lab.Path.html#3593" class="Function">refl</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="60399" href="1Lab.Path.html#39613" class="Function Operator">∙</a> <a id="60401" href="1Lab.Path.html#59937" class="Bound">loop</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="60406" href="1Lab.Path.html#39613" class="Function Operator">∙</a> <a data-type="x ≡ x" id="60408" href="1Lab.Path.html#3593" class="Function">refl</a>    <a data-type="(x : A) → x ≡ y → x ≡ y" id="60416" href="1Lab.Path.html#47038" class="Function Operator">≡⟨⟩</a>
      <a data-type="x ≡ x" id="60426" href="1Lab.Path.html#3593" class="Function">refl</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="60431" href="1Lab.Path.html#39613" class="Function Operator">∙</a> <a id="60433" href="1Lab.Path.html#59937" class="Bound">loop</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="60438" href="1Lab.Path.html#39613" class="Function Operator">∙</a> <a data-type="x ≡ x" id="60440" href="1Lab.Path.html#3593" class="Function">refl</a>        <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="60452" href="1Lab.Path.html#46786" class="Function">≡⟨</a> <a data-type="x ≡ y → y ≡ x" id="60455" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="60459" class="Symbol">(</a><a data-type="(p : x ≡ y) (q : y ≡ z) → Square (sym p) q (p ∙ q) refl" id="60460" href="1Lab.Path.html#40460" class="Function">∙-filler&#39;</a> <a data-type="x ≡ x" id="60470" href="1Lab.Path.html#3593" class="Function">refl</a> <a id="60475" class="Symbol">_)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="60478" href="1Lab.Path.html#46786" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="60486" href="1Lab.Path.html#59937" class="Bound">loop</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="60491" href="1Lab.Path.html#39613" class="Function Operator">∙</a> <a data-type="x ≡ x" id="60493" href="1Lab.Path.html#3593" class="Function">refl</a>               <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="60512" href="1Lab.Path.html#46786" class="Function">≡⟨</a> <a data-type="x ≡ y → y ≡ x" id="60515" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="60519" class="Symbol">(</a><a data-type="(p : x ≡ y) (q : y ≡ z) → Square refl p (p ∙ q) q" id="60520" href="1Lab.Path.html#39961" class="Function">∙-filler</a> <a id="60529" class="Symbol">_</a> <a data-type="x ≡ x" id="60531" href="1Lab.Path.html#3593" class="Function">refl</a><a id="60535" class="Symbol">)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="60537" href="1Lab.Path.html#46786" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="60545" href="1Lab.Path.html#59937" class="Bound">loop</a>                      <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="60571" href="1Lab.Path.html#46786" class="Function">≡⟨</a> <a data-type="x ≡ y → y ≡ x" id="60574" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="60578" class="Symbol">(</a><a data-type="(x : A) → transport (λ i → A) x ≡ x" id="60579" href="1Lab.Path.html#13526" class="Function">transport-refl</a> <a id="60594" class="Symbol">_)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="60597" href="1Lab.Path.html#46786" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="60605" href="1Lab.Path.html#15381" class="Function">subst</a> <a id="60611" class="Symbol">(λ</a> <a id="60614" href="1Lab.Path.html#60614" class="Bound">x</a> <a id="60616" class="Symbol">→</a> <a id="60618" href="1Lab.Path.html#60614" class="Bound">x</a><a id="60619" class="Symbol">)</a> <a data-type="x ≡ x" id="60621" href="1Lab.Path.html#3593" class="Function">refl</a> <a id="60626" href="1Lab.Path.html#59937" class="Bound">loop</a> <a data-type="(x : A) → x ≡ x" id="60631" href="1Lab.Path.html#47114" class="Function Operator">∎</a>
</pre>
<p>Similar statements can be proven about substitution where we hold the right endpoint constant, in which case we get something homotopic to composing with the inverse of the adjustment:</p>
<pre class="Agda"><a id="subst-path-left"></a><a data-type="(loop₁ : x ≡ z) (adj : x ≡ y) →
subst (λ e → e ≡ z) adj loop₁ ≡ sym adj ∙ loop₁" id="60832" href="1Lab.Path.html#60832" class="Function">subst-path-left</a> <a id="60848" class="Symbol">:</a> <a id="60850" class="Symbol">∀</a> <a id="60852" class="Symbol">{</a><a id="60853" href="1Lab.Path.html#60853" class="Bound">ℓ</a><a id="60854" class="Symbol">}</a> <a id="60856" class="Symbol">{</a><a id="60857" href="1Lab.Path.html#60857" class="Bound">A</a> <a id="60859" class="Symbol">:</a> <a id="60861" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="60866" href="1Lab.Path.html#60853" class="Bound">ℓ</a><a id="60867" class="Symbol">}</a> <a id="60869" class="Symbol">{</a><a id="60870" href="1Lab.Path.html#60870" class="Bound">x</a> <a id="60872" href="1Lab.Path.html#60872" class="Bound">y</a> <a id="60874" href="1Lab.Path.html#60874" class="Bound">z</a> <a id="60876" class="Symbol">:</a> <a id="60878" href="1Lab.Path.html#60857" class="Bound">A</a><a id="60879" class="Symbol">}</a>
                <a id="60897" class="Symbol">→</a> <a id="60899" class="Symbol">(</a><a id="60900" href="1Lab.Path.html#60900" class="Bound">loop</a> <a id="60905" class="Symbol">:</a> <a id="60907" href="1Lab.Path.html#60870" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="60909" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="60911" href="1Lab.Path.html#60874" class="Bound">z</a><a id="60912" class="Symbol">)</a>
                <a id="60930" class="Symbol">→</a> <a id="60932" class="Symbol">(</a><a id="60933" href="1Lab.Path.html#60933" class="Bound">adj</a> <a id="60937" class="Symbol">:</a> <a id="60939" href="1Lab.Path.html#60870" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="60941" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="60943" href="1Lab.Path.html#60872" class="Bound">y</a><a id="60944" class="Symbol">)</a>
                <a id="60962" class="Symbol">→</a> <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="60964" href="1Lab.Path.html#15381" class="Function">subst</a> <a id="60970" class="Symbol">(λ</a> <a id="60973" href="1Lab.Path.html#60973" class="Bound">e</a> <a id="60975" class="Symbol">→</a> <a id="60977" href="1Lab.Path.html#60973" class="Bound">e</a> <a data-type="A → A → Type ℓ" id="60979" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="60981" href="1Lab.Path.html#60874" class="Bound">z</a><a id="60982" class="Symbol">)</a> <a id="60984" href="1Lab.Path.html#60933" class="Bound">adj</a> <a id="60988" href="1Lab.Path.html#60900" class="Bound">loop</a> <a data-type="A → A → Type ℓ" id="60993" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="x ≡ y → y ≡ x" id="60995" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="60999" href="1Lab.Path.html#60933" class="Bound">adj</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="61003" href="1Lab.Path.html#39613" class="Function Operator">∙</a> <a id="61005" href="1Lab.Path.html#60900" class="Bound">loop</a>
<a data-type="(loop₁ : x ≡ z) (adj : x ≡ y) →
subst (λ e → e ≡ z) adj loop₁ ≡ sym adj ∙ loop₁" id="61010" href="1Lab.Path.html#60832" class="Function">subst-path-left</a> <a id="61026" class="Symbol">{</a><a id="61027" class="Argument">x</a> <a id="61029" class="Symbol">=</a> <a id="61031" href="1Lab.Path.html#61031" class="Bound">x</a><a id="61032" class="Symbol">}</a> <a id="61034" class="Symbol">{</a><a id="61035" href="1Lab.Path.html#61035" class="Bound">y</a><a id="61036" class="Symbol">}</a> <a id="61038" class="Symbol">{</a><a id="61039" href="1Lab.Path.html#61039" class="Bound">z</a><a id="61040" class="Symbol">}</a> <a id="61042" href="1Lab.Path.html#61042" class="Bound">loop</a> <a id="61047" href="1Lab.Path.html#61047" class="Bound">adj</a> <a id="61051" class="Symbol">=</a>
  <a data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" id="61055" href="1Lab.Path.html#19616" class="Function">J</a> <a id="61057" class="Symbol">(λ</a> <a id="61060" href="1Lab.Path.html#61060" class="Bound">_</a> <a id="61062" href="1Lab.Path.html#61062" class="Bound">adj</a> <a id="61066" class="Symbol">→</a> <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="61068" href="1Lab.Path.html#15381" class="Function">subst</a> <a id="61074" class="Symbol">(λ</a> <a id="61077" href="1Lab.Path.html#61077" class="Bound">e</a> <a id="61079" class="Symbol">→</a> <a id="61081" href="1Lab.Path.html#61077" class="Bound">e</a> <a data-type="A → A → Type ℓ" id="61083" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="61085" href="1Lab.Path.html#61039" class="Bound">z</a><a id="61086" class="Symbol">)</a> <a id="61088" href="1Lab.Path.html#61062" class="Bound">adj</a> <a id="61092" href="1Lab.Path.html#61042" class="Bound">loop</a> <a data-type="A → A → Type ℓ" id="61097" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="x ≡ y → y ≡ x" id="61099" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="61103" href="1Lab.Path.html#61062" class="Bound">adj</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="61107" href="1Lab.Path.html#39613" class="Function Operator">∙</a> <a id="61109" href="1Lab.Path.html#61042" class="Bound">loop</a><a id="61113" class="Symbol">)</a>
    <a id="61119" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="61120" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="61124" href="1Lab.Path.html#61151" class="Function">lemma</a><a id="61129" class="Symbol">)</a>
    <a id="61135" href="1Lab.Path.html#61047" class="Bound">adj</a>
  <a id="61141" class="Keyword">where</a>
    <a id="61151" href="1Lab.Path.html#61151" class="Function">lemma</a> <a id="61157" class="Symbol">:</a> <a data-type="x ≡ y → y ≡ x" id="61159" href="1Lab.Path.html#10630" class="Function">sym</a> <a data-type="x ≡ x" id="61163" href="1Lab.Path.html#3593" class="Function">refl</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="61168" href="1Lab.Path.html#39613" class="Function Operator">∙</a> <a id="61170" href="1Lab.Path.html#61042" class="Bound">loop</a> <a data-type="A → A → Type ℓ" id="61175" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="61177" href="1Lab.Path.html#15381" class="Function">subst</a> <a id="61183" class="Symbol">(λ</a> <a id="61186" href="1Lab.Path.html#61186" class="Bound">e</a> <a id="61188" class="Symbol">→</a> <a id="61190" href="1Lab.Path.html#61186" class="Bound">e</a> <a data-type="A → A → Type ℓ" id="61192" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="61194" href="1Lab.Path.html#61039" class="Bound">z</a><a id="61195" class="Symbol">)</a> <a data-type="x ≡ x" id="61197" href="1Lab.Path.html#3593" class="Function">refl</a> <a id="61202" href="1Lab.Path.html#61042" class="Bound">loop</a>
    <a id="61211" href="1Lab.Path.html#61151" class="Function">lemma</a> <a id="61217" class="Symbol">=</a>
      <a data-type="x ≡ y → y ≡ x" id="61225" href="1Lab.Path.html#10630" class="Function">sym</a> <a data-type="x ≡ x" id="61229" href="1Lab.Path.html#3593" class="Function">refl</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="61234" href="1Lab.Path.html#39613" class="Function Operator">∙</a> <a id="61236" href="1Lab.Path.html#61042" class="Bound">loop</a>           <a data-type="(x : A) → x ≡ y → x ≡ y" id="61251" href="1Lab.Path.html#47038" class="Function Operator">≡⟨⟩</a>
      <a data-type="x ≡ x" id="61261" href="1Lab.Path.html#3593" class="Function">refl</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="61266" href="1Lab.Path.html#39613" class="Function Operator">∙</a> <a id="61268" href="1Lab.Path.html#61042" class="Bound">loop</a>               <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="61287" href="1Lab.Path.html#46786" class="Function">≡⟨</a> <a data-type="x ≡ y → y ≡ x" id="61290" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="61294" class="Symbol">(</a><a data-type="(p : x ≡ y) (q : y ≡ z) → Square (sym p) q (p ∙ q) refl" id="61295" href="1Lab.Path.html#40460" class="Function">∙-filler&#39;</a> <a data-type="x ≡ x" id="61305" href="1Lab.Path.html#3593" class="Function">refl</a> <a id="61310" class="Symbol">_)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="61313" href="1Lab.Path.html#46786" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="61321" href="1Lab.Path.html#61042" class="Bound">loop</a>                      <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="61347" href="1Lab.Path.html#46786" class="Function">≡⟨</a> <a data-type="x ≡ y → y ≡ x" id="61350" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="61354" class="Symbol">(</a><a data-type="(x : A) → transport (λ i → A) x ≡ x" id="61355" href="1Lab.Path.html#13526" class="Function">transport-refl</a> <a id="61370" class="Symbol">_)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="61373" href="1Lab.Path.html#46786" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="61381" href="1Lab.Path.html#15381" class="Function">subst</a> <a id="61387" class="Symbol">(λ</a> <a id="61390" href="1Lab.Path.html#61390" class="Bound">x</a> <a id="61392" class="Symbol">→</a> <a id="61394" href="1Lab.Path.html#61390" class="Bound">x</a><a id="61395" class="Symbol">)</a> <a data-type="x ≡ x" id="61397" href="1Lab.Path.html#3593" class="Function">refl</a> <a id="61402" href="1Lab.Path.html#61042" class="Bound">loop</a> <a data-type="(x : A) → x ≡ x" id="61407" href="1Lab.Path.html#47114" class="Function Operator">∎</a>
</pre>
<p>And for the case where we hold the left endpoint constant, in which case we get a respelling of composition:</p>
<pre class="Agda"><a id="subst-path-right"></a><a data-type="(loop₁ : x ≡ z) (adj : z ≡ y) →
subst (_≡_ x) adj loop₁ ≡ loop₁ ∙ adj" id="61532" href="1Lab.Path.html#61532" class="Function">subst-path-right</a> <a id="61549" class="Symbol">:</a> <a id="61551" class="Symbol">∀</a> <a id="61553" class="Symbol">{</a><a id="61554" href="1Lab.Path.html#61554" class="Bound">ℓ</a><a id="61555" class="Symbol">}</a> <a id="61557" class="Symbol">{</a><a id="61558" href="1Lab.Path.html#61558" class="Bound">A</a> <a id="61560" class="Symbol">:</a> <a id="61562" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="61567" href="1Lab.Path.html#61554" class="Bound">ℓ</a><a id="61568" class="Symbol">}</a> <a id="61570" class="Symbol">{</a><a id="61571" href="1Lab.Path.html#61571" class="Bound">x</a> <a id="61573" href="1Lab.Path.html#61573" class="Bound">y</a> <a id="61575" href="1Lab.Path.html#61575" class="Bound">z</a> <a id="61577" class="Symbol">:</a> <a id="61579" href="1Lab.Path.html#61558" class="Bound">A</a><a id="61580" class="Symbol">}</a>
                 <a id="61599" class="Symbol">→</a> <a id="61601" class="Symbol">(</a><a id="61602" href="1Lab.Path.html#61602" class="Bound">loop</a> <a id="61607" class="Symbol">:</a> <a id="61609" href="1Lab.Path.html#61571" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="61611" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="61613" href="1Lab.Path.html#61575" class="Bound">z</a><a id="61614" class="Symbol">)</a>
                 <a id="61633" class="Symbol">→</a> <a id="61635" class="Symbol">(</a><a id="61636" href="1Lab.Path.html#61636" class="Bound">adj</a> <a id="61640" class="Symbol">:</a> <a id="61642" href="1Lab.Path.html#61575" class="Bound">z</a> <a data-type="A → A → Type ℓ" id="61644" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="61646" href="1Lab.Path.html#61573" class="Bound">y</a><a id="61647" class="Symbol">)</a>
                 <a id="61666" class="Symbol">→</a> <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="61668" href="1Lab.Path.html#15381" class="Function">subst</a> <a id="61674" class="Symbol">(λ</a> <a id="61677" href="1Lab.Path.html#61677" class="Bound">e</a> <a id="61679" class="Symbol">→</a> <a id="61681" href="1Lab.Path.html#61571" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="61683" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="61685" href="1Lab.Path.html#61677" class="Bound">e</a><a id="61686" class="Symbol">)</a> <a id="61688" href="1Lab.Path.html#61636" class="Bound">adj</a> <a id="61692" href="1Lab.Path.html#61602" class="Bound">loop</a> <a data-type="A → A → Type ℓ" id="61697" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="61699" href="1Lab.Path.html#61602" class="Bound">loop</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="61704" href="1Lab.Path.html#39613" class="Function Operator">∙</a> <a id="61706" href="1Lab.Path.html#61636" class="Bound">adj</a>
<a data-type="(loop₁ : x ≡ z) (adj : z ≡ y) →
subst (_≡_ x) adj loop₁ ≡ loop₁ ∙ adj" id="61710" href="1Lab.Path.html#61532" class="Function">subst-path-right</a> <a id="61727" class="Symbol">{</a><a id="61728" class="Argument">x</a> <a id="61730" class="Symbol">=</a> <a id="61732" href="1Lab.Path.html#61732" class="Bound">x</a><a id="61733" class="Symbol">}</a> <a id="61735" href="1Lab.Path.html#61735" class="Bound">loop</a> <a id="61740" href="1Lab.Path.html#61740" class="Bound">adj</a> <a id="61744" class="Symbol">=</a>
  <a data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" id="61748" href="1Lab.Path.html#19616" class="Function">J</a> <a id="61750" class="Symbol">(λ</a> <a id="61753" href="1Lab.Path.html#61753" class="Bound">_</a> <a id="61755" href="1Lab.Path.html#61755" class="Bound">adj</a> <a id="61759" class="Symbol">→</a> <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="61761" href="1Lab.Path.html#15381" class="Function">subst</a> <a id="61767" class="Symbol">(λ</a> <a id="61770" href="1Lab.Path.html#61770" class="Bound">e</a> <a id="61772" class="Symbol">→</a> <a id="61774" href="1Lab.Path.html#61732" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="61776" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="61778" href="1Lab.Path.html#61770" class="Bound">e</a><a id="61779" class="Symbol">)</a> <a id="61781" href="1Lab.Path.html#61755" class="Bound">adj</a> <a id="61785" href="1Lab.Path.html#61735" class="Bound">loop</a> <a data-type="A → A → Type ℓ" id="61790" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="61792" href="1Lab.Path.html#61735" class="Bound">loop</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="61797" href="1Lab.Path.html#39613" class="Function Operator">∙</a> <a id="61799" href="1Lab.Path.html#61755" class="Bound">adj</a><a id="61802" class="Symbol">)</a>
    <a id="61808" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="61809" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="61813" href="1Lab.Path.html#61840" class="Function">lemma</a><a id="61818" class="Symbol">)</a>
    <a id="61824" href="1Lab.Path.html#61740" class="Bound">adj</a>
  <a id="61830" class="Keyword">where</a>
    <a id="61840" href="1Lab.Path.html#61840" class="Function">lemma</a> <a id="61846" class="Symbol">:</a> <a id="61848" href="1Lab.Path.html#61735" class="Bound">loop</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="61853" href="1Lab.Path.html#39613" class="Function Operator">∙</a> <a data-type="x ≡ x" id="61855" href="1Lab.Path.html#3593" class="Function">refl</a> <a data-type="A → A → Type ℓ" id="61860" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="61862" href="1Lab.Path.html#15381" class="Function">subst</a> <a id="61868" class="Symbol">(λ</a> <a id="61871" href="1Lab.Path.html#61871" class="Bound">e</a> <a id="61873" class="Symbol">→</a> <a id="61875" href="1Lab.Path.html#61732" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="61877" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="61879" href="1Lab.Path.html#61871" class="Bound">e</a><a id="61880" class="Symbol">)</a> <a data-type="x ≡ x" id="61882" href="1Lab.Path.html#3593" class="Function">refl</a> <a id="61887" href="1Lab.Path.html#61735" class="Bound">loop</a>
    <a id="61896" href="1Lab.Path.html#61840" class="Function">lemma</a> <a id="61902" class="Symbol">=</a>
      <a id="61910" href="1Lab.Path.html#61735" class="Bound">loop</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="61915" href="1Lab.Path.html#39613" class="Function Operator">∙</a> <a data-type="x ≡ x" id="61917" href="1Lab.Path.html#3593" class="Function">refl</a>               <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="61936" href="1Lab.Path.html#46786" class="Function">≡⟨</a> <a data-type="x ≡ y → y ≡ x" id="61939" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="61943" class="Symbol">(</a><a data-type="(p : x ≡ y) (q : y ≡ z) → Square refl p (p ∙ q) q" id="61944" href="1Lab.Path.html#39961" class="Function">∙-filler</a> <a id="61953" class="Symbol">_</a> <a data-type="x ≡ x" id="61955" href="1Lab.Path.html#3593" class="Function">refl</a><a id="61959" class="Symbol">)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="61961" href="1Lab.Path.html#46786" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="61969" href="1Lab.Path.html#61735" class="Bound">loop</a>                      <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="61995" href="1Lab.Path.html#46786" class="Function">≡⟨</a> <a data-type="x ≡ y → y ≡ x" id="61998" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="62002" class="Symbol">(</a><a data-type="(x : A) → transport (λ i → A) x ≡ x" id="62003" href="1Lab.Path.html#13526" class="Function">transport-refl</a> <a id="62018" class="Symbol">_)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="62021" href="1Lab.Path.html#46786" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="62029" href="1Lab.Path.html#15381" class="Function">subst</a> <a id="62035" class="Symbol">(λ</a> <a id="62038" href="1Lab.Path.html#62038" class="Bound">x</a> <a id="62040" class="Symbol">→</a> <a id="62042" href="1Lab.Path.html#62038" class="Bound">x</a><a id="62043" class="Symbol">)</a> <a data-type="x ≡ x" id="62045" href="1Lab.Path.html#3593" class="Function">refl</a> <a id="62050" href="1Lab.Path.html#61735" class="Bound">loop</a> <a data-type="(x : A) → x ≡ x" id="62055" href="1Lab.Path.html#47114" class="Function Operator">∎</a>
</pre>
<!--
TODO: Explain these whiskerings

<pre class="Agda"><a id="_◁_"></a><a id="62108" href="1Lab.Path.html#62108" class="Function Operator">_◁_</a> <a id="62112" class="Symbol">:</a> <a id="62114" class="Symbol">∀</a> <a id="62116" class="Symbol">{</a><a id="62117" href="1Lab.Path.html#62117" class="Bound">ℓ</a><a id="62118" class="Symbol">}</a> <a id="62120" class="Symbol">{</a><a id="62121" href="1Lab.Path.html#62121" class="Bound">A</a> <a id="62123" class="Symbol">:</a> <a id="62125" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="62127" class="Symbol">→</a> <a id="62129" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="62134" href="1Lab.Path.html#62117" class="Bound">ℓ</a><a id="62135" class="Symbol">}</a> <a id="62137" class="Symbol">{</a><a id="62138" href="1Lab.Path.html#62138" class="Bound">a₀</a> <a id="62141" href="1Lab.Path.html#62141" class="Bound">a₀&#39;</a> <a id="62145" class="Symbol">:</a> <a id="62147" href="1Lab.Path.html#62121" class="Bound">A</a> <a id="62149" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="62151" class="Symbol">}</a> <a id="62153" class="Symbol">{</a><a id="62154" href="1Lab.Path.html#62154" class="Bound">a₁</a> <a id="62157" class="Symbol">:</a> <a id="62159" href="1Lab.Path.html#62121" class="Bound">A</a> <a id="62161" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="62163" class="Symbol">}</a>
  <a id="62167" class="Symbol">→</a> <a id="62169" href="1Lab.Path.html#62138" class="Bound">a₀</a> <a id="62172" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="62174" href="1Lab.Path.html#62141" class="Bound">a₀&#39;</a> <a id="62178" class="Symbol">→</a> <a id="62180" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="62186" href="1Lab.Path.html#62121" class="Bound">A</a> <a id="62188" href="1Lab.Path.html#62141" class="Bound">a₀&#39;</a> <a id="62192" href="1Lab.Path.html#62154" class="Bound">a₁</a> <a id="62195" class="Symbol">→</a> <a id="62197" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="62203" href="1Lab.Path.html#62121" class="Bound">A</a> <a id="62205" href="1Lab.Path.html#62138" class="Bound">a₀</a> <a id="62208" href="1Lab.Path.html#62154" class="Bound">a₁</a>
<a id="62211" class="Symbol">(</a><a id="62212" href="1Lab.Path.html#62212" class="Bound">p</a> <a id="62214" href="1Lab.Path.html#62108" class="Function Operator">◁</a> <a id="62216" href="1Lab.Path.html#62216" class="Bound">q</a><a id="62217" class="Symbol">)</a> <a id="62219" href="1Lab.Path.html#62219" class="Bound">i</a> <a id="62221" class="Symbol">=</a>
  <a id="62225" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="62231" class="Symbol">(λ</a> <a id="62234" href="1Lab.Path.html#62234" class="Bound">j</a> <a id="62236" class="Symbol">→</a> <a id="62238" class="Symbol">λ</a> <a id="62240" class="Symbol">{(</a><a id="62242" href="1Lab.Path.html#62219" class="Bound">i</a> <a id="62244" class="Symbol">=</a> <a id="62246" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="62248" class="Symbol">)</a> <a id="62250" class="Symbol">→</a> <a id="62252" href="1Lab.Path.html#62212" class="Bound">p</a> <a id="62254" class="Symbol">(</a><a id="62255" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="62257" href="1Lab.Path.html#62234" class="Bound">j</a><a id="62258" class="Symbol">);</a> <a id="62261" class="Symbol">(</a><a id="62262" href="1Lab.Path.html#62219" class="Bound">i</a> <a id="62264" class="Symbol">=</a> <a id="62266" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="62268" class="Symbol">)</a> <a id="62270" class="Symbol">→</a> <a id="62272" href="1Lab.Path.html#62216" class="Bound">q</a> <a id="62274" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="62276" class="Symbol">})</a> <a id="62279" class="Symbol">(</a><a id="62280" href="1Lab.Path.html#62216" class="Bound">q</a> <a id="62282" href="1Lab.Path.html#62219" class="Bound">i</a><a id="62283" class="Symbol">)</a>

<a id="_▷_"></a><a id="62286" href="1Lab.Path.html#62286" class="Function Operator">_▷_</a> <a id="62290" class="Symbol">:</a> <a id="62292" class="Symbol">∀</a> <a id="62294" class="Symbol">{</a><a id="62295" href="1Lab.Path.html#62295" class="Bound">ℓ</a><a id="62296" class="Symbol">}</a> <a id="62298" class="Symbol">{</a><a id="62299" href="1Lab.Path.html#62299" class="Bound">A</a> <a id="62301" class="Symbol">:</a> <a id="62303" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="62305" class="Symbol">→</a> <a id="62307" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="62312" href="1Lab.Path.html#62295" class="Bound">ℓ</a><a id="62313" class="Symbol">}</a> <a id="62315" class="Symbol">{</a><a id="62316" href="1Lab.Path.html#62316" class="Bound">a₀</a> <a id="62319" class="Symbol">:</a> <a id="62321" href="1Lab.Path.html#62299" class="Bound">A</a> <a id="62323" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="62325" class="Symbol">}</a> <a id="62327" class="Symbol">{</a><a id="62328" href="1Lab.Path.html#62328" class="Bound">a₁</a> <a id="62331" href="1Lab.Path.html#62331" class="Bound">a₁&#39;</a> <a id="62335" class="Symbol">:</a> <a id="62337" href="1Lab.Path.html#62299" class="Bound">A</a> <a id="62339" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="62341" class="Symbol">}</a>
  <a id="62345" class="Symbol">→</a> <a id="62347" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="62353" href="1Lab.Path.html#62299" class="Bound">A</a> <a id="62355" href="1Lab.Path.html#62316" class="Bound">a₀</a> <a id="62358" href="1Lab.Path.html#62328" class="Bound">a₁</a> <a id="62361" class="Symbol">→</a> <a id="62363" href="1Lab.Path.html#62328" class="Bound">a₁</a> <a id="62366" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="62368" href="1Lab.Path.html#62331" class="Bound">a₁&#39;</a> <a id="62372" class="Symbol">→</a> <a id="62374" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="62380" href="1Lab.Path.html#62299" class="Bound">A</a> <a id="62382" href="1Lab.Path.html#62316" class="Bound">a₀</a> <a id="62385" href="1Lab.Path.html#62331" class="Bound">a₁&#39;</a>
<a id="62389" class="Symbol">(</a><a id="62390" href="1Lab.Path.html#62390" class="Bound">p</a> <a id="62392" href="1Lab.Path.html#62286" class="Function Operator">▷</a> <a id="62394" href="1Lab.Path.html#62394" class="Bound">q</a><a id="62395" class="Symbol">)</a> <a id="62397" href="1Lab.Path.html#62397" class="Bound">i</a> <a id="62399" class="Symbol">=</a>
  <a id="62403" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="62409" class="Symbol">(λ</a> <a id="62412" href="1Lab.Path.html#62412" class="Bound">j</a> <a id="62414" class="Symbol">→</a> <a id="62416" class="Symbol">λ</a> <a id="62418" class="Symbol">{(</a><a id="62420" href="1Lab.Path.html#62397" class="Bound">i</a> <a id="62422" class="Symbol">=</a> <a id="62424" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="62426" class="Symbol">)</a> <a id="62428" class="Symbol">→</a> <a id="62430" href="1Lab.Path.html#62390" class="Bound">p</a> <a id="62432" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="62434" class="Symbol">;</a> <a id="62436" class="Symbol">(</a><a id="62437" href="1Lab.Path.html#62397" class="Bound">i</a> <a id="62439" class="Symbol">=</a> <a id="62441" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="62443" class="Symbol">)</a> <a id="62445" class="Symbol">→</a> <a id="62447" href="1Lab.Path.html#62394" class="Bound">q</a> <a id="62449" href="1Lab.Path.html#62412" class="Bound">j</a><a id="62450" class="Symbol">})</a> <a id="62453" class="Symbol">(</a><a id="62454" href="1Lab.Path.html#62390" class="Bound">p</a> <a id="62456" href="1Lab.Path.html#62397" class="Bound">i</a><a id="62457" class="Symbol">)</a>

<a id="Square≡··"></a><a id="62460" href="1Lab.Path.html#62460" class="Function">Square≡··</a> <a id="62470" class="Symbol">:</a> <a id="62472" class="Symbol">∀</a> <a id="62474" class="Symbol">{</a><a id="62475" href="1Lab.Path.html#62475" class="Bound">ℓ</a><a id="62476" class="Symbol">}</a> <a id="62478" class="Symbol">{</a><a id="62479" href="1Lab.Path.html#62479" class="Bound">A</a> <a id="62481" class="Symbol">:</a> <a id="62483" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="62488" href="1Lab.Path.html#62475" class="Bound">ℓ</a><a id="62489" class="Symbol">}</a>
          <a id="62501" class="Symbol">→</a> <a id="62503" class="Symbol">{</a><a id="62504" href="1Lab.Path.html#62504" class="Bound">w</a> <a id="62506" href="1Lab.Path.html#62506" class="Bound">x</a> <a id="62508" href="1Lab.Path.html#62508" class="Bound">y</a> <a id="62510" href="1Lab.Path.html#62510" class="Bound">z</a> <a id="62512" class="Symbol">:</a> <a id="62514" href="1Lab.Path.html#62479" class="Bound">A</a><a id="62515" class="Symbol">}</a>
          <a id="62527" class="Symbol">→</a> <a id="62529" class="Symbol">{</a><a id="62530" href="1Lab.Path.html#62530" class="Bound">p</a> <a id="62532" class="Symbol">:</a> <a id="62534" href="1Lab.Path.html#62506" class="Bound">x</a> <a id="62536" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="62538" href="1Lab.Path.html#62504" class="Bound">w</a><a id="62539" class="Symbol">}</a> <a id="62541" class="Symbol">{</a><a id="62542" href="1Lab.Path.html#62542" class="Bound">q</a> <a id="62544" class="Symbol">:</a> <a id="62546" href="1Lab.Path.html#62506" class="Bound">x</a> <a id="62548" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="62550" href="1Lab.Path.html#62508" class="Bound">y</a><a id="62551" class="Symbol">}</a> <a id="62553" class="Symbol">{</a><a id="62554" href="1Lab.Path.html#62554" class="Bound">s</a> <a id="62556" class="Symbol">:</a> <a id="62558" href="1Lab.Path.html#62504" class="Bound">w</a> <a id="62560" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="62562" href="1Lab.Path.html#62510" class="Bound">z</a><a id="62563" class="Symbol">}</a> <a id="62565" class="Symbol">{</a><a id="62566" href="1Lab.Path.html#62566" class="Bound">r</a> <a id="62568" class="Symbol">:</a> <a id="62570" href="1Lab.Path.html#62508" class="Bound">y</a> <a id="62572" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="62574" href="1Lab.Path.html#62510" class="Bound">z</a><a id="62575" class="Symbol">}</a>
          <a id="62587" class="Symbol">→</a> <a id="62589" href="1Lab.Path.html#9481" class="Function">Square</a> <a id="62596" href="1Lab.Path.html#62530" class="Bound">p</a> <a id="62598" href="1Lab.Path.html#62542" class="Bound">q</a> <a id="62600" href="1Lab.Path.html#62554" class="Bound">s</a> <a id="62602" href="1Lab.Path.html#62566" class="Bound">r</a> <a id="62604" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="62606" class="Symbol">(</a><a id="62607" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="62611" href="1Lab.Path.html#62530" class="Bound">p</a> <a id="62613" href="1Lab.Path.html#38442" class="Function Operator">··</a> <a id="62616" href="1Lab.Path.html#62542" class="Bound">q</a> <a id="62618" href="1Lab.Path.html#38442" class="Function Operator">··</a> <a id="62621" href="1Lab.Path.html#62566" class="Bound">r</a> <a id="62623" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="62625" href="1Lab.Path.html#62554" class="Bound">s</a><a id="62626" class="Symbol">)</a>
<a id="62628" href="1Lab.Path.html#62460" class="Function">Square≡··</a> <a id="62638" class="Symbol">{</a><a id="62639" class="Argument">p</a> <a id="62641" class="Symbol">=</a> <a id="62643" href="1Lab.Path.html#62643" class="Bound">p</a><a id="62644" class="Symbol">}</a> <a id="62646" class="Symbol">{</a><a id="62647" href="1Lab.Path.html#62647" class="Bound">q</a><a id="62648" class="Symbol">}</a> <a id="62650" class="Symbol">{</a><a id="62651" href="1Lab.Path.html#62651" class="Bound">s</a><a id="62652" class="Symbol">}</a> <a id="62654" class="Symbol">{</a><a id="62655" href="1Lab.Path.html#62655" class="Bound">r</a><a id="62656" class="Symbol">}</a> <a id="62658" href="1Lab.Path.html#62658" class="Bound">k</a> <a id="62660" class="Symbol">=</a>
  <a id="62664" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="62670" class="Symbol">(λ</a> <a id="62673" href="1Lab.Path.html#62673" class="Bound">i</a> <a id="62675" class="Symbol">→</a> <a id="62677" href="1Lab.Path.html#62643" class="Bound">p</a> <a id="62679" class="Symbol">(</a><a id="62680" href="1Lab.Path.html#62673" class="Bound">i</a> <a id="62682" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="62684" href="1Lab.Path.html#62658" class="Bound">k</a><a id="62685" class="Symbol">)</a> <a id="62687" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="62689" href="1Lab.Path.html#62655" class="Bound">r</a> <a id="62691" class="Symbol">(</a><a id="62692" href="1Lab.Path.html#62673" class="Bound">i</a> <a id="62694" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="62696" href="1Lab.Path.html#62658" class="Bound">k</a><a id="62697" class="Symbol">))</a>
    <a id="62704" class="Symbol">(</a><a id="62705" href="1Lab.Path.html#38760" class="Function">··-filler</a> <a id="62715" class="Symbol">(</a><a id="62716" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="62720" href="1Lab.Path.html#62643" class="Bound">p</a><a id="62721" class="Symbol">)</a> <a id="62723" href="1Lab.Path.html#62647" class="Bound">q</a> <a id="62725" href="1Lab.Path.html#62655" class="Bound">r</a> <a id="62727" href="1Lab.Path.html#62658" class="Bound">k</a><a id="62728" class="Symbol">)</a> <a id="62730" href="1Lab.Path.html#62651" class="Bound">s</a>

<a id="≡⟨⟩⟨⟩-syntax"></a><a id="62733" href="1Lab.Path.html#62733" class="Function">≡⟨⟩⟨⟩-syntax</a> <a id="62746" class="Symbol">:</a> <a id="62748" class="Symbol">∀</a> <a id="62750" class="Symbol">{</a><a id="62751" href="1Lab.Path.html#62751" class="Bound">ℓ</a><a id="62752" class="Symbol">}</a> <a id="62754" class="Symbol">{</a><a id="62755" href="1Lab.Path.html#62755" class="Bound">A</a> <a id="62757" class="Symbol">:</a> <a id="62759" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="62764" href="1Lab.Path.html#62751" class="Bound">ℓ</a><a id="62765" class="Symbol">}</a> <a id="62767" class="Symbol">(</a><a id="62768" href="1Lab.Path.html#62768" class="Bound">x</a> <a id="62770" href="1Lab.Path.html#62770" class="Bound">y</a> <a id="62772" class="Symbol">:</a> <a id="62774" href="1Lab.Path.html#62755" class="Bound">A</a><a id="62775" class="Symbol">)</a> <a id="62777" class="Symbol">{</a><a id="62778" href="1Lab.Path.html#62778" class="Bound">w</a> <a id="62780" href="1Lab.Path.html#62780" class="Bound">z</a> <a id="62782" class="Symbol">:</a> <a id="62784" href="1Lab.Path.html#62755" class="Bound">A</a><a id="62785" class="Symbol">}</a> <a id="62787" class="Symbol">→</a> <a id="62789" href="1Lab.Path.html#62768" class="Bound">x</a> <a id="62791" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="62793" href="1Lab.Path.html#62770" class="Bound">y</a> <a id="62795" class="Symbol">→</a> <a id="62797" href="1Lab.Path.html#62770" class="Bound">y</a> <a id="62799" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="62801" href="1Lab.Path.html#62780" class="Bound">z</a> <a id="62803" class="Symbol">→</a> <a id="62805" href="1Lab.Path.html#62780" class="Bound">z</a> <a id="62807" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="62809" href="1Lab.Path.html#62778" class="Bound">w</a> <a id="62811" class="Symbol">→</a> <a id="62813" href="1Lab.Path.html#62768" class="Bound">x</a> <a id="62815" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="62817" href="1Lab.Path.html#62778" class="Bound">w</a>
<a id="62819" href="1Lab.Path.html#62733" class="Function">≡⟨⟩⟨⟩-syntax</a> <a id="62832" href="1Lab.Path.html#62832" class="Bound">x</a> <a id="62834" href="1Lab.Path.html#62834" class="Bound">y</a> <a id="62836" href="1Lab.Path.html#62836" class="Bound">p</a> <a id="62838" href="1Lab.Path.html#62838" class="Bound">q</a> <a id="62840" href="1Lab.Path.html#62840" class="Bound">r</a> <a id="62842" class="Symbol">=</a> <a id="62844" href="1Lab.Path.html#62836" class="Bound">p</a> <a id="62846" href="1Lab.Path.html#38442" class="Function Operator">··</a> <a id="62849" href="1Lab.Path.html#62838" class="Bound">q</a> <a id="62851" href="1Lab.Path.html#38442" class="Function Operator">··</a> <a id="62854" href="1Lab.Path.html#62840" class="Bound">r</a>
<a id="62856" class="Keyword">infixr</a> <a id="62863" class="Number">2.5</a> <a id="62867" href="1Lab.Path.html#62733" class="Function">≡⟨⟩⟨⟩-syntax</a>
<a id="62880" class="Keyword">syntax</a> <a id="62887" href="1Lab.Path.html#62733" class="Function">≡⟨⟩⟨⟩-syntax</a> <a id="62900" class="Bound">x</a> <a id="62902" class="Bound">y</a> <a id="62904" class="Bound">B</a> <a id="62906" class="Bound">C</a> <a id="62908" class="Symbol">=</a> <a id="62910" class="Bound">x</a> <a id="62912" class="Function">≡⟨</a> <a id="62915" class="Bound">B</a> <a id="62917" class="Function">⟩≡</a> <a id="62920" class="Bound">y</a> <a id="62922" class="Function">≡⟨</a> <a id="62925" class="Bound">C</a> <a id="62927" class="Function">⟩≡</a>

<a id="J′"></a><a id="62931" href="1Lab.Path.html#62931" class="Function">J′</a> <a id="62934" class="Symbol">:</a> <a id="62936" class="Symbol">∀</a> <a id="62938" class="Symbol">{</a><a id="62939" href="1Lab.Path.html#62939" class="Bound">ℓ₁</a> <a id="62942" href="1Lab.Path.html#62942" class="Bound">ℓ₂</a><a id="62944" class="Symbol">}</a> <a id="62946" class="Symbol">{</a><a id="62947" href="1Lab.Path.html#62947" class="Bound">A</a> <a id="62949" class="Symbol">:</a> <a id="62951" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="62956" href="1Lab.Path.html#62939" class="Bound">ℓ₁</a><a id="62958" class="Symbol">}</a>
     <a id="62965" class="Symbol">(</a><a id="62966" href="1Lab.Path.html#62966" class="Bound">P</a> <a id="62968" class="Symbol">:</a> <a id="62970" class="Symbol">(</a><a id="62971" href="1Lab.Path.html#62971" class="Bound">x</a> <a id="62973" href="1Lab.Path.html#62973" class="Bound">y</a> <a id="62975" class="Symbol">:</a> <a id="62977" href="1Lab.Path.html#62947" class="Bound">A</a><a id="62978" class="Symbol">)</a> <a id="62980" class="Symbol">→</a> <a id="62982" href="1Lab.Path.html#62971" class="Bound">x</a> <a id="62984" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="62986" href="1Lab.Path.html#62973" class="Bound">y</a> <a id="62988" class="Symbol">→</a> <a id="62990" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="62995" href="1Lab.Path.html#62942" class="Bound">ℓ₂</a><a id="62997" class="Symbol">)</a>
   <a id="63002" class="Symbol">→</a> <a id="63004" class="Symbol">(∀</a> <a id="63007" href="1Lab.Path.html#63007" class="Bound">x</a> <a id="63009" class="Symbol">→</a> <a id="63011" href="1Lab.Path.html#62966" class="Bound">P</a> <a id="63013" href="1Lab.Path.html#63007" class="Bound">x</a> <a id="63015" href="1Lab.Path.html#63007" class="Bound">x</a> <a id="63017" href="1Lab.Path.html#3593" class="Function">refl</a><a id="63021" class="Symbol">)</a>
   <a id="63026" class="Symbol">→</a> <a id="63028" class="Symbol">{</a><a id="63029" href="1Lab.Path.html#63029" class="Bound">x</a> <a id="63031" href="1Lab.Path.html#63031" class="Bound">y</a> <a id="63033" class="Symbol">:</a> <a id="63035" href="1Lab.Path.html#62947" class="Bound">A</a><a id="63036" class="Symbol">}</a> <a id="63038" class="Symbol">(</a><a id="63039" href="1Lab.Path.html#63039" class="Bound">p</a> <a id="63041" class="Symbol">:</a> <a id="63043" href="1Lab.Path.html#63029" class="Bound">x</a> <a id="63045" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="63047" href="1Lab.Path.html#63031" class="Bound">y</a><a id="63048" class="Symbol">)</a>
   <a id="63053" class="Symbol">→</a> <a id="63055" href="1Lab.Path.html#62966" class="Bound">P</a> <a id="63057" href="1Lab.Path.html#63029" class="Bound">x</a> <a id="63059" href="1Lab.Path.html#63031" class="Bound">y</a> <a id="63061" href="1Lab.Path.html#63039" class="Bound">p</a>
<a id="63063" href="1Lab.Path.html#62931" class="Function">J′</a> <a id="63066" href="1Lab.Path.html#63066" class="Bound">P</a> <a id="63068" href="1Lab.Path.html#63068" class="Bound">prefl</a> <a id="63074" class="Symbol">{</a><a id="63075" href="1Lab.Path.html#63075" class="Bound">x</a><a id="63076" class="Symbol">}</a> <a id="63078" href="1Lab.Path.html#63078" class="Bound">p</a> <a id="63080" class="Symbol">=</a> <a id="63082" href="1Lab.Path.html#11848" class="Function">transport</a> <a id="63092" class="Symbol">(λ</a> <a id="63095" href="1Lab.Path.html#63095" class="Bound">i</a> <a id="63097" class="Symbol">→</a> <a id="63099" href="1Lab.Path.html#63066" class="Bound">P</a> <a id="63101" href="1Lab.Path.html#63075" class="Bound">x</a> <a id="63103" class="Symbol">(</a><a id="63104" href="1Lab.Path.html#63078" class="Bound">p</a> <a id="63106" href="1Lab.Path.html#63095" class="Bound">i</a><a id="63107" class="Symbol">)</a> <a id="63109" class="Symbol">λ</a> <a id="63111" href="1Lab.Path.html#63111" class="Bound">j</a> <a id="63113" class="Symbol">→</a> <a id="63115" href="1Lab.Path.html#63078" class="Bound">p</a> <a id="63117" class="Symbol">(</a><a id="63118" href="1Lab.Path.html#63095" class="Bound">i</a> <a id="63120" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="63122" href="1Lab.Path.html#63111" class="Bound">j</a><a id="63123" class="Symbol">))</a> <a id="63126" class="Symbol">(</a><a id="63127" href="1Lab.Path.html#63068" class="Bound">prefl</a> <a id="63133" href="1Lab.Path.html#63075" class="Bound">x</a><a id="63134" class="Symbol">)</a>
</pre>-->
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>The distinction between these two is elaborated on in the <a href="1Lab.intro.html">Intro to HoTT</a> page.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>For the semantically inclined, these correspond to face inclusions (including the inclusions of endpoints into a line) being monomorphisms, and thus <em>cofibrations</em> in the model structure on cubical sets.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>Since <span class="Agda"><a href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a></span> is not Kan (that is — it does not have a <a href="#composition"><em>composition</em></a> structure), it is not an inhabitant of the “fibrant universe” <span class="Agda"><a href="1Lab.Type.html#391" class="Primitive">Type</a></span>. Instead it lives in <code>SSet</code>, or, in Agda 2.6.3, its own universe – <code>IUniv</code>.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>I (Amélia) wrote <a href="https://amelia.how/posts/cubical-sets.html">a blog post</a> explaining the semantics of them in a lot of depth.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p><span class="Agda"><a data-type="(A : Type a) (φ : I) → Partial φ A → SSet a" href="Agda.Builtin.Cubical.Sub.html#191" class="Postulate">Sub</a></span> lives in the universe <code>SSetω</code>, which we do not have a binding for, so we can not name the type of <span class="Agda"><a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" href="1Lab.Path.html#28690" class="Function Operator">_[_↦_]</a></span>.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>Although it is not proven to be a contradiction in <em>this</em> module, see <a href="Data.Bool.html">Data.Bool</a> for that construction.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>This element has type <code>(i : I) → I → Partial (~ i ∨ i) A</code> rather than <code>(i : I) → Partial (~ i ∨ i) (I → A)</code> because of a universe restriction in Agda: The second argument to <span class="Agda"><a href="Agda.Primitive.Cubical.html#1065" class="Primitive">Partial</a></span> must be a <span class="Agda"><a href="1Lab.Type.html#391" class="Primitive">Type</a></span>, but <span class="Agda"><a href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a></span> is not a <span class="Agda"><a href="1Lab.Type.html#391" class="Primitive">Type</a></span>.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p>In Agda 2.6.2, function types <code>I → A</code> are <em>not</em> fibrant, even though they correspond to paths with “unmarked” endpoints. In Agda 2.6.3 (in development at the time of writing), <code>I</code> was moved to its own universe, <code>IUniv</code>, with a typing rule for functions saying that <code>A → B</code> is fibrant whenever <code>B : Type</code> and <code>A : Type</code> <em>or</em> <code>A : IUniv</code> - i.e. function types <code>I → A</code> were made fibrant whenever <code>A</code> is.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
  </article>
</div>

</main>
</body>
</html>
