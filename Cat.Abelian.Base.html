<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>Cat.Abelian.Base - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />
  <link rel="stylesheet" href="/css/agda-cats.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Cat.Abelian.Base - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="Cat.Abelian.Base - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script src="/equations.js"></script>
  <script src="/unfold.js"></script>
  <script src="/highlight-hover.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

  <!-- Google font embeds -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&amp;family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&amp;display=swap" rel="stylesheet">
</head>

<body>
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">Cat.Abelian.Base</a>
              </h3>

      <!-- Cube logo -->
      <a id="logo" href="/">
        <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />
      </a>

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#abelian-categories"><a href="#abelian-categories" class="header-link">Abelian categories<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#ab-enriched-categories"><a href="#ab-enriched-categories" class="header-link">Ab-enriched categories<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#additive-categories"><a href="#additive-categories" class="header-link">Additive categories<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#pre-abelian-abelian-categories"><a href="#pre-abelian-abelian-categories" class="header-link">Pre-abelian &amp; abelian categories<span class="header-link-emoji">🔗</span></a></a></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>

        <!-- Sidebar footnotes control -->
        <span id="footnote-control" style="display: none; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-fns" type="checkbox" id="sidebar-fns">
          <label for="sidebar-fns">Inline Footnotes</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
              <a href="/">back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/0a04349e4d7b6a436737e6702574d5f0f28dc6ec/src/Cat/Abelian/Base.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="/">back to index</a>
      </div>
      
      <!-- Font toggle checkbox -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="Algebra.Magma.Unital.html" class="Module">Algebra.Magma.Unital</a>
<a id="42" class="Keyword">open</a> <a id="47" class="Keyword">import</a> <a id="54" href="Algebra.Group.Ab.html" class="Module">Algebra.Group.Ab</a>
<a id="71" class="Keyword">open</a> <a id="76" class="Keyword">import</a> <a id="83" href="Algebra.Prelude.html" class="Module">Algebra.Prelude</a>
<a id="99" class="Keyword">open</a> <a id="104" class="Keyword">import</a> <a id="111" href="Algebra.Monoid.html" class="Module">Algebra.Monoid</a>
<a id="126" class="Keyword">open</a> <a id="131" class="Keyword">import</a> <a id="138" href="Algebra.Group.html" class="Module">Algebra.Group</a>

<a id="153" class="Keyword">open</a> <a id="158" class="Keyword">import</a> <a id="165" href="Cat.Diagram.Equaliser.Kernel.html" class="Module">Cat.Diagram.Equaliser.Kernel</a>

<a id="195" class="Keyword">import</a> <a id="202" href="Algebra.Group.Cat.Base.html" class="Module">Algebra.Group.Cat.Base</a> <a id="225" class="Symbol">as</a> <a id="228" class="Module">Grp</a>

<a id="233" class="Keyword">module</a> <a id="240" href="Cat.Abelian.Base.html" class="Module">Cat.Abelian.Base</a> <a id="257" class="Keyword">where</a>
</pre>
<h1 id="abelian-categories"><a href="#abelian-categories" class="header-link">Abelian categories<span class="header-link-emoji">🔗</span></a></h1>
<p>This module defines the sequence of properties which “work up to” abelian categories: Ab-enriched categories, pre-additive categories, pre-abelian categories, and abelian categories. Each concept builds on the last by adding a new categorical property on top of a precategory.</p>
<h2 id="ab-enriched-categories"><a href="#ab-enriched-categories" class="header-link">Ab-enriched categories<span class="header-link-emoji">🔗</span></a></h2>
<p>An <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">\Ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathbf">Ab</span></span></span></span></span>-enriched</span> category is one where each <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>hom</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\hom</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mop">hom</span></span></span></span> set carries the structure of an <a href="Algebra.Group.Ab.html">Abelian group</a>, such that the composition map is <em>bilinear</em>, hence extending to an Abelian group homomorphism</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo><mo>⊗</mo><mi>hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>→</mo><mi>hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo><mtext>,</mtext></mrow><annotation encoding="application/x-tex">
\hom(b, c) \otimes \hom(a, b) \to \hom(a, c)\text{,}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">hom</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">hom</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">hom</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mord text"><span class="mord">,</span></span></span></span></span></span></p>
<p>where the term on the left is the <a href="Algebra.Group.Ab.html#the-tensor-product">tensor product</a> of the corresponding <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>hom</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\hom</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mop">hom</span></span></span></span>-groups.</span> As the name implies, every such category has a canonical <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">\Ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathbf">Ab</span></span></span></span></span>-enrichment</span> (made monoidal using <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mo>⊗</mo><mo>−</mo></mrow><annotation encoding="application/x-tex">- \otimes -</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">−</span></span></span></span>),</span> but we do not use the language of enriched category theory in our development of Abelian categories.</p>
<pre class="Agda"><a id="1295" class="Keyword">record</a> <a id="Ab-category"></a><a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="1302" href="Cat.Abelian.Base.html#1302" class="Record">Ab-category</a> <a id="1314" class="Symbol">{</a><a id="1315" href="Cat.Abelian.Base.html#1315" class="Bound">o</a> <a id="1317" href="Cat.Abelian.Base.html#1317" class="Bound">ℓ</a><a id="1318" class="Symbol">}</a> <a id="1320" class="Symbol">(</a><a id="1321" href="Cat.Abelian.Base.html#1321" class="Bound">C</a> <a id="1323" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="1325" href="Cat.Base.html#704" class="Record">Precategory</a> <a id="1337" href="Cat.Abelian.Base.html#1315" class="Bound">o</a> <a id="1339" href="Cat.Abelian.Base.html#1317" class="Bound">ℓ</a><a id="1340" class="Symbol">)</a> <a id="1342" class="Symbol">:</a> <a id="1344" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="1349" class="Symbol">(</a><a id="1350" href="Cat.Abelian.Base.html#1315" class="Bound">o</a> <a data-type="Level → Level → Level" id="1352" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a data-type="Level → Level" id="1354" href="Agda.Primitive.html#780" class="Primitive">lsuc</a> <a id="1359" href="Cat.Abelian.Base.html#1317" class="Bound">ℓ</a><a id="1360" class="Symbol">)</a> <a id="1362" class="Keyword">where</a>
  <a id="1370" class="Keyword">open</a> <a id="1375" href="Algebra.Prelude.html#883" class="Module">Cat</a> <a id="1379" href="Cat.Abelian.Base.html#1321" class="Bound">C</a> <a id="1381" class="Keyword">public</a>
  <a id="1390" class="Keyword">field</a>
    <a id="Ab-category.Group-on-hom"></a><a data-type="(r : is-abelian C) (A B₁ : C .Ob) → Group-on (Hom C A B₁)" id="1400" href="Cat.Abelian.Base.html#1400" class="Field">Group-on-hom</a> <a id="1413" class="Symbol">:</a> <a id="1415" class="Symbol">∀</a> <a id="1417" href="Cat.Abelian.Base.html#1417" class="Bound">A</a> <a id="1419" href="Cat.Abelian.Base.html#1419" class="Bound">B</a> <a id="1421" class="Symbol">→</a> <a data-type="(A : Type ℓ) → Type ℓ" id="1423" href="Algebra.Group.html#5688" class="Record">Group-on</a> <a id="1432" class="Symbol">(</a><a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1433" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="1437" href="Cat.Abelian.Base.html#1417" class="Bound">A</a> <a id="1439" href="Cat.Abelian.Base.html#1419" class="Bound">B</a><a id="1440" class="Symbol">)</a>

  <a id="Ab-category._+_"></a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="1445" href="Cat.Abelian.Base.html#1445" class="Function Operator">_+_</a> <a id="1449" class="Symbol">:</a> <a id="1451" class="Symbol">∀</a> <a id="1453" class="Symbol">{</a><a id="1454" href="Cat.Abelian.Base.html#1454" class="Bound">A</a> <a id="1456" href="Cat.Abelian.Base.html#1456" class="Bound">B</a><a id="1457" class="Symbol">}</a> <a id="1459" class="Symbol">(</a><a id="1460" href="Cat.Abelian.Base.html#1460" class="Bound">f</a> <a id="1462" href="Cat.Abelian.Base.html#1462" class="Bound">g</a> <a id="1464" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1466" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="1470" href="Cat.Abelian.Base.html#1454" class="Bound">A</a> <a id="1472" href="Cat.Abelian.Base.html#1456" class="Bound">B</a><a id="1473" class="Symbol">)</a> <a id="1475" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1477" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="1481" href="Cat.Abelian.Base.html#1454" class="Bound">A</a> <a id="1483" href="Cat.Abelian.Base.html#1456" class="Bound">B</a>
  <a id="1487" href="Cat.Abelian.Base.html#1487" class="Bound">f</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="1489" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="1491" href="Cat.Abelian.Base.html#1491" class="Bound">g</a> <a id="1493" class="Symbol">=</a> <a data-type="(r : is-abelian C) (A B₁ : C .Ob) → Group-on (Hom C A B₁)" id="1495" href="Cat.Abelian.Base.html#1400" class="Field">Group-on-hom</a> <a id="1508" class="Symbol">_</a> <a id="1510" class="Symbol">_</a> <a id="1512" class="Symbol">.</a><a data-type="(G : AbGroup ℓ) → G .object .fst → G .object .fst → G .object .fst" id="1513" href="Algebra.Group.html#5741" class="Field Operator">Group-on._⋆_</a> <a id="1526" href="Cat.Abelian.Base.html#1487" class="Bound">f</a> <a id="1528" href="Cat.Abelian.Base.html#1491" class="Bound">g</a>

  <a id="Ab-category.0m"></a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="1533" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a id="1536" class="Symbol">:</a> <a id="1538" class="Symbol">∀</a> <a id="1540" class="Symbol">{</a><a id="1541" href="Cat.Abelian.Base.html#1541" class="Bound">A</a> <a id="1543" href="Cat.Abelian.Base.html#1543" class="Bound">B</a><a id="1544" class="Symbol">}</a> <a id="1546" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1548" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="1552" href="Cat.Abelian.Base.html#1541" class="Bound">A</a> <a id="1554" href="Cat.Abelian.Base.html#1543" class="Bound">B</a>
  <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="1558" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a id="1561" class="Symbol">=</a> <a data-type="(r : is-abelian C) (A B₁ : C .Ob) → Group-on (Hom C A B₁)" id="1563" href="Cat.Abelian.Base.html#1400" class="Field">Group-on-hom</a> <a id="1576" class="Symbol">_</a> <a id="1578" class="Symbol">_</a> <a id="1580" class="Symbol">.</a><a data-type="(G : AbGroup ℓ) → G .object .fst" id="1581" href="Algebra.Group.html#1060" class="Function">Group-on.unit</a>

  <a id="1598" class="Keyword">field</a>
    <a id="Ab-category.Hom-grp-ab"></a><a data-type="(r : is-abelian C) (A B₁ : C .Ob) (f g : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ f g
≡
has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g f" id="1608" href="Cat.Abelian.Base.html#1608" class="Field">Hom-grp-ab</a> <a id="1619" class="Symbol">:</a> <a id="1621" class="Symbol">∀</a> <a id="1623" href="Cat.Abelian.Base.html#1623" class="Bound">A</a> <a id="1625" href="Cat.Abelian.Base.html#1625" class="Bound">B</a> <a id="1627" class="Symbol">(</a><a id="1628" href="Cat.Abelian.Base.html#1628" class="Bound">f</a> <a id="1630" href="Cat.Abelian.Base.html#1630" class="Bound">g</a> <a id="1632" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1634" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="1638" href="Cat.Abelian.Base.html#1623" class="Bound">A</a> <a id="1640" href="Cat.Abelian.Base.html#1625" class="Bound">B</a><a id="1641" class="Symbol">)</a> <a id="1643" class="Symbol">→</a> <a id="1645" href="Cat.Abelian.Base.html#1628" class="Bound">f</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="1647" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="1649" href="Cat.Abelian.Base.html#1630" class="Bound">g</a> <a data-type="A → A → Type ℓ" id="1651" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="1653" href="Cat.Abelian.Base.html#1630" class="Bound">g</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="1655" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="1657" href="Cat.Abelian.Base.html#1628" class="Bound">f</a>

  <a id="Ab-category.Hom-grp"></a><a data-type="(r : is-abelian C) (A : C .Ob) → C .Ob → AbGroup ℓ" id="1662" href="Cat.Abelian.Base.html#1662" class="Function">Hom-grp</a> <a id="1670" class="Symbol">:</a> <a id="1672" class="Symbol">∀</a> <a id="1674" href="Cat.Abelian.Base.html#1674" class="Bound">A</a> <a id="1676" href="Cat.Abelian.Base.html#1676" class="Bound">B</a> <a id="1678" class="Symbol">→</a> <a data-type="(ℓ : Level) → Type (lsuc ℓ)" id="1680" href="Algebra.Group.Ab.html#1602" class="Function">AbGroup</a> <a id="1688" href="Cat.Abelian.Base.html#1317" class="Bound">ℓ</a>
  <a data-type="(r : is-abelian C) (A : C .Ob) → C .Ob → AbGroup ℓ" id="1692" href="Cat.Abelian.Base.html#1662" class="Function">Hom-grp</a> <a id="1700" href="Cat.Abelian.Base.html#1700" class="Bound">A</a> <a id="1702" href="Cat.Abelian.Base.html#1702" class="Bound">B</a> <a id="1704" class="Symbol">=</a> <a id="1706" class="Symbol">(</a><a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1707" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="1711" href="Cat.Abelian.Base.html#1700" class="Bound">A</a> <a id="1713" href="Cat.Abelian.Base.html#1702" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="1715" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="(r : is-abelian C) (A B₁ : C .Ob) → Group-on (Hom C A B₁)" id="1717" href="Cat.Abelian.Base.html#1400" class="Field">Group-on-hom</a> <a id="1730" href="Cat.Abelian.Base.html#1700" class="Bound">A</a> <a id="1732" href="Cat.Abelian.Base.html#1702" class="Bound">B</a><a id="1733" class="Symbol">)</a> <a data-type="(object₁ : Ob C) (witness₁ : P object₁) → Restrict-ob P" id="1735" href="Cat.Functor.FullSubcategory.html#1047" class="InductiveConstructor Operator">,</a> <a data-type="(r : is-abelian C) (A B₁ : C .Ob) (f g : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ f g
≡
has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g f" id="1737" href="Cat.Abelian.Base.html#1608" class="Field">Hom-grp-ab</a> <a id="1748" href="Cat.Abelian.Base.html#1700" class="Bound">A</a> <a id="1750" href="Cat.Abelian.Base.html#1702" class="Bound">B</a>

  <a id="1755" class="Keyword">field</a>
    <a id="1765" class="Comment">-- Composition is multilinear:</a>
    <a id="Ab-category.∘-linear-l"></a><a data-type="(r : is-abelian C) (f g : Hom C B₁ C) (h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) h) ((C ∘ g) h)
≡
(C ∘
 has-ab (has-additive (has-is-preab r)) .Group-on-hom B₁ C ._⋆_ f g)
h" id="1800" href="Cat.Abelian.Base.html#1800" class="Field">∘-linear-l</a>
      <a id="1817" class="Symbol">:</a> <a id="1819" class="Symbol">∀</a> <a id="1821" class="Symbol">{</a><a id="1822" href="Cat.Abelian.Base.html#1822" class="Bound">A</a> <a id="1824" href="Cat.Abelian.Base.html#1824" class="Bound">B</a> <a id="1826" href="Cat.Abelian.Base.html#1826" class="Bound">C</a><a id="1827" class="Symbol">}</a> <a id="1829" class="Symbol">(</a><a id="1830" href="Cat.Abelian.Base.html#1830" class="Bound">f</a> <a id="1832" href="Cat.Abelian.Base.html#1832" class="Bound">g</a> <a id="1834" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1836" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="1840" href="Cat.Abelian.Base.html#1824" class="Bound">B</a> <a id="1842" href="Cat.Abelian.Base.html#1826" class="Bound">C</a><a id="1843" class="Symbol">)</a> <a id="1845" class="Symbol">(</a><a id="1846" href="Cat.Abelian.Base.html#1846" class="Bound">h</a> <a id="1848" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1850" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="1854" href="Cat.Abelian.Base.html#1822" class="Bound">A</a> <a id="1856" href="Cat.Abelian.Base.html#1824" class="Bound">B</a><a id="1857" class="Symbol">)</a>
      <a id="1865" class="Symbol">→</a> <a id="1867" class="Symbol">(</a><a id="1868" href="Cat.Abelian.Base.html#1830" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="1870" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="1872" href="Cat.Abelian.Base.html#1846" class="Bound">h</a><a id="1873" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="1875" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="1877" class="Symbol">(</a><a id="1878" href="Cat.Abelian.Base.html#1832" class="Bound">g</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="1880" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="1882" href="Cat.Abelian.Base.html#1846" class="Bound">h</a><a id="1883" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="1885" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="1887" class="Symbol">(</a><a id="1888" href="Cat.Abelian.Base.html#1830" class="Bound">f</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="1890" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="1892" href="Cat.Abelian.Base.html#1832" class="Bound">g</a><a id="1893" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="1895" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="1897" href="Cat.Abelian.Base.html#1846" class="Bound">h</a>
    <a id="Ab-category.∘-linear-r"></a><a data-type="(r : is-abelian C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) g) ((C ∘ f) h)
≡
(C ∘ f)
(has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g
 h)" id="1903" href="Cat.Abelian.Base.html#1903" class="Field">∘-linear-r</a>
      <a id="1920" class="Symbol">:</a> <a id="1922" class="Symbol">∀</a> <a id="1924" class="Symbol">{</a><a id="1925" href="Cat.Abelian.Base.html#1925" class="Bound">A</a> <a id="1927" href="Cat.Abelian.Base.html#1927" class="Bound">B</a> <a id="1929" href="Cat.Abelian.Base.html#1929" class="Bound">C</a><a id="1930" class="Symbol">}</a> <a id="1932" class="Symbol">(</a><a id="1933" href="Cat.Abelian.Base.html#1933" class="Bound">f</a> <a id="1935" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1937" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="1941" href="Cat.Abelian.Base.html#1927" class="Bound">B</a> <a id="1943" href="Cat.Abelian.Base.html#1929" class="Bound">C</a><a id="1944" class="Symbol">)</a> <a id="1946" class="Symbol">(</a><a id="1947" href="Cat.Abelian.Base.html#1947" class="Bound">g</a> <a id="1949" href="Cat.Abelian.Base.html#1949" class="Bound">h</a> <a id="1951" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1953" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="1957" href="Cat.Abelian.Base.html#1925" class="Bound">A</a> <a id="1959" href="Cat.Abelian.Base.html#1927" class="Bound">B</a><a id="1960" class="Symbol">)</a>
      <a id="1968" class="Symbol">→</a> <a id="1970" class="Symbol">(</a><a id="1971" href="Cat.Abelian.Base.html#1933" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="1973" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="1975" href="Cat.Abelian.Base.html#1947" class="Bound">g</a><a id="1976" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="1978" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="1980" class="Symbol">(</a><a id="1981" href="Cat.Abelian.Base.html#1933" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="1983" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="1985" href="Cat.Abelian.Base.html#1949" class="Bound">h</a><a id="1986" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="1988" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="1990" href="Cat.Abelian.Base.html#1933" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="1992" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="1994" class="Symbol">(</a><a id="1995" href="Cat.Abelian.Base.html#1947" class="Bound">g</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="1997" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="1999" href="Cat.Abelian.Base.html#1949" class="Bound">h</a><a id="2000" class="Symbol">)</a>

  <a id="Ab-category.∘map"></a><a data-type="(r : is-abelian C) →
Hom (Hom-grp r B₁ C ⊗ Hom-grp r A B₁) (Hom-grp r A C)" id="2005" href="Cat.Abelian.Base.html#2005" class="Function">∘map</a> <a id="2010" class="Symbol">:</a> <a id="2012" class="Symbol">∀</a> <a id="2014" class="Symbol">{</a><a id="2015" href="Cat.Abelian.Base.html#2015" class="Bound">A</a> <a id="2017" href="Cat.Abelian.Base.html#2017" class="Bound">B</a> <a id="2019" href="Cat.Abelian.Base.html#2019" class="Bound">C</a><a id="2020" class="Symbol">}</a> <a id="2022" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="2024" href="Cat.Base.html#1436" class="Function">Ab.Hom</a> <a id="2031" class="Symbol">(</a><a data-type="(r : is-abelian C) (A : C .Ob) → C .Ob → AbGroup ℓ" id="2032" href="Cat.Abelian.Base.html#1662" class="Function">Hom-grp</a> <a id="2040" href="Cat.Abelian.Base.html#2017" class="Bound">B</a> <a id="2042" href="Cat.Abelian.Base.html#2019" class="Bound">C</a> <a data-type="(A B₁ : AbGroup ℓ) → AbGroup ℓ" id="2044" href="Algebra.Group.Ab.html#8398" class="Function Operator">⊗</a> <a data-type="(r : is-abelian C) (A : C .Ob) → C .Ob → AbGroup ℓ" id="2046" href="Cat.Abelian.Base.html#1662" class="Function">Hom-grp</a> <a id="2054" href="Cat.Abelian.Base.html#2015" class="Bound">A</a> <a id="2056" href="Cat.Abelian.Base.html#2017" class="Bound">B</a><a id="2057" class="Symbol">)</a> <a id="2059" class="Symbol">(</a><a data-type="(r : is-abelian C) (A : C .Ob) → C .Ob → AbGroup ℓ" id="2060" href="Cat.Abelian.Base.html#1662" class="Function">Hom-grp</a> <a id="2068" href="Cat.Abelian.Base.html#2015" class="Bound">A</a> <a id="2070" href="Cat.Abelian.Base.html#2019" class="Bound">C</a><a id="2071" class="Symbol">)</a>
  <a data-type="(r : is-abelian C) →
Hom (Hom-grp r B₁ C ⊗ Hom-grp r A B₁) (Hom-grp r A C)" id="2075" href="Cat.Abelian.Base.html#2005" class="Function">∘map</a> <a id="2080" class="Symbol">{</a><a id="2081" href="Cat.Abelian.Base.html#2081" class="Bound">A</a><a id="2082" class="Symbol">}</a> <a id="2084" class="Symbol">{</a><a id="2085" href="Cat.Abelian.Base.html#2085" class="Bound">B</a><a id="2086" class="Symbol">}</a> <a id="2088" class="Symbol">{</a><a id="2089" href="Cat.Abelian.Base.html#2089" class="Bound">C</a><a id="2090" class="Symbol">}</a> <a id="2092" class="Symbol">=</a>
    <a data-type="(f : ₀ A → ₀ B₁ → ₀ C) →
((x y : A .object .fst) (z : ₀ B₁) →
 f ((A ⋆ x) y) z ≡ (C ⋆ f x z) (f y z)) →
((x y : B₁ .object .fst) (z : ₀ A) →
 f z ((B₁ ⋆ x) y) ≡ (C ⋆ f z x) (f z y)) →
Hom (A ⊗ B₁) C" id="2098" href="Algebra.Group.Ab.html#10577" class="Function">from-multilinear-map</a> <a id="2119" class="Symbol">{</a><a id="2120" class="Argument">A</a> <a id="2122" class="Symbol">=</a> <a data-type="(r : is-abelian C) (A : C .Ob) → C .Ob → AbGroup ℓ" id="2124" href="Cat.Abelian.Base.html#1662" class="Function">Hom-grp</a> <a id="2132" href="Cat.Abelian.Base.html#2085" class="Bound">B</a> <a id="2134" href="Cat.Abelian.Base.html#2089" class="Bound">C</a><a id="2135" class="Symbol">}</a> <a id="2137" class="Symbol">{</a><a id="2138" class="Argument">B</a> <a id="2140" class="Symbol">=</a> <a data-type="(r : is-abelian C) (A : C .Ob) → C .Ob → AbGroup ℓ" id="2142" href="Cat.Abelian.Base.html#1662" class="Function">Hom-grp</a> <a id="2150" href="Cat.Abelian.Base.html#2081" class="Bound">A</a> <a id="2152" href="Cat.Abelian.Base.html#2085" class="Bound">B</a><a id="2153" class="Symbol">}</a> <a id="2155" class="Symbol">{</a><a id="2156" class="Argument">C</a> <a id="2158" class="Symbol">=</a> <a data-type="(r : is-abelian C) (A : C .Ob) → C .Ob → AbGroup ℓ" id="2160" href="Cat.Abelian.Base.html#1662" class="Function">Hom-grp</a> <a id="2168" href="Cat.Abelian.Base.html#2081" class="Bound">A</a> <a id="2170" href="Cat.Abelian.Base.html#2089" class="Bound">C</a><a id="2171" class="Symbol">}</a>
      <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2179" href="Cat.Base.html#3006" class="Function Operator">_∘_</a>
      <a id="2189" class="Symbol">(λ</a> <a id="2192" href="Cat.Abelian.Base.html#2192" class="Bound">f</a> <a id="2194" href="Cat.Abelian.Base.html#2194" class="Bound">g</a> <a id="2196" href="Cat.Abelian.Base.html#2196" class="Bound">h</a> <a id="2198" class="Symbol">→</a> <a data-type="x ≡ y → y ≡ x" id="2200" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="2204" class="Symbol">(</a><a data-type="(r : is-abelian C) (f g : Hom C B₁ C) (h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) h) ((C ∘ g) h)
≡
(C ∘
 has-ab (has-additive (has-is-preab r)) .Group-on-hom B₁ C ._⋆_ f g)
h" id="2205" href="Cat.Abelian.Base.html#1800" class="Field">∘-linear-l</a> <a id="2216" class="Symbol">_</a> <a id="2218" class="Symbol">_</a> <a id="2220" class="Symbol">_))</a>
      <a id="2230" class="Symbol">(λ</a> <a id="2233" href="Cat.Abelian.Base.html#2233" class="Bound">f</a> <a id="2235" href="Cat.Abelian.Base.html#2235" class="Bound">g</a> <a id="2237" href="Cat.Abelian.Base.html#2237" class="Bound">h</a> <a id="2239" class="Symbol">→</a> <a data-type="x ≡ y → y ≡ x" id="2241" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="2245" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) g) ((C ∘ f) h)
≡
(C ∘ f)
(has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g
 h)" id="2246" href="Cat.Abelian.Base.html#1903" class="Field">∘-linear-r</a> <a id="2257" class="Symbol">_</a> <a id="2259" class="Symbol">_</a> <a id="2261" class="Symbol">_))</a>

  <a id="2268" class="Keyword">module</a> <a id="Ab-category.Hom"></a><a id="2275" href="Cat.Abelian.Base.html#2275" class="Module">Hom</a> <a id="2279" class="Symbol">{</a><a id="2280" href="Cat.Abelian.Base.html#2280" class="Bound">A</a> <a id="2282" href="Cat.Abelian.Base.html#2282" class="Bound">B</a><a id="2283" class="Symbol">}</a> <a id="2285" class="Symbol">=</a> <a id="2287" href="Algebra.Group.Ab.html#1916" class="Module">AbGrp</a> <a id="2293" class="Symbol">(</a><a data-type="(r : is-abelian C) (A : C .Ob) → C .Ob → AbGroup ℓ" id="2294" href="Cat.Abelian.Base.html#1662" class="Function">Hom-grp</a> <a id="2302" href="Cat.Abelian.Base.html#2280" class="Bound">A</a> <a id="2304" href="Cat.Abelian.Base.html#2282" class="Bound">B</a><a id="2305" class="Symbol">)</a>
  <a id="2309" class="Keyword">open</a> <a id="2314" href="Cat.Abelian.Base.html#2275" class="Module">Hom</a>
    <a id="2322" class="Keyword">using</a> <a id="2328" class="Symbol">(</a><a data-type="(G : AbGroup ℓ) →
(has-is-group (G .object .snd) — x) y ≡
unit (has-is-group (G .object .snd)) →
x ≡ y" id="2329" href="Algebra.Group.html#2225" class="Function">zero-diff</a><a id="2338" class="Symbol">)</a>
    <a id="2344" class="Keyword">renaming</a> <a id="2353" class="Symbol">(</a><a data-type="(G : AbGroup ℓ) → G .object .fst → G .object .fst → G .object .fst" id="2354" href="Algebra.Group.html#1488" class="Function Operator">_—_</a> <a id="2358" class="Symbol">to</a> <a id="2361" class="Function Operator">_-_</a><a id="2364" class="Symbol">)</a>
    <a id="2370" class="Keyword">public</a>
</pre>
<details>
<summary>
Note that from multilinearity of composition, it follows that the addition of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>hom</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\hom</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mop">hom</span></span></span></span>-groups</span> and composition<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> operations satisfy familiar algebraic identities, e.g. <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>f</mi><mo>=</mo><mi>f</mi><mn>0</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">0f = f0 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>,</span> <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi>a</mi><mi>b</mi><mo>=</mo><mo stretchy="false">(</mo><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo><mi>b</mi><mo>=</mo><mi>a</mi><mo stretchy="false">(</mo><mo>−</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">-ab = (-a)b = a(-b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord mathnormal">ab</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>,</span> etc.
</summary>
<pre class="Agda">  <a id="Ab-category.∘-zero-r"></a><a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ f) (0m r) ≡ 0m r" id="2648" href="Cat.Abelian.Base.html#2648" class="Function">∘-zero-r</a> <a id="2657" class="Symbol">:</a> <a id="2659" class="Symbol">∀</a> <a id="2661" class="Symbol">{</a><a id="2662" href="Cat.Abelian.Base.html#2662" class="Bound">A</a> <a id="2664" href="Cat.Abelian.Base.html#2664" class="Bound">B</a> <a id="2666" href="Cat.Abelian.Base.html#2666" class="Bound">C</a><a id="2667" class="Symbol">}</a> <a id="2669" class="Symbol">{</a><a id="2670" href="Cat.Abelian.Base.html#2670" class="Bound">f</a> <a id="2672" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="2674" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="2678" href="Cat.Abelian.Base.html#2664" class="Bound">B</a> <a id="2680" href="Cat.Abelian.Base.html#2666" class="Bound">C</a><a id="2681" class="Symbol">}</a> <a id="2683" class="Symbol">→</a> <a id="2685" href="Cat.Abelian.Base.html#2670" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2687" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2689" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a id="2692" class="Symbol">{</a><a id="2693" href="Cat.Abelian.Base.html#2662" class="Bound">A</a><a id="2694" class="Symbol">}</a> <a id="2696" class="Symbol">{</a><a id="2697" href="Cat.Abelian.Base.html#2664" class="Bound">B</a><a id="2698" class="Symbol">}</a> <a data-type="A → A → Type ℓ" id="2700" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2702" href="Cat.Abelian.Base.html#1533" class="Function">0m</a>
  <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ f) (0m r) ≡ 0m r" id="2707" href="Cat.Abelian.Base.html#2648" class="Function">∘-zero-r</a> <a id="2716" class="Symbol">{</a><a id="2717" class="Argument">f</a> <a id="2719" class="Symbol">=</a> <a id="2721" href="Cat.Abelian.Base.html#2721" class="Bound">f</a><a id="2722" class="Symbol">}</a> <a id="2724" class="Symbol">=</a>
    <a id="2730" href="Cat.Abelian.Base.html#2721" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2732" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2734" href="Cat.Abelian.Base.html#1533" class="Function">0m</a>                     <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2757" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → f ≡ (C ∘ f) a" id="2760" href="Cat.Reasoning.html#1250" class="Function">Hom.intror</a> <a data-type="(G : AbGroup ℓ) →
G .object .snd ._⋆_ x (has-is-group (G .object .snd) .inverse x) ≡
has-is-group (G .object .snd) .unit" id="2771" href="Algebra.Group.html#1387" class="Function">Hom.inverser</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2784" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="2790" href="Cat.Abelian.Base.html#2721" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2792" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2794" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2797" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="2799" class="Symbol">(</a><a id="2800" href="Cat.Abelian.Base.html#2721" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2802" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2804" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : is-abelian C) →
Hom-grp r A B₁ .object .fst →
Hom-grp r A B₁ .object .fst → Hom-grp r A B₁ .object .fst" id="2807" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="2809" href="Cat.Abelian.Base.html#2721" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2811" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2813" href="Cat.Abelian.Base.html#1533" class="Function">0m</a><a id="2815" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2817" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="is-semigroup _⋆₁_ → (x ⋆₁ (y ⋆₁ z)) ≡ ((x ⋆₁ y) ⋆₁ z)" id="2820" href="Algebra.Semigroup.html#453" class="Function">Hom.associative</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2836" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="2842" class="Symbol">(</a><a id="2843" href="Cat.Abelian.Base.html#2721" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2845" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2847" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2850" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="2852" href="Cat.Abelian.Base.html#2721" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2854" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2856" href="Cat.Abelian.Base.html#1533" class="Function">0m</a><a id="2858" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom-grp r A B₁ .object .fst →
Hom-grp r A B₁ .object .fst → Hom-grp r A B₁ .object .fst" id="2860" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="2862" href="Cat.Abelian.Base.html#2721" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2864" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2866" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2869" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="2872" href="1Lab.Path.html#20756" class="Function">ap</a> <a id="2875" class="Symbol">(</a><a data-type="(r : is-abelian C) →
Hom-grp r A B₁ .object .fst →
Hom-grp r A B₁ .object .fst → Hom-grp r A B₁ .object .fst" id="2876" href="Cat.Abelian.Base.html#2361" class="Function Operator">_-</a> <a id="2879" href="Cat.Abelian.Base.html#2721" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2881" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2883" href="Cat.Abelian.Base.html#1533" class="Function">0m</a><a id="2885" class="Symbol">)</a> <a id="2887" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) g) ((C ∘ f) h)
≡
(C ∘ f)
(has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g
 h)" id="2888" href="Cat.Abelian.Base.html#1903" class="Field">∘-linear-r</a> <a id="2899" class="Symbol">_</a> <a id="2901" class="Symbol">_</a> <a id="2903" class="Symbol">_)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2906" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="2912" class="Symbol">(</a><a id="2913" href="Cat.Abelian.Base.html#2721" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2915" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="2917" class="Symbol">(</a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2918" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2921" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2923" href="Cat.Abelian.Base.html#1533" class="Function">0m</a><a id="2925" class="Symbol">))</a> <a data-type="(r : is-abelian C) →
Hom-grp r A B₁ .object .fst →
Hom-grp r A B₁ .object .fst → Hom-grp r A B₁ .object .fst" id="2928" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="2930" href="Cat.Abelian.Base.html#2721" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2932" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2934" href="Cat.Abelian.Base.html#1533" class="Function">0m</a>   <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2939" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="2942" href="1Lab.Path.html#20756" class="Function">ap</a> <a id="2945" class="Symbol">((</a><a data-type="(r : is-abelian C) →
Hom-grp r A B₁ .object .fst →
Hom-grp r A B₁ .object .fst → Hom-grp r A B₁ .object .fst" id="2947" href="Cat.Abelian.Base.html#2361" class="Function Operator">_-</a> <a id="2950" href="Cat.Abelian.Base.html#2721" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2952" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2954" href="Cat.Abelian.Base.html#1533" class="Function">0m</a><a id="2956" class="Symbol">)</a> <a id="2958" href="Cat.Prelude.html#232" class="Function Operator">⊙</a> <a id="2960" class="Symbol">(</a><a id="2961" href="Cat.Abelian.Base.html#2721" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2963" href="Cat.Base.html#3006" class="Function Operator">∘_</a><a id="2965" class="Symbol">))</a> <a data-type="(r : Monoid-on A) → r ._⋆_ (r .identity) x ≡ x" id="2968" href="Algebra.Monoid.html#1088" class="Function">Hom.idl</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2976" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="2982" class="Symbol">(</a><a id="2983" href="Cat.Abelian.Base.html#2721" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2985" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2987" href="Cat.Abelian.Base.html#1533" class="Function">0m</a><a id="2989" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom-grp r A B₁ .object .fst →
Hom-grp r A B₁ .object .fst → Hom-grp r A B₁ .object .fst" id="2991" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="2993" href="Cat.Abelian.Base.html#2721" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2995" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2997" href="Cat.Abelian.Base.html#1533" class="Function">0m</a>          <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3009" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(G : AbGroup ℓ) →
G .object .snd ._⋆_ x (has-is-group (G .object .snd) .inverse x) ≡
has-is-group (G .object .snd) .unit" id="3012" href="Algebra.Group.html#1387" class="Function">Hom.inverser</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3025" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3031" href="Cat.Abelian.Base.html#1533" class="Function">0m</a>                         <a data-type="(x : A) → x ≡ x" id="3058" href="1Lab.Path.html#46957" class="Function Operator">∎</a>

  <a id="Ab-category.∘-zero-l"></a><a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ 0m r) f ≡ 0m r" id="3063" href="Cat.Abelian.Base.html#3063" class="Function">∘-zero-l</a> <a id="3072" class="Symbol">:</a> <a id="3074" class="Symbol">∀</a> <a id="3076" class="Symbol">{</a><a id="3077" href="Cat.Abelian.Base.html#3077" class="Bound">A</a> <a id="3079" href="Cat.Abelian.Base.html#3079" class="Bound">B</a> <a id="3081" href="Cat.Abelian.Base.html#3081" class="Bound">C</a><a id="3082" class="Symbol">}</a> <a id="3084" class="Symbol">{</a><a id="3085" href="Cat.Abelian.Base.html#3085" class="Bound">f</a> <a id="3087" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="3089" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="3093" href="Cat.Abelian.Base.html#3077" class="Bound">A</a> <a id="3095" href="Cat.Abelian.Base.html#3079" class="Bound">B</a><a id="3096" class="Symbol">}</a> <a id="3098" class="Symbol">→</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3100" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3103" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3105" href="Cat.Abelian.Base.html#3085" class="Bound">f</a> <a data-type="A → A → Type ℓ" id="3107" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3109" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a id="3112" class="Symbol">{</a><a id="3113" href="Cat.Abelian.Base.html#3077" class="Bound">A</a><a id="3114" class="Symbol">}</a> <a id="3116" class="Symbol">{</a><a id="3117" href="Cat.Abelian.Base.html#3081" class="Bound">C</a><a id="3118" class="Symbol">}</a>
  <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ 0m r) f ≡ 0m r" id="3122" href="Cat.Abelian.Base.html#3063" class="Function">∘-zero-l</a> <a id="3131" class="Symbol">{</a><a id="3132" class="Argument">f</a> <a id="3134" class="Symbol">=</a> <a id="3136" href="Cat.Abelian.Base.html#3136" class="Bound">f</a><a id="3137" class="Symbol">}</a> <a id="3139" class="Symbol">=</a>
    <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3145" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3148" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3150" href="Cat.Abelian.Base.html#3136" class="Bound">f</a>                                   <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3186" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → f ≡ (C ∘ a) f" id="3189" href="Cat.Reasoning.html#1207" class="Function">Hom.introl</a> <a data-type="(G : AbGroup ℓ) →
G .object .snd ._⋆_ (has-is-group (G .object .snd) .inverse x) x ≡
has-is-group (G .object .snd) .unit" id="3200" href="Algebra.Group.html#1341" class="Function">Hom.inversel</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3213" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="3219" class="Symbol">(</a><a data-type="(G : AbGroup ℓ) → G .object .fst → G .object .fst" id="3220" href="Algebra.Group.html#1320" class="Function">Hom.inverse</a> <a id="3232" class="Symbol">(</a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3233" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3236" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3238" href="Cat.Abelian.Base.html#3136" class="Bound">f</a><a id="3239" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3241" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3243" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3246" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3248" href="Cat.Abelian.Base.html#3136" class="Bound">f</a><a id="3249" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3251" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3253" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3256" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3258" href="Cat.Abelian.Base.html#3136" class="Bound">f</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3260" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="x ≡ y → y ≡ x" id="3263" href="1Lab.Path.html#10558" class="Function">sym</a> <a data-type="is-semigroup _⋆₁_ → (x ⋆₁ (y ⋆₁ z)) ≡ ((x ⋆₁ y) ⋆₁ z)" id="3267" href="Algebra.Semigroup.html#453" class="Function">Hom.associative</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3283" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a data-type="(G : AbGroup ℓ) → G .object .fst → G .object .fst" id="3289" href="Algebra.Group.html#1320" class="Function">Hom.inverse</a> <a id="3301" class="Symbol">(</a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3302" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3305" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3307" href="Cat.Abelian.Base.html#3136" class="Bound">f</a><a id="3308" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3310" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="3312" class="Symbol">(</a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3313" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3316" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3318" href="Cat.Abelian.Base.html#3136" class="Bound">f</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3320" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3322" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3325" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3327" href="Cat.Abelian.Base.html#3136" class="Bound">f</a><a id="3328" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3330" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="3333" href="1Lab.Path.html#20756" class="Function">ap</a> <a id="3336" class="Symbol">(</a><a data-type="(G : AbGroup ℓ) → G .object .fst → G .object .fst" id="3337" href="Algebra.Group.html#1320" class="Function">Hom.inverse</a> <a id="3349" class="Symbol">(</a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3350" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3353" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3355" href="Cat.Abelian.Base.html#3136" class="Bound">f</a><a id="3356" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3358" href="Cat.Abelian.Base.html#1445" class="Function Operator">+_</a><a id="3360" class="Symbol">)</a> <a id="3362" class="Symbol">(</a><a data-type="(r : is-abelian C) (f g : Hom C B₁ C) (h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) h) ((C ∘ g) h)
≡
(C ∘
 has-ab (has-additive (has-is-preab r)) .Group-on-hom B₁ C ._⋆_ f g)
h" id="3363" href="Cat.Abelian.Base.html#1800" class="Field">∘-linear-l</a> <a id="3374" class="Symbol">_</a> <a id="3376" class="Symbol">_</a> <a id="3378" class="Symbol">_)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3381" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a data-type="(G : AbGroup ℓ) → G .object .fst → G .object .fst" id="3387" href="Algebra.Group.html#1320" class="Function">Hom.inverse</a> <a id="3399" class="Symbol">(</a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3400" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3403" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3405" href="Cat.Abelian.Base.html#3136" class="Bound">f</a><a id="3406" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3408" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="3410" class="Symbol">((</a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3412" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3415" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3417" href="Cat.Abelian.Base.html#1533" class="Function">0m</a><a id="3419" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3421" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3423" href="Cat.Abelian.Base.html#3136" class="Bound">f</a><a id="3424" class="Symbol">)</a>   <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3428" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="3431" href="1Lab.Path.html#20756" class="Function">ap</a> <a id="3434" class="Symbol">((</a><a data-type="(G : AbGroup ℓ) → G .object .fst → G .object .fst" id="3436" href="Algebra.Group.html#1320" class="Function">Hom.inverse</a> <a id="3448" class="Symbol">(</a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3449" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3452" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3454" href="Cat.Abelian.Base.html#3136" class="Bound">f</a><a id="3455" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3457" href="Cat.Abelian.Base.html#1445" class="Function Operator">+_</a><a id="3459" class="Symbol">)</a> <a id="3461" href="Cat.Prelude.html#232" class="Function Operator">⊙</a> <a id="3463" class="Symbol">(</a><a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3464" href="Cat.Base.html#3006" class="Function Operator">_∘</a> <a id="3467" href="Cat.Abelian.Base.html#3136" class="Bound">f</a><a id="3468" class="Symbol">))</a> <a data-type="(r : Monoid-on A) → r ._⋆_ (r .identity) x ≡ x" id="3471" href="Algebra.Monoid.html#1088" class="Function">Hom.idl</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3479" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a data-type="(G : AbGroup ℓ) → G .object .fst → G .object .fst" id="3485" href="Algebra.Group.html#1320" class="Function">Hom.inverse</a> <a id="3497" class="Symbol">(</a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3498" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3501" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3503" href="Cat.Abelian.Base.html#3136" class="Bound">f</a><a id="3504" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3506" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="3508" class="Symbol">(</a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3509" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3512" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3514" href="Cat.Abelian.Base.html#3136" class="Bound">f</a><a id="3515" class="Symbol">)</a>          <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3526" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(G : AbGroup ℓ) →
G .object .snd ._⋆_ (has-is-group (G .object .snd) .inverse x) x ≡
has-is-group (G .object .snd) .unit" id="3529" href="Algebra.Group.html#1341" class="Function">Hom.inversel</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3542" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3548" href="Cat.Abelian.Base.html#1533" class="Function">0m</a>                                       <a data-type="(x : A) → x ≡ x" id="3589" href="1Lab.Path.html#46957" class="Function Operator">∎</a>

  <a id="Ab-category.neg-∘-l"></a><a data-type="(r : is-abelian C) →
inverse r ((has-ab (has-additive (has-is-preab r)) ∘ g) h) ≡
(has-ab (has-additive (has-is-preab r)) ∘ inverse r g) h" id="3594" href="Cat.Abelian.Base.html#3594" class="Function">neg-∘-l</a>
    <a id="3606" class="Symbol">:</a> <a id="3608" class="Symbol">∀</a> <a id="3610" class="Symbol">{</a><a id="3611" href="Cat.Abelian.Base.html#3611" class="Bound">A</a> <a id="3613" href="Cat.Abelian.Base.html#3613" class="Bound">B</a> <a id="3615" href="Cat.Abelian.Base.html#3615" class="Bound">C</a><a id="3616" class="Symbol">}</a> <a id="3618" class="Symbol">{</a><a id="3619" href="Cat.Abelian.Base.html#3619" class="Bound">g</a> <a id="3621" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="3623" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="3627" href="Cat.Abelian.Base.html#3613" class="Bound">B</a> <a id="3629" href="Cat.Abelian.Base.html#3615" class="Bound">C</a><a id="3630" class="Symbol">}</a> <a id="3632" class="Symbol">{</a><a id="3633" href="Cat.Abelian.Base.html#3633" class="Bound">h</a> <a id="3635" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="3637" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="3641" href="Cat.Abelian.Base.html#3611" class="Bound">A</a> <a id="3643" href="Cat.Abelian.Base.html#3613" class="Bound">B</a><a id="3644" class="Symbol">}</a>
    <a id="3650" class="Symbol">→</a> <a data-type="(G : AbGroup ℓ) → G .object .fst → G .object .fst" id="3652" href="Algebra.Group.html#1320" class="Function">Hom.inverse</a> <a id="3664" class="Symbol">(</a><a id="3665" href="Cat.Abelian.Base.html#3619" class="Bound">g</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3667" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3669" href="Cat.Abelian.Base.html#3633" class="Bound">h</a><a id="3670" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="3672" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(G : AbGroup ℓ) → G .object .fst → G .object .fst" id="3674" href="Algebra.Group.html#1320" class="Function">Hom.inverse</a> <a id="3686" href="Cat.Abelian.Base.html#3619" class="Bound">g</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3688" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3690" href="Cat.Abelian.Base.html#3633" class="Bound">h</a>
  <a data-type="(r : is-abelian C) →
inverse r ((has-ab (has-additive (has-is-preab r)) ∘ g) h) ≡
(has-ab (has-additive (has-is-preab r)) ∘ inverse r g) h" id="3694" href="Cat.Abelian.Base.html#3594" class="Function">neg-∘-l</a> <a id="3702" class="Symbol">{</a><a id="3703" class="Argument">g</a> <a id="3705" class="Symbol">=</a> <a id="3707" href="Cat.Abelian.Base.html#3707" class="Bound">g</a><a id="3708" class="Symbol">}</a> <a id="3710" class="Symbol">{</a><a id="3711" href="Cat.Abelian.Base.html#3711" class="Bound">h</a><a id="3712" class="Symbol">}</a> <a id="3714" class="Symbol">=</a> <a data-type="is-monoid 1M _⋆₁_ →
(e x y : A) → (x ⋆₁ e) ≡ 1M → (e ⋆₁ y) ≡ 1M → x ≡ y" id="3716" href="Algebra.Monoid.html#5105" class="Function">monoid-inverse-unique</a> <a data-type="(G : AbGroup ℓ) →
is-monoid (has-is-group (G .object .snd) .unit)
(G .object .snd ._⋆_)" id="3738" href="Algebra.Group.html#1073" class="Function">Hom.has-is-monoid</a> <a id="3756" class="Symbol">(</a><a id="3757" href="Cat.Abelian.Base.html#3707" class="Bound">g</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3759" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3761" href="Cat.Abelian.Base.html#3711" class="Bound">h</a><a id="3762" class="Symbol">)</a> <a id="3764" class="Symbol">_</a> <a id="3766" class="Symbol">_</a>
    <a data-type="(G : AbGroup ℓ) →
G .object .snd ._⋆_ (has-is-group (G .object .snd) .inverse x) x ≡
has-is-group (G .object .snd) .unit" id="3772" href="Algebra.Group.html#1341" class="Function">Hom.inversel</a>
    <a id="3789" class="Symbol">(</a><a data-type="(r : is-abelian C) (f g : Hom C B₁ C) (h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) h) ((C ∘ g) h)
≡
(C ∘
 has-ab (has-additive (has-is-preab r)) .Group-on-hom B₁ C ._⋆_ f g)
h" id="3790" href="Cat.Abelian.Base.html#1800" class="Field">∘-linear-l</a> <a id="3801" class="Symbol">_</a> <a id="3803" class="Symbol">_</a> <a id="3805" class="Symbol">_</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="3807" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="3809" href="1Lab.Path.html#20756" class="Function">ap</a> <a id="3812" class="Symbol">(</a><a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3813" href="Cat.Base.html#3006" class="Function Operator">_∘</a> <a id="3816" href="Cat.Abelian.Base.html#3711" class="Bound">h</a><a id="3817" class="Symbol">)</a> <a data-type="(G : AbGroup ℓ) →
G .object .snd ._⋆_ x (has-is-group (G .object .snd) .inverse x) ≡
has-is-group (G .object .snd) .unit" id="3819" href="Algebra.Group.html#1387" class="Function">Hom.inverser</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="3832" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ 0m r) f ≡ 0m r" id="3834" href="Cat.Abelian.Base.html#3063" class="Function">∘-zero-l</a><a id="3842" class="Symbol">)</a>

  <a id="Ab-category.neg-∘-r"></a><a data-type="(r : is-abelian C) →
inverse r ((has-ab (has-additive (has-is-preab r)) ∘ g) h) ≡
(has-ab (has-additive (has-is-preab r)) ∘ g) (inverse r h)" id="3847" href="Cat.Abelian.Base.html#3847" class="Function">neg-∘-r</a>
    <a id="3859" class="Symbol">:</a> <a id="3861" class="Symbol">∀</a> <a id="3863" class="Symbol">{</a><a id="3864" href="Cat.Abelian.Base.html#3864" class="Bound">A</a> <a id="3866" href="Cat.Abelian.Base.html#3866" class="Bound">B</a> <a id="3868" href="Cat.Abelian.Base.html#3868" class="Bound">C</a><a id="3869" class="Symbol">}</a> <a id="3871" class="Symbol">{</a><a id="3872" href="Cat.Abelian.Base.html#3872" class="Bound">g</a> <a id="3874" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="3876" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="3880" href="Cat.Abelian.Base.html#3866" class="Bound">B</a> <a id="3882" href="Cat.Abelian.Base.html#3868" class="Bound">C</a><a id="3883" class="Symbol">}</a> <a id="3885" class="Symbol">{</a><a id="3886" href="Cat.Abelian.Base.html#3886" class="Bound">h</a> <a id="3888" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="3890" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="3894" href="Cat.Abelian.Base.html#3864" class="Bound">A</a> <a id="3896" href="Cat.Abelian.Base.html#3866" class="Bound">B</a><a id="3897" class="Symbol">}</a>
    <a id="3903" class="Symbol">→</a> <a data-type="(G : AbGroup ℓ) → G .object .fst → G .object .fst" id="3905" href="Algebra.Group.html#1320" class="Function">Hom.inverse</a> <a id="3917" class="Symbol">(</a><a id="3918" href="Cat.Abelian.Base.html#3872" class="Bound">g</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3920" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3922" href="Cat.Abelian.Base.html#3886" class="Bound">h</a><a id="3923" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="3925" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="3927" href="Cat.Abelian.Base.html#3872" class="Bound">g</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3929" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(G : AbGroup ℓ) → G .object .fst → G .object .fst" id="3931" href="Algebra.Group.html#1320" class="Function">Hom.inverse</a> <a id="3943" href="Cat.Abelian.Base.html#3886" class="Bound">h</a>
  <a data-type="(r : is-abelian C) →
inverse r ((has-ab (has-additive (has-is-preab r)) ∘ g) h) ≡
(has-ab (has-additive (has-is-preab r)) ∘ g) (inverse r h)" id="3947" href="Cat.Abelian.Base.html#3847" class="Function">neg-∘-r</a> <a id="3955" class="Symbol">{</a><a id="3956" class="Argument">g</a> <a id="3958" class="Symbol">=</a> <a id="3960" href="Cat.Abelian.Base.html#3960" class="Bound">g</a><a id="3961" class="Symbol">}</a> <a id="3963" class="Symbol">{</a><a id="3964" href="Cat.Abelian.Base.html#3964" class="Bound">h</a><a id="3965" class="Symbol">}</a> <a id="3967" class="Symbol">=</a> <a data-type="is-monoid 1M _⋆₁_ →
(e x y : A) → (x ⋆₁ e) ≡ 1M → (e ⋆₁ y) ≡ 1M → x ≡ y" id="3969" href="Algebra.Monoid.html#5105" class="Function">monoid-inverse-unique</a> <a data-type="(G : AbGroup ℓ) →
is-monoid (has-is-group (G .object .snd) .unit)
(G .object .snd ._⋆_)" id="3991" href="Algebra.Group.html#1073" class="Function">Hom.has-is-monoid</a> <a id="4009" class="Symbol">(</a><a id="4010" href="Cat.Abelian.Base.html#3960" class="Bound">g</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="4012" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="4014" href="Cat.Abelian.Base.html#3964" class="Bound">h</a><a id="4015" class="Symbol">)</a> <a id="4017" class="Symbol">_</a> <a id="4019" class="Symbol">_</a>
    <a data-type="(G : AbGroup ℓ) →
G .object .snd ._⋆_ (has-is-group (G .object .snd) .inverse x) x ≡
has-is-group (G .object .snd) .unit" id="4025" href="Algebra.Group.html#1341" class="Function">Hom.inversel</a>
    <a id="4042" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) g) ((C ∘ f) h)
≡
(C ∘ f)
(has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g
 h)" id="4043" href="Cat.Abelian.Base.html#1903" class="Field">∘-linear-r</a> <a id="4054" class="Symbol">_</a> <a id="4056" class="Symbol">_</a> <a id="4058" class="Symbol">_</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="4060" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="4062" href="1Lab.Path.html#20756" class="Function">ap</a> <a id="4065" class="Symbol">(</a><a id="4066" href="Cat.Abelian.Base.html#3960" class="Bound">g</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="4068" href="Cat.Base.html#3006" class="Function Operator">∘_</a><a id="4070" class="Symbol">)</a> <a data-type="(G : AbGroup ℓ) →
G .object .snd ._⋆_ x (has-is-group (G .object .snd) .inverse x) ≡
has-is-group (G .object .snd) .unit" id="4072" href="Algebra.Group.html#1387" class="Function">Hom.inverser</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="4085" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ f) (0m r) ≡ 0m r" id="4087" href="Cat.Abelian.Base.html#2648" class="Function">∘-zero-r</a><a id="4095" class="Symbol">)</a>

  <a id="Ab-category.∘-minus-l"></a><a data-type="(r : is-abelian C)
(f g : Hom (has-ab (has-additive (has-is-preab r))) B₁ C)
(h : Hom (has-ab (has-additive (has-is-preab r))) A B₁) →
(r — (has-ab (has-additive (has-is-preab r)) ∘ f) h)
((has-ab (has-additive (has-is-preab r)) ∘ g) h)
≡ (has-ab (has-additive (has-is-preab r)) ∘ (r — f) g) h" id="4100" href="Cat.Abelian.Base.html#4100" class="Function">∘-minus-l</a>
    <a id="4114" class="Symbol">:</a> <a id="4116" class="Symbol">∀</a> <a id="4118" class="Symbol">{</a><a id="4119" href="Cat.Abelian.Base.html#4119" class="Bound">A</a> <a id="4121" href="Cat.Abelian.Base.html#4121" class="Bound">B</a> <a id="4123" href="Cat.Abelian.Base.html#4123" class="Bound">C</a><a id="4124" class="Symbol">}</a> <a id="4126" class="Symbol">(</a><a id="4127" href="Cat.Abelian.Base.html#4127" class="Bound">f</a> <a id="4129" href="Cat.Abelian.Base.html#4129" class="Bound">g</a> <a id="4131" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="4133" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="4137" href="Cat.Abelian.Base.html#4121" class="Bound">B</a> <a id="4139" href="Cat.Abelian.Base.html#4123" class="Bound">C</a><a id="4140" class="Symbol">)</a> <a id="4142" class="Symbol">(</a><a id="4143" href="Cat.Abelian.Base.html#4143" class="Bound">h</a> <a id="4145" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="4147" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="4151" href="Cat.Abelian.Base.html#4119" class="Bound">A</a> <a id="4153" href="Cat.Abelian.Base.html#4121" class="Bound">B</a><a id="4154" class="Symbol">)</a>
    <a id="4160" class="Symbol">→</a> <a id="4162" class="Symbol">(</a><a id="4163" href="Cat.Abelian.Base.html#4127" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="4165" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="4167" href="Cat.Abelian.Base.html#4143" class="Bound">h</a><a id="4168" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom-grp r A B₁ .object .fst →
Hom-grp r A B₁ .object .fst → Hom-grp r A B₁ .object .fst" id="4170" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="4172" class="Symbol">(</a><a id="4173" href="Cat.Abelian.Base.html#4129" class="Bound">g</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="4175" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="4177" href="Cat.Abelian.Base.html#4143" class="Bound">h</a><a id="4178" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="4180" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="4182" class="Symbol">(</a><a id="4183" href="Cat.Abelian.Base.html#4127" class="Bound">f</a> <a data-type="(r : is-abelian C) →
Hom-grp r A B₁ .object .fst →
Hom-grp r A B₁ .object .fst → Hom-grp r A B₁ .object .fst" id="4185" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="4187" href="Cat.Abelian.Base.html#4129" class="Bound">g</a><a id="4188" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="4190" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="4192" href="Cat.Abelian.Base.html#4143" class="Bound">h</a>
  <a data-type="(r : is-abelian C)
(f g : Hom (has-ab (has-additive (has-is-preab r))) B₁ C)
(h : Hom (has-ab (has-additive (has-is-preab r))) A B₁) →
(r — (has-ab (has-additive (has-is-preab r)) ∘ f) h)
((has-ab (has-additive (has-is-preab r)) ∘ g) h)
≡ (has-ab (has-additive (has-is-preab r)) ∘ (r — f) g) h" id="4196" href="Cat.Abelian.Base.html#4100" class="Function">∘-minus-l</a> <a id="4206" href="Cat.Abelian.Base.html#4206" class="Bound">f</a> <a id="4208" href="Cat.Abelian.Base.html#4208" class="Bound">g</a> <a id="4210" href="Cat.Abelian.Base.html#4210" class="Bound">h</a> <a id="4212" class="Symbol">=</a>
    <a id="4218" href="Cat.Abelian.Base.html#4206" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="4220" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="4222" href="Cat.Abelian.Base.html#4210" class="Bound">h</a> <a data-type="(r : is-abelian C) →
Hom-grp r A B₁ .object .fst →
Hom-grp r A B₁ .object .fst → Hom-grp r A B₁ .object .fst" id="4224" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="4226" href="Cat.Abelian.Base.html#4208" class="Bound">g</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="4228" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="4230" href="Cat.Abelian.Base.html#4210" class="Bound">h</a>               <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="4246" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="4249" href="1Lab.Path.html#20756" class="Function">ap</a> <a id="4252" class="Symbol">(</a><a id="4253" href="Cat.Abelian.Base.html#4206" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="4255" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="4257" href="Cat.Abelian.Base.html#4210" class="Bound">h</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="4259" href="Cat.Abelian.Base.html#1445" class="Function Operator">+_</a><a id="4261" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
inverse r ((has-ab (has-additive (has-is-preab r)) ∘ g) h) ≡
(has-ab (has-additive (has-is-preab r)) ∘ inverse r g) h" id="4263" href="Cat.Abelian.Base.html#3594" class="Function">neg-∘-l</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="4271" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="4277" href="Cat.Abelian.Base.html#4206" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="4279" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="4281" href="Cat.Abelian.Base.html#4210" class="Bound">h</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="4283" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="4285" class="Symbol">(</a><a data-type="(G : AbGroup ℓ) → G .object .fst → G .object .fst" id="4286" href="Algebra.Group.html#1320" class="Function">Hom.inverse</a> <a id="4298" href="Cat.Abelian.Base.html#4208" class="Bound">g</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="4300" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="4302" href="Cat.Abelian.Base.html#4210" class="Bound">h</a><a id="4303" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="4305" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(r : is-abelian C) (f g : Hom C B₁ C) (h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) h) ((C ∘ g) h)
≡
(C ∘
 has-ab (has-additive (has-is-preab r)) .Group-on-hom B₁ C ._⋆_ f g)
h" id="4308" href="Cat.Abelian.Base.html#1800" class="Field">∘-linear-l</a> <a id="4319" class="Symbol">_</a> <a id="4321" class="Symbol">_</a> <a id="4323" class="Symbol">_</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="4325" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="4331" class="Symbol">(</a><a id="4332" href="Cat.Abelian.Base.html#4206" class="Bound">f</a> <a data-type="(r : is-abelian C) →
Hom-grp r A B₁ .object .fst →
Hom-grp r A B₁ .object .fst → Hom-grp r A B₁ .object .fst" id="4334" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="4336" href="Cat.Abelian.Base.html#4208" class="Bound">g</a><a id="4337" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="4339" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="4341" href="Cat.Abelian.Base.html#4210" class="Bound">h</a>                 <a data-type="(x : A) → x ≡ x" id="4359" href="1Lab.Path.html#46957" class="Function Operator">∎</a>

  <a id="Ab-category.∘-minus-r"></a><a data-type="(r : is-abelian C)
(f : Hom (has-ab (has-additive (has-is-preab r))) B₁ C)
(g h : Hom (has-ab (has-additive (has-is-preab r))) A B₁) →
(r — (has-ab (has-additive (has-is-preab r)) ∘ f) g)
((has-ab (has-additive (has-is-preab r)) ∘ f) h)
≡ (has-ab (has-additive (has-is-preab r)) ∘ f) ((r — g) h)" id="4364" href="Cat.Abelian.Base.html#4364" class="Function">∘-minus-r</a>
    <a id="4378" class="Symbol">:</a> <a id="4380" class="Symbol">∀</a> <a id="4382" class="Symbol">{</a><a id="4383" href="Cat.Abelian.Base.html#4383" class="Bound">A</a> <a id="4385" href="Cat.Abelian.Base.html#4385" class="Bound">B</a> <a id="4387" href="Cat.Abelian.Base.html#4387" class="Bound">C</a><a id="4388" class="Symbol">}</a> <a id="4390" class="Symbol">(</a><a id="4391" href="Cat.Abelian.Base.html#4391" class="Bound">f</a> <a id="4393" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="4395" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="4399" href="Cat.Abelian.Base.html#4385" class="Bound">B</a> <a id="4401" href="Cat.Abelian.Base.html#4387" class="Bound">C</a><a id="4402" class="Symbol">)</a> <a id="4404" class="Symbol">(</a><a id="4405" href="Cat.Abelian.Base.html#4405" class="Bound">g</a> <a id="4407" href="Cat.Abelian.Base.html#4407" class="Bound">h</a> <a id="4409" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="4411" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="4415" href="Cat.Abelian.Base.html#4383" class="Bound">A</a> <a id="4417" href="Cat.Abelian.Base.html#4385" class="Bound">B</a><a id="4418" class="Symbol">)</a>
    <a id="4424" class="Symbol">→</a> <a id="4426" class="Symbol">(</a><a id="4427" href="Cat.Abelian.Base.html#4391" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="4429" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="4431" href="Cat.Abelian.Base.html#4405" class="Bound">g</a><a id="4432" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom-grp r A B₁ .object .fst →
Hom-grp r A B₁ .object .fst → Hom-grp r A B₁ .object .fst" id="4434" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="4436" class="Symbol">(</a><a id="4437" href="Cat.Abelian.Base.html#4391" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="4439" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="4441" href="Cat.Abelian.Base.html#4407" class="Bound">h</a><a id="4442" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="4444" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="4446" href="Cat.Abelian.Base.html#4391" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="4448" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="4450" class="Symbol">(</a><a id="4451" href="Cat.Abelian.Base.html#4405" class="Bound">g</a> <a data-type="(r : is-abelian C) →
Hom-grp r A B₁ .object .fst →
Hom-grp r A B₁ .object .fst → Hom-grp r A B₁ .object .fst" id="4453" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="4455" href="Cat.Abelian.Base.html#4407" class="Bound">h</a><a id="4456" class="Symbol">)</a>
  <a data-type="(r : is-abelian C)
(f : Hom (has-ab (has-additive (has-is-preab r))) B₁ C)
(g h : Hom (has-ab (has-additive (has-is-preab r))) A B₁) →
(r — (has-ab (has-additive (has-is-preab r)) ∘ f) g)
((has-ab (has-additive (has-is-preab r)) ∘ f) h)
≡ (has-ab (has-additive (has-is-preab r)) ∘ f) ((r — g) h)" id="4460" href="Cat.Abelian.Base.html#4364" class="Function">∘-minus-r</a> <a id="4470" href="Cat.Abelian.Base.html#4470" class="Bound">f</a> <a id="4472" href="Cat.Abelian.Base.html#4472" class="Bound">g</a> <a id="4474" href="Cat.Abelian.Base.html#4474" class="Bound">h</a> <a id="4476" class="Symbol">=</a>
    <a id="4482" href="Cat.Abelian.Base.html#4470" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="4484" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="4486" href="Cat.Abelian.Base.html#4472" class="Bound">g</a> <a data-type="(r : is-abelian C) →
Hom-grp r A B₁ .object .fst →
Hom-grp r A B₁ .object .fst → Hom-grp r A B₁ .object .fst" id="4488" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="4490" href="Cat.Abelian.Base.html#4470" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="4492" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="4494" href="Cat.Abelian.Base.html#4474" class="Bound">h</a>               <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="4510" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="4513" href="1Lab.Path.html#20756" class="Function">ap</a> <a id="4516" class="Symbol">(</a><a id="4517" href="Cat.Abelian.Base.html#4470" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="4519" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="4521" href="Cat.Abelian.Base.html#4472" class="Bound">g</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="4523" href="Cat.Abelian.Base.html#1445" class="Function Operator">+_</a><a id="4525" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
inverse r ((has-ab (has-additive (has-is-preab r)) ∘ g) h) ≡
(has-ab (has-additive (has-is-preab r)) ∘ g) (inverse r h)" id="4527" href="Cat.Abelian.Base.html#3847" class="Function">neg-∘-r</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="4535" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="4541" href="Cat.Abelian.Base.html#4470" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="4543" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="4545" href="Cat.Abelian.Base.html#4472" class="Bound">g</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="4547" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="4549" class="Symbol">(</a><a id="4550" href="Cat.Abelian.Base.html#4470" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="4552" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(G : AbGroup ℓ) → G .object .fst → G .object .fst" id="4554" href="Algebra.Group.html#1320" class="Function">Hom.inverse</a> <a id="4566" href="Cat.Abelian.Base.html#4474" class="Bound">h</a><a id="4567" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="4569" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(r : is-abelian C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) g) ((C ∘ f) h)
≡
(C ∘ f)
(has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g
 h)" id="4572" href="Cat.Abelian.Base.html#1903" class="Field">∘-linear-r</a> <a id="4583" class="Symbol">_</a> <a id="4585" class="Symbol">_</a> <a id="4587" class="Symbol">_</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="4589" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="4595" href="Cat.Abelian.Base.html#4470" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="4597" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="4599" class="Symbol">(</a><a id="4600" href="Cat.Abelian.Base.html#4472" class="Bound">g</a> <a data-type="(r : is-abelian C) →
Hom-grp r A B₁ .object .fst →
Hom-grp r A B₁ .object .fst → Hom-grp r A B₁ .object .fst" id="4602" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="4604" href="Cat.Abelian.Base.html#4474" class="Bound">h</a><a id="4605" class="Symbol">)</a>                 <a data-type="(x : A) → x ≡ x" id="4623" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
</pre>
</details>
<p>Before moving on, we note the following property of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">\Ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathbf">Ab</span></span></span></span></span>-categories:</span> If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> is an object s.t. <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mi>A</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\id{id}_{A} = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">id</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>,</span> then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> is a zero object.</p>
<pre class="Agda"><a id="4792" class="Keyword">module</a> <a id="4799" href="Cat.Abelian.Base.html#4799" class="Module">_</a> <a id="4801" class="Symbol">{</a><a id="4802" href="Cat.Abelian.Base.html#4802" class="Bound">o</a> <a id="4804" href="Cat.Abelian.Base.html#4804" class="Bound">ℓ</a><a id="4805" class="Symbol">}</a> <a id="4807" class="Symbol">{</a><a id="4808" href="Cat.Abelian.Base.html#4808" class="Bound">C</a> <a id="4810" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="4812" href="Cat.Base.html#704" class="Record">Precategory</a> <a id="4824" href="Cat.Abelian.Base.html#4802" class="Bound">o</a> <a id="4826" href="Cat.Abelian.Base.html#4804" class="Bound">ℓ</a><a id="4827" class="Symbol">}</a> <a id="4829" class="Symbol">(</a><a id="4830" href="Cat.Abelian.Base.html#4830" class="Bound">A</a> <a id="4832" class="Symbol">:</a> <a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="4834" href="Cat.Abelian.Base.html#1302" class="Record">Ab-category</a> <a id="4846" href="Cat.Abelian.Base.html#4808" class="Bound">C</a><a id="4847" class="Symbol">)</a> <a id="4849" class="Keyword">where</a>
  <a id="4857" class="Keyword">private</a> <a id="4865" class="Keyword">module</a> <a id="4872" href="Cat.Abelian.Base.html#4872" class="Module">A</a> <a id="4874" class="Symbol">=</a> <a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="4876" href="Cat.Abelian.Base.html#1302" class="Module">Ab-category</a> <a id="4888" href="Cat.Abelian.Base.html#4830" class="Bound">A</a>

  <a data-type="(A : Ab-category C) → id A ≡ 0m A → is-zero A A₁" id="4893" href="Cat.Abelian.Base.html#4893" class="Function">id-zero→zero</a> <a id="4906" class="Symbol">:</a> <a id="4908" class="Symbol">∀</a> <a id="4910" class="Symbol">{</a><a id="4911" href="Cat.Abelian.Base.html#4911" class="Bound">A</a><a id="4912" class="Symbol">}</a> <a id="4914" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="4916" href="Cat.Base.html#2976" class="Function">A.id</a> <a id="4921" class="Symbol">{</a><a id="4922" href="Cat.Abelian.Base.html#4911" class="Bound">A</a><a id="4923" class="Symbol">}</a> <a data-type="A → A → Type ℓ" id="4925" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="4927" href="Cat.Abelian.Base.html#1533" class="Function">A.0m</a> <a id="4932" class="Symbol">→</a> <a data-type="(C : Precategory o h) (ob : Ob C) → Type (o ⊔ h)" id="4934" href="Cat.Diagram.Zero.html#408" class="Record">A.is-zero</a> <a id="4944" href="Cat.Abelian.Base.html#4911" class="Bound">A</a>
  <a data-type="(A : Ab-category C) → id A ≡ 0m A → is-zero A A₁" id="4948" href="Cat.Abelian.Base.html#4893" class="Function">id-zero→zero</a> <a id="4961" href="Cat.Abelian.Base.html#4961" class="Bound">idm</a> <a id="4965" class="Symbol">.</a><a data-type="(r : Zero C) → is-initial C (r .∅)" id="4966" href="Cat.Diagram.Zero.html#459" class="Field">A.is-zero.has-is-initial</a> <a id="4991" href="Cat.Abelian.Base.html#4991" class="Bound">B</a> <a id="4993" class="Symbol">=</a> <a data-type="(centre₁ : A) (paths₁ : (x : A) → centre₁ ≡ x) → is-contr A" id="4995" href="1Lab.HLevel.html#1383" class="InductiveConstructor">contr</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="5001" href="Cat.Abelian.Base.html#1533" class="Function">A.0m</a> <a id="5006" class="Symbol">λ</a> <a id="5008" href="Cat.Abelian.Base.html#5008" class="Bound">h</a> <a id="5010" class="Symbol">→</a> <a data-type="x ≡ y → y ≡ x" id="5012" href="1Lab.Path.html#10558" class="Function">sym</a> <a data-type="((x : A) → B₁ x) → (x : A) → B₁ x" id="5016" href="1Lab.Type.html#2481" class="Function Operator">$</a>
    <a id="5022" href="Cat.Abelian.Base.html#5008" class="Bound">h</a>                                <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="5055" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → f ≡ (C ∘ f) a" id="5058" href="Cat.Reasoning.html#1250" class="Function">A.intror</a> <a data-type="x ≡ x" id="5067" href="1Lab.Path.html#3593" class="Function">refl</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="5072" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="5078" href="Cat.Abelian.Base.html#5008" class="Bound">h</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="5080" href="Cat.Base.html#3006" class="Function Operator">A.∘</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="5084" href="Cat.Base.html#2976" class="Function">A.id</a>                       <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="5111" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) → g ≡ h → (C ∘ f) g ≡ (C ∘ f) h" id="5114" href="Cat.Reasoning.html#4627" class="Function Operator">A.refl⟩∘⟨</a> <a id="5124" href="Cat.Abelian.Base.html#4961" class="Bound">idm</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="5128" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="5134" href="Cat.Abelian.Base.html#5008" class="Bound">h</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="5136" href="Cat.Base.html#3006" class="Function Operator">A.∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="5140" href="Cat.Abelian.Base.html#1533" class="Function">A.0m</a>                       <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="5167" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ f) (0m r) ≡ 0m r" id="5170" href="Cat.Abelian.Base.html#2648" class="Function">A.∘-zero-r</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="5181" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="5187" href="Cat.Abelian.Base.html#1533" class="Function">A.0m</a>                             <a data-type="(x : A) → x ≡ x" id="5220" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
  <a data-type="(A : Ab-category C) → id A ≡ 0m A → is-zero A A₁" id="5224" href="Cat.Abelian.Base.html#4893" class="Function">id-zero→zero</a> <a id="5237" href="Cat.Abelian.Base.html#5237" class="Bound">idm</a> <a id="5241" class="Symbol">.</a><a data-type="(r : Zero C) → is-terminal C (r .∅)" id="5242" href="Cat.Diagram.Zero.html#495" class="Field">A.is-zero.has-is-terminal</a> <a id="5268" href="Cat.Abelian.Base.html#5268" class="Bound">x</a> <a id="5270" class="Symbol">=</a> <a data-type="(centre₁ : A) (paths₁ : (x : A) → centre₁ ≡ x) → is-contr A" id="5272" href="1Lab.HLevel.html#1383" class="InductiveConstructor">contr</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="5278" href="Cat.Abelian.Base.html#1533" class="Function">A.0m</a> <a id="5283" class="Symbol">λ</a> <a id="5285" href="Cat.Abelian.Base.html#5285" class="Bound">h</a> <a id="5287" class="Symbol">→</a> <a data-type="x ≡ y → y ≡ x" id="5289" href="1Lab.Path.html#10558" class="Function">sym</a> <a data-type="((x : A) → B₁ x) → (x : A) → B₁ x" id="5293" href="1Lab.Type.html#2481" class="Function Operator">$</a>
    <a id="5299" href="Cat.Abelian.Base.html#5285" class="Bound">h</a>                              <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="5330" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → f ≡ (C ∘ a) f" id="5333" href="Cat.Reasoning.html#1207" class="Function">A.introl</a> <a data-type="x ≡ x" id="5342" href="1Lab.Path.html#3593" class="Function">refl</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="5347" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a data-type="(r : Precategory o h) → r .Hom x x" id="5353" href="Cat.Base.html#2976" class="Function">A.id</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="5358" href="Cat.Base.html#3006" class="Function Operator">A.∘</a> <a id="5362" href="Cat.Abelian.Base.html#5285" class="Bound">h</a>                     <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="5384" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a id="5387" href="Cat.Abelian.Base.html#5237" class="Bound">idm</a> <a data-type="(C : Precategory o ℓ) → f ≡ h → (C ∘ f) g ≡ (C ∘ h) g" id="5391" href="Cat.Reasoning.html#4694" class="Function Operator">A.⟩∘⟨refl</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="5401" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="5407" href="Cat.Abelian.Base.html#1533" class="Function">A.0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="5412" href="Cat.Base.html#3006" class="Function Operator">A.∘</a> <a id="5416" href="Cat.Abelian.Base.html#5285" class="Bound">h</a>                     <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="5438" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ 0m r) f ≡ 0m r" id="5441" href="Cat.Abelian.Base.html#3063" class="Function">A.∘-zero-l</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="5452" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="5458" href="Cat.Abelian.Base.html#1533" class="Function">A.0m</a>                           <a data-type="(x : A) → x ≡ x" id="5489" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
</pre>
<p>Perhaps the simplest example of an <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">\Ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathbf">Ab</span></span></span></span></span>-category</span> is.. any ring! In the same way that a monoid is a category with one object, and a group is a groupoid with one object, a ring is a <em>ringoid</em> with one object; Ringoid being another word for <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">\Ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathbf">Ab</span></span></span></span></span>-category,</span> rather than a horizontal categorification of the drummer for the Beatles. The next simplest example is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">\Ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathbf">Ab</span></span></span></span></span> itself:</p>
<pre class="Agda"><a id="5877" class="Keyword">module</a> <a id="5884" href="Cat.Abelian.Base.html#5884" class="Module">_</a> <a id="5886" class="Keyword">where</a>
  <a id="5894" class="Keyword">open</a> <a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="5899" href="Cat.Abelian.Base.html#1302" class="Module">Ab-category</a>
  <a data-type="Ab-category (Ab ℓ)" id="5913" href="Cat.Abelian.Base.html#5913" class="Function">Ab-ab-category</a> <a id="5928" class="Symbol">:</a> <a id="5930" class="Symbol">∀</a> <a id="5932" class="Symbol">{</a><a id="5933" href="Cat.Abelian.Base.html#5933" class="Bound">ℓ</a><a id="5934" class="Symbol">}</a> <a id="5936" class="Symbol">→</a> <a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="5938" href="Cat.Abelian.Base.html#1302" class="Record">Ab-category</a> <a id="5950" class="Symbol">(</a><a data-type="(ℓ : Level) → Precategory (lsuc ℓ) ℓ" id="5951" href="Algebra.Group.Ab.html#1491" class="Function">Ab</a> <a id="5954" href="Cat.Abelian.Base.html#5933" class="Bound">ℓ</a><a id="5955" class="Symbol">)</a>
  <a data-type="Ab-category (Ab ℓ)" id="5959" href="Cat.Abelian.Base.html#5913" class="Function">Ab-ab-category</a> <a id="5974" class="Symbol">.</a><a data-type="(r : is-abelian C) (A B₁ : C .Ob) → Group-on (Hom C A B₁)" id="5975" href="Cat.Abelian.Base.html#1400" class="Field">Group-on-hom</a> <a id="5988" href="Cat.Abelian.Base.html#5988" class="Bound">A</a> <a id="5990" href="Cat.Abelian.Base.html#5990" class="Bound">B</a> <a id="5992" class="Symbol">=</a> <a data-type="(A B₁ : AbGroup ℓ) → AbGroup ℓ" id="5994" href="Algebra.Group.Ab.html#3543" class="Function">Hom-group</a> <a id="6004" href="Cat.Abelian.Base.html#5988" class="Bound">A</a> <a id="6006" href="Cat.Abelian.Base.html#5990" class="Bound">B</a> <a id="6008" class="Symbol">.</a><a data-type="Restrict-ob P → Ob C" id="6009" href="Cat.Functor.FullSubcategory.html#1063" class="Field">object</a> <a id="6016" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="6017" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a>
  <a data-type="Ab-category (Ab ℓ)" id="6023" href="Cat.Abelian.Base.html#5913" class="Function">Ab-ab-category</a> <a id="6038" class="Symbol">.</a><a data-type="(r : is-abelian C) (A B₁ : C .Ob) (f g : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ f g
≡
has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g f" id="6039" href="Cat.Abelian.Base.html#1608" class="Field">Hom-grp-ab</a> <a id="6050" href="Cat.Abelian.Base.html#6050" class="Bound">A</a> <a id="6052" href="Cat.Abelian.Base.html#6052" class="Bound">B</a> <a id="6054" class="Symbol">=</a> <a data-type="(A B₁ : AbGroup ℓ) → AbGroup ℓ" id="6056" href="Algebra.Group.Ab.html#3543" class="Function">Hom-group</a> <a id="6066" href="Cat.Abelian.Base.html#6050" class="Bound">A</a> <a id="6068" href="Cat.Abelian.Base.html#6052" class="Bound">B</a> <a id="6070" class="Symbol">.</a><a data-type="(r : Restrict-ob P) → P (r .object)" id="6071" href="Cat.Functor.FullSubcategory.html#1081" class="Field">witness</a>
  <a data-type="Ab-category (Ab ℓ)" id="6081" href="Cat.Abelian.Base.html#5913" class="Function">Ab-ab-category</a> <a id="6096" class="Symbol">.</a><a data-type="(r : is-abelian C) (f g : Hom C B₁ C) (h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) h) ((C ∘ g) h)
≡
(C ∘
 has-ab (has-additive (has-is-preab r)) .Group-on-hom B₁ C ._⋆_ f g)
h" id="6097" href="Cat.Abelian.Base.html#1800" class="Field">∘-linear-l</a> <a id="6108" href="Cat.Abelian.Base.html#6108" class="Bound">f</a> <a id="6110" href="Cat.Abelian.Base.html#6110" class="Bound">g</a> <a id="6112" href="Cat.Abelian.Base.html#6112" class="Bound">h</a> <a id="6114" class="Symbol">=</a> <a data-type="is-faithful Forget" id="6116" href="Algebra.Group.Cat.Base.html#1867" class="Function">Grp.Forget-is-faithful</a> <a data-type="x ≡ x" id="6139" href="1Lab.Path.html#3593" class="Function">refl</a>
  <a data-type="Ab-category (Ab ℓ)" id="6146" href="Cat.Abelian.Base.html#5913" class="Function">Ab-ab-category</a> <a id="6161" class="Symbol">.</a><a data-type="(r : is-abelian C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) g) ((C ∘ f) h)
≡
(C ∘ f)
(has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g
 h)" id="6162" href="Cat.Abelian.Base.html#1903" class="Field">∘-linear-r</a> <a id="6173" href="Cat.Abelian.Base.html#6173" class="Bound">f</a> <a id="6175" href="Cat.Abelian.Base.html#6175" class="Bound">g</a> <a id="6177" href="Cat.Abelian.Base.html#6177" class="Bound">h</a> <a id="6179" class="Symbol">=</a> <a data-type="is-faithful Forget" id="6181" href="Algebra.Group.Cat.Base.html#1867" class="Function">Grp.Forget-is-faithful</a> <a data-type="((x : A) → B₁ x) → (x : A) → B₁ x" id="6204" href="1Lab.Type.html#2481" class="Function Operator">$</a> <a data-type="((x : A) → f x ≡ g x) → f ≡ g" id="6206" href="1Lab.Path.html#58486" class="Function">funext</a> <a id="6213" class="Symbol">λ</a> <a id="6215" href="Cat.Abelian.Base.html#6215" class="Bound">x</a> <a id="6217" class="Symbol">→</a>
    <a data-type="x ≡ y → y ≡ x" id="6223" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="6227" class="Symbol">(</a><a id="6228" href="Cat.Abelian.Base.html#6173" class="Bound">f</a> <a id="6230" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="6231" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="6235" class="Symbol">.</a><a data-type="Group-hom A B₁ e →
(x y : A .fst) → e (A .snd ._⋆_ x y) ≡ B₁ .snd ._⋆_ (e x) (e y)" id="6236" href="Algebra.Group.html#6284" class="Field">Group-hom.pres-⋆</a> <a id="6253" class="Symbol">_</a> <a id="6255" class="Symbol">_)</a>
</pre>
<h1 id="additive-categories"><a href="#additive-categories" class="header-link">Additive categories<span class="header-link-emoji">🔗</span></a></h1>
<p>An <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">\Ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathbf">Ab</span></span></span></span></span>-category</span> is <strong>additive</strong> when its underlying category has a terminal object and finite products; By the yoga above, this implies that the terminal object is also a zero object, and the finite products coincide with finite coproducts.</p>
<pre class="Agda"><a id="6538" class="Keyword">record</a> <a id="is-additive"></a><a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="6545" href="Cat.Abelian.Base.html#6545" class="Record">is-additive</a> <a id="6557" class="Symbol">{</a><a id="6558" href="Cat.Abelian.Base.html#6558" class="Bound">o</a> <a id="6560" href="Cat.Abelian.Base.html#6560" class="Bound">ℓ</a><a id="6561" class="Symbol">}</a> <a id="6563" class="Symbol">(</a><a id="6564" href="Cat.Abelian.Base.html#6564" class="Bound">C</a> <a id="6566" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="6568" href="Cat.Base.html#704" class="Record">Precategory</a> <a id="6580" href="Cat.Abelian.Base.html#6558" class="Bound">o</a> <a id="6582" href="Cat.Abelian.Base.html#6560" class="Bound">ℓ</a><a id="6583" class="Symbol">)</a> <a id="6585" class="Symbol">:</a> <a id="6587" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="6592" class="Symbol">(</a><a id="6593" href="Cat.Abelian.Base.html#6558" class="Bound">o</a> <a data-type="Level → Level → Level" id="6595" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a data-type="Level → Level" id="6597" href="Agda.Primitive.html#780" class="Primitive">lsuc</a> <a id="6602" href="Cat.Abelian.Base.html#6560" class="Bound">ℓ</a><a id="6603" class="Symbol">)</a> <a id="6605" class="Keyword">where</a>
  <a id="6613" class="Keyword">field</a> <a id="is-additive.has-ab"></a><a data-type="(r : is-abelian C) → Ab-category C" id="6619" href="Cat.Abelian.Base.html#6619" class="Field">has-ab</a> <a id="6626" class="Symbol">:</a> <a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="6628" href="Cat.Abelian.Base.html#1302" class="Record">Ab-category</a> <a id="6640" href="Cat.Abelian.Base.html#6564" class="Bound">C</a>
  <a id="6644" class="Keyword">open</a> <a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="6649" href="Cat.Abelian.Base.html#1302" class="Module">Ab-category</a> <a data-type="(r : is-abelian C) → Ab-category C" id="6661" href="Cat.Abelian.Base.html#6619" class="Field">has-ab</a> <a id="6668" class="Keyword">public</a>

  <a id="6678" class="Keyword">field</a>
    <a id="is-additive.has-terminal"></a><a data-type="(r : is-abelian C) → Terminal r" id="6688" href="Cat.Abelian.Base.html#6688" class="Field">has-terminal</a> <a id="6701" class="Symbol">:</a> <a data-type="(C : Precategory o h) → Type (o ⊔ h)" id="6703" href="Cat.Diagram.Terminal.html#406" class="Record">Terminal</a>
    <a id="is-additive.has-prods"></a><a data-type="(r : is-abelian C) (A B₁ : Ob C) → Product r A B₁" id="6716" href="Cat.Abelian.Base.html#6716" class="Field">has-prods</a>    <a id="6729" class="Symbol">:</a> <a id="6731" class="Symbol">∀</a> <a id="6733" href="Cat.Abelian.Base.html#6733" class="Bound">A</a> <a id="6735" href="Cat.Abelian.Base.html#6735" class="Bound">B</a> <a id="6737" class="Symbol">→</a> <a data-type="(C : Precategory o h) (A B₁ : Ob C) → Type (o ⊔ h)" id="6739" href="Cat.Diagram.Product.html#2703" class="Record">Product</a> <a id="6747" href="Cat.Abelian.Base.html#6733" class="Bound">A</a> <a id="6749" href="Cat.Abelian.Base.html#6735" class="Bound">B</a>

  <a id="is-additive.∅"></a><a data-type="(r : is-abelian C) → Zero r" id="6754" href="Cat.Abelian.Base.html#6754" class="Function">∅</a> <a id="6756" class="Symbol">:</a> <a data-type="(C : Precategory o h) → Type (o ⊔ h)" id="6758" href="Cat.Diagram.Zero.html#536" class="Record">Zero</a>
  <a data-type="(r : is-abelian C) → Zero r" id="6765" href="Cat.Abelian.Base.html#6754" class="Function">∅</a> <a id="6767" class="Symbol">.</a><a data-type="Zero C → Ob C" id="6768" href="Cat.Diagram.Zero.html#574" class="Field">Zero.∅</a> <a id="6775" class="Symbol">=</a> <a data-type="(r : is-abelian C) → Terminal r" id="6777" href="Cat.Abelian.Base.html#6688" class="Field">has-terminal</a> <a id="6790" class="Symbol">.</a><a data-type="Terminal C → Ob C" id="6791" href="Cat.Diagram.Terminal.html#448" class="Field">Terminal.top</a>
  <a data-type="(r : is-abelian C) → Zero r" id="6806" href="Cat.Abelian.Base.html#6754" class="Function">∅</a> <a id="6808" class="Symbol">.</a><a data-type="(r : Zero C) → is-zero C (r .∅)" id="6809" href="Cat.Diagram.Zero.html#591" class="Field">Zero.has-is-zero</a> <a id="6826" class="Symbol">=</a> <a data-type="(A : Ab-category C) → id A ≡ 0m A → is-zero A A₁" id="6828" href="Cat.Abelian.Base.html#4893" class="Function">id-zero→zero</a> <a data-type="(r : is-abelian C) → Ab-category C" id="6841" href="Cat.Abelian.Base.html#6619" class="Field">has-ab</a> <a data-type="((x : A) → B₁ x) → (x : A) → B₁ x" id="6848" href="1Lab.Type.html#2481" class="Function Operator">$</a>
    <a data-type="is-contr A → is-prop A" id="6854" href="1Lab.HLevel.html#3818" class="Function">is-contr→is-prop</a> <a id="6871" class="Symbol">(</a><a data-type="(r : is-abelian C) → Terminal r" id="6872" href="Cat.Abelian.Base.html#6688" class="Field">has-terminal</a> <a id="6885" class="Symbol">.</a><a data-type="(r : Terminal C) → is-terminal C (r .top)" id="6886" href="Cat.Diagram.Terminal.html#461" class="Field">Terminal.has⊤</a> <a id="6900" class="Symbol">_)</a> <a id="6903" class="Symbol">_</a> <a id="6905" class="Symbol">_</a>
  <a id="6909" class="Keyword">module</a> <a id="is-additive.∅"></a><a id="6916" href="Cat.Abelian.Base.html#6916" class="Module">∅</a> <a id="6918" class="Symbol">=</a> <a data-type="(C : Precategory o h) → Type (o ⊔ h)" id="6920" href="Cat.Diagram.Zero.html#536" class="Module">Zero</a> <a data-type="(r : is-abelian C) → Zero r" id="6925" href="Cat.Abelian.Base.html#6754" class="Function">∅</a>

  <a id="is-additive.0m-unique"></a><a data-type="(r : is-abelian C) → zero→ r ≡ 0m r" id="6930" href="Cat.Abelian.Base.html#6930" class="Function">0m-unique</a> <a id="6940" class="Symbol">:</a> <a id="6942" class="Symbol">∀</a> <a id="6944" class="Symbol">{</a><a id="6945" href="Cat.Abelian.Base.html#6945" class="Bound">A</a> <a id="6947" href="Cat.Abelian.Base.html#6947" class="Bound">B</a><a id="6948" class="Symbol">}</a> <a id="6950" class="Symbol">→</a> <a data-type="Zero C → Hom C x y" id="6952" href="Cat.Diagram.Zero.html#1010" class="Function">∅.zero→</a> <a id="6960" class="Symbol">{</a><a id="6961" href="Cat.Abelian.Base.html#6945" class="Bound">A</a><a id="6962" class="Symbol">}</a> <a id="6964" class="Symbol">{</a><a id="6965" href="Cat.Abelian.Base.html#6947" class="Bound">B</a><a id="6966" class="Symbol">}</a> <a data-type="A → A → Type ℓ" id="6968" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="6970" href="Cat.Abelian.Base.html#1533" class="Function">0m</a>
  <a data-type="(r : is-abelian C) → zero→ r ≡ 0m r" id="6975" href="Cat.Abelian.Base.html#6930" class="Function">0m-unique</a> <a id="6985" class="Symbol">=</a> <a data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" id="6987" href="1Lab.Path.html#21189" class="Function">ap₂</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="6991" href="Cat.Base.html#3006" class="Function Operator">_∘_</a> <a id="6995" class="Symbol">(</a><a data-type="(r : Initial C) → is-initial C (r .bot)" id="6996" href="Cat.Diagram.Initial.html#456" class="Function">∅.has⊥</a> <a id="7003" class="Symbol">_</a> <a id="7005" class="Symbol">.</a><a data-type="(r : is-contr A) (x : A) → r .centre ≡ x" id="7006" href="1Lab.HLevel.html#1416" class="Field">paths</a> <a id="7012" class="Symbol">_)</a> <a data-type="x ≡ x" id="7015" href="1Lab.Path.html#3593" class="Function">refl</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="7020" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ 0m r) f ≡ 0m r" id="7022" href="Cat.Abelian.Base.html#3063" class="Function">∘-zero-l</a>
</pre>
<p>Coincidence of finite products and finite coproducts leads to an object commonly called a (finite) <strong>biproduct</strong>. The coproduct coprojections are given by the pair of maps</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo>×</mo><mn>0</mn><mo stretchy="false">)</mo><mo>:</mo><mi>A</mi><mo>→</mo><mi>A</mi><mo>×</mo><mi>B</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo stretchy="false">(</mo><mn>0</mn><mo>×</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo stretchy="false">)</mo><mo>:</mo><mi>B</mi><mo>→</mo><mi>A</mi><mo>×</mo><mi>B</mi><mtext>,</mtext></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{align*}
&amp;(\id{id} \times 0) : A \to A \times B \\
&amp;(0 \times \id{id}) : B \to A \times B\text{,}
\end{align*}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.75em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">id</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathrm">id</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord text"><span class="mord">,</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>respectively, and the comultiplication of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> is given by <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><msub><mi>π</mi><mn>1</mn></msub><mo>+</mo><mi>g</mi><msub><mi>π</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">f\pi_1 + g\pi_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span> We can calculate, for the first coprojection followed by comultiplication,</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo stretchy="false">(</mo><mi>f</mi><msub><mi>π</mi><mn>1</mn></msub><mo>+</mo><mi>g</mi><msub><mi>π</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo>×</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>f</mi><msub><mi>π</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo>×</mo><mn>0</mn><mo stretchy="false">)</mo><mo>+</mo><mi>g</mi><msub><mi>π</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo>×</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>f</mi><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo>+</mo><mi>g</mi><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>f</mi><mo>×</mo><mo separator="true" lspace="0em" rspace="0em">,</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{align*}
&amp; (f\pi_1+g\pi_2)(\id{id}\times 0) \\
=&amp; f\pi_1(\id{id}\times 0) + g\pi_2(\id{id}\times 0) \\
=&amp; f\id{id} + g0 \\
=&amp; f\times{,}
\end{align*}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6em;vertical-align:-2.75em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">=</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">=</span></span></span><span style="top:-0.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">=</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">id</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">id</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">id</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathrm">id</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">0</span></span></span><span style="top:-0.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mpunct">,</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>and analogously for the second coprojection followed by comultiplication.</p>
<pre class="Agda">  <a id="is-additive.has-coprods"></a><a data-type="(r : is-abelian C) (A B₁ : Ob C) → Coproduct r A B₁" id="7742" href="Cat.Abelian.Base.html#7742" class="Function">has-coprods</a> <a id="7754" class="Symbol">:</a> <a id="7756" class="Symbol">∀</a> <a id="7758" href="Cat.Abelian.Base.html#7758" class="Bound">A</a> <a id="7760" href="Cat.Abelian.Base.html#7760" class="Bound">B</a> <a id="7762" class="Symbol">→</a> <a data-type="(C : Precategory o h) (A B₁ : Ob C) → Type (o ⊔ h)" id="7764" href="Cat.Diagram.Coproduct.html#1758" class="Record">Coproduct</a> <a id="7774" href="Cat.Abelian.Base.html#7758" class="Bound">A</a> <a id="7776" href="Cat.Abelian.Base.html#7760" class="Bound">B</a>
  <a data-type="(r : is-abelian C) (A B₁ : Ob C) → Coproduct r A B₁" id="7780" href="Cat.Abelian.Base.html#7742" class="Function">has-coprods</a> <a id="7792" href="Cat.Abelian.Base.html#7792" class="Bound">A</a> <a id="7794" href="Cat.Abelian.Base.html#7794" class="Bound">B</a> <a id="7796" class="Symbol">=</a> <a id="7798" href="Cat.Abelian.Base.html#7898" class="Function">coprod</a> <a id="7805" class="Keyword">where</a>
    <a id="7815" class="Keyword">open</a> <a data-type="(C : Precategory o h) (A B₁ : Ob C) → Type (o ⊔ h)" id="7820" href="Cat.Diagram.Coproduct.html#1758" class="Module">Coproduct</a>
    <a id="7834" class="Keyword">open</a> <a data-type="(C : Precategory o h) (in₀ : Hom C A P) (in₁ : Hom C B₁ P) →
Type (o ⊔ h)" id="7839" href="Cat.Diagram.Coproduct.html#924" class="Module">is-coproduct</a>
    <a id="7856" class="Keyword">module</a> <a id="7863" href="Cat.Abelian.Base.html#7863" class="Module">Prod</a> <a id="7868" class="Symbol">=</a> <a data-type="(C : Precategory o h) (A B₁ : Ob C) → Type (o ⊔ h)" id="7870" href="Cat.Diagram.Product.html#2703" class="Module">Product</a> <a id="7878" class="Symbol">(</a><a data-type="(r : is-abelian C) (A B₁ : Ob C) → Product r A B₁" id="7879" href="Cat.Abelian.Base.html#6716" class="Field">has-prods</a> <a id="7889" href="Cat.Abelian.Base.html#7792" class="Bound">A</a> <a id="7891" href="Cat.Abelian.Base.html#7794" class="Bound">B</a><a id="7892" class="Symbol">)</a>
    <a id="7898" href="Cat.Abelian.Base.html#7898" class="Function">coprod</a> <a id="7905" class="Symbol">:</a> <a data-type="(C : Precategory o h) (A B₁ : Ob C) → Type (o ⊔ h)" id="7907" href="Cat.Diagram.Coproduct.html#1758" class="Record">Coproduct</a> <a id="7917" href="Cat.Abelian.Base.html#7792" class="Bound">A</a> <a id="7919" href="Cat.Abelian.Base.html#7794" class="Bound">B</a>
    <a id="7925" href="Cat.Abelian.Base.html#7898" class="Function">coprod</a> <a id="7932" class="Symbol">.</a><a data-type="Coproduct C A B₁ → Ob C" id="7933" href="Cat.Diagram.Coproduct.html#1812" class="Field">coapex</a> <a id="7940" class="Symbol">=</a> <a data-type="Product C A B₁ → Ob C" id="7942" href="Cat.Diagram.Product.html#2773" class="Function">Prod.apex</a>
    <a id="7956" href="Cat.Abelian.Base.html#7898" class="Function">coprod</a> <a id="7963" class="Symbol">.</a><a data-type="(r : Coproduct C A B₁) → Hom C A (r .coapex)" id="7964" href="Cat.Diagram.Coproduct.html#1828" class="Field">in₀</a> <a id="7968" class="Symbol">=</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7970" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="7977" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7980" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="7982" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7985" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span>
    <a id="7991" href="Cat.Abelian.Base.html#7898" class="Function">coprod</a> <a id="7998" class="Symbol">.</a><a data-type="(r : Coproduct C A B₁) → Hom C B₁ (r .coapex)" id="7999" href="Cat.Diagram.Coproduct.html#1851" class="Field">in₁</a> <a id="8003" class="Symbol">=</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8005" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8012" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8015" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="8017" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8020" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span>
    <a id="8026" href="Cat.Abelian.Base.html#7898" class="Function">coprod</a> <a id="8033" class="Symbol">.</a><a data-type="(r : Coproduct C A B₁) → is-coproduct C (r .in₀) (r .in₁)" id="8034" href="Cat.Diagram.Coproduct.html#1874" class="Field">has-is-coproduct</a> <a id="8051" class="Symbol">.</a><a data-type="(r : Coproduct C A B₁) →
Hom C A Q → Hom C B₁ Q → Hom C (r .coapex) Q" id="8052" href="Cat.Diagram.Coproduct.html#1010" class="Field Operator">[_,_]</a> <a id="8058" href="Cat.Abelian.Base.html#8058" class="Bound">f</a> <a id="8060" href="Cat.Abelian.Base.html#8060" class="Bound">g</a> <a id="8062" class="Symbol">=</a> <a id="8064" href="Cat.Abelian.Base.html#8058" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8066" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) A" id="8068" href="Cat.Diagram.Product.html#2787" class="Function">Prod.π₁</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8076" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="8078" href="Cat.Abelian.Base.html#8060" class="Bound">g</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8080" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" id="8082" href="Cat.Diagram.Product.html#2807" class="Function">Prod.π₂</a>
    <a id="8094" href="Cat.Abelian.Base.html#7898" class="Function">coprod</a> <a id="8101" class="Symbol">.</a><a data-type="(r : Coproduct C A B₁) → is-coproduct C (r .in₀) (r .in₁)" id="8102" href="Cat.Diagram.Coproduct.html#1874" class="Field">has-is-coproduct</a> <a id="8119" class="Symbol">.</a><a data-type="(r : Coproduct C A B₁) →
(C ∘ has-is-coproduct r .[_,_] inj0 inj1) (r .in₀) ≡ inj0" id="8120" href="Cat.Diagram.Coproduct.html#1077" class="Field">in₀∘factor</a> <a id="8131" class="Symbol">{</a><a id="8132" class="Argument">inj0</a> <a id="8137" class="Symbol">=</a> <a id="8139" href="Cat.Abelian.Base.html#8139" class="Bound">inj0</a><a id="8143" class="Symbol">}</a> <a id="8145" class="Symbol">{</a><a id="8146" href="Cat.Abelian.Base.html#8146" class="Bound">inj1</a><a id="8150" class="Symbol">}</a> <a id="8152" class="Symbol">=</a>
      <a id="8160" class="Symbol">(</a><a id="8161" href="Cat.Abelian.Base.html#8139" class="Bound">inj0</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8166" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) A" id="8168" href="Cat.Diagram.Product.html#2787" class="Function">Prod.π₁</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8176" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="8178" href="Cat.Abelian.Base.html#8146" class="Bound">inj1</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8183" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" id="8185" href="Cat.Diagram.Product.html#2807" class="Function">Prod.π₂</a><a id="8192" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8194" href="Cat.Base.html#3006" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8196" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="8203" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8206" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8208" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8211" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="8213" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="x ≡ y → y ≡ x" id="8216" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="8220" class="Symbol">(</a><a data-type="(r : is-abelian C) (f g : Hom C B₁ C) (h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) h) ((C ∘ g) h)
≡
(C ∘
 has-ab (has-additive (has-is-preab r)) .Group-on-hom B₁ C ._⋆_ f g)
h" id="8221" href="Cat.Abelian.Base.html#1800" class="Function">∘-linear-l</a> <a id="8232" class="Symbol">_</a> <a id="8234" class="Symbol">_</a> <a id="8236" class="Symbol">_)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="8239" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="8247" class="Symbol">((</a><a id="8249" href="Cat.Abelian.Base.html#8139" class="Bound">inj0</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8254" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) A" id="8256" href="Cat.Diagram.Product.html#2787" class="Function">Prod.π₁</a><a id="8263" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8265" href="Cat.Base.html#3006" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8267" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="8274" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8277" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8279" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8282" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8284" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="8286" class="Symbol">_)</a>            <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="8300" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" id="8303" href="Cat.Reasoning.html#1108" class="Function">Hom.elimr</a> <a id="8313" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" id="8314" href="Cat.Reasoning.html#1678" class="Function">pullr</a> <a data-type="(r : Product C A B₁) →
(C ∘ r .π₂) (has-is-product r .⟨_,_⟩ p1 p2) ≡ p2" id="8320" href="Cat.Diagram.Product.html#1984" class="Function">Prod.π₂∘factor</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="8335" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ f) (0m r) ≡ 0m r" id="8337" href="Cat.Abelian.Base.html#2648" class="Function">∘-zero-r</a><a id="8345" class="Symbol">)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="8347" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="8355" class="Symbol">(</a><a id="8356" href="Cat.Abelian.Base.html#8139" class="Bound">inj0</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8361" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) A" id="8363" href="Cat.Diagram.Product.html#2787" class="Function">Prod.π₁</a><a id="8370" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8372" href="Cat.Base.html#3006" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8374" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="8381" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8384" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8386" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8389" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span>                  <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="8408" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ (C ∘ f) h) i ≡ f" id="8411" href="Cat.Reasoning.html#2731" class="Function">cancelr</a> <a data-type="(r : Product C A B₁) →
(C ∘ r .π₁) (has-is-product r .⟨_,_⟩ p1 p2) ≡ p1" id="8419" href="Cat.Diagram.Product.html#1918" class="Function">Prod.π₁∘factor</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="8434" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="8442" href="Cat.Abelian.Base.html#8139" class="Bound">inj0</a>                                                <a data-type="(x : A) → x ≡ x" id="8494" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
    <a id="8500" href="Cat.Abelian.Base.html#7898" class="Function">coprod</a> <a id="8507" class="Symbol">.</a><a data-type="(r : Coproduct C A B₁) → is-coproduct C (r .in₀) (r .in₁)" id="8508" href="Cat.Diagram.Coproduct.html#1874" class="Field">has-is-coproduct</a> <a id="8525" class="Symbol">.</a><a data-type="(r : Coproduct C A B₁) →
(C ∘ has-is-coproduct r .[_,_] inj0 inj1) (r .in₁) ≡ inj1" id="8526" href="Cat.Diagram.Coproduct.html#1155" class="Field">in₁∘factor</a> <a id="8537" class="Symbol">{</a><a id="8538" class="Argument">inj0</a> <a id="8543" class="Symbol">=</a> <a id="8545" href="Cat.Abelian.Base.html#8545" class="Bound">inj0</a><a id="8549" class="Symbol">}</a> <a id="8551" class="Symbol">{</a><a id="8552" href="Cat.Abelian.Base.html#8552" class="Bound">inj1</a><a id="8556" class="Symbol">}</a> <a id="8558" class="Symbol">=</a>
      <a id="8566" class="Symbol">(</a><a id="8567" href="Cat.Abelian.Base.html#8545" class="Bound">inj0</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8572" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) A" id="8574" href="Cat.Diagram.Product.html#2787" class="Function">Prod.π₁</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8582" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="8584" href="Cat.Abelian.Base.html#8552" class="Bound">inj1</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8589" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" id="8591" href="Cat.Diagram.Product.html#2807" class="Function">Prod.π₂</a><a id="8598" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8600" href="Cat.Base.html#3006" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8602" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8609" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8612" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="8614" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8617" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="8619" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="x ≡ y → y ≡ x" id="8622" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="8626" class="Symbol">(</a><a data-type="(r : is-abelian C) (f g : Hom C B₁ C) (h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) h) ((C ∘ g) h)
≡
(C ∘
 has-ab (has-additive (has-is-preab r)) .Group-on-hom B₁ C ._⋆_ f g)
h" id="8627" href="Cat.Abelian.Base.html#1800" class="Function">∘-linear-l</a> <a id="8638" class="Symbol">_</a> <a id="8640" class="Symbol">_</a> <a id="8642" class="Symbol">_)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="8645" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="8653" class="Symbol">(_</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8656" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="8658" class="Symbol">(</a><a id="8659" href="Cat.Abelian.Base.html#8552" class="Bound">inj1</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8664" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" id="8666" href="Cat.Diagram.Product.html#2807" class="Function">Prod.π₂</a><a id="8673" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8675" href="Cat.Base.html#3006" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8677" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8684" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8687" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="8689" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8692" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span><a id="8693" class="Symbol">)</a>            <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="8706" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ a) f ≡ f" id="8709" href="Cat.Reasoning.html#1009" class="Function">Hom.eliml</a> <a id="8719" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" id="8720" href="Cat.Reasoning.html#1678" class="Function">pullr</a> <a data-type="(r : Product C A B₁) →
(C ∘ r .π₁) (has-is-product r .⟨_,_⟩ p1 p2) ≡ p1" id="8726" href="Cat.Diagram.Product.html#1918" class="Function">Prod.π₁∘factor</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="8741" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ f) (0m r) ≡ 0m r" id="8743" href="Cat.Abelian.Base.html#2648" class="Function">∘-zero-r</a><a id="8751" class="Symbol">)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="8753" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="8761" class="Symbol">(</a><a id="8762" href="Cat.Abelian.Base.html#8552" class="Bound">inj1</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8767" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" id="8769" href="Cat.Diagram.Product.html#2807" class="Function">Prod.π₂</a><a id="8776" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8778" href="Cat.Base.html#3006" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8780" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8787" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8790" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="8792" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8795" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span>                  <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="8814" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ (C ∘ f) h) i ≡ f" id="8817" href="Cat.Reasoning.html#2731" class="Function">cancelr</a> <a data-type="(r : Product C A B₁) →
(C ∘ r .π₂) (has-is-product r .⟨_,_⟩ p1 p2) ≡ p2" id="8825" href="Cat.Diagram.Product.html#1984" class="Function">Prod.π₂∘factor</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="8840" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="8848" href="Cat.Abelian.Base.html#8552" class="Bound">inj1</a>                                                 <a data-type="(x : A) → x ≡ x" id="8901" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
</pre>
<p>For uniqueness, we use distributivity of composition over addition of morphisms and the universal property of the product to establish the desired equation. Check it out:</p>
<pre class="Agda">    <a id="9092" href="Cat.Abelian.Base.html#7898" class="Function">coprod</a> <a id="9099" class="Symbol">.</a><a data-type="(r : Coproduct C A B₁) → is-coproduct C (r .in₀) (r .in₁)" id="9100" href="Cat.Diagram.Coproduct.html#1874" class="Field">has-is-coproduct</a> <a id="9117" class="Symbol">.</a><a data-type="(r : Coproduct C A B₁) (other : Hom C (r .coapex) Q) →
(C ∘ other) (r .in₀) ≡ inj0 →
(C ∘ other) (r .in₁) ≡ inj1 →
other ≡ has-is-coproduct r .[_,_] inj0 inj1" id="9118" href="Cat.Diagram.Coproduct.html#1234" class="Field">unique</a> <a id="9125" class="Symbol">{</a><a id="9126" class="Argument">inj0</a> <a id="9131" class="Symbol">=</a> <a id="9133" href="Cat.Abelian.Base.html#9133" class="Bound">inj0</a><a id="9137" class="Symbol">}</a> <a id="9139" class="Symbol">{</a><a id="9140" href="Cat.Abelian.Base.html#9140" class="Bound">inj1</a><a id="9144" class="Symbol">}</a> <a id="9146" href="Cat.Abelian.Base.html#9146" class="Bound">other</a> <a id="9152" href="Cat.Abelian.Base.html#9152" class="Bound">p</a> <a id="9154" href="Cat.Abelian.Base.html#9154" class="Bound">q</a> <a id="9156" class="Symbol">=</a> <a data-type="x ≡ y → y ≡ x" id="9158" href="1Lab.Path.html#10558" class="Function">sym</a> <a data-type="((x : A) → B₁ x) → (x : A) → B₁ x" id="9162" href="1Lab.Type.html#2481" class="Function Operator">$</a>
      <a id="9170" href="Cat.Abelian.Base.html#9133" class="Bound">inj0</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="9175" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) A" id="9177" href="Cat.Diagram.Product.html#2787" class="Function">Prod.π₁</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="9185" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="9187" href="Cat.Abelian.Base.html#9140" class="Bound">inj1</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="9192" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" id="9194" href="Cat.Diagram.Product.html#2807" class="Function">Prod.π₂</a>                                             <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="9246" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" id="9249" href="1Lab.Path.html#21189" class="Function">ap₂</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="9253" href="Cat.Abelian.Base.html#1445" class="Function Operator">_+_</a> <a id="9257" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (c≡ab : c ≡ (C ∘ a) b) →
(C ∘ c) f ≡ (C ∘ a) ((C ∘ b) f)" id="9258" href="Cat.Reasoning.html#1844" class="Function">pushl</a> <a id="9264" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="9265" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="9269" href="Cat.Abelian.Base.html#9152" class="Bound">p</a><a id="9270" class="Symbol">))</a> <a id="9273" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (c≡ab : c ≡ (C ∘ a) b) →
(C ∘ c) f ≡ (C ∘ a) ((C ∘ b) f)" id="9274" href="Cat.Reasoning.html#1844" class="Function">pushl</a> <a id="9280" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="9281" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="9285" href="Cat.Abelian.Base.html#9154" class="Bound">q</a><a id="9286" class="Symbol">))</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="9289" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="9297" class="Symbol">(</a><a id="9298" href="Cat.Abelian.Base.html#9146" class="Bound">other</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="9304" href="Cat.Base.html#3006" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="9306" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="9313" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="9316" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="9318" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="9321" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="9323" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) A" id="9325" href="Cat.Diagram.Product.html#2787" class="Function">Prod.π₁</a><a id="9332" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="9334" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="9336" class="Symbol">(</a><a id="9337" href="Cat.Abelian.Base.html#9146" class="Bound">other</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="9343" href="Cat.Base.html#3006" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="9345" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="9352" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="9355" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="9357" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="9360" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="9362" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" id="9364" href="Cat.Diagram.Product.html#2807" class="Function">Prod.π₂</a><a id="9371" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="9373" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(r : is-abelian C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) g) ((C ∘ f) h)
≡
(C ∘ f)
(has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g
 h)" id="9376" href="Cat.Abelian.Base.html#1903" class="Function">∘-linear-r</a> <a id="9387" class="Symbol">_</a> <a id="9389" class="Symbol">_</a> <a id="9391" class="Symbol">_</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="9393" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="9401" href="Cat.Abelian.Base.html#9146" class="Bound">other</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="9407" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="9409" class="Symbol">(</a><span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="9410" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="9417" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="9420" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="9422" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="9425" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="9427" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) A" id="9429" href="Cat.Diagram.Product.html#2787" class="Function">Prod.π₁</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="9437" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="9439" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="9446" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="9449" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="9451" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="9454" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="9456" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" id="9458" href="Cat.Diagram.Product.html#2807" class="Function">Prod.π₂</a><a id="9465" class="Symbol">)</a>           <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="9477" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" id="9480" href="Cat.Reasoning.html#1108" class="Function">elimr</a> <a id="9486" href="Cat.Abelian.Base.html#9598" class="Function">lemma</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="9492" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="9500" href="Cat.Abelian.Base.html#9146" class="Bound">other</a>                                                                       <a data-type="(x : A) → x ≡ x" id="9576" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
      <a id="9584" class="Keyword">where</a>
        <a id="9598" href="Cat.Abelian.Base.html#9598" class="Function">lemma</a> <a id="9604" class="Symbol">:</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="9606" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="9613" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="9616" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="9618" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="9621" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="9623" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) A" id="9625" href="Cat.Diagram.Product.html#2787" class="Function">Prod.π₁</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="9633" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="9635" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="9642" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="9645" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="9647" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="9650" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="9652" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" id="9654" href="Cat.Diagram.Product.html#2807" class="Function">Prod.π₂</a>
              <a data-type="A → A → Type ℓ" id="9676" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="9678" href="Cat.Base.html#2976" class="Function">id</a>
        <a id="9689" href="Cat.Abelian.Base.html#9598" class="Function">lemma</a> <a id="9695" class="Symbol">=</a> <a data-type="(r : Product C A B₁) →
(C ∘ r .π₁) o1 ≡ pr1 →
(C ∘ r .π₂) o1 ≡ pr2 →
(C ∘ r .π₁) o2 ≡ pr1 → (C ∘ r .π₂) o2 ≡ pr2 → o1 ≡ o2" id="9697" href="Cat.Diagram.Product.html#2211" class="Function">Prod.unique₂</a> <a id="9710" class="Symbol">{</a><a id="9711" class="Argument">pr1</a> <a id="9715" class="Symbol">=</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) A" id="9717" href="Cat.Diagram.Product.html#2787" class="Function">Prod.π₁</a><a id="9724" class="Symbol">}</a> <a id="9726" class="Symbol">{</a><a id="9727" class="Argument">pr2</a> <a id="9731" class="Symbol">=</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" id="9733" href="Cat.Diagram.Product.html#2807" class="Function">Prod.π₂</a><a id="9740" class="Symbol">}</a>
          <a id="9752" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="9753" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="9757" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) g) ((C ∘ f) h)
≡
(C ∘ f)
(has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g
 h)" id="9758" href="Cat.Abelian.Base.html#1903" class="Function">∘-linear-r</a> <a id="9769" class="Symbol">_</a> <a id="9771" class="Symbol">_</a> <a id="9773" class="Symbol">_)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="9776" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" id="9778" href="1Lab.Path.html#21189" class="Function">ap₂</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="9782" href="Cat.Abelian.Base.html#1445" class="Function Operator">_+_</a> <a id="9786" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ h) ((C ∘ i) f) ≡ f" id="9787" href="Cat.Reasoning.html#2621" class="Function">cancell</a> <a data-type="(r : Product C A B₁) →
(C ∘ r .π₁) (has-is-product r .⟨_,_⟩ p1 p2) ≡ p1" id="9795" href="Cat.Diagram.Product.html#1918" class="Function">Prod.π₁∘factor</a><a id="9809" class="Symbol">)</a> <a id="9811" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ a) ((C ∘ b) f) ≡ (C ∘ c) f" id="9812" href="Cat.Reasoning.html#1548" class="Function">pulll</a> <a data-type="(r : Product C A B₁) →
(C ∘ r .π₁) (has-is-product r .⟨_,_⟩ p1 p2) ≡ p1" id="9818" href="Cat.Diagram.Product.html#1918" class="Function">Prod.π₁∘factor</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="9833" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ 0m r) f ≡ 0m r" id="9835" href="Cat.Abelian.Base.html#3063" class="Function">∘-zero-l</a><a id="9843" class="Symbol">)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="9845" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" id="9847" href="Cat.Reasoning.html#1108" class="Function">Hom.elimr</a> <a data-type="x ≡ x" id="9857" href="1Lab.Path.html#3593" class="Function">refl</a><a id="9861" class="Symbol">)</a>
          <a id="9873" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="9874" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="9878" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) g) ((C ∘ f) h)
≡
(C ∘ f)
(has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g
 h)" id="9879" href="Cat.Abelian.Base.html#1903" class="Function">∘-linear-r</a> <a id="9890" class="Symbol">_</a> <a id="9892" class="Symbol">_</a> <a id="9894" class="Symbol">_)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="9897" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" id="9899" href="1Lab.Path.html#21189" class="Function">ap₂</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="9903" href="Cat.Abelian.Base.html#1445" class="Function Operator">_+_</a> <a id="9907" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ a) ((C ∘ b) f) ≡ (C ∘ c) f" id="9908" href="Cat.Reasoning.html#1548" class="Function">pulll</a> <a data-type="(r : Product C A B₁) →
(C ∘ r .π₂) (has-is-product r .⟨_,_⟩ p1 p2) ≡ p2" id="9914" href="Cat.Diagram.Product.html#1984" class="Function">Prod.π₂∘factor</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="9929" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ 0m r) f ≡ 0m r" id="9931" href="Cat.Abelian.Base.html#3063" class="Function">∘-zero-l</a><a id="9939" class="Symbol">)</a> <a id="9941" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ h) ((C ∘ i) f) ≡ f" id="9942" href="Cat.Reasoning.html#2621" class="Function">cancell</a> <a data-type="(r : Product C A B₁) →
(C ∘ r .π₂) (has-is-product r .⟨_,_⟩ p1 p2) ≡ p2" id="9950" href="Cat.Diagram.Product.html#1984" class="Function">Prod.π₂∘factor</a><a id="9964" class="Symbol">)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="9966" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ a) f ≡ f" id="9968" href="Cat.Reasoning.html#1009" class="Function">Hom.eliml</a> <a data-type="x ≡ x" id="9978" href="1Lab.Path.html#3593" class="Function">refl</a><a id="9982" class="Symbol">)</a>
          <a id="9994" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" id="9995" href="Cat.Reasoning.html#1108" class="Function">elimr</a> <a data-type="x ≡ x" id="10001" href="1Lab.Path.html#3593" class="Function">refl</a><a id="10005" class="Symbol">)</a>
          <a id="10017" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" id="10018" href="Cat.Reasoning.html#1108" class="Function">elimr</a> <a data-type="x ≡ x" id="10024" href="1Lab.Path.html#3593" class="Function">refl</a><a id="10028" class="Symbol">)</a>
</pre>
<h1 id="pre-abelian-abelian-categories"><a href="#pre-abelian-abelian-categories" class="header-link">Pre-abelian &amp; abelian categories<span class="header-link-emoji">🔗</span></a></h1>
<p>An additive category is <strong>pre-abelian</strong> when it additionally has <a href="Cat.Diagram.Kernel.html">kernels</a> and cokernels, hence binary <a href="Cat.Diagram.Equaliser.html">equalisers</a> and <a href="Cat.Diagram.Coequaliser.html">coequalisers</a> where one of the maps is zero.</p>
<pre class="Agda"><a id="10368" class="Keyword">record</a> <a id="is-pre-abelian"></a><a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="10375" href="Cat.Abelian.Base.html#10375" class="Record">is-pre-abelian</a> <a id="10390" class="Symbol">{</a><a id="10391" href="Cat.Abelian.Base.html#10391" class="Bound">o</a> <a id="10393" href="Cat.Abelian.Base.html#10393" class="Bound">ℓ</a><a id="10394" class="Symbol">}</a> <a id="10396" class="Symbol">(</a><a id="10397" href="Cat.Abelian.Base.html#10397" class="Bound">C</a> <a id="10399" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="10401" href="Cat.Base.html#704" class="Record">Precategory</a> <a id="10413" href="Cat.Abelian.Base.html#10391" class="Bound">o</a> <a id="10415" href="Cat.Abelian.Base.html#10393" class="Bound">ℓ</a><a id="10416" class="Symbol">)</a> <a id="10418" class="Symbol">:</a> <a id="10420" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="10425" class="Symbol">(</a><a id="10426" href="Cat.Abelian.Base.html#10391" class="Bound">o</a> <a data-type="Level → Level → Level" id="10428" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a data-type="Level → Level" id="10430" href="Agda.Primitive.html#780" class="Primitive">lsuc</a> <a id="10435" href="Cat.Abelian.Base.html#10393" class="Bound">ℓ</a><a id="10436" class="Symbol">)</a> <a id="10438" class="Keyword">where</a>
  <a id="10446" class="Keyword">field</a> <a id="is-pre-abelian.has-additive"></a><a data-type="(r : is-abelian C) → is-additive C" id="10452" href="Cat.Abelian.Base.html#10452" class="Field">has-additive</a> <a id="10465" class="Symbol">:</a> <a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="10467" href="Cat.Abelian.Base.html#6545" class="Record">is-additive</a> <a id="10479" href="Cat.Abelian.Base.html#10397" class="Bound">C</a>
  <a id="10483" class="Keyword">open</a> <a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="10488" href="Cat.Abelian.Base.html#6545" class="Module">is-additive</a> <a data-type="(r : is-abelian C) → is-additive C" id="10500" href="Cat.Abelian.Base.html#10452" class="Field">has-additive</a> <a id="10513" class="Keyword">public</a>
  <a id="10522" class="Keyword">field</a>
    <a id="is-pre-abelian.kernel"></a><a data-type="(r : is-abelian C) (f : Hom (has-is-preab r .has-additive) A B₁) →
Kernel C (∅ r) f" id="10532" href="Cat.Abelian.Base.html#10532" class="Field">kernel</a>   <a id="10541" class="Symbol">:</a> <a id="10543" class="Symbol">∀</a> <a id="10545" class="Symbol">{</a><a id="10546" href="Cat.Abelian.Base.html#10546" class="Bound">A</a> <a id="10548" href="Cat.Abelian.Base.html#10548" class="Bound">B</a><a id="10549" class="Symbol">}</a> <a id="10551" class="Symbol">(</a><a id="10552" href="Cat.Abelian.Base.html#10552" class="Bound">f</a> <a id="10554" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="10556" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="10560" href="Cat.Abelian.Base.html#10546" class="Bound">A</a> <a id="10562" href="Cat.Abelian.Base.html#10548" class="Bound">B</a><a id="10563" class="Symbol">)</a> <a id="10565" class="Symbol">→</a> <a data-type="(C : Precategory o ℓ) (∅ : Zero C) (f : Hom C a b) → Type (o ⊔ ℓ)" id="10567" href="Cat.Diagram.Equaliser.Kernel.html#1023" class="Record">Kernel</a> <a id="10574" href="Cat.Abelian.Base.html#10397" class="Bound">C</a> <a data-type="(r : is-abelian C) → Zero r" id="10576" href="Cat.Abelian.Base.html#6754" class="Function">∅</a> <a id="10578" href="Cat.Abelian.Base.html#10552" class="Bound">f</a>
    <a id="is-pre-abelian.cokernel"></a><a data-type="(r : is-abelian C) (f : Hom (has-is-preab r .has-additive) A B₁) →
Coequaliser r (0m r) f" id="10584" href="Cat.Abelian.Base.html#10584" class="Field">cokernel</a> <a id="10593" class="Symbol">:</a> <a id="10595" class="Symbol">∀</a> <a id="10597" class="Symbol">{</a><a id="10598" href="Cat.Abelian.Base.html#10598" class="Bound">A</a> <a id="10600" href="Cat.Abelian.Base.html#10600" class="Bound">B</a><a id="10601" class="Symbol">}</a> <a id="10603" class="Symbol">(</a><a id="10604" href="Cat.Abelian.Base.html#10604" class="Bound">f</a> <a id="10606" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="10608" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="10612" href="Cat.Abelian.Base.html#10598" class="Bound">A</a> <a id="10614" href="Cat.Abelian.Base.html#10600" class="Bound">B</a><a id="10615" class="Symbol">)</a> <a id="10617" class="Symbol">→</a> <a data-type="(C : Precategory o ℓ) (f g : Hom C A B₁) → Type (o ⊔ ℓ)" id="10619" href="Cat.Diagram.Coequaliser.html#1495" class="Record">Coequaliser</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="10631" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a id="10634" href="Cat.Abelian.Base.html#10604" class="Bound">f</a>

  <a id="10639" class="Keyword">module</a> <a id="is-pre-abelian.Ker"></a><a id="10646" href="Cat.Abelian.Base.html#10646" class="Module">Ker</a> <a id="10650" class="Symbol">{</a><a id="10651" href="Cat.Abelian.Base.html#10651" class="Bound">A</a> <a id="10653" href="Cat.Abelian.Base.html#10653" class="Bound">B</a><a id="10654" class="Symbol">}</a> <a id="10656" class="Symbol">(</a><a id="10657" href="Cat.Abelian.Base.html#10657" class="Bound">f</a> <a id="10659" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="10661" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="10665" href="Cat.Abelian.Base.html#10651" class="Bound">A</a> <a id="10667" href="Cat.Abelian.Base.html#10653" class="Bound">B</a><a id="10668" class="Symbol">)</a> <a id="10670" class="Symbol">=</a> <a data-type="(C : Precategory o ℓ) (∅ : Zero C) (f : Hom C a b) → Type (o ⊔ ℓ)" id="10672" href="Cat.Diagram.Equaliser.Kernel.html#1023" class="Module">Kernel</a> <a id="10679" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom (has-is-preab r .has-additive) A B₁) →
Kernel C (∅ r) f" id="10680" href="Cat.Abelian.Base.html#10532" class="Field">kernel</a> <a id="10687" href="Cat.Abelian.Base.html#10657" class="Bound">f</a><a id="10688" class="Symbol">)</a>
  <a id="10692" class="Keyword">module</a> <a id="is-pre-abelian.Coker"></a><a id="10699" href="Cat.Abelian.Base.html#10699" class="Module">Coker</a> <a id="10705" class="Symbol">{</a><a id="10706" href="Cat.Abelian.Base.html#10706" class="Bound">A</a> <a id="10708" href="Cat.Abelian.Base.html#10708" class="Bound">B</a><a id="10709" class="Symbol">}</a> <a id="10711" class="Symbol">(</a><a id="10712" href="Cat.Abelian.Base.html#10712" class="Bound">f</a> <a id="10714" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="10716" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="10720" href="Cat.Abelian.Base.html#10706" class="Bound">A</a> <a id="10722" href="Cat.Abelian.Base.html#10708" class="Bound">B</a><a id="10723" class="Symbol">)</a> <a id="10725" class="Symbol">=</a> <a data-type="(C : Precategory o ℓ) (f g : Hom C A B₁) → Type (o ⊔ ℓ)" id="10727" href="Cat.Diagram.Coequaliser.html#1495" class="Module">Coequaliser</a> <a id="10739" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom (has-is-preab r .has-additive) A B₁) →
Coequaliser r (0m r) f" id="10740" href="Cat.Abelian.Base.html#10584" class="Field">cokernel</a> <a id="10749" href="Cat.Abelian.Base.html#10712" class="Bound">f</a><a id="10750" class="Symbol">)</a>
</pre>
<p>Every morphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mi>f</mi></mpadded></mover><mi>B</mi></mrow><annotation encoding="application/x-tex">A \xto{f} B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1191em;vertical-align:-0.011em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1081em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> in a preabelian category admits a canonical decomposition as</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mover><mo stretchy="true" minsize="3.0em">↠</mo><mpadded width="+0.6em" lspace="0.3em"><mi>p</mi></mpadded></mover><mi mathvariant="normal">coker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>ker</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">)</mo><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mpadded></mover><mi>ker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">coker</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">)</mo><mover><mo stretchy="true" minsize="3.0em">↪</mo><mpadded width="+0.6em" lspace="0.3em"><mi>i</mi></mpadded></mover><mi>B</mi><mtext>,</mtext></mrow><annotation encoding="application/x-tex">
A \xepi{p} \coker (\ker f) \xto{f&#39;} \ker (\coker f) \xmono{i} B\text{,}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8294em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8294em;"><span style="top:-3.228em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="svg-align" style="top:-2.783em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.334em;min-width:0.888em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.334em" viewBox="0 0 400000 334" preserveAspectRatio="xMaxYMin slice"><path d="M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z"></path></svg></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4515em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mopen">(</span><span class="mop">ker</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2015em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3337em;vertical-align:-0.25em;"></span><span class="mop">ker</span><span class="mopen">(</span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0837em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="stretchy" style="height:0.522em;min-width:1.08em;"><span class="halfarrow-left" style="height:0.522em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMinYMin slice"><path d="M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z"></path></svg></span><span class="halfarrow-right" style="height:0.522em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"></path></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord text"><span class="mord">,</span></span></span></span></span></span></p>
<p>where, as indicated, the map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> is an epimorphism (indeed a <a href="Cat.Diagram.Coequaliser.RegularEpi.html">regular epimorphism</a>, since it is a cokernel) and the map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> is a <a href="Cat.Diagram.Equaliser.RegularMono.html">regular monomorphism</a>.</p>
<pre class="Agda">  <a id="is-pre-abelian.decompose"></a><a data-type="(r : is-abelian C) (f : Hom (has-is-preab r) A B₁) →
Σ
(λ f′ →
   f ≡
   (r ∘ kernel (has-is-preab r) (coeq (has-is-preab r) f))
   ((r ∘ f′) (coeq (has-is-preab r) (kernel (has-is-preab r) f))))" id="11218" href="Cat.Abelian.Base.html#11218" class="Function">decompose</a>
    <a id="11232" class="Symbol">:</a> <a id="11234" class="Symbol">∀</a> <a id="11236" class="Symbol">{</a><a id="11237" href="Cat.Abelian.Base.html#11237" class="Bound">A</a> <a id="11239" href="Cat.Abelian.Base.html#11239" class="Bound">B</a><a id="11240" class="Symbol">}</a> <a id="11242" class="Symbol">(</a><a id="11243" href="Cat.Abelian.Base.html#11243" class="Bound">f</a> <a id="11245" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="11247" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="11251" href="Cat.Abelian.Base.html#11237" class="Bound">A</a> <a id="11253" href="Cat.Abelian.Base.html#11239" class="Bound">B</a><a id="11254" class="Symbol">)</a>
    <a id="11260" class="Symbol">→</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="11262" href="1Lab.Type.html#1573" class="Function">Σ[</a> <a id="11265" href="Cat.Abelian.Base.html#11265" class="Bound">f′</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="11268" href="1Lab.Type.html#1573" class="Function">∈</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="11270" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="11274" class="Symbol">(</a><a data-type="Coequaliser C f g → Ob C" id="11275" href="Cat.Diagram.Coequaliser.html#1557" class="Function">Coker.coapex</a> <a id="11288" class="Symbol">(</a><a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="11289" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="11300" href="Cat.Abelian.Base.html#11243" class="Bound">f</a><a id="11301" class="Symbol">))</a> <a id="11304" class="Symbol">(</a><a data-type="Kernel C ∅ f → Ob C" id="11305" href="Cat.Diagram.Equaliser.Kernel.html#1088" class="Function">Ker.ker</a> <a id="11313" class="Symbol">(</a><a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="11314" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="11325" href="Cat.Abelian.Base.html#11243" class="Bound">f</a><a id="11326" class="Symbol">))</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="11329" href="1Lab.Type.html#1573" class="Function">]</a>
       <a id="11338" class="Symbol">(</a><a id="11339" href="Cat.Abelian.Base.html#11243" class="Bound">f</a> <a data-type="A → A → Type ℓ" id="11341" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="11343" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="11354" class="Symbol">(</a><a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="11355" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="11366" href="Cat.Abelian.Base.html#11243" class="Bound">f</a><a id="11367" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="11369" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="11371" href="Cat.Abelian.Base.html#11265" class="Bound">f′</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="11374" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="11376" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="11387" class="Symbol">(</a><a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="11388" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="11399" href="Cat.Abelian.Base.html#11243" class="Bound">f</a><a id="11400" class="Symbol">))</a>
  <a data-type="(r : is-abelian C) (f : Hom (has-is-preab r) A B₁) →
Σ
(λ f′ →
   f ≡
   (r ∘ kernel (has-is-preab r) (coeq (has-is-preab r) f))
   ((r ∘ f′) (coeq (has-is-preab r) (kernel (has-is-preab r) f))))" id="11405" href="Cat.Abelian.Base.html#11218" class="Function">decompose</a> <a id="11415" class="Symbol">{</a><a id="11416" href="Cat.Abelian.Base.html#11416" class="Bound">A</a><a id="11417" class="Symbol">}</a> <a id="11419" class="Symbol">{</a><a id="11420" href="Cat.Abelian.Base.html#11420" class="Bound">B</a><a id="11421" class="Symbol">}</a> <a id="11423" href="Cat.Abelian.Base.html#11423" class="Bound">f</a> <a id="11425" class="Symbol">=</a> <a id="11427" href="Cat.Abelian.Base.html#11831" class="Function">map</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="11431" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="x ≡ y → y ≡ x" id="11433" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="11437" href="Cat.Abelian.Base.html#12708" class="Function">path</a>
    <a id="11446" class="Keyword">where</a>
      <a id="11458" href="Cat.Abelian.Base.html#11458" class="Function">proj′</a> <a id="11464" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="11466" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="11470" class="Symbol">(</a><a data-type="Coequaliser C f g → Ob C" id="11471" href="Cat.Diagram.Coequaliser.html#1557" class="Function">Coker.coapex</a> <a id="11484" class="Symbol">(</a><a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="11485" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="11496" href="Cat.Abelian.Base.html#11423" class="Bound">f</a><a id="11497" class="Symbol">))</a> <a id="11500" href="Cat.Abelian.Base.html#11420" class="Bound">B</a>
      <a id="11508" href="Cat.Abelian.Base.html#11458" class="Function">proj′</a> <a id="11514" class="Symbol">=</a> <a data-type="(r : Coequaliser C f g) →
(C ∘ e′) f ≡ (C ∘ e′) g → Hom C (r .coapex) F" id="11516" href="Cat.Diagram.Coequaliser.html#764" class="Function">Coker.coequalise</a> <a id="11533" class="Symbol">(</a><a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="11534" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="11545" href="Cat.Abelian.Base.html#11423" class="Bound">f</a><a id="11546" class="Symbol">)</a> <a id="11548" class="Symbol">{</a><a id="11549" class="Argument">e′</a> <a id="11552" class="Symbol">=</a> <a id="11554" href="Cat.Abelian.Base.html#11423" class="Bound">f</a><a id="11555" class="Symbol">}</a> <a data-type="((x : A) → B₁ x) → (x : A) → B₁ x" id="11557" href="1Lab.Type.html#2481" class="Function Operator">$</a> <a data-type="x ≡ y → y ≡ x" id="11559" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="11563" href="Cat.Abelian.Base.html#11619" class="Function">path</a>
</pre>
<!--
<pre class="Agda">        <a id="11594" class="Keyword">where</a> <a id="11600" class="Keyword">abstract</a>
          <a id="11619" href="Cat.Abelian.Base.html#11619" class="Function">path</a> <a id="11624" class="Symbol">:</a> <a id="11626" href="Cat.Abelian.Base.html#11423" class="Bound">f</a> <a id="11628" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="11630" href="Cat.Abelian.Base.html#10532" class="Field">kernel</a> <a id="11637" href="Cat.Abelian.Base.html#11423" class="Bound">f</a> <a id="11639" class="Symbol">.</a><a id="11640" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Field">Kernel.kernel</a> <a id="11654" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="11656" href="Cat.Abelian.Base.html#11423" class="Bound">f</a> <a id="11658" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="11660" href="Cat.Abelian.Base.html#1533" class="Function">0m</a>
          <a id="11673" href="Cat.Abelian.Base.html#11619" class="Function">path</a> <a id="11678" class="Symbol">=</a> <a id="11680" href="Cat.Diagram.Equaliser.html#687" class="Function">Ker.equal</a> <a id="11690" href="Cat.Abelian.Base.html#11423" class="Bound">f</a>
            <a id="11704" href="1Lab.Path.html#38305" class="Function Operator">··</a> <a id="11707" href="Cat.Diagram.Zero.html#1167" class="Function">∅.zero-∘r</a> <a id="11717" class="Symbol">_</a>
            <a id="11731" href="1Lab.Path.html#38305" class="Function Operator">··</a> <a id="11734" href="1Lab.Path.html#21189" class="Function">ap₂</a> <a id="11738" href="Cat.Base.html#3006" class="Function Operator">_∘_</a> <a id="11742" class="Symbol">(</a><a id="11743" href="Cat.Diagram.Initial.html#456" class="Function">∅.has⊥</a> <a id="11750" class="Symbol">_</a> <a id="11752" class="Symbol">.</a><a id="11753" href="1Lab.HLevel.html#1416" class="Field">paths</a> <a id="11759" href="Cat.Abelian.Base.html#1533" class="Function">0m</a><a id="11761" class="Symbol">)</a> <a id="11763" href="1Lab.Path.html#3593" class="Function">refl</a>
            <a id="11780" href="1Lab.Path.html#38305" class="Function Operator">··</a> <a id="11783" href="Cat.Abelian.Base.html#3063" class="Function">∘-zero-l</a> <a id="11792" href="1Lab.Path.html#38305" class="Function Operator">··</a> <a id="11795" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="11799" href="Cat.Abelian.Base.html#2648" class="Function">∘-zero-r</a>
</pre>-->
<pre class="Agda">      <a id="11831" href="Cat.Abelian.Base.html#11831" class="Function">map</a> <a id="11835" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="11837" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="11841" class="Symbol">(</a><a data-type="Coequaliser C f g → Ob C" id="11842" href="Cat.Diagram.Coequaliser.html#1557" class="Function">Coker.coapex</a> <a id="11855" class="Symbol">(</a><a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="11856" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="11867" href="Cat.Abelian.Base.html#11423" class="Bound">f</a><a id="11868" class="Symbol">))</a> <a id="11871" class="Symbol">(</a><a data-type="Kernel C ∅ f → Ob C" id="11872" href="Cat.Diagram.Equaliser.Kernel.html#1088" class="Function">Ker.ker</a> <a id="11880" class="Symbol">(</a><a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="11881" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="11892" href="Cat.Abelian.Base.html#11423" class="Bound">f</a><a id="11893" class="Symbol">))</a>
      <a id="11902" href="Cat.Abelian.Base.html#11831" class="Function">map</a> <a id="11906" class="Symbol">=</a> <a data-type="(r : Kernel C ∅ f) →
(C ∘ f) e′ ≡ (C ∘ zero→ ∅) e′ → Hom C F (r .ker)" id="11908" href="Cat.Diagram.Equaliser.html#721" class="Function">Ker.limiting</a> <a id="11921" class="Symbol">(</a><a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="11922" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="11933" href="Cat.Abelian.Base.html#11423" class="Bound">f</a><a id="11934" class="Symbol">)</a> <a id="11936" class="Symbol">{</a><a id="11937" class="Argument">e′</a> <a id="11940" class="Symbol">=</a> <a id="11942" href="Cat.Abelian.Base.html#11458" class="Function">proj′</a><a id="11947" class="Symbol">}</a> <a data-type="((x : A) → B₁ x) → (x : A) → B₁ x" id="11949" href="1Lab.Type.html#2481" class="Function Operator">$</a> <a data-type="x ≡ y → y ≡ x" id="11951" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="11955" href="Cat.Abelian.Base.html#12273" class="Function">path</a>
</pre>
<p>The existence of the map <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">f&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>,</span> and indeed of the maps <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> and <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>,</span> follow from the universal properties of kernels and cokernels. The map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> is the canonical quotient map <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi mathvariant="normal">coker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A \to \coker(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>,</span> and the map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> is the canonical subobject inclusion <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\ker(f) \to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">ker</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>.</span></p>
<!--
<pre class="Agda">        <a id="12248" class="Keyword">where</a> <a id="12254" class="Keyword">abstract</a>
          <a id="12273" href="Cat.Abelian.Base.html#12273" class="Function">path</a> <a id="12278" class="Symbol">:</a> <a id="12280" href="Cat.Diagram.Zero.html#1010" class="Function">∅.zero→</a> <a id="12288" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="12290" href="Cat.Abelian.Base.html#11458" class="Function">proj′</a> <a id="12296" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="12298" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="12309" href="Cat.Abelian.Base.html#11423" class="Bound">f</a> <a id="12311" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="12313" href="Cat.Abelian.Base.html#11458" class="Function">proj′</a>
          <a id="12329" href="Cat.Abelian.Base.html#12273" class="Function">path</a> <a id="12334" class="Symbol">=</a> <a id="12336" href="Cat.Diagram.Coequaliser.html#1087" class="Function">Coker.unique₂</a> <a id="12350" class="Symbol">(</a><a id="12351" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="12362" href="Cat.Abelian.Base.html#11423" class="Bound">f</a><a id="12363" class="Symbol">)</a>
            <a id="12377" class="Symbol">{</a><a id="12378" class="Argument">e′</a> <a id="12381" class="Symbol">=</a> <a id="12383" href="Cat.Abelian.Base.html#1533" class="Function">0m</a><a id="12385" class="Symbol">}</a> <a id="12387" class="Symbol">{</a><a id="12388" class="Argument">p</a> <a id="12390" class="Symbol">=</a> <a id="12392" href="Cat.Abelian.Base.html#2648" class="Function">∘-zero-r</a> <a id="12401" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a id="12403" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="12407" href="Cat.Abelian.Base.html#3063" class="Function">∘-zero-l</a><a id="12415" class="Symbol">}</a>
            <a id="12429" class="Symbol">(</a><a id="12430" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="12434" class="Symbol">(</a> <a id="12436" href="Cat.Reasoning.html#1844" class="Function">pushl</a> <a id="12442" class="Symbol">(</a><a id="12443" href="Cat.Diagram.Zero.html#1167" class="Function">∅.zero-∘r</a> <a id="12453" class="Symbol">_)</a> <a id="12456" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a id="12458" href="Cat.Reasoning.html#1548" class="Function">pulll</a> <a id="12464" class="Symbol">(</a> <a id="12466" href="1Lab.Path.html#21189" class="Function">ap₂</a> <a id="12470" href="Cat.Base.html#3006" class="Function Operator">_∘_</a> <a id="12474" href="1Lab.Path.html#3593" class="Function">refl</a> <a id="12479" class="Symbol">(</a><a id="12480" href="Cat.Diagram.Terminal.html#461" class="Function">∅.has⊤</a> <a id="12487" class="Symbol">_</a> <a id="12489" class="Symbol">.</a><a id="12490" href="1Lab.HLevel.html#1416" class="Field">paths</a> <a id="12496" href="Cat.Abelian.Base.html#1533" class="Function">0m</a><a id="12498" class="Symbol">)</a>
                                               <a id="12547" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a id="12549" href="Cat.Abelian.Base.html#2648" class="Function">∘-zero-r</a><a id="12557" class="Symbol">)</a>
                 <a id="12576" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a id="12578" href="Cat.Abelian.Base.html#3063" class="Function">∘-zero-l</a><a id="12586" class="Symbol">))</a>
            <a id="12601" class="Symbol">(</a><a id="12602" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="12606" class="Symbol">(</a> <a id="12608" href="Cat.Reasoning.html#1678" class="Function">pullr</a> <a id="12614" class="Symbol">(</a><a id="12615" href="Cat.Diagram.Coequaliser.html#834" class="Function">Coker.universal</a> <a id="12631" class="Symbol">(</a><a id="12632" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="12643" href="Cat.Abelian.Base.html#11423" class="Bound">f</a><a id="12644" class="Symbol">))</a> <a id="12647" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a id="12649" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="12653" class="Symbol">(</a><a id="12654" href="Cat.Diagram.Coequaliser.html#727" class="Function">Coker.coequal</a> <a id="12668" class="Symbol">_)</a>
                 <a id="12688" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a id="12690" href="Cat.Abelian.Base.html#2648" class="Function">∘-zero-r</a><a id="12698" class="Symbol">))</a>

      <a id="12708" href="Cat.Abelian.Base.html#12708" class="Function">path</a> <a id="12713" class="Symbol">=</a>
        <a id="12723" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="12734" class="Symbol">(</a><a id="12735" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="12746" href="Cat.Abelian.Base.html#11423" class="Bound">f</a><a id="12747" class="Symbol">)</a> <a id="12749" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="12751" href="Cat.Abelian.Base.html#11831" class="Function">map</a> <a id="12755" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="12757" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="12768" class="Symbol">(</a><a id="12769" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="12780" href="Cat.Abelian.Base.html#11423" class="Bound">f</a><a id="12781" class="Symbol">)</a> <a id="12783" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a id="12786" href="Cat.Reasoning.html#1548" class="Function">pulll</a> <a id="12792" class="Symbol">(</a><a id="12793" href="Cat.Diagram.Equaliser.html#790" class="Function">Ker.universal</a> <a id="12807" class="Symbol">_)</a> <a id="12810" href="1Lab.Path.html#46629" class="Function">⟩</a>
        <a id="12820" href="Cat.Abelian.Base.html#11458" class="Function">proj′</a> <a id="12826" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="12828" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="12839" class="Symbol">(</a><a id="12840" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="12851" href="Cat.Abelian.Base.html#11423" class="Bound">f</a><a id="12852" class="Symbol">)</a>                           <a id="12880" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a id="12883" href="Cat.Diagram.Coequaliser.html#834" class="Function">Coker.universal</a> <a id="12899" class="Symbol">_</a> <a id="12901" href="1Lab.Path.html#46629" class="Function">⟩</a>
        <a id="12911" href="Cat.Abelian.Base.html#11423" class="Bound">f</a>                                                           <a id="12971" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
</pre>-->
<p>A pre-abelian category is <strong>abelian</strong> when the map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">f&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> in the above decomposition is an isomorphism.</p>
<pre class="Agda"><a id="13093" class="Keyword">record</a> <a id="is-abelian"></a><a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="13100" href="Cat.Abelian.Base.html#13100" class="Record">is-abelian</a> <a id="13111" class="Symbol">{</a><a id="13112" href="Cat.Abelian.Base.html#13112" class="Bound">o</a> <a id="13114" href="Cat.Abelian.Base.html#13114" class="Bound">ℓ</a><a id="13115" class="Symbol">}</a> <a id="13117" class="Symbol">(</a><a id="13118" href="Cat.Abelian.Base.html#13118" class="Bound">C</a> <a id="13120" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="13122" href="Cat.Base.html#704" class="Record">Precategory</a> <a id="13134" href="Cat.Abelian.Base.html#13112" class="Bound">o</a> <a id="13136" href="Cat.Abelian.Base.html#13114" class="Bound">ℓ</a><a id="13137" class="Symbol">)</a> <a id="13139" class="Symbol">:</a> <a id="13141" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="13146" class="Symbol">(</a><a id="13147" href="Cat.Abelian.Base.html#13112" class="Bound">o</a> <a data-type="Level → Level → Level" id="13149" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a data-type="Level → Level" id="13151" href="Agda.Primitive.html#780" class="Primitive">lsuc</a> <a id="13156" href="Cat.Abelian.Base.html#13114" class="Bound">ℓ</a><a id="13157" class="Symbol">)</a> <a id="13159" class="Keyword">where</a>
  <a id="13167" class="Keyword">field</a> <a id="is-abelian.has-is-preab"></a><a data-type="is-abelian C → is-pre-abelian C" id="13173" href="Cat.Abelian.Base.html#13173" class="Field">has-is-preab</a> <a id="13186" class="Symbol">:</a> <a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="13188" href="Cat.Abelian.Base.html#10375" class="Record">is-pre-abelian</a> <a id="13203" href="Cat.Abelian.Base.html#13118" class="Bound">C</a>
  <a id="13207" class="Keyword">open</a> <a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="13212" href="Cat.Abelian.Base.html#10375" class="Module">is-pre-abelian</a> <a data-type="is-abelian C → is-pre-abelian C" id="13227" href="Cat.Abelian.Base.html#13173" class="Field">has-is-preab</a> <a id="13240" class="Keyword">public</a>
  <a id="13249" class="Keyword">field</a>
    <a id="is-abelian.coker-ker≃ker-coker"></a><a data-type="(r : is-abelian C) (f : Hom (r .has-is-preab) A B₁) →
is-invertible r (decompose r f .fst)" id="13259" href="Cat.Abelian.Base.html#13259" class="Field">coker-ker≃ker-coker</a>
      <a id="13285" class="Symbol">:</a> <a id="13287" class="Symbol">∀</a> <a id="13289" class="Symbol">{</a><a id="13290" href="Cat.Abelian.Base.html#13290" class="Bound">A</a> <a id="13292" href="Cat.Abelian.Base.html#13292" class="Bound">B</a><a id="13293" class="Symbol">}</a> <a id="13295" class="Symbol">(</a><a id="13296" href="Cat.Abelian.Base.html#13296" class="Bound">f</a> <a id="13298" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="13300" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="13304" href="Cat.Abelian.Base.html#13290" class="Bound">A</a> <a id="13306" href="Cat.Abelian.Base.html#13292" class="Bound">B</a><a id="13307" class="Symbol">)</a> <a id="13309" class="Symbol">→</a> <a data-type="(C : Precategory o h) (f : Hom C a b) → Type (o ⊔ h)" id="13311" href="Cat.Morphism.html#1930" class="Record">is-invertible</a> <a id="13325" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom (has-is-preab r) A B₁) →
Σ
(λ f′ →
   f ≡
   (r ∘ kernel (has-is-preab r) (coeq (has-is-preab r) f))
   ((r ∘ f′) (coeq (has-is-preab r) (kernel (has-is-preab r) f))))" id="13326" href="Cat.Abelian.Base.html#11218" class="Function">decompose</a> <a id="13336" href="Cat.Abelian.Base.html#13296" class="Bound">f</a> <a id="13338" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="13339" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="13342" class="Symbol">)</a>
</pre>
<p>This implies in particular that any monomorphism is a kernel, and every epimorphism is a cokernel. Let’s investigate the case for “every mono is a kernel” first: Suppose that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>↪</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f : A \mono B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6943em;vertical-align:-0.011em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↪</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> is some monomorphism; We’ll show that it’s isomorphic to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">coker</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\ker (\coker f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">ker</span><span class="mopen">(</span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span> in the slice category <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">A</mi><mi mathvariant="normal">/</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">\ca{A}/B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal">A</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>.</span></p>
<pre class="Agda">  <a id="13660" class="Keyword">module</a> <a id="13667" href="Cat.Abelian.Base.html#13667" class="Module">_</a> <a id="13669" class="Symbol">{</a><a id="13670" href="Cat.Abelian.Base.html#13670" class="Bound">A</a> <a id="13672" href="Cat.Abelian.Base.html#13672" class="Bound">B</a><a id="13673" class="Symbol">}</a> <a id="13675" class="Symbol">(</a><a id="13676" href="Cat.Abelian.Base.html#13676" class="Bound">f</a> <a id="13678" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="13680" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="13684" href="Cat.Abelian.Base.html#13670" class="Bound">A</a> <a id="13686" href="Cat.Abelian.Base.html#13672" class="Bound">B</a><a id="13687" class="Symbol">)</a> <a id="13689" class="Symbol">(</a><a id="13690" href="Cat.Abelian.Base.html#13690" class="Bound">monic</a> <a id="13696" class="Symbol">:</a> <a data-type="(C : Precategory o h) → Hom C a b → Type (o ⊔ h)" id="13698" href="Cat.Morphism.html#590" class="Function">is-monic</a> <a id="13707" href="Cat.Abelian.Base.html#13676" class="Bound">f</a><a id="13708" class="Symbol">)</a> <a id="13710" class="Keyword">where</a>
    <a id="13720" class="Keyword">private</a>
      <a id="13734" class="Keyword">module</a> <a id="13741" href="Cat.Abelian.Base.html#13741" class="Module">m</a> <a id="13743" class="Symbol">=</a> <a id="13745" href="Algebra.Prelude.html#883" class="Module">Cat</a> <a id="13749" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) → Ob C → Precategory (o ⊔ ℓ) ℓ" id="13750" href="Cat.Instances.Slice.html#4479" class="Function">Slice</a> <a id="13756" href="Cat.Abelian.Base.html#13118" class="Bound">C</a> <a id="13758" href="Cat.Abelian.Base.html#13672" class="Bound">B</a><a id="13759" class="Symbol">)</a>
</pre>
<p>The map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>ker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">coker</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A \to \ker (\coker f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">ker</span><span class="mopen">(</span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span> is obtained as the composite</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mover><mo stretchy="true" minsize="3.0em">↠</mo><mpadded width="+0.6em" lspace="0.3em"><mi>p</mi></mpadded></mover><mi mathvariant="normal">coker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>ker</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>ker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">coker</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">)</mo><mtext>,</mtext></mrow><annotation encoding="application/x-tex">
A \xepi{p} \coker (\ker f) \cong \ker (\coker f)\text{,}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8294em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8294em;"><span style="top:-3.228em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="svg-align" style="top:-2.783em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.334em;min-width:0.888em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.334em" viewBox="0 0 400000 334" preserveAspectRatio="xMaxYMin slice"><path d="M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z"></path></svg></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mopen">(</span><span class="mop">ker</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">ker</span><span class="mopen">(</span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mord text"><span class="mord">,</span></span></span></span></span></span></p>
<p>where the isomorphism is our canonical map from before.</p>
<pre class="Agda">      <a id="13963" href="Cat.Abelian.Base.html#13963" class="Function">f→kercoker</a> <a id="13974" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="13976" href="Cat.Base.html#1436" class="Function">m.Hom</a> <a id="13982" class="Symbol">(</a><a data-type="(map₁ : Hom C domain c) → /-Obj c" id="13983" href="Cat.Instances.Slice.html#2264" class="InductiveConstructor">cut</a> <a id="13987" href="Cat.Abelian.Base.html#13676" class="Bound">f</a><a id="13988" class="Symbol">)</a> <a id="13990" class="Symbol">(</a><a data-type="(map₁ : Hom C domain c) → /-Obj c" id="13991" href="Cat.Instances.Slice.html#2264" class="InductiveConstructor">cut</a> <a id="13995" class="Symbol">(</a><a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="13996" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="14007" class="Symbol">(</a><a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="14008" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="14019" href="Cat.Abelian.Base.html#13676" class="Bound">f</a><a id="14020" class="Symbol">)))</a>
      <a id="14030" href="Cat.Abelian.Base.html#13963" class="Function">f→kercoker</a> <a id="14041" class="Symbol">.</a><a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="14042" href="Cat.Instances.Slice.html#2951" class="Field">/-Hom.map</a> <a id="14052" class="Symbol">=</a> <a data-type="(r : is-abelian C) (f : Hom (has-is-preab r) A B₁) →
Σ
(λ f′ →
   f ≡
   (r ∘ kernel (has-is-preab r) (coeq (has-is-preab r) f))
   ((r ∘ f′) (coeq (has-is-preab r) (kernel (has-is-preab r) f))))" id="14054" href="Cat.Abelian.Base.html#11218" class="Function">decompose</a> <a id="14064" href="Cat.Abelian.Base.html#13676" class="Bound">f</a> <a id="14066" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="14067" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="14071" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="14073" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="14084" class="Symbol">(</a><a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="14085" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="14096" href="Cat.Abelian.Base.html#13676" class="Bound">f</a><a id="14097" class="Symbol">)</a>
      <a id="14105" href="Cat.Abelian.Base.html#13963" class="Function">f→kercoker</a> <a id="14116" class="Symbol">.</a><a data-type="(r : /-Hom a b) → (C ∘ map b) (r .map) ≡ a .map" id="14117" href="Cat.Instances.Slice.html#2992" class="Field">/-Hom.commutes</a> <a id="14132" class="Symbol">=</a> <a data-type="x ≡ y → y ≡ x" id="14134" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="14138" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom (has-is-preab r) A B₁) →
Σ
(λ f′ →
   f ≡
   (r ∘ kernel (has-is-preab r) (coeq (has-is-preab r) f))
   ((r ∘ f′) (coeq (has-is-preab r) (kernel (has-is-preab r) f))))" id="14139" href="Cat.Abelian.Base.html#11218" class="Function">decompose</a> <a id="14149" href="Cat.Abelian.Base.html#13676" class="Bound">f</a> <a id="14151" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="14152" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="14155" class="Symbol">)</a>
</pre>
<p>Conversely, map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">coker</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">)</mo><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\ker (\coker f) \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">ker</span><span class="mopen">(</span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> is the composite</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>ker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">coker</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">)</mo><mo>≅</mo><mi mathvariant="normal">coker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>ker</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">)</mo><mo>→</mo><mi>A</mi><mtext>,</mtext></mrow><annotation encoding="application/x-tex">
\ker (\coker f) \cong \coker (\ker f) \to A\text{,}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">ker</span><span class="mopen">(</span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mopen">(</span><span class="mop">ker</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mord text"><span class="mord">,</span></span></span></span></span></span></p>
<p>where the second map arises from the universal property of the cokernel: We can map out of it with the map <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ker</mi><mo>⁡</mo><mi>f</mi><mo>↪</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\ker f \mono A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mop">ker</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↪</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>,</span> since (using that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> is mono), we have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>=</mo><mi>ker</mi><mo>⁡</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">0 = \ker f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mop">ker</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> from <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mn>0</mn><mo>=</mo><mi>f</mi><mi>ker</mi><mo>⁡</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">f0 = f\ker f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">ker</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>.</span></p>
<pre class="Agda">      <a id="14493" href="Cat.Abelian.Base.html#14493" class="Function">kercoker→f</a> <a id="14504" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="14506" href="Cat.Base.html#1436" class="Function">m.Hom</a> <a id="14512" class="Symbol">(</a><a data-type="(map₁ : Hom C domain c) → /-Obj c" id="14513" href="Cat.Instances.Slice.html#2264" class="InductiveConstructor">cut</a> <a id="14517" class="Symbol">(</a><a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="14518" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="14529" class="Symbol">(</a><a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="14530" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="14541" href="Cat.Abelian.Base.html#13676" class="Bound">f</a><a id="14542" class="Symbol">)))</a> <a id="14546" class="Symbol">(</a><a data-type="(map₁ : Hom C domain c) → /-Obj c" id="14547" href="Cat.Instances.Slice.html#2264" class="InductiveConstructor">cut</a> <a id="14551" href="Cat.Abelian.Base.html#13676" class="Bound">f</a><a id="14552" class="Symbol">)</a>
      <a id="14560" href="Cat.Abelian.Base.html#14493" class="Function">kercoker→f</a> <a id="14571" class="Symbol">.</a><a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="14572" href="Cat.Instances.Slice.html#2951" class="Field">/-Hom.map</a> <a id="14582" class="Symbol">=</a>
        <a data-type="(r : Coequaliser C f g) →
(C ∘ e′) f ≡ (C ∘ e′) g → Hom C (r .coapex) F" id="14592" href="Cat.Diagram.Coequaliser.html#764" class="Function">Coker.coequalise</a> <a id="14609" class="Symbol">(</a><a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="14610" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="14621" href="Cat.Abelian.Base.html#13676" class="Bound">f</a><a id="14622" class="Symbol">)</a> <a id="14624" class="Symbol">{</a><a id="14625" class="Argument">e′</a> <a id="14628" class="Symbol">=</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="14630" href="Cat.Base.html#2976" class="Function">id</a><a id="14632" class="Symbol">}</a> <a id="14634" class="Symbol">(</a><a id="14635" href="Cat.Abelian.Base.html#13690" class="Bound">monic</a> <a id="14641" class="Symbol">_</a> <a id="14643" class="Symbol">_</a> <a id="14645" href="Cat.Abelian.Base.html#14737" class="Function">path</a><a id="14649" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="14651" href="Cat.Base.html#3006" class="Function Operator">∘</a>
          <a data-type="(r : is-abelian C) (f : Hom (r .has-is-preab) A B₁) →
is-invertible r (decompose r f .fst)" id="14663" href="Cat.Abelian.Base.html#13259" class="Field">coker-ker≃ker-coker</a> <a id="14683" href="Cat.Abelian.Base.html#13676" class="Bound">f</a> <a id="14685" class="Symbol">.</a><a data-type="is-invertible C f → Hom C b a" id="14686" href="Cat.Morphism.html#1991" class="Field">is-invertible.inv</a>
        <a id="14712" class="Keyword">where</a> <a id="14718" class="Keyword">abstract</a>
          <a id="14737" href="Cat.Abelian.Base.html#14737" class="Function">path</a> <a id="14742" class="Symbol">:</a> <a id="14744" href="Cat.Abelian.Base.html#13676" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="14746" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="14748" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="14751" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="14753" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="A → A → Type ℓ" id="14756" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="14758" href="Cat.Abelian.Base.html#13676" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="14760" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="14762" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="14765" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="14767" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="14778" href="Cat.Abelian.Base.html#13676" class="Bound">f</a>
          <a id="14790" href="Cat.Abelian.Base.html#14737" class="Function">path</a> <a id="14795" class="Symbol">=</a>
            <a id="14809" href="Cat.Abelian.Base.html#13676" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="14811" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="14813" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="14816" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="14818" href="Cat.Abelian.Base.html#1533" class="Function">0m</a>              <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="14834" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="14837" href="1Lab.Path.html#20756" class="Function">ap</a> <a id="14840" class="Symbol">(</a><a id="14841" href="Cat.Abelian.Base.html#13676" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="14843" href="Cat.Base.html#3006" class="Function Operator">∘_</a><a id="14845" class="Symbol">)</a> <a id="14847" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ a) f ≡ f" id="14848" href="Cat.Reasoning.html#1009" class="Function">eliml</a> <a data-type="x ≡ x" id="14854" href="1Lab.Path.html#3593" class="Function">refl</a><a id="14858" class="Symbol">)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="14860" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ f) (0m r) ≡ 0m r" id="14862" href="Cat.Abelian.Base.html#2648" class="Function">∘-zero-r</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="14871" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
            <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="14885" href="Cat.Abelian.Base.html#1533" class="Function">0m</a>                       <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" id="14910" href="1Lab.Path.html#46783" class="Function Operator">≡˘⟨</a> <a data-type="(r : Zero C) (f : Hom C x y) → (C ∘ zero→ r) f ≡ zero→ r" id="14914" href="Cat.Diagram.Zero.html#1167" class="Function">∅.zero-∘r</a> <a id="14924" class="Symbol">_</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="14926" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(r : is-abelian C) → zero→ r ≡ 0m r" id="14928" href="Cat.Abelian.Base.html#6930" class="Function">0m-unique</a> <a data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" id="14938" href="1Lab.Path.html#46783" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
            <a id="14952" class="Symbol">(</a><a data-type="Zero C → Hom C x y" id="14953" href="Cat.Diagram.Zero.html#1010" class="Function">∅.zero→</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="14961" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="14963" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="14974" href="Cat.Abelian.Base.html#13676" class="Bound">f</a><a id="14975" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" id="14977" href="1Lab.Path.html#46783" class="Function Operator">≡˘⟨</a> <a data-type="(r : Kernel C ∅ f) →
(C ∘ f) (r .kernel) ≡ (C ∘ zero→ ∅) (r .kernel)" id="14981" href="Cat.Diagram.Equaliser.html#687" class="Function">Ker.equal</a> <a id="14991" href="Cat.Abelian.Base.html#13676" class="Bound">f</a> <a data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" id="14993" href="1Lab.Path.html#46783" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
            <a id="15007" href="Cat.Abelian.Base.html#13676" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="15009" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="15011" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="15022" href="Cat.Abelian.Base.html#13676" class="Bound">f</a>         <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="15032" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="15035" href="1Lab.Path.html#20756" class="Function">ap</a> <a id="15038" class="Symbol">(</a><a id="15039" href="Cat.Abelian.Base.html#13676" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="15041" href="Cat.Base.html#3006" class="Function Operator">∘_</a><a id="15043" class="Symbol">)</a> <a id="15045" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → f ≡ (C ∘ a) f" id="15046" href="Cat.Reasoning.html#1207" class="Function">introl</a> <a data-type="x ≡ x" id="15053" href="1Lab.Path.html#3593" class="Function">refl</a><a id="15057" class="Symbol">)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="15059" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
            <a id="15073" href="Cat.Abelian.Base.html#13676" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="15075" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="15077" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="15080" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="15082" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="15093" href="Cat.Abelian.Base.html#13676" class="Bound">f</a>    <a data-type="(x : A) → x ≡ x" id="15098" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
</pre>
<p>This is indeed a map in the slice using that both isomorphisms and coequalisers are epic to make progress.</p>
<pre class="Agda">      <a id="15227" href="Cat.Abelian.Base.html#14493" class="Function">kercoker→f</a> <a id="15238" class="Symbol">.</a><a data-type="(r : /-Hom a b) → (C ∘ map b) (r .map) ≡ a .map" id="15239" href="Cat.Instances.Slice.html#2992" class="Field">/-Hom.commutes</a> <a id="15254" class="Symbol">=</a> <a id="15256" href="Cat.Abelian.Base.html#15483" class="Function">path</a> <a id="15261" class="Keyword">where</a>
        <a id="15275" href="Cat.Abelian.Base.html#15275" class="Function">lemma</a> <a id="15281" class="Symbol">=</a>
          <a data-type="(C : Precategory o ℓ) (coequ : Hom C A E) →
is-coequaliser C f g coequ → is-epic C coequ" id="15293" href="Cat.Diagram.Coequaliser.html#1837" class="Function">is-coequaliser→is-epic</a> <a id="15316" class="Symbol">(</a><a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="15317" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="15328" class="Symbol">_)</a> <a id="15331" class="Symbol">(</a><a data-type="(r : Coequaliser C f g) → is-coequaliser C f g (r .coeq)" id="15332" href="Cat.Diagram.Coequaliser.html#1604" class="Function">Coker.has-is-coeq</a> <a id="15350" class="Symbol">_)</a> <a id="15353" class="Symbol">_</a> <a id="15355" class="Symbol">_</a> <a data-type="((x : A) → B₁ x) → (x : A) → B₁ x" id="15357" href="1Lab.Type.html#2481" class="Function Operator">$</a>
               <a data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" id="15374" href="Cat.Reasoning.html#1678" class="Function">pullr</a> <a id="15380" class="Symbol">(</a><a data-type="(r : Coequaliser C f g) →
(C ∘ has-is-coeq r .coequalise p) (r .coeq) ≡ e′" id="15381" href="Cat.Diagram.Coequaliser.html#834" class="Function">Coker.universal</a> <a id="15397" class="Symbol">_)</a>
            <a data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" id="15412" href="1Lab.Path.html#38305" class="Function Operator">··</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" id="15415" href="Cat.Reasoning.html#1108" class="Function">elimr</a> <a data-type="x ≡ x" id="15421" href="1Lab.Path.html#3593" class="Function">refl</a>
            <a data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" id="15438" href="1Lab.Path.html#38305" class="Function Operator">··</a> <a id="15441" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom (has-is-preab r) A B₁) →
Σ
(λ f′ →
   f ≡
   (r ∘ kernel (has-is-preab r) (coeq (has-is-preab r) f))
   ((r ∘ f′) (coeq (has-is-preab r) (kernel (has-is-preab r) f))))" id="15442" href="Cat.Abelian.Base.html#11218" class="Function">decompose</a> <a id="15452" href="Cat.Abelian.Base.html#13676" class="Bound">f</a> <a id="15454" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="15455" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="15459" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(r : Precategory o h) (f : r .Hom y z) (g : r .Hom x y)
(h : r .Hom w x) →
r ._∘_ f (r ._∘_ g h) ≡ r ._∘_ (r ._∘_ f g) h" id="15461" href="Cat.Base.html#3857" class="Function">assoc</a> <a id="15467" class="Symbol">_</a> <a id="15469" class="Symbol">_</a> <a id="15471" class="Symbol">_)</a>

        <a id="15483" href="Cat.Abelian.Base.html#15483" class="Function">path</a> <a id="15488" class="Symbol">=</a>
          <a data-type="(C : Precategory o h) → is-invertible C f → is-epic C f" id="15500" href="Cat.Morphism.html#7222" class="Function">invertible→epic</a> <a id="15516" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom (r .has-is-preab) A B₁) →
is-invertible r (decompose r f .fst)" id="15517" href="Cat.Abelian.Base.html#13259" class="Field">coker-ker≃ker-coker</a> <a id="15537" class="Symbol">_)</a> <a id="15540" class="Symbol">_</a> <a id="15542" class="Symbol">_</a> <a data-type="((x : A) → B₁ x) → (x : A) → B₁ x" id="15544" href="1Lab.Type.html#2481" class="Function Operator">$</a>
            <a id="15558" class="Symbol">(</a><a id="15559" href="Cat.Abelian.Base.html#13676" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="15561" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Coequaliser C f g) →
(C ∘ e′) f ≡ (C ∘ e′) g → Hom C (r .coapex) F" id="15563" href="Cat.Diagram.Coequaliser.html#764" class="Function">Coker.coequalise</a> <a id="15580" class="Symbol">_</a> <a id="15582" class="Symbol">_</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="15584" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="15586" class="Symbol">_)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="15589" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) (f : Hom (has-is-preab r) A B₁) →
Σ
(λ f′ →
   f ≡
   (r ∘ kernel (has-is-preab r) (coeq (has-is-preab r) f))
   ((r ∘ f′) (coeq (has-is-preab r) (kernel (has-is-preab r) f))))" id="15591" href="Cat.Abelian.Base.html#11218" class="Function">decompose</a> <a id="15601" href="Cat.Abelian.Base.html#13676" class="Bound">f</a> <a id="15603" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="15604" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a>   <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="15610" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" id="15613" href="1Lab.Path.html#21189" class="Function">ap₂</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="15617" href="Cat.Base.html#3006" class="Function Operator">_∘_</a> <a id="15621" class="Symbol">(</a><a data-type="(r : Precategory o h) (f : r .Hom y z) (g : r .Hom x y)
(h : r .Hom w x) →
r ._∘_ f (r ._∘_ g h) ≡ r ._∘_ (r ._∘_ f g) h" id="15622" href="Cat.Base.html#3857" class="Function">assoc</a> <a id="15628" class="Symbol">_</a> <a id="15630" class="Symbol">_</a> <a id="15632" class="Symbol">_)</a> <a data-type="x ≡ x" id="15635" href="1Lab.Path.html#3593" class="Function">refl</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="15640" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
            <a id="15654" class="Symbol">((</a><a id="15656" href="Cat.Abelian.Base.html#13676" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="15658" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Coequaliser C f g) →
(C ∘ e′) f ≡ (C ∘ e′) g → Hom C (r .coapex) F" id="15660" href="Cat.Diagram.Coequaliser.html#764" class="Function">Coker.coequalise</a> <a id="15677" class="Symbol">_</a> <a id="15679" class="Symbol">_)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="15682" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="15684" class="Symbol">_)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="15687" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) (f : Hom (has-is-preab r) A B₁) →
Σ
(λ f′ →
   f ≡
   (r ∘ kernel (has-is-preab r) (coeq (has-is-preab r) f))
   ((r ∘ f′) (coeq (has-is-preab r) (kernel (has-is-preab r) f))))" id="15689" href="Cat.Abelian.Base.html#11218" class="Function">decompose</a> <a id="15699" href="Cat.Abelian.Base.html#13676" class="Bound">f</a> <a id="15701" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="15702" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="15706" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ (C ∘ f) h) i ≡ f" id="15709" href="Cat.Reasoning.html#2731" class="Function">cancelr</a> <a id="15717" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom (r .has-is-preab) A B₁) →
is-invertible r (decompose r f .fst)" id="15718" href="Cat.Abelian.Base.html#13259" class="Field">coker-ker≃ker-coker</a> <a id="15738" class="Symbol">_</a> <a id="15740" class="Symbol">.</a><a data-type="(r : (C ≅ a) b) → (C ∘ r .from) (r .to) ≡ id C" id="15741" href="Cat.Morphism.html#1889" class="Function">is-invertible.invr</a><a id="15759" class="Symbol">)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="15761" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
            <a id="15775" href="Cat.Abelian.Base.html#13676" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="15777" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Coequaliser C f g) →
(C ∘ e′) f ≡ (C ∘ e′) g → Hom C (r .coapex) F" id="15779" href="Cat.Diagram.Coequaliser.html#764" class="Function">Coker.coequalise</a> <a id="15796" class="Symbol">_</a> <a id="15798" class="Symbol">_</a>                            <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="15827" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a id="15830" href="Cat.Abelian.Base.html#15275" class="Function">lemma</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="15836" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
            <a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="15850" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="15861" class="Symbol">_</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="15863" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) (f : Hom (has-is-preab r) A B₁) →
Σ
(λ f′ →
   f ≡
   (r ∘ kernel (has-is-preab r) (coeq (has-is-preab r) f))
   ((r ∘ f′) (coeq (has-is-preab r) (kernel (has-is-preab r) f))))" id="15865" href="Cat.Abelian.Base.html#11218" class="Function">decompose</a> <a id="15875" href="Cat.Abelian.Base.html#13676" class="Bound">f</a> <a id="15877" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="15878" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a>                     <a data-type="(x : A) → x ≡ x" id="15902" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
</pre>
<p>Using the universal property of the cokernel (both uniqueness and universality), we establish that the maps defined above are inverses in <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">A</mi></mrow><annotation encoding="application/x-tex">\ca{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal">A</span></span></span></span>,</span> thus assemble into an isomorphism in the slice.</p>
<pre class="Agda">    <a data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
(Slice C B₁ ≅ cut f) (cut (kernel r (coeq r f)))" id="16118" href="Cat.Abelian.Base.html#16118" class="Function">mono→kernel</a> <a id="16130" class="Symbol">:</a> <a data-type="(map₁ : Hom C domain c) → /-Obj c" id="16132" href="Cat.Instances.Slice.html#2264" class="InductiveConstructor">cut</a> <a id="16136" href="Cat.Abelian.Base.html#13676" class="Bound">f</a> <a data-type="(C : Precategory o h) (a b : Ob C) → Type (o ⊔ h)" id="16138" href="Cat.Morphism.html#2208" class="Record Operator">m.≅</a> <a data-type="(map₁ : Hom C domain c) → /-Obj c" id="16142" href="Cat.Instances.Slice.html#2264" class="InductiveConstructor">cut</a> <a id="16146" class="Symbol">(</a><a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="16147" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="16158" class="Symbol">(</a><a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="16159" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="16170" href="Cat.Abelian.Base.html#13676" class="Bound">f</a><a id="16171" class="Symbol">))</a>
    <a data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
(Slice C B₁ ≅ cut f) (cut (kernel r (coeq r f)))" id="16178" href="Cat.Abelian.Base.html#16118" class="Function">mono→kernel</a> <a id="16190" class="Symbol">=</a> <a data-type="(C : Precategory o h) (f : Hom C a b) (g : Hom C b a) →
(C ∘ f) g ≡ id C → (C ∘ g) f ≡ id C → (C ≅ a) b" id="16192" href="Cat.Morphism.html#3719" class="Function">m.make-iso</a> <a id="16203" href="Cat.Abelian.Base.html#13963" class="Function">f→kercoker</a> <a id="16214" href="Cat.Abelian.Base.html#14493" class="Function">kercoker→f</a> <a id="16225" href="Cat.Abelian.Base.html#16252" class="Function">f→kc→f</a> <a id="16232" href="Cat.Abelian.Base.html#16868" class="Function">kc→f→kc</a> <a id="16240" class="Keyword">where</a>
      <a id="16252" href="Cat.Abelian.Base.html#16252" class="Function">f→kc→f</a> <a id="16259" class="Symbol">:</a> <a id="16261" href="Cat.Abelian.Base.html#13963" class="Function">f→kercoker</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="16272" href="Cat.Base.html#3006" class="Function Operator">m.∘</a> <a id="16276" href="Cat.Abelian.Base.html#14493" class="Function">kercoker→f</a> <a data-type="A → A → Type ℓ" id="16287" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="16289" href="Cat.Base.html#2976" class="Function">m.id</a>
      <a id="16300" href="Cat.Abelian.Base.html#16252" class="Function">f→kc→f</a> <a id="16307" class="Symbol">=</a> <a data-type="x .map ≡ y .map → x ≡ y" id="16309" href="Cat.Instances.Slice.html#3929" class="Function">/-Hom-path</a> <a data-type="((x : A) → B₁ x) → (x : A) → B₁ x" id="16320" href="1Lab.Type.html#2481" class="Function Operator">$</a>
        <a id="16330" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom (has-is-preab r) A B₁) →
Σ
(λ f′ →
   f ≡
   (r ∘ kernel (has-is-preab r) (coeq (has-is-preab r) f))
   ((r ∘ f′) (coeq (has-is-preab r) (kernel (has-is-preab r) f))))" id="16331" href="Cat.Abelian.Base.html#11218" class="Function">decompose</a> <a id="16341" href="Cat.Abelian.Base.html#13676" class="Bound">f</a> <a id="16343" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="16344" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="16348" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="16350" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="16361" class="Symbol">_)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="16364" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Coequaliser C f g) →
(C ∘ e′) f ≡ (C ∘ e′) g → Hom C (r .coapex) F" id="16366" href="Cat.Diagram.Coequaliser.html#764" class="Function">Coker.coequalise</a> <a id="16383" class="Symbol">_</a> <a id="16385" class="Symbol">_</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="16387" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="16389" class="Symbol">_</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="16391" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ (C ∘ f) h) ((C ∘ i) g) ≡ (C ∘ f) g" id="16394" href="Cat.Reasoning.html#2947" class="Function">cancel-inner</a> <a id="16407" href="Cat.Abelian.Base.html#16626" class="Function">lemma</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="16413" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a data-type="(r : is-abelian C) (f : Hom (has-is-preab r) A B₁) →
Σ
(λ f′ →
   f ≡
   (r ∘ kernel (has-is-preab r) (coeq (has-is-preab r) f))
   ((r ∘ f′) (coeq (has-is-preab r) (kernel (has-is-preab r) f))))" id="16423" href="Cat.Abelian.Base.html#11218" class="Function">decompose</a> <a id="16433" href="Cat.Abelian.Base.html#13676" class="Bound">f</a> <a id="16435" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="16436" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="16440" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="16442" class="Symbol">_</a>                                         <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="16484" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(r : is-abelian C) (f : Hom (r .has-is-preab) A B₁) →
is-invertible r (decompose r f .fst)" id="16487" href="Cat.Abelian.Base.html#13259" class="Field">coker-ker≃ker-coker</a> <a id="16507" href="Cat.Abelian.Base.html#13676" class="Bound">f</a> <a id="16509" class="Symbol">.</a><a data-type="(r : (C ≅ a) b) → (C ∘ r .to) (r .from) ≡ id C" id="16510" href="Cat.Morphism.html#1867" class="Function">is-invertible.invl</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="16529" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a data-type="(r : Precategory o h) → r .Hom x x" id="16539" href="Cat.Base.html#2976" class="Function">id</a>                                                           <a data-type="(x : A) → x ≡ x" id="16600" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
        <a id="16610" class="Keyword">where</a>
          <a id="16626" href="Cat.Abelian.Base.html#16626" class="Function">lemma</a> <a id="16632" class="Symbol">=</a> <a data-type="(r : Coequaliser C f g) →
e′ ≡ (C ∘ colim&#39;) (r .coeq) →
e′ ≡ (C ∘ colim&#39;&#39;) (r .coeq) → colim&#39; ≡ colim&#39;&#39;" id="16634" href="Cat.Diagram.Coequaliser.html#1087" class="Function">Coker.unique₂</a> <a id="16648" class="Symbol">_</a>
            <a id="16662" class="Symbol">{</a><a id="16663" class="Argument">e′</a> <a id="16666" class="Symbol">=</a> <a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="16668" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="16679" class="Symbol">(</a><a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="16680" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="16691" href="Cat.Abelian.Base.html#13676" class="Bound">f</a><a id="16692" class="Symbol">)}</a>
            <a id="16707" class="Symbol">{</a><a id="16708" class="Argument">p</a> <a id="16710" class="Symbol">=</a> <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ f) (0m r) ≡ 0m r" id="16712" href="Cat.Abelian.Base.html#2648" class="Function">∘-zero-r</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="16721" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="x ≡ y → y ≡ x" id="16723" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="16727" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="16728" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="16732" class="Symbol">(</a><a data-type="(r : Coequaliser C f g) → (C ∘ r .coeq) f ≡ (C ∘ r .coeq) g" id="16733" href="Cat.Diagram.Coequaliser.html#727" class="Function">Coker.coequal</a> <a id="16747" class="Symbol">_)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="16750" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ f) (0m r) ≡ 0m r" id="16752" href="Cat.Abelian.Base.html#2648" class="Function">∘-zero-r</a><a id="16760" class="Symbol">)}</a>
            <a id="16775" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="16776" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="16780" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" id="16781" href="Cat.Reasoning.html#1678" class="Function">pullr</a> <a id="16787" class="Symbol">(</a><a data-type="(r : Coequaliser C f g) →
(C ∘ has-is-coeq r .coequalise p) (r .coeq) ≡ e′" id="16788" href="Cat.Diagram.Coequaliser.html#834" class="Function">Coker.universal</a> <a id="16804" class="Symbol">(</a><a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="16805" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="16816" href="Cat.Abelian.Base.html#13676" class="Bound">f</a><a id="16817" class="Symbol">))</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="16820" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" id="16822" href="Cat.Reasoning.html#1108" class="Function">elimr</a> <a data-type="x ≡ x" id="16828" href="1Lab.Path.html#3593" class="Function">refl</a><a id="16832" class="Symbol">))</a>
            <a id="16847" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → f ≡ (C ∘ a) f" id="16848" href="Cat.Reasoning.html#1207" class="Function">introl</a> <a data-type="x ≡ x" id="16855" href="1Lab.Path.html#3593" class="Function">refl</a><a id="16859" class="Symbol">)</a>

      <a id="16868" href="Cat.Abelian.Base.html#16868" class="Function">kc→f→kc</a> <a id="16876" class="Symbol">:</a> <a id="16878" href="Cat.Abelian.Base.html#14493" class="Function">kercoker→f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="16889" href="Cat.Base.html#3006" class="Function Operator">m.∘</a> <a id="16893" href="Cat.Abelian.Base.html#13963" class="Function">f→kercoker</a> <a data-type="A → A → Type ℓ" id="16904" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="16906" href="Cat.Base.html#2976" class="Function">m.id</a>
      <a id="16917" href="Cat.Abelian.Base.html#16868" class="Function">kc→f→kc</a> <a id="16925" class="Symbol">=</a> <a data-type="x .map ≡ y .map → x ≡ y" id="16927" href="Cat.Instances.Slice.html#3929" class="Function">/-Hom-path</a> <a data-type="((x : A) → B₁ x) → (x : A) → B₁ x" id="16938" href="1Lab.Type.html#2481" class="Function Operator">$</a>
        <a id="16948" class="Symbol">(</a><a data-type="(r : Coequaliser C f g) →
(C ∘ e′) f ≡ (C ∘ e′) g → Hom C (r .coapex) F" id="16949" href="Cat.Diagram.Coequaliser.html#764" class="Function">Coker.coequalise</a> <a id="16966" class="Symbol">_</a> <a id="16968" class="Symbol">_</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="16970" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="16972" class="Symbol">_)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="16975" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) (f : Hom (has-is-preab r) A B₁) →
Σ
(λ f′ →
   f ≡
   (r ∘ kernel (has-is-preab r) (coeq (has-is-preab r) f))
   ((r ∘ f′) (coeq (has-is-preab r) (kernel (has-is-preab r) f))))" id="16977" href="Cat.Abelian.Base.html#11218" class="Function">decompose</a> <a id="16987" href="Cat.Abelian.Base.html#13676" class="Bound">f</a> <a id="16989" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="16990" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="16994" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="16996" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="17007" class="Symbol">_</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="17009" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ (C ∘ f) h) ((C ∘ i) g) ≡ (C ∘ f) g" id="17012" href="Cat.Reasoning.html#2947" class="Function">cancel-inner</a> <a id="17025" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom (r .has-is-preab) A B₁) →
is-invertible r (decompose r f .fst)" id="17026" href="Cat.Abelian.Base.html#13259" class="Field">coker-ker≃ker-coker</a> <a id="17046" href="Cat.Abelian.Base.html#13676" class="Bound">f</a> <a id="17048" class="Symbol">.</a><a data-type="(r : (C ≅ a) b) → (C ∘ r .from) (r .to) ≡ id C" id="17049" href="Cat.Morphism.html#1889" class="Function">is-invertible.invr</a><a id="17067" class="Symbol">)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="17069" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a data-type="(r : Coequaliser C f g) →
(C ∘ e′) f ≡ (C ∘ e′) g → Hom C (r .coapex) F" id="17079" href="Cat.Diagram.Coequaliser.html#764" class="Function">Coker.coequalise</a> <a id="17096" class="Symbol">_</a> <a id="17098" class="Symbol">_</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="17100" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="17102" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="17113" class="Symbol">_</a>                          <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="17140" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(r : Coequaliser C f g) →
(C ∘ has-is-coeq r .coequalise p) (r .coeq) ≡ e′" id="17143" href="Cat.Diagram.Coequaliser.html#834" class="Function">Coker.universal</a> <a id="17159" class="Symbol">_</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="17161" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a data-type="(r : Precategory o h) → r .Hom x x" id="17171" href="Cat.Base.html#2976" class="Function">id</a>                                                           <a data-type="(x : A) → x ≡ x" id="17232" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
</pre>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>“multiplication”<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
  </article>
</div>

</main>
</body>
</html>
