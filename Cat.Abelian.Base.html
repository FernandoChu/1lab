<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>Cat.Abelian.Base - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />
  <link rel="stylesheet" href="/css/agda-cats.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Cat.Abelian.Base - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="Cat.Abelian.Base - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script src="/equations.js"></script>
  <script src="/highlight-hover.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

  <!-- Google font embeds -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&amp;family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&amp;display=swap" rel="stylesheet">
</head>

<body>
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">Cat.Abelian.Base</a>
              </h3>

      <!-- Cube logo -->
      <a id="logo" href="/">
        <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />
      </a>

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#abelian-categories"><a href="#abelian-categories" class="header-link">Abelian categories<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#ab-enriched-categories"><a href="#ab-enriched-categories" class="header-link">Ab-enriched categories<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#additive-categories"><a href="#additive-categories" class="header-link">Additive categories<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#pre-abelian-abelian-categories"><a href="#pre-abelian-abelian-categories" class="header-link">Pre-abelian &amp; abelian categories<span class="header-link-emoji">🔗</span></a></a></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
              <a href="/">back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/23156877e0e274f33fdcc9ff7257cc79abaed97b/src/Cat/Abelian/Base.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="/">back to index</a>
      </div>
      
      <!-- Font toggle checkbox -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="Algebra.Magma.Unital.html" class="Module">Algebra.Magma.Unital</a>
<a id="42" class="Keyword">open</a> <a id="47" class="Keyword">import</a> <a id="54" href="Algebra.Group.Ab.html" class="Module">Algebra.Group.Ab</a>
<a id="71" class="Keyword">open</a> <a id="76" class="Keyword">import</a> <a id="83" href="Algebra.Prelude.html" class="Module">Algebra.Prelude</a>
<a id="99" class="Keyword">open</a> <a id="104" class="Keyword">import</a> <a id="111" href="Algebra.Monoid.html" class="Module">Algebra.Monoid</a>
<a id="126" class="Keyword">open</a> <a id="131" class="Keyword">import</a> <a id="138" href="Algebra.Group.html" class="Module">Algebra.Group</a>

<a id="153" class="Keyword">open</a> <a id="158" class="Keyword">import</a> <a id="165" href="Cat.Diagram.Equaliser.Kernel.html" class="Module">Cat.Diagram.Equaliser.Kernel</a>

<a id="195" class="Keyword">import</a> <a id="202" href="Algebra.Group.Cat.Base.html" class="Module">Algebra.Group.Cat.Base</a> <a id="225" class="Symbol">as</a> <a id="228" class="Module">Grp</a>

<a id="233" class="Keyword">module</a> <a id="240" href="Cat.Abelian.Base.html" class="Module">Cat.Abelian.Base</a> <a id="257" class="Keyword">where</a>
</pre>
<h1 id="abelian-categories"><a href="#abelian-categories" class="header-link">Abelian categories<span class="header-link-emoji">🔗</span></a></h1>
<p>This module defines the sequence of properties which “work up to” abelian categories: Ab-enriched categories, pre-additive categories, pre-abelian categories, and abelian categories. Each concept builds on the last by adding a new categorical property on top of a precategory.</p>
<h2 id="ab-enriched-categories"><a href="#ab-enriched-categories" class="header-link">Ab-enriched categories<span class="header-link-emoji">🔗</span></a></h2>
<p>An <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">\Ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathbf">Ab</span></span></span></span></span>-enriched</span> category is one where each <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>hom</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\hom</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mop">hom</span></span></span></span> set carries the structure of an <a href="Algebra.Group.Ab.html">Abelian group</a>, such that the composition map is <em>bilinear</em>, hence extending to an Abelian group homomorphism</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo><mo>⊗</mo><mi>hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>→</mo><mi>hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo><mtext>,</mtext></mrow><annotation encoding="application/x-tex">
\hom(b, c) \otimes \hom(a, b) \to \hom(a, c)\text{,}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">hom</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">hom</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">hom</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mord text"><span class="mord">,</span></span></span></span></span></span></p>
<p>where the term on the left is the <a href="Algebra.Group.Ab.html#the-tensor-product">tensor product</a> of the corresponding <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>hom</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\hom</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mop">hom</span></span></span></span>-groups.</span> As the name implies, every such category has a canonical <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">\Ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathbf">Ab</span></span></span></span></span>-enrichment</span> (made monoidal using <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mo>⊗</mo><mo>−</mo></mrow><annotation encoding="application/x-tex">- \otimes -</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">−</span></span></span></span>),</span> but we do not use the language of enriched category theory in our development of Abelian categories.</p>
<pre class="Agda"><a id="1295" class="Keyword">record</a> <a id="Ab-category"></a><a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="1302" href="Cat.Abelian.Base.html#1302" class="Record">Ab-category</a> <a id="1314" class="Symbol">{</a><a id="1315" href="Cat.Abelian.Base.html#1315" class="Bound">o</a> <a id="1317" href="Cat.Abelian.Base.html#1317" class="Bound">ℓ</a><a id="1318" class="Symbol">}</a> <a id="1320" class="Symbol">(</a><a id="1321" href="Cat.Abelian.Base.html#1321" class="Bound">C</a> <a id="1323" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="1325" href="Cat.Base.html#704" class="Record">Precategory</a> <a id="1337" href="Cat.Abelian.Base.html#1315" class="Bound">o</a> <a id="1339" href="Cat.Abelian.Base.html#1317" class="Bound">ℓ</a><a id="1340" class="Symbol">)</a> <a id="1342" class="Symbol">:</a> <a id="1344" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="1349" class="Symbol">(</a><a id="1350" href="Cat.Abelian.Base.html#1315" class="Bound">o</a> <a data-type="Level → Level → Level" id="1352" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a data-type="Level → Level" id="1354" href="Agda.Primitive.html#780" class="Primitive">lsuc</a> <a id="1359" href="Cat.Abelian.Base.html#1317" class="Bound">ℓ</a><a id="1360" class="Symbol">)</a> <a id="1362" class="Keyword">where</a>
  <a id="1370" class="Keyword">open</a> <a id="1375" href="Algebra.Prelude.html#883" class="Module">Cat</a> <a id="1379" href="Cat.Abelian.Base.html#1321" class="Bound">C</a> <a id="1381" class="Keyword">public</a>
  <a id="1390" class="Keyword">field</a>
    <a id="Ab-category.Group-on-hom"></a><a data-type="(r : is-abelian C) (A B₁ : C .Ob) → Group-on (Hom C A B₁)" id="1400" href="Cat.Abelian.Base.html#1400" class="Field">Group-on-hom</a> <a id="1413" class="Symbol">:</a> <a id="1415" class="Symbol">∀</a> <a id="1417" href="Cat.Abelian.Base.html#1417" class="Bound">A</a> <a id="1419" href="Cat.Abelian.Base.html#1419" class="Bound">B</a> <a id="1421" class="Symbol">→</a> <a data-type="(A : Type ℓ) → Type ℓ" id="1423" href="Algebra.Group.html#5688" class="Record">Group-on</a> <a id="1432" class="Symbol">(</a><a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1433" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="1437" href="Cat.Abelian.Base.html#1417" class="Bound">A</a> <a id="1439" href="Cat.Abelian.Base.html#1419" class="Bound">B</a><a id="1440" class="Symbol">)</a>

  <a id="Ab-category._+_"></a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="1445" href="Cat.Abelian.Base.html#1445" class="Function Operator">_+_</a> <a id="1449" class="Symbol">:</a> <a id="1451" class="Symbol">∀</a> <a id="1453" class="Symbol">{</a><a id="1454" href="Cat.Abelian.Base.html#1454" class="Bound">A</a> <a id="1456" href="Cat.Abelian.Base.html#1456" class="Bound">B</a><a id="1457" class="Symbol">}</a> <a id="1459" class="Symbol">(</a><a id="1460" href="Cat.Abelian.Base.html#1460" class="Bound">f</a> <a id="1462" href="Cat.Abelian.Base.html#1462" class="Bound">g</a> <a id="1464" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1466" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="1470" href="Cat.Abelian.Base.html#1454" class="Bound">A</a> <a id="1472" href="Cat.Abelian.Base.html#1456" class="Bound">B</a><a id="1473" class="Symbol">)</a> <a id="1475" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1477" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="1481" href="Cat.Abelian.Base.html#1454" class="Bound">A</a> <a id="1483" href="Cat.Abelian.Base.html#1456" class="Bound">B</a>
  <a id="1487" href="Cat.Abelian.Base.html#1487" class="Bound">f</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="1489" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="1491" href="Cat.Abelian.Base.html#1491" class="Bound">g</a> <a id="1493" class="Symbol">=</a> <a data-type="(r : is-abelian C) (A B₁ : C .Ob) → Group-on (Hom C A B₁)" id="1495" href="Cat.Abelian.Base.html#1400" class="Field">Group-on-hom</a> <a id="1508" class="Symbol">_</a> <a id="1510" class="Symbol">_</a> <a id="1512" class="Symbol">.</a><a data-type="(G : AbGroup ℓ) → G .object .fst → G .object .fst → G .object .fst" id="1513" href="Algebra.Group.html#5741" class="Field Operator">Group-on._⋆_</a> <a id="1526" href="Cat.Abelian.Base.html#1487" class="Bound">f</a> <a id="1528" href="Cat.Abelian.Base.html#1491" class="Bound">g</a>

  <a id="Ab-category.0m"></a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="1533" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a id="1536" class="Symbol">:</a> <a id="1538" class="Symbol">∀</a> <a id="1540" class="Symbol">{</a><a id="1541" href="Cat.Abelian.Base.html#1541" class="Bound">A</a> <a id="1543" href="Cat.Abelian.Base.html#1543" class="Bound">B</a><a id="1544" class="Symbol">}</a> <a id="1546" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1548" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="1552" href="Cat.Abelian.Base.html#1541" class="Bound">A</a> <a id="1554" href="Cat.Abelian.Base.html#1543" class="Bound">B</a>
  <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="1558" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a id="1561" class="Symbol">=</a> <a data-type="(r : is-abelian C) (A B₁ : C .Ob) → Group-on (Hom C A B₁)" id="1563" href="Cat.Abelian.Base.html#1400" class="Field">Group-on-hom</a> <a id="1576" class="Symbol">_</a> <a id="1578" class="Symbol">_</a> <a id="1580" class="Symbol">.</a><a data-type="(G : AbGroup ℓ) → G .object .fst" id="1581" href="Algebra.Group.html#1060" class="Function">Group-on.unit</a>

  <a id="1598" class="Keyword">field</a>
    <a id="Ab-category.Hom-grp-ab"></a><a data-type="(r : is-abelian C) (A B₁ : C .Ob) (f g : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ f g
≡
has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g f" id="1608" href="Cat.Abelian.Base.html#1608" class="Field">Hom-grp-ab</a> <a id="1619" class="Symbol">:</a> <a id="1621" class="Symbol">∀</a> <a id="1623" href="Cat.Abelian.Base.html#1623" class="Bound">A</a> <a id="1625" href="Cat.Abelian.Base.html#1625" class="Bound">B</a> <a id="1627" class="Symbol">(</a><a id="1628" href="Cat.Abelian.Base.html#1628" class="Bound">f</a> <a id="1630" href="Cat.Abelian.Base.html#1630" class="Bound">g</a> <a id="1632" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1634" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="1638" href="Cat.Abelian.Base.html#1623" class="Bound">A</a> <a id="1640" href="Cat.Abelian.Base.html#1625" class="Bound">B</a><a id="1641" class="Symbol">)</a> <a id="1643" class="Symbol">→</a> <a id="1645" href="Cat.Abelian.Base.html#1628" class="Bound">f</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="1647" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="1649" href="Cat.Abelian.Base.html#1630" class="Bound">g</a> <a data-type="A → A → Type ℓ" id="1651" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="1653" href="Cat.Abelian.Base.html#1630" class="Bound">g</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="1655" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="1657" href="Cat.Abelian.Base.html#1628" class="Bound">f</a>

  <a id="Ab-category.Hom-grp"></a><a data-type="(r : is-abelian C) (A : C .Ob) → C .Ob → AbGroup ℓ" id="1662" href="Cat.Abelian.Base.html#1662" class="Function">Hom-grp</a> <a id="1670" class="Symbol">:</a> <a id="1672" class="Symbol">∀</a> <a id="1674" href="Cat.Abelian.Base.html#1674" class="Bound">A</a> <a id="1676" href="Cat.Abelian.Base.html#1676" class="Bound">B</a> <a id="1678" class="Symbol">→</a> <a data-type="(ℓ : Level) → Type (lsuc ℓ)" id="1680" href="Algebra.Group.Ab.html#1602" class="Function">AbGroup</a> <a id="1688" href="Cat.Abelian.Base.html#1317" class="Bound">ℓ</a>
  <a data-type="(r : is-abelian C) (A : C .Ob) → C .Ob → AbGroup ℓ" id="1692" href="Cat.Abelian.Base.html#1662" class="Function">Hom-grp</a> <a id="1700" href="Cat.Abelian.Base.html#1700" class="Bound">A</a> <a id="1702" href="Cat.Abelian.Base.html#1702" class="Bound">B</a> <a id="1704" class="Symbol">=</a> <a id="1706" class="Symbol">(</a><a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1707" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="1711" href="Cat.Abelian.Base.html#1700" class="Bound">A</a> <a id="1713" href="Cat.Abelian.Base.html#1702" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="1715" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="(r : is-abelian C) (A B₁ : C .Ob) → Group-on (Hom C A B₁)" id="1717" href="Cat.Abelian.Base.html#1400" class="Field">Group-on-hom</a> <a id="1730" href="Cat.Abelian.Base.html#1700" class="Bound">A</a> <a id="1732" href="Cat.Abelian.Base.html#1702" class="Bound">B</a><a id="1733" class="Symbol">)</a> <a data-type="(object₁ : Ob C) (witness₁ : P object₁) → Restrict-ob P" id="1735" href="Cat.Functor.FullSubcategory.html#1047" class="InductiveConstructor Operator">,</a> <a data-type="(r : is-abelian C) (A B₁ : C .Ob) (f g : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ f g
≡
has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g f" id="1737" href="Cat.Abelian.Base.html#1608" class="Field">Hom-grp-ab</a> <a id="1748" href="Cat.Abelian.Base.html#1700" class="Bound">A</a> <a id="1750" href="Cat.Abelian.Base.html#1702" class="Bound">B</a>

  <a id="1755" class="Keyword">field</a>
    <a id="1765" class="Comment">-- Composition is multilinear:</a>
    <a id="Ab-category.∘-linear-l"></a><a data-type="(r : is-abelian C) (f g : Hom C B₁ C) (h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) h) ((C ∘ g) h)
≡
(C ∘
 has-ab (has-additive (has-is-preab r)) .Group-on-hom B₁ C ._⋆_ f g)
h" id="1800" href="Cat.Abelian.Base.html#1800" class="Field">∘-linear-l</a>
      <a id="1817" class="Symbol">:</a> <a id="1819" class="Symbol">∀</a> <a id="1821" class="Symbol">{</a><a id="1822" href="Cat.Abelian.Base.html#1822" class="Bound">A</a> <a id="1824" href="Cat.Abelian.Base.html#1824" class="Bound">B</a> <a id="1826" href="Cat.Abelian.Base.html#1826" class="Bound">C</a><a id="1827" class="Symbol">}</a> <a id="1829" class="Symbol">(</a><a id="1830" href="Cat.Abelian.Base.html#1830" class="Bound">f</a> <a id="1832" href="Cat.Abelian.Base.html#1832" class="Bound">g</a> <a id="1834" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1836" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="1840" href="Cat.Abelian.Base.html#1824" class="Bound">B</a> <a id="1842" href="Cat.Abelian.Base.html#1826" class="Bound">C</a><a id="1843" class="Symbol">)</a> <a id="1845" class="Symbol">(</a><a id="1846" href="Cat.Abelian.Base.html#1846" class="Bound">h</a> <a id="1848" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1850" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="1854" href="Cat.Abelian.Base.html#1822" class="Bound">A</a> <a id="1856" href="Cat.Abelian.Base.html#1824" class="Bound">B</a><a id="1857" class="Symbol">)</a>
      <a id="1865" class="Symbol">→</a> <a id="1867" class="Symbol">(</a><a id="1868" href="Cat.Abelian.Base.html#1830" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="1870" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="1872" href="Cat.Abelian.Base.html#1846" class="Bound">h</a><a id="1873" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="1875" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="1877" class="Symbol">(</a><a id="1878" href="Cat.Abelian.Base.html#1832" class="Bound">g</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="1880" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="1882" href="Cat.Abelian.Base.html#1846" class="Bound">h</a><a id="1883" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="1885" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="1887" class="Symbol">(</a><a id="1888" href="Cat.Abelian.Base.html#1830" class="Bound">f</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="1890" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="1892" href="Cat.Abelian.Base.html#1832" class="Bound">g</a><a id="1893" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="1895" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="1897" href="Cat.Abelian.Base.html#1846" class="Bound">h</a>
    <a id="Ab-category.∘-linear-r"></a><a data-type="(r : is-abelian C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) g) ((C ∘ f) h)
≡
(C ∘ f)
(has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g
 h)" id="1903" href="Cat.Abelian.Base.html#1903" class="Field">∘-linear-r</a>
      <a id="1920" class="Symbol">:</a> <a id="1922" class="Symbol">∀</a> <a id="1924" class="Symbol">{</a><a id="1925" href="Cat.Abelian.Base.html#1925" class="Bound">A</a> <a id="1927" href="Cat.Abelian.Base.html#1927" class="Bound">B</a> <a id="1929" href="Cat.Abelian.Base.html#1929" class="Bound">C</a><a id="1930" class="Symbol">}</a> <a id="1932" class="Symbol">(</a><a id="1933" href="Cat.Abelian.Base.html#1933" class="Bound">f</a> <a id="1935" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1937" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="1941" href="Cat.Abelian.Base.html#1927" class="Bound">B</a> <a id="1943" href="Cat.Abelian.Base.html#1929" class="Bound">C</a><a id="1944" class="Symbol">)</a> <a id="1946" class="Symbol">(</a><a id="1947" href="Cat.Abelian.Base.html#1947" class="Bound">g</a> <a id="1949" href="Cat.Abelian.Base.html#1949" class="Bound">h</a> <a id="1951" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1953" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="1957" href="Cat.Abelian.Base.html#1925" class="Bound">A</a> <a id="1959" href="Cat.Abelian.Base.html#1927" class="Bound">B</a><a id="1960" class="Symbol">)</a>
      <a id="1968" class="Symbol">→</a> <a id="1970" class="Symbol">(</a><a id="1971" href="Cat.Abelian.Base.html#1933" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="1973" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="1975" href="Cat.Abelian.Base.html#1947" class="Bound">g</a><a id="1976" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="1978" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="1980" class="Symbol">(</a><a id="1981" href="Cat.Abelian.Base.html#1933" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="1983" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="1985" href="Cat.Abelian.Base.html#1949" class="Bound">h</a><a id="1986" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="1988" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="1990" href="Cat.Abelian.Base.html#1933" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="1992" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="1994" class="Symbol">(</a><a id="1995" href="Cat.Abelian.Base.html#1947" class="Bound">g</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="1997" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="1999" href="Cat.Abelian.Base.html#1949" class="Bound">h</a><a id="2000" class="Symbol">)</a>

  <a id="Ab-category.∘map"></a><a data-type="(r : is-abelian C) →
Hom (Hom-grp r B₁ C ⊗ Hom-grp r A B₁) (Hom-grp r A C)" id="2005" href="Cat.Abelian.Base.html#2005" class="Function">∘map</a> <a id="2010" class="Symbol">:</a> <a id="2012" class="Symbol">∀</a> <a id="2014" class="Symbol">{</a><a id="2015" href="Cat.Abelian.Base.html#2015" class="Bound">A</a> <a id="2017" href="Cat.Abelian.Base.html#2017" class="Bound">B</a> <a id="2019" href="Cat.Abelian.Base.html#2019" class="Bound">C</a><a id="2020" class="Symbol">}</a> <a id="2022" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="2024" href="Cat.Base.html#1436" class="Function">Ab.Hom</a> <a id="2031" class="Symbol">(</a><a data-type="(r : is-abelian C) (A : C .Ob) → C .Ob → AbGroup ℓ" id="2032" href="Cat.Abelian.Base.html#1662" class="Function">Hom-grp</a> <a id="2040" href="Cat.Abelian.Base.html#2017" class="Bound">B</a> <a id="2042" href="Cat.Abelian.Base.html#2019" class="Bound">C</a> <a data-type="(A B₁ : AbGroup ℓ) → AbGroup ℓ" id="2044" href="Algebra.Group.Ab.html#8398" class="Function Operator">⊗</a> <a data-type="(r : is-abelian C) (A : C .Ob) → C .Ob → AbGroup ℓ" id="2046" href="Cat.Abelian.Base.html#1662" class="Function">Hom-grp</a> <a id="2054" href="Cat.Abelian.Base.html#2015" class="Bound">A</a> <a id="2056" href="Cat.Abelian.Base.html#2017" class="Bound">B</a><a id="2057" class="Symbol">)</a> <a id="2059" class="Symbol">(</a><a data-type="(r : is-abelian C) (A : C .Ob) → C .Ob → AbGroup ℓ" id="2060" href="Cat.Abelian.Base.html#1662" class="Function">Hom-grp</a> <a id="2068" href="Cat.Abelian.Base.html#2015" class="Bound">A</a> <a id="2070" href="Cat.Abelian.Base.html#2019" class="Bound">C</a><a id="2071" class="Symbol">)</a>
  <a data-type="(r : is-abelian C) →
Hom (Hom-grp r B₁ C ⊗ Hom-grp r A B₁) (Hom-grp r A C)" id="2075" href="Cat.Abelian.Base.html#2005" class="Function">∘map</a> <a id="2080" class="Symbol">{</a><a id="2081" href="Cat.Abelian.Base.html#2081" class="Bound">A</a><a id="2082" class="Symbol">}</a> <a id="2084" class="Symbol">{</a><a id="2085" href="Cat.Abelian.Base.html#2085" class="Bound">B</a><a id="2086" class="Symbol">}</a> <a id="2088" class="Symbol">{</a><a id="2089" href="Cat.Abelian.Base.html#2089" class="Bound">C</a><a id="2090" class="Symbol">}</a> <a id="2092" class="Symbol">=</a>
    <a data-type="(f : ₀ A → ₀ B₁ → ₀ C) →
((x y : A .object .fst) (z : ₀ B₁) →
 f ((A ⋆ x) y) z ≡ (C ⋆ f x z) (f y z)) →
((x y : B₁ .object .fst) (z : ₀ A) →
 f z ((B₁ ⋆ x) y) ≡ (C ⋆ f z x) (f z y)) →
Hom (A ⊗ B₁) C" id="2098" href="Algebra.Group.Ab.html#10577" class="Function">from-multilinear-map</a> <a id="2119" class="Symbol">{</a><a id="2120" class="Argument">A</a> <a id="2122" class="Symbol">=</a> <a data-type="(r : is-abelian C) (A : C .Ob) → C .Ob → AbGroup ℓ" id="2124" href="Cat.Abelian.Base.html#1662" class="Function">Hom-grp</a> <a id="2132" href="Cat.Abelian.Base.html#2085" class="Bound">B</a> <a id="2134" href="Cat.Abelian.Base.html#2089" class="Bound">C</a><a id="2135" class="Symbol">}</a> <a id="2137" class="Symbol">{</a><a id="2138" class="Argument">B</a> <a id="2140" class="Symbol">=</a> <a data-type="(r : is-abelian C) (A : C .Ob) → C .Ob → AbGroup ℓ" id="2142" href="Cat.Abelian.Base.html#1662" class="Function">Hom-grp</a> <a id="2150" href="Cat.Abelian.Base.html#2081" class="Bound">A</a> <a id="2152" href="Cat.Abelian.Base.html#2085" class="Bound">B</a><a id="2153" class="Symbol">}</a> <a id="2155" class="Symbol">{</a><a id="2156" class="Argument">C</a> <a id="2158" class="Symbol">=</a> <a data-type="(r : is-abelian C) (A : C .Ob) → C .Ob → AbGroup ℓ" id="2160" href="Cat.Abelian.Base.html#1662" class="Function">Hom-grp</a> <a id="2168" href="Cat.Abelian.Base.html#2081" class="Bound">A</a> <a id="2170" href="Cat.Abelian.Base.html#2089" class="Bound">C</a><a id="2171" class="Symbol">}</a>
      <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2179" href="Cat.Base.html#3006" class="Function Operator">_∘_</a>
      <a id="2189" class="Symbol">(λ</a> <a id="2192" href="Cat.Abelian.Base.html#2192" class="Bound">f</a> <a id="2194" href="Cat.Abelian.Base.html#2194" class="Bound">g</a> <a id="2196" href="Cat.Abelian.Base.html#2196" class="Bound">h</a> <a id="2198" class="Symbol">→</a> <a data-type="x ≡ y → y ≡ x" id="2200" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="2204" class="Symbol">(</a><a data-type="(r : is-abelian C) (f g : Hom C B₁ C) (h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) h) ((C ∘ g) h)
≡
(C ∘
 has-ab (has-additive (has-is-preab r)) .Group-on-hom B₁ C ._⋆_ f g)
h" id="2205" href="Cat.Abelian.Base.html#1800" class="Field">∘-linear-l</a> <a id="2216" class="Symbol">_</a> <a id="2218" class="Symbol">_</a> <a id="2220" class="Symbol">_))</a>
      <a id="2230" class="Symbol">(λ</a> <a id="2233" href="Cat.Abelian.Base.html#2233" class="Bound">f</a> <a id="2235" href="Cat.Abelian.Base.html#2235" class="Bound">g</a> <a id="2237" href="Cat.Abelian.Base.html#2237" class="Bound">h</a> <a id="2239" class="Symbol">→</a> <a data-type="x ≡ y → y ≡ x" id="2241" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="2245" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) g) ((C ∘ f) h)
≡
(C ∘ f)
(has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g
 h)" id="2246" href="Cat.Abelian.Base.html#1903" class="Field">∘-linear-r</a> <a id="2257" class="Symbol">_</a> <a id="2259" class="Symbol">_</a> <a id="2261" class="Symbol">_))</a>

  <a id="2268" class="Keyword">module</a> <a id="Ab-category.Hom"></a><a id="2275" href="Cat.Abelian.Base.html#2275" class="Module">Hom</a> <a id="2279" class="Symbol">{</a><a id="2280" href="Cat.Abelian.Base.html#2280" class="Bound">A</a> <a id="2282" href="Cat.Abelian.Base.html#2282" class="Bound">B</a><a id="2283" class="Symbol">}</a> <a id="2285" class="Symbol">=</a> <a id="2287" href="Algebra.Group.Ab.html#1916" class="Module">AbGrp</a> <a id="2293" class="Symbol">(</a><a data-type="(r : is-abelian C) (A : C .Ob) → C .Ob → AbGroup ℓ" id="2294" href="Cat.Abelian.Base.html#1662" class="Function">Hom-grp</a> <a id="2302" href="Cat.Abelian.Base.html#2280" class="Bound">A</a> <a id="2304" href="Cat.Abelian.Base.html#2282" class="Bound">B</a><a id="2305" class="Symbol">)</a>
  <a id="2309" class="Keyword">open</a> <a id="2314" href="Cat.Abelian.Base.html#2275" class="Module">Hom</a>
    <a id="2322" class="Keyword">using</a> <a id="2328" class="Symbol">(</a><a data-type="(G : AbGroup ℓ) →
(has-is-group (G .object .snd) — x) y ≡
unit (has-is-group (G .object .snd)) →
x ≡ y" id="2329" href="Algebra.Group.html#2225" class="Function">zero-diff</a><a id="2338" class="Symbol">)</a>
    <a id="2344" class="Keyword">renaming</a> <a id="2353" class="Symbol">(</a><a data-type="(G : AbGroup ℓ) → G .object .fst → G .object .fst → G .object .fst" id="2354" href="Algebra.Group.html#1488" class="Function Operator">_—_</a> <a id="2358" class="Symbol">to</a> <a id="2361" class="Function Operator">_-_</a><a id="2364" class="Symbol">)</a>
    <a id="2370" class="Keyword">public</a>
</pre>
<p>Note that from multilinearity of composition, it follows that <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>f</mi><mo>=</mo><mi>f</mi><mn>0</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">0f = f0 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>:</span></p>
<pre class="Agda">  <a id="Ab-category.∘-zero-r"></a><a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ f) (0m r) ≡ 0m r" id="2470" href="Cat.Abelian.Base.html#2470" class="Function">∘-zero-r</a> <a id="2479" class="Symbol">:</a> <a id="2481" class="Symbol">∀</a> <a id="2483" class="Symbol">{</a><a id="2484" href="Cat.Abelian.Base.html#2484" class="Bound">A</a> <a id="2486" href="Cat.Abelian.Base.html#2486" class="Bound">B</a> <a id="2488" href="Cat.Abelian.Base.html#2488" class="Bound">C</a><a id="2489" class="Symbol">}</a> <a id="2491" class="Symbol">{</a><a id="2492" href="Cat.Abelian.Base.html#2492" class="Bound">f</a> <a id="2494" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="2496" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="2500" href="Cat.Abelian.Base.html#2486" class="Bound">B</a> <a id="2502" href="Cat.Abelian.Base.html#2488" class="Bound">C</a><a id="2503" class="Symbol">}</a> <a id="2505" class="Symbol">→</a> <a id="2507" href="Cat.Abelian.Base.html#2492" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2509" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2511" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a id="2514" class="Symbol">{</a><a id="2515" href="Cat.Abelian.Base.html#2484" class="Bound">A</a><a id="2516" class="Symbol">}</a> <a id="2518" class="Symbol">{</a><a id="2519" href="Cat.Abelian.Base.html#2486" class="Bound">B</a><a id="2520" class="Symbol">}</a> <a data-type="A → A → Type ℓ" id="2522" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2524" href="Cat.Abelian.Base.html#1533" class="Function">0m</a>
  <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ f) (0m r) ≡ 0m r" id="2529" href="Cat.Abelian.Base.html#2470" class="Function">∘-zero-r</a> <a id="2538" class="Symbol">{</a><a id="2539" class="Argument">f</a> <a id="2541" class="Symbol">=</a> <a id="2543" href="Cat.Abelian.Base.html#2543" class="Bound">f</a><a id="2544" class="Symbol">}</a> <a id="2546" class="Symbol">=</a>
    <a id="2552" href="Cat.Abelian.Base.html#2543" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2554" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2556" href="Cat.Abelian.Base.html#1533" class="Function">0m</a>                     <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2579" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → f ≡ (C ∘ f) a" id="2582" href="Cat.Reasoning.html#1250" class="Function">Hom.intror</a> <a data-type="(G : AbGroup ℓ) →
G .object .snd ._⋆_ x (has-is-group (G .object .snd) .inverse x) ≡
has-is-group (G .object .snd) .unit" id="2593" href="Algebra.Group.html#1387" class="Function">Hom.inverser</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2606" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="2612" href="Cat.Abelian.Base.html#2543" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2614" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2616" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2619" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="2621" class="Symbol">(</a><a id="2622" href="Cat.Abelian.Base.html#2543" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2624" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2626" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : is-abelian C) →
Hom-grp r A B₁ .object .fst →
Hom-grp r A B₁ .object .fst → Hom-grp r A B₁ .object .fst" id="2629" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="2631" href="Cat.Abelian.Base.html#2543" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2633" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2635" href="Cat.Abelian.Base.html#1533" class="Function">0m</a><a id="2637" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2639" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="is-semigroup _⋆₁_ → (x ⋆₁ (y ⋆₁ z)) ≡ ((x ⋆₁ y) ⋆₁ z)" id="2642" href="Algebra.Semigroup.html#453" class="Function">Hom.associative</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2658" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="2664" class="Symbol">(</a><a id="2665" href="Cat.Abelian.Base.html#2543" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2667" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2669" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2672" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="2674" href="Cat.Abelian.Base.html#2543" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2676" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2678" href="Cat.Abelian.Base.html#1533" class="Function">0m</a><a id="2680" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom-grp r A B₁ .object .fst →
Hom-grp r A B₁ .object .fst → Hom-grp r A B₁ .object .fst" id="2682" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="2684" href="Cat.Abelian.Base.html#2543" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2686" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2688" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2691" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="2694" href="1Lab.Path.html#20756" class="Function">ap</a> <a id="2697" class="Symbol">(</a><a data-type="(r : is-abelian C) →
Hom-grp r A B₁ .object .fst →
Hom-grp r A B₁ .object .fst → Hom-grp r A B₁ .object .fst" id="2698" href="Cat.Abelian.Base.html#2361" class="Function Operator">_-</a> <a id="2701" href="Cat.Abelian.Base.html#2543" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2703" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2705" href="Cat.Abelian.Base.html#1533" class="Function">0m</a><a id="2707" class="Symbol">)</a> <a id="2709" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) g) ((C ∘ f) h)
≡
(C ∘ f)
(has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g
 h)" id="2710" href="Cat.Abelian.Base.html#1903" class="Field">∘-linear-r</a> <a id="2721" class="Symbol">_</a> <a id="2723" class="Symbol">_</a> <a id="2725" class="Symbol">_)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2728" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="2734" class="Symbol">(</a><a id="2735" href="Cat.Abelian.Base.html#2543" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2737" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="2739" class="Symbol">(</a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2740" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2743" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2745" href="Cat.Abelian.Base.html#1533" class="Function">0m</a><a id="2747" class="Symbol">))</a> <a data-type="(r : is-abelian C) →
Hom-grp r A B₁ .object .fst →
Hom-grp r A B₁ .object .fst → Hom-grp r A B₁ .object .fst" id="2750" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="2752" href="Cat.Abelian.Base.html#2543" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2754" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2756" href="Cat.Abelian.Base.html#1533" class="Function">0m</a>   <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2761" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="2764" href="1Lab.Path.html#20756" class="Function">ap</a> <a id="2767" class="Symbol">((</a><a data-type="(r : is-abelian C) →
Hom-grp r A B₁ .object .fst →
Hom-grp r A B₁ .object .fst → Hom-grp r A B₁ .object .fst" id="2769" href="Cat.Abelian.Base.html#2361" class="Function Operator">_-</a> <a id="2772" href="Cat.Abelian.Base.html#2543" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2774" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2776" href="Cat.Abelian.Base.html#1533" class="Function">0m</a><a id="2778" class="Symbol">)</a> <a id="2780" href="Cat.Prelude.html#232" class="Function Operator">⊙</a> <a id="2782" class="Symbol">(</a><a id="2783" href="Cat.Abelian.Base.html#2543" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2785" href="Cat.Base.html#3006" class="Function Operator">∘_</a><a id="2787" class="Symbol">))</a> <a data-type="(r : Monoid-on A) → r ._⋆_ (r .identity) x ≡ x" id="2790" href="Algebra.Monoid.html#1088" class="Function">Hom.idl</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2798" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="2804" class="Symbol">(</a><a id="2805" href="Cat.Abelian.Base.html#2543" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2807" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2809" href="Cat.Abelian.Base.html#1533" class="Function">0m</a><a id="2811" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom-grp r A B₁ .object .fst →
Hom-grp r A B₁ .object .fst → Hom-grp r A B₁ .object .fst" id="2813" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="2815" href="Cat.Abelian.Base.html#2543" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2817" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2819" href="Cat.Abelian.Base.html#1533" class="Function">0m</a>          <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2831" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(G : AbGroup ℓ) →
G .object .snd ._⋆_ x (has-is-group (G .object .snd) .inverse x) ≡
has-is-group (G .object .snd) .unit" id="2834" href="Algebra.Group.html#1387" class="Function">Hom.inverser</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2847" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2853" href="Cat.Abelian.Base.html#1533" class="Function">0m</a>                         <a data-type="(x : A) → x ≡ x" id="2880" href="1Lab.Path.html#46957" class="Function Operator">∎</a>

  <a id="Ab-category.∘-zero-l"></a><a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ 0m r) f ≡ 0m r" id="2885" href="Cat.Abelian.Base.html#2885" class="Function">∘-zero-l</a> <a id="2894" class="Symbol">:</a> <a id="2896" class="Symbol">∀</a> <a id="2898" class="Symbol">{</a><a id="2899" href="Cat.Abelian.Base.html#2899" class="Bound">A</a> <a id="2901" href="Cat.Abelian.Base.html#2901" class="Bound">B</a> <a id="2903" href="Cat.Abelian.Base.html#2903" class="Bound">C</a><a id="2904" class="Symbol">}</a> <a id="2906" class="Symbol">{</a><a id="2907" href="Cat.Abelian.Base.html#2907" class="Bound">f</a> <a id="2909" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="2911" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="2915" href="Cat.Abelian.Base.html#2899" class="Bound">A</a> <a id="2917" href="Cat.Abelian.Base.html#2901" class="Bound">B</a><a id="2918" class="Symbol">}</a> <a id="2920" class="Symbol">→</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2922" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2925" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="2927" href="Cat.Abelian.Base.html#2907" class="Bound">f</a> <a data-type="A → A → Type ℓ" id="2929" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2931" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a id="2934" class="Symbol">{</a><a id="2935" href="Cat.Abelian.Base.html#2899" class="Bound">A</a><a id="2936" class="Symbol">}</a> <a id="2938" class="Symbol">{</a><a id="2939" href="Cat.Abelian.Base.html#2903" class="Bound">C</a><a id="2940" class="Symbol">}</a>
  <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ 0m r) f ≡ 0m r" id="2944" href="Cat.Abelian.Base.html#2885" class="Function">∘-zero-l</a> <a id="2953" class="Symbol">{</a><a id="2954" class="Argument">f</a> <a id="2956" class="Symbol">=</a> <a id="2958" href="Cat.Abelian.Base.html#2958" class="Bound">f</a><a id="2959" class="Symbol">}</a> <a id="2961" class="Symbol">=</a>
    <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2967" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2970" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="2972" href="Cat.Abelian.Base.html#2958" class="Bound">f</a>                                   <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3008" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → f ≡ (C ∘ a) f" id="3011" href="Cat.Reasoning.html#1207" class="Function">Hom.introl</a> <a data-type="(G : AbGroup ℓ) →
G .object .snd ._⋆_ (has-is-group (G .object .snd) .inverse x) x ≡
has-is-group (G .object .snd) .unit" id="3022" href="Algebra.Group.html#1341" class="Function">Hom.inversel</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3035" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="3041" class="Symbol">(</a><a data-type="(G : AbGroup ℓ) → G .object .fst → G .object .fst" id="3042" href="Algebra.Group.html#1320" class="Function">Hom.inverse</a> <a id="3054" class="Symbol">(</a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3055" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3058" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3060" href="Cat.Abelian.Base.html#2958" class="Bound">f</a><a id="3061" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3063" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3065" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3068" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3070" href="Cat.Abelian.Base.html#2958" class="Bound">f</a><a id="3071" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3073" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3075" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3078" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3080" href="Cat.Abelian.Base.html#2958" class="Bound">f</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3082" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="x ≡ y → y ≡ x" id="3085" href="1Lab.Path.html#10558" class="Function">sym</a> <a data-type="is-semigroup _⋆₁_ → (x ⋆₁ (y ⋆₁ z)) ≡ ((x ⋆₁ y) ⋆₁ z)" id="3089" href="Algebra.Semigroup.html#453" class="Function">Hom.associative</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3105" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a data-type="(G : AbGroup ℓ) → G .object .fst → G .object .fst" id="3111" href="Algebra.Group.html#1320" class="Function">Hom.inverse</a> <a id="3123" class="Symbol">(</a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3124" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3127" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3129" href="Cat.Abelian.Base.html#2958" class="Bound">f</a><a id="3130" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3132" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="3134" class="Symbol">(</a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3135" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3138" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3140" href="Cat.Abelian.Base.html#2958" class="Bound">f</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3142" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3144" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3147" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3149" href="Cat.Abelian.Base.html#2958" class="Bound">f</a><a id="3150" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3152" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="3155" href="1Lab.Path.html#20756" class="Function">ap</a> <a id="3158" class="Symbol">(</a><a data-type="(G : AbGroup ℓ) → G .object .fst → G .object .fst" id="3159" href="Algebra.Group.html#1320" class="Function">Hom.inverse</a> <a id="3171" class="Symbol">(</a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3172" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3175" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3177" href="Cat.Abelian.Base.html#2958" class="Bound">f</a><a id="3178" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3180" href="Cat.Abelian.Base.html#1445" class="Function Operator">+_</a><a id="3182" class="Symbol">)</a> <a id="3184" class="Symbol">(</a><a data-type="(r : is-abelian C) (f g : Hom C B₁ C) (h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) h) ((C ∘ g) h)
≡
(C ∘
 has-ab (has-additive (has-is-preab r)) .Group-on-hom B₁ C ._⋆_ f g)
h" id="3185" href="Cat.Abelian.Base.html#1800" class="Field">∘-linear-l</a> <a id="3196" class="Symbol">_</a> <a id="3198" class="Symbol">_</a> <a id="3200" class="Symbol">_)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3203" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a data-type="(G : AbGroup ℓ) → G .object .fst → G .object .fst" id="3209" href="Algebra.Group.html#1320" class="Function">Hom.inverse</a> <a id="3221" class="Symbol">(</a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3222" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3225" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3227" href="Cat.Abelian.Base.html#2958" class="Bound">f</a><a id="3228" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3230" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="3232" class="Symbol">((</a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3234" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3237" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3239" href="Cat.Abelian.Base.html#1533" class="Function">0m</a><a id="3241" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3243" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3245" href="Cat.Abelian.Base.html#2958" class="Bound">f</a><a id="3246" class="Symbol">)</a>   <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3250" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="3253" href="1Lab.Path.html#20756" class="Function">ap</a> <a id="3256" class="Symbol">((</a><a data-type="(G : AbGroup ℓ) → G .object .fst → G .object .fst" id="3258" href="Algebra.Group.html#1320" class="Function">Hom.inverse</a> <a id="3270" class="Symbol">(</a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3271" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3274" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3276" href="Cat.Abelian.Base.html#2958" class="Bound">f</a><a id="3277" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3279" href="Cat.Abelian.Base.html#1445" class="Function Operator">+_</a><a id="3281" class="Symbol">)</a> <a id="3283" href="Cat.Prelude.html#232" class="Function Operator">⊙</a> <a id="3285" class="Symbol">(</a><a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3286" href="Cat.Base.html#3006" class="Function Operator">_∘</a> <a id="3289" href="Cat.Abelian.Base.html#2958" class="Bound">f</a><a id="3290" class="Symbol">))</a> <a data-type="(r : Monoid-on A) → r ._⋆_ (r .identity) x ≡ x" id="3293" href="Algebra.Monoid.html#1088" class="Function">Hom.idl</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3301" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a data-type="(G : AbGroup ℓ) → G .object .fst → G .object .fst" id="3307" href="Algebra.Group.html#1320" class="Function">Hom.inverse</a> <a id="3319" class="Symbol">(</a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3320" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3323" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3325" href="Cat.Abelian.Base.html#2958" class="Bound">f</a><a id="3326" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3328" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="3330" class="Symbol">(</a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3331" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3334" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3336" href="Cat.Abelian.Base.html#2958" class="Bound">f</a><a id="3337" class="Symbol">)</a>          <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3348" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(G : AbGroup ℓ) →
G .object .snd ._⋆_ (has-is-group (G .object .snd) .inverse x) x ≡
has-is-group (G .object .snd) .unit" id="3351" href="Algebra.Group.html#1341" class="Function">Hom.inversel</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3364" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3370" href="Cat.Abelian.Base.html#1533" class="Function">0m</a>                                       <a data-type="(x : A) → x ≡ x" id="3411" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
</pre>
<p>Before moving on, we note the following property of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">\Ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathbf">Ab</span></span></span></span></span>-categories:</span> If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> is an object s.t. <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mi>A</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\id{id}_{A} = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">id</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>,</span> then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> is a zero object.</p>
<pre class="Agda"><a id="3568" class="Keyword">module</a> <a id="3575" href="Cat.Abelian.Base.html#3575" class="Module">_</a> <a id="3577" class="Symbol">{</a><a id="3578" href="Cat.Abelian.Base.html#3578" class="Bound">o</a> <a id="3580" href="Cat.Abelian.Base.html#3580" class="Bound">ℓ</a><a id="3581" class="Symbol">}</a> <a id="3583" class="Symbol">{</a><a id="3584" href="Cat.Abelian.Base.html#3584" class="Bound">C</a> <a id="3586" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="3588" href="Cat.Base.html#704" class="Record">Precategory</a> <a id="3600" href="Cat.Abelian.Base.html#3578" class="Bound">o</a> <a id="3602" href="Cat.Abelian.Base.html#3580" class="Bound">ℓ</a><a id="3603" class="Symbol">}</a> <a id="3605" class="Symbol">(</a><a id="3606" href="Cat.Abelian.Base.html#3606" class="Bound">A</a> <a id="3608" class="Symbol">:</a> <a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="3610" href="Cat.Abelian.Base.html#1302" class="Record">Ab-category</a> <a id="3622" href="Cat.Abelian.Base.html#3584" class="Bound">C</a><a id="3623" class="Symbol">)</a> <a id="3625" class="Keyword">where</a>
  <a id="3633" class="Keyword">private</a> <a id="3641" class="Keyword">module</a> <a id="3648" href="Cat.Abelian.Base.html#3648" class="Module">A</a> <a id="3650" class="Symbol">=</a> <a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="3652" href="Cat.Abelian.Base.html#1302" class="Module">Ab-category</a> <a id="3664" href="Cat.Abelian.Base.html#3606" class="Bound">A</a>

  <a data-type="(A : Ab-category C) → id A ≡ 0m A → is-zero A A₁" id="3669" href="Cat.Abelian.Base.html#3669" class="Function">id-zero→zero</a> <a id="3682" class="Symbol">:</a> <a id="3684" class="Symbol">∀</a> <a id="3686" class="Symbol">{</a><a id="3687" href="Cat.Abelian.Base.html#3687" class="Bound">A</a><a id="3688" class="Symbol">}</a> <a id="3690" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="3692" href="Cat.Base.html#2976" class="Function">A.id</a> <a id="3697" class="Symbol">{</a><a id="3698" href="Cat.Abelian.Base.html#3687" class="Bound">A</a><a id="3699" class="Symbol">}</a> <a data-type="A → A → Type ℓ" id="3701" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3703" href="Cat.Abelian.Base.html#1533" class="Function">A.0m</a> <a id="3708" class="Symbol">→</a> <a data-type="(C : Precategory o h) (ob : Ob C) → Type (o ⊔ h)" id="3710" href="Cat.Diagram.Zero.html#408" class="Record">A.is-zero</a> <a id="3720" href="Cat.Abelian.Base.html#3687" class="Bound">A</a>
  <a data-type="(A : Ab-category C) → id A ≡ 0m A → is-zero A A₁" id="3724" href="Cat.Abelian.Base.html#3669" class="Function">id-zero→zero</a> <a id="3737" href="Cat.Abelian.Base.html#3737" class="Bound">idm</a> <a id="3741" class="Symbol">.</a><a data-type="(r : Zero C) → is-initial C (r .∅)" id="3742" href="Cat.Diagram.Zero.html#459" class="Field">A.is-zero.has-is-initial</a> <a id="3767" href="Cat.Abelian.Base.html#3767" class="Bound">B</a> <a id="3769" class="Symbol">=</a> <a data-type="(centre₁ : A) (paths₁ : (x : A) → centre₁ ≡ x) → is-contr A" id="3771" href="1Lab.HLevel.html#1383" class="InductiveConstructor">contr</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3777" href="Cat.Abelian.Base.html#1533" class="Function">A.0m</a> <a id="3782" class="Symbol">λ</a> <a id="3784" href="Cat.Abelian.Base.html#3784" class="Bound">h</a> <a id="3786" class="Symbol">→</a> <a data-type="x ≡ y → y ≡ x" id="3788" href="1Lab.Path.html#10558" class="Function">sym</a> <a data-type="((x : A) → B₁ x) → (x : A) → B₁ x" id="3792" href="1Lab.Type.html#2481" class="Function Operator">$</a>
    <a id="3798" href="Cat.Abelian.Base.html#3784" class="Bound">h</a>                                <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3831" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → f ≡ (C ∘ f) a" id="3834" href="Cat.Reasoning.html#1250" class="Function">A.intror</a> <a data-type="x ≡ x" id="3843" href="1Lab.Path.html#3593" class="Function">refl</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3848" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="3854" href="Cat.Abelian.Base.html#3784" class="Bound">h</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3856" href="Cat.Base.html#3006" class="Function Operator">A.∘</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="3860" href="Cat.Base.html#2976" class="Function">A.id</a>                       <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3887" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) → g ≡ h → (C ∘ f) g ≡ (C ∘ f) h" id="3890" href="Cat.Reasoning.html#4627" class="Function Operator">A.refl⟩∘⟨</a> <a id="3900" href="Cat.Abelian.Base.html#3737" class="Bound">idm</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3904" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="3910" href="Cat.Abelian.Base.html#3784" class="Bound">h</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3912" href="Cat.Base.html#3006" class="Function Operator">A.∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3916" href="Cat.Abelian.Base.html#1533" class="Function">A.0m</a>                       <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3943" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ f) (0m r) ≡ 0m r" id="3946" href="Cat.Abelian.Base.html#2470" class="Function">A.∘-zero-r</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3957" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3963" href="Cat.Abelian.Base.html#1533" class="Function">A.0m</a>                             <a data-type="(x : A) → x ≡ x" id="3996" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
  <a data-type="(A : Ab-category C) → id A ≡ 0m A → is-zero A A₁" id="4000" href="Cat.Abelian.Base.html#3669" class="Function">id-zero→zero</a> <a id="4013" href="Cat.Abelian.Base.html#4013" class="Bound">idm</a> <a id="4017" class="Symbol">.</a><a data-type="(r : Zero C) → is-terminal C (r .∅)" id="4018" href="Cat.Diagram.Zero.html#495" class="Field">A.is-zero.has-is-terminal</a> <a id="4044" href="Cat.Abelian.Base.html#4044" class="Bound">x</a> <a id="4046" class="Symbol">=</a> <a data-type="(centre₁ : A) (paths₁ : (x : A) → centre₁ ≡ x) → is-contr A" id="4048" href="1Lab.HLevel.html#1383" class="InductiveConstructor">contr</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="4054" href="Cat.Abelian.Base.html#1533" class="Function">A.0m</a> <a id="4059" class="Symbol">λ</a> <a id="4061" href="Cat.Abelian.Base.html#4061" class="Bound">h</a> <a id="4063" class="Symbol">→</a> <a data-type="x ≡ y → y ≡ x" id="4065" href="1Lab.Path.html#10558" class="Function">sym</a> <a data-type="((x : A) → B₁ x) → (x : A) → B₁ x" id="4069" href="1Lab.Type.html#2481" class="Function Operator">$</a>
    <a id="4075" href="Cat.Abelian.Base.html#4061" class="Bound">h</a>                              <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="4106" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → f ≡ (C ∘ a) f" id="4109" href="Cat.Reasoning.html#1207" class="Function">A.introl</a> <a data-type="x ≡ x" id="4118" href="1Lab.Path.html#3593" class="Function">refl</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="4123" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a data-type="(r : Precategory o h) → r .Hom x x" id="4129" href="Cat.Base.html#2976" class="Function">A.id</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="4134" href="Cat.Base.html#3006" class="Function Operator">A.∘</a> <a id="4138" href="Cat.Abelian.Base.html#4061" class="Bound">h</a>                     <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="4160" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a id="4163" href="Cat.Abelian.Base.html#4013" class="Bound">idm</a> <a data-type="(C : Precategory o ℓ) → f ≡ h → (C ∘ f) g ≡ (C ∘ h) g" id="4167" href="Cat.Reasoning.html#4694" class="Function Operator">A.⟩∘⟨refl</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="4177" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="4183" href="Cat.Abelian.Base.html#1533" class="Function">A.0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="4188" href="Cat.Base.html#3006" class="Function Operator">A.∘</a> <a id="4192" href="Cat.Abelian.Base.html#4061" class="Bound">h</a>                     <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="4214" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ 0m r) f ≡ 0m r" id="4217" href="Cat.Abelian.Base.html#2885" class="Function">A.∘-zero-l</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="4228" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="4234" href="Cat.Abelian.Base.html#1533" class="Function">A.0m</a>                           <a data-type="(x : A) → x ≡ x" id="4265" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
</pre>
<p>Perhaps the simplest example of an <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">\Ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathbf">Ab</span></span></span></span></span>-category</span> is.. any ring! In the same way that a monoid is a category with one object, and a group is a groupoid with one object, a ring is a <em>ringoid</em> with one object; Ringoid being another word for <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">\Ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathbf">Ab</span></span></span></span></span>-category,</span> rather than a horizontal categorification of the drummer for the Beatles. The next simplest example is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">\Ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathbf">Ab</span></span></span></span></span> itself:</p>
<pre class="Agda"><a id="4653" class="Keyword">module</a> <a id="4660" href="Cat.Abelian.Base.html#4660" class="Module">_</a> <a id="4662" class="Keyword">where</a>
  <a id="4670" class="Keyword">open</a> <a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="4675" href="Cat.Abelian.Base.html#1302" class="Module">Ab-category</a>
  <a data-type="Ab-category (Ab ℓ)" id="4689" href="Cat.Abelian.Base.html#4689" class="Function">Ab-ab-category</a> <a id="4704" class="Symbol">:</a> <a id="4706" class="Symbol">∀</a> <a id="4708" class="Symbol">{</a><a id="4709" href="Cat.Abelian.Base.html#4709" class="Bound">ℓ</a><a id="4710" class="Symbol">}</a> <a id="4712" class="Symbol">→</a> <a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="4714" href="Cat.Abelian.Base.html#1302" class="Record">Ab-category</a> <a id="4726" class="Symbol">(</a><a data-type="(ℓ : Level) → Precategory (lsuc ℓ) ℓ" id="4727" href="Algebra.Group.Ab.html#1491" class="Function">Ab</a> <a id="4730" href="Cat.Abelian.Base.html#4709" class="Bound">ℓ</a><a id="4731" class="Symbol">)</a>
  <a data-type="Ab-category (Ab ℓ)" id="4735" href="Cat.Abelian.Base.html#4689" class="Function">Ab-ab-category</a> <a id="4750" class="Symbol">.</a><a data-type="(r : is-abelian C) (A B₁ : C .Ob) → Group-on (Hom C A B₁)" id="4751" href="Cat.Abelian.Base.html#1400" class="Field">Group-on-hom</a> <a id="4764" href="Cat.Abelian.Base.html#4764" class="Bound">A</a> <a id="4766" href="Cat.Abelian.Base.html#4766" class="Bound">B</a> <a id="4768" class="Symbol">=</a> <a data-type="(A B₁ : AbGroup ℓ) → AbGroup ℓ" id="4770" href="Algebra.Group.Ab.html#3543" class="Function">Hom-group</a> <a id="4780" href="Cat.Abelian.Base.html#4764" class="Bound">A</a> <a id="4782" href="Cat.Abelian.Base.html#4766" class="Bound">B</a> <a id="4784" class="Symbol">.</a><a data-type="Restrict-ob P → Ob C" id="4785" href="Cat.Functor.FullSubcategory.html#1063" class="Field">object</a> <a id="4792" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="4793" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a>
  <a data-type="Ab-category (Ab ℓ)" id="4799" href="Cat.Abelian.Base.html#4689" class="Function">Ab-ab-category</a> <a id="4814" class="Symbol">.</a><a data-type="(r : is-abelian C) (A B₁ : C .Ob) (f g : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ f g
≡
has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g f" id="4815" href="Cat.Abelian.Base.html#1608" class="Field">Hom-grp-ab</a> <a id="4826" href="Cat.Abelian.Base.html#4826" class="Bound">A</a> <a id="4828" href="Cat.Abelian.Base.html#4828" class="Bound">B</a> <a id="4830" class="Symbol">=</a> <a data-type="(A B₁ : AbGroup ℓ) → AbGroup ℓ" id="4832" href="Algebra.Group.Ab.html#3543" class="Function">Hom-group</a> <a id="4842" href="Cat.Abelian.Base.html#4826" class="Bound">A</a> <a id="4844" href="Cat.Abelian.Base.html#4828" class="Bound">B</a> <a id="4846" class="Symbol">.</a><a data-type="(r : Restrict-ob P) → P (r .object)" id="4847" href="Cat.Functor.FullSubcategory.html#1081" class="Field">witness</a>
  <a data-type="Ab-category (Ab ℓ)" id="4857" href="Cat.Abelian.Base.html#4689" class="Function">Ab-ab-category</a> <a id="4872" class="Symbol">.</a><a data-type="(r : is-abelian C) (f g : Hom C B₁ C) (h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) h) ((C ∘ g) h)
≡
(C ∘
 has-ab (has-additive (has-is-preab r)) .Group-on-hom B₁ C ._⋆_ f g)
h" id="4873" href="Cat.Abelian.Base.html#1800" class="Field">∘-linear-l</a> <a id="4884" href="Cat.Abelian.Base.html#4884" class="Bound">f</a> <a id="4886" href="Cat.Abelian.Base.html#4886" class="Bound">g</a> <a id="4888" href="Cat.Abelian.Base.html#4888" class="Bound">h</a> <a id="4890" class="Symbol">=</a> <a data-type="is-faithful Forget" id="4892" href="Algebra.Group.Cat.Base.html#1867" class="Function">Grp.Forget-is-faithful</a> <a data-type="x ≡ x" id="4915" href="1Lab.Path.html#3593" class="Function">refl</a>
  <a data-type="Ab-category (Ab ℓ)" id="4922" href="Cat.Abelian.Base.html#4689" class="Function">Ab-ab-category</a> <a id="4937" class="Symbol">.</a><a data-type="(r : is-abelian C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) g) ((C ∘ f) h)
≡
(C ∘ f)
(has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g
 h)" id="4938" href="Cat.Abelian.Base.html#1903" class="Field">∘-linear-r</a> <a id="4949" href="Cat.Abelian.Base.html#4949" class="Bound">f</a> <a id="4951" href="Cat.Abelian.Base.html#4951" class="Bound">g</a> <a id="4953" href="Cat.Abelian.Base.html#4953" class="Bound">h</a> <a id="4955" class="Symbol">=</a> <a data-type="is-faithful Forget" id="4957" href="Algebra.Group.Cat.Base.html#1867" class="Function">Grp.Forget-is-faithful</a> <a data-type="((x : A) → B₁ x) → (x : A) → B₁ x" id="4980" href="1Lab.Type.html#2481" class="Function Operator">$</a> <a data-type="((x : A) → f x ≡ g x) → f ≡ g" id="4982" href="1Lab.Path.html#58486" class="Function">funext</a> <a id="4989" class="Symbol">λ</a> <a id="4991" href="Cat.Abelian.Base.html#4991" class="Bound">x</a> <a id="4993" class="Symbol">→</a>
    <a data-type="x ≡ y → y ≡ x" id="4999" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="5003" class="Symbol">(</a><a id="5004" href="Cat.Abelian.Base.html#4949" class="Bound">f</a> <a id="5006" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="5007" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="5011" class="Symbol">.</a><a data-type="Group-hom A B₁ e →
(x y : A .fst) → e (A .snd ._⋆_ x y) ≡ B₁ .snd ._⋆_ (e x) (e y)" id="5012" href="Algebra.Group.html#6284" class="Field">Group-hom.pres-⋆</a> <a id="5029" class="Symbol">_</a> <a id="5031" class="Symbol">_)</a>
</pre>
<h1 id="additive-categories"><a href="#additive-categories" class="header-link">Additive categories<span class="header-link-emoji">🔗</span></a></h1>
<p>An <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">\Ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathbf">Ab</span></span></span></span></span>-category</span> is <strong>additive</strong> when its underlying category has a terminal object and finite products; By the yoga above, this implies that the terminal object is also a zero object, and the finite products coincide with finite coproducts.</p>
<pre class="Agda"><a id="5314" class="Keyword">record</a> <a id="is-additive"></a><a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="5321" href="Cat.Abelian.Base.html#5321" class="Record">is-additive</a> <a id="5333" class="Symbol">{</a><a id="5334" href="Cat.Abelian.Base.html#5334" class="Bound">o</a> <a id="5336" href="Cat.Abelian.Base.html#5336" class="Bound">ℓ</a><a id="5337" class="Symbol">}</a> <a id="5339" class="Symbol">(</a><a id="5340" href="Cat.Abelian.Base.html#5340" class="Bound">C</a> <a id="5342" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="5344" href="Cat.Base.html#704" class="Record">Precategory</a> <a id="5356" href="Cat.Abelian.Base.html#5334" class="Bound">o</a> <a id="5358" href="Cat.Abelian.Base.html#5336" class="Bound">ℓ</a><a id="5359" class="Symbol">)</a> <a id="5361" class="Symbol">:</a> <a id="5363" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="5368" class="Symbol">(</a><a id="5369" href="Cat.Abelian.Base.html#5334" class="Bound">o</a> <a data-type="Level → Level → Level" id="5371" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a data-type="Level → Level" id="5373" href="Agda.Primitive.html#780" class="Primitive">lsuc</a> <a id="5378" href="Cat.Abelian.Base.html#5336" class="Bound">ℓ</a><a id="5379" class="Symbol">)</a> <a id="5381" class="Keyword">where</a>
  <a id="5389" class="Keyword">field</a> <a id="is-additive.has-ab"></a><a data-type="(r : is-abelian C) → Ab-category C" id="5395" href="Cat.Abelian.Base.html#5395" class="Field">has-ab</a> <a id="5402" class="Symbol">:</a> <a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="5404" href="Cat.Abelian.Base.html#1302" class="Record">Ab-category</a> <a id="5416" href="Cat.Abelian.Base.html#5340" class="Bound">C</a>
  <a id="5420" class="Keyword">open</a> <a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="5425" href="Cat.Abelian.Base.html#1302" class="Module">Ab-category</a> <a data-type="(r : is-abelian C) → Ab-category C" id="5437" href="Cat.Abelian.Base.html#5395" class="Field">has-ab</a> <a id="5444" class="Keyword">public</a>

  <a id="5454" class="Keyword">field</a>
    <a id="is-additive.has-terminal"></a><a data-type="(r : is-abelian C) → Terminal r" id="5464" href="Cat.Abelian.Base.html#5464" class="Field">has-terminal</a> <a id="5477" class="Symbol">:</a> <a data-type="(C : Precategory o h) → Type (o ⊔ h)" id="5479" href="Cat.Diagram.Terminal.html#406" class="Record">Terminal</a>
    <a id="is-additive.has-prods"></a><a data-type="(r : is-abelian C) (A B₁ : Ob C) → Product r A B₁" id="5492" href="Cat.Abelian.Base.html#5492" class="Field">has-prods</a>    <a id="5505" class="Symbol">:</a> <a id="5507" class="Symbol">∀</a> <a id="5509" href="Cat.Abelian.Base.html#5509" class="Bound">A</a> <a id="5511" href="Cat.Abelian.Base.html#5511" class="Bound">B</a> <a id="5513" class="Symbol">→</a> <a data-type="(C : Precategory o h) (A B₁ : Ob C) → Type (o ⊔ h)" id="5515" href="Cat.Diagram.Product.html#2703" class="Record">Product</a> <a id="5523" href="Cat.Abelian.Base.html#5509" class="Bound">A</a> <a id="5525" href="Cat.Abelian.Base.html#5511" class="Bound">B</a>

  <a id="is-additive.∅"></a><a data-type="(r : is-abelian C) → Zero r" id="5530" href="Cat.Abelian.Base.html#5530" class="Function">∅</a> <a id="5532" class="Symbol">:</a> <a data-type="(C : Precategory o h) → Type (o ⊔ h)" id="5534" href="Cat.Diagram.Zero.html#536" class="Record">Zero</a>
  <a data-type="(r : is-abelian C) → Zero r" id="5541" href="Cat.Abelian.Base.html#5530" class="Function">∅</a> <a id="5543" class="Symbol">.</a><a data-type="Zero C → Ob C" id="5544" href="Cat.Diagram.Zero.html#574" class="Field">Zero.∅</a> <a id="5551" class="Symbol">=</a> <a data-type="(r : is-abelian C) → Terminal r" id="5553" href="Cat.Abelian.Base.html#5464" class="Field">has-terminal</a> <a id="5566" class="Symbol">.</a><a data-type="Terminal C → Ob C" id="5567" href="Cat.Diagram.Terminal.html#448" class="Field">Terminal.top</a>
  <a data-type="(r : is-abelian C) → Zero r" id="5582" href="Cat.Abelian.Base.html#5530" class="Function">∅</a> <a id="5584" class="Symbol">.</a><a data-type="(r : Zero C) → is-zero C (r .∅)" id="5585" href="Cat.Diagram.Zero.html#591" class="Field">Zero.has-is-zero</a> <a id="5602" class="Symbol">=</a> <a data-type="(A : Ab-category C) → id A ≡ 0m A → is-zero A A₁" id="5604" href="Cat.Abelian.Base.html#3669" class="Function">id-zero→zero</a> <a data-type="(r : is-abelian C) → Ab-category C" id="5617" href="Cat.Abelian.Base.html#5395" class="Field">has-ab</a> <a data-type="((x : A) → B₁ x) → (x : A) → B₁ x" id="5624" href="1Lab.Type.html#2481" class="Function Operator">$</a>
    <a data-type="is-contr A → is-prop A" id="5630" href="1Lab.HLevel.html#3818" class="Function">is-contr→is-prop</a> <a id="5647" class="Symbol">(</a><a data-type="(r : is-abelian C) → Terminal r" id="5648" href="Cat.Abelian.Base.html#5464" class="Field">has-terminal</a> <a id="5661" class="Symbol">.</a><a data-type="(r : Terminal C) → is-terminal C (r .top)" id="5662" href="Cat.Diagram.Terminal.html#461" class="Field">Terminal.has⊤</a> <a id="5676" class="Symbol">_)</a> <a id="5679" class="Symbol">_</a> <a id="5681" class="Symbol">_</a>
  <a id="5685" class="Keyword">module</a> <a id="is-additive.∅"></a><a id="5692" href="Cat.Abelian.Base.html#5692" class="Module">∅</a> <a id="5694" class="Symbol">=</a> <a data-type="(C : Precategory o h) → Type (o ⊔ h)" id="5696" href="Cat.Diagram.Zero.html#536" class="Module">Zero</a> <a data-type="(r : is-abelian C) → Zero r" id="5701" href="Cat.Abelian.Base.html#5530" class="Function">∅</a>
</pre>
<p>Coincidence of finite products and finite coproducts leads to an object commonly called a (finite) <strong>biproduct</strong>. The coproduct coprojections are given by the pair of maps</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo>×</mo><mn>0</mn><mo stretchy="false">)</mo><mo>:</mo><mi>A</mi><mo>→</mo><mi>A</mi><mo>×</mo><mi>B</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo stretchy="false">(</mo><mn>0</mn><mo>×</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo stretchy="false">)</mo><mo>:</mo><mi>B</mi><mo>→</mo><mi>A</mi><mo>×</mo><mi>B</mi><mtext>,</mtext></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{align*}
&amp;(\id{id} \times 0) : A \to A \times B \\
&amp;(0 \times \id{id}) : B \to A \times B\text{,}
\end{align*}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.75em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">id</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathrm">id</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord text"><span class="mord">,</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>respectively, and the comultiplication of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> is given by <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><msub><mi>π</mi><mn>1</mn></msub><mo>+</mo><mi>g</mi><msub><mi>π</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">f\pi_1 + g\pi_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span> We can calculate, for the first coprojection followed by comultiplication,</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo stretchy="false">(</mo><mi>f</mi><msub><mi>π</mi><mn>1</mn></msub><mo>+</mo><mi>g</mi><msub><mi>π</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo>×</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>f</mi><msub><mi>π</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo>×</mo><mn>0</mn><mo stretchy="false">)</mo><mo>+</mo><mi>g</mi><msub><mi>π</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo>×</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>f</mi><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo>+</mo><mi>g</mi><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>f</mi><mo>×</mo><mo separator="true" lspace="0em" rspace="0em">,</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{align*}
&amp; (f\pi_1+g\pi_2)(\id{id}\times 0) \\
=&amp; f\pi_1(\id{id}\times 0) + g\pi_2(\id{id}\times 0) \\
=&amp; f\id{id} + g0 \\
=&amp; f\times{,}
\end{align*}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6em;vertical-align:-2.75em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">=</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">=</span></span></span><span style="top:-0.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">=</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">id</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">id</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">id</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathrm">id</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">0</span></span></span><span style="top:-0.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mpunct">,</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>and analogously for the second coprojection followed by comultiplication.</p>
<pre class="Agda">  <a id="is-additive.has-coprods"></a><a data-type="(r : is-abelian C) (A B₁ : Ob C) → Coproduct r A B₁" id="6414" href="Cat.Abelian.Base.html#6414" class="Function">has-coprods</a> <a id="6426" class="Symbol">:</a> <a id="6428" class="Symbol">∀</a> <a id="6430" href="Cat.Abelian.Base.html#6430" class="Bound">A</a> <a id="6432" href="Cat.Abelian.Base.html#6432" class="Bound">B</a> <a id="6434" class="Symbol">→</a> <a data-type="(C : Precategory o h) (A B₁ : Ob C) → Type (o ⊔ h)" id="6436" href="Cat.Diagram.Coproduct.html#1758" class="Record">Coproduct</a> <a id="6446" href="Cat.Abelian.Base.html#6430" class="Bound">A</a> <a id="6448" href="Cat.Abelian.Base.html#6432" class="Bound">B</a>
  <a data-type="(r : is-abelian C) (A B₁ : Ob C) → Coproduct r A B₁" id="6452" href="Cat.Abelian.Base.html#6414" class="Function">has-coprods</a> <a id="6464" href="Cat.Abelian.Base.html#6464" class="Bound">A</a> <a id="6466" href="Cat.Abelian.Base.html#6466" class="Bound">B</a> <a id="6468" class="Symbol">=</a> <a id="6470" href="Cat.Abelian.Base.html#6570" class="Function">coprod</a> <a id="6477" class="Keyword">where</a>
    <a id="6487" class="Keyword">open</a> <a data-type="(C : Precategory o h) (A B₁ : Ob C) → Type (o ⊔ h)" id="6492" href="Cat.Diagram.Coproduct.html#1758" class="Module">Coproduct</a>
    <a id="6506" class="Keyword">open</a> <a data-type="(C : Precategory o h) (in₀ : Hom C A P) (in₁ : Hom C B₁ P) →
Type (o ⊔ h)" id="6511" href="Cat.Diagram.Coproduct.html#924" class="Module">is-coproduct</a>
    <a id="6528" class="Keyword">module</a> <a id="6535" href="Cat.Abelian.Base.html#6535" class="Module">Prod</a> <a id="6540" class="Symbol">=</a> <a data-type="(C : Precategory o h) (A B₁ : Ob C) → Type (o ⊔ h)" id="6542" href="Cat.Diagram.Product.html#2703" class="Module">Product</a> <a id="6550" class="Symbol">(</a><a data-type="(r : is-abelian C) (A B₁ : Ob C) → Product r A B₁" id="6551" href="Cat.Abelian.Base.html#5492" class="Field">has-prods</a> <a id="6561" href="Cat.Abelian.Base.html#6464" class="Bound">A</a> <a id="6563" href="Cat.Abelian.Base.html#6466" class="Bound">B</a><a id="6564" class="Symbol">)</a>
    <a id="6570" href="Cat.Abelian.Base.html#6570" class="Function">coprod</a> <a id="6577" class="Symbol">:</a> <a data-type="(C : Precategory o h) (A B₁ : Ob C) → Type (o ⊔ h)" id="6579" href="Cat.Diagram.Coproduct.html#1758" class="Record">Coproduct</a> <a id="6589" href="Cat.Abelian.Base.html#6464" class="Bound">A</a> <a id="6591" href="Cat.Abelian.Base.html#6466" class="Bound">B</a>
    <a id="6597" href="Cat.Abelian.Base.html#6570" class="Function">coprod</a> <a id="6604" class="Symbol">.</a><a data-type="Coproduct C A B₁ → Ob C" id="6605" href="Cat.Diagram.Coproduct.html#1812" class="Field">coapex</a> <a id="6612" class="Symbol">=</a> <a data-type="Product C A B₁ → Ob C" id="6614" href="Cat.Diagram.Product.html#2773" class="Function">Prod.apex</a>
    <a id="6628" href="Cat.Abelian.Base.html#6570" class="Function">coprod</a> <a id="6635" class="Symbol">.</a><a data-type="(r : Coproduct C A B₁) → Hom C A (r .coapex)" id="6636" href="Cat.Diagram.Coproduct.html#1828" class="Field">in₀</a> <a id="6640" class="Symbol">=</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="6642" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="6649" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="6652" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="6654" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="6657" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span>
    <a id="6663" href="Cat.Abelian.Base.html#6570" class="Function">coprod</a> <a id="6670" class="Symbol">.</a><a data-type="(r : Coproduct C A B₁) → Hom C B₁ (r .coapex)" id="6671" href="Cat.Diagram.Coproduct.html#1851" class="Field">in₁</a> <a id="6675" class="Symbol">=</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="6677" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="6684" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="6687" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="6689" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="6692" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span>
    <a id="6698" href="Cat.Abelian.Base.html#6570" class="Function">coprod</a> <a id="6705" class="Symbol">.</a><a data-type="(r : Coproduct C A B₁) → is-coproduct C (r .in₀) (r .in₁)" id="6706" href="Cat.Diagram.Coproduct.html#1874" class="Field">has-is-coproduct</a> <a id="6723" class="Symbol">.</a><a data-type="(r : Coproduct C A B₁) →
Hom C A Q → Hom C B₁ Q → Hom C (r .coapex) Q" id="6724" href="Cat.Diagram.Coproduct.html#1010" class="Field Operator">[_,_]</a> <a id="6730" href="Cat.Abelian.Base.html#6730" class="Bound">f</a> <a id="6732" href="Cat.Abelian.Base.html#6732" class="Bound">g</a> <a id="6734" class="Symbol">=</a> <a id="6736" href="Cat.Abelian.Base.html#6730" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="6738" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) A" id="6740" href="Cat.Diagram.Product.html#2787" class="Function">Prod.π₁</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="6748" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="6750" href="Cat.Abelian.Base.html#6732" class="Bound">g</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="6752" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" id="6754" href="Cat.Diagram.Product.html#2807" class="Function">Prod.π₂</a>
    <a id="6766" href="Cat.Abelian.Base.html#6570" class="Function">coprod</a> <a id="6773" class="Symbol">.</a><a data-type="(r : Coproduct C A B₁) → is-coproduct C (r .in₀) (r .in₁)" id="6774" href="Cat.Diagram.Coproduct.html#1874" class="Field">has-is-coproduct</a> <a id="6791" class="Symbol">.</a><a data-type="(r : Coproduct C A B₁) →
(C ∘ has-is-coproduct r .[_,_] inj0 inj1) (r .in₀) ≡ inj0" id="6792" href="Cat.Diagram.Coproduct.html#1077" class="Field">in₀∘factor</a> <a id="6803" class="Symbol">{</a><a id="6804" class="Argument">inj0</a> <a id="6809" class="Symbol">=</a> <a id="6811" href="Cat.Abelian.Base.html#6811" class="Bound">inj0</a><a id="6815" class="Symbol">}</a> <a id="6817" class="Symbol">{</a><a id="6818" href="Cat.Abelian.Base.html#6818" class="Bound">inj1</a><a id="6822" class="Symbol">}</a> <a id="6824" class="Symbol">=</a>
      <a id="6832" class="Symbol">(</a><a id="6833" href="Cat.Abelian.Base.html#6811" class="Bound">inj0</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="6838" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) A" id="6840" href="Cat.Diagram.Product.html#2787" class="Function">Prod.π₁</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="6848" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="6850" href="Cat.Abelian.Base.html#6818" class="Bound">inj1</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="6855" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" id="6857" href="Cat.Diagram.Product.html#2807" class="Function">Prod.π₂</a><a id="6864" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="6866" href="Cat.Base.html#3006" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="6868" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="6875" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="6878" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="6880" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="6883" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="6885" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="x ≡ y → y ≡ x" id="6888" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="6892" class="Symbol">(</a><a data-type="(r : is-abelian C) (f g : Hom C B₁ C) (h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) h) ((C ∘ g) h)
≡
(C ∘
 has-ab (has-additive (has-is-preab r)) .Group-on-hom B₁ C ._⋆_ f g)
h" id="6893" href="Cat.Abelian.Base.html#1800" class="Function">∘-linear-l</a> <a id="6904" class="Symbol">_</a> <a id="6906" class="Symbol">_</a> <a id="6908" class="Symbol">_)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="6911" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="6919" class="Symbol">((</a><a id="6921" href="Cat.Abelian.Base.html#6811" class="Bound">inj0</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="6926" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) A" id="6928" href="Cat.Diagram.Product.html#2787" class="Function">Prod.π₁</a><a id="6935" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="6937" href="Cat.Base.html#3006" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="6939" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="6946" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="6949" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="6951" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="6954" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="6956" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="6958" class="Symbol">_)</a>            <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="6972" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" id="6975" href="Cat.Reasoning.html#1108" class="Function">Hom.elimr</a> <a id="6985" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" id="6986" href="Cat.Reasoning.html#1678" class="Function">pullr</a> <a data-type="(r : Product C A B₁) →
(C ∘ r .π₂) (has-is-product r .⟨_,_⟩ p1 p2) ≡ p2" id="6992" href="Cat.Diagram.Product.html#1984" class="Function">Prod.π₂∘factor</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="7007" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ f) (0m r) ≡ 0m r" id="7009" href="Cat.Abelian.Base.html#2470" class="Function">∘-zero-r</a><a id="7017" class="Symbol">)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="7019" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="7027" class="Symbol">(</a><a id="7028" href="Cat.Abelian.Base.html#6811" class="Bound">inj0</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7033" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) A" id="7035" href="Cat.Diagram.Product.html#2787" class="Function">Prod.π₁</a><a id="7042" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7044" href="Cat.Base.html#3006" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7046" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="7053" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7056" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="7058" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7061" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span>                  <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="7080" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ (C ∘ f) h) i ≡ f" id="7083" href="Cat.Reasoning.html#2731" class="Function">cancelr</a> <a data-type="(r : Product C A B₁) →
(C ∘ r .π₁) (has-is-product r .⟨_,_⟩ p1 p2) ≡ p1" id="7091" href="Cat.Diagram.Product.html#1918" class="Function">Prod.π₁∘factor</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="7106" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="7114" href="Cat.Abelian.Base.html#6811" class="Bound">inj0</a>                                                <a data-type="(x : A) → x ≡ x" id="7166" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
    <a id="7172" href="Cat.Abelian.Base.html#6570" class="Function">coprod</a> <a id="7179" class="Symbol">.</a><a data-type="(r : Coproduct C A B₁) → is-coproduct C (r .in₀) (r .in₁)" id="7180" href="Cat.Diagram.Coproduct.html#1874" class="Field">has-is-coproduct</a> <a id="7197" class="Symbol">.</a><a data-type="(r : Coproduct C A B₁) →
(C ∘ has-is-coproduct r .[_,_] inj0 inj1) (r .in₁) ≡ inj1" id="7198" href="Cat.Diagram.Coproduct.html#1155" class="Field">in₁∘factor</a> <a id="7209" class="Symbol">{</a><a id="7210" class="Argument">inj0</a> <a id="7215" class="Symbol">=</a> <a id="7217" href="Cat.Abelian.Base.html#7217" class="Bound">inj0</a><a id="7221" class="Symbol">}</a> <a id="7223" class="Symbol">{</a><a id="7224" href="Cat.Abelian.Base.html#7224" class="Bound">inj1</a><a id="7228" class="Symbol">}</a> <a id="7230" class="Symbol">=</a>
      <a id="7238" class="Symbol">(</a><a id="7239" href="Cat.Abelian.Base.html#7217" class="Bound">inj0</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7244" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) A" id="7246" href="Cat.Diagram.Product.html#2787" class="Function">Prod.π₁</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="7254" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="7256" href="Cat.Abelian.Base.html#7224" class="Bound">inj1</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7261" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" id="7263" href="Cat.Diagram.Product.html#2807" class="Function">Prod.π₂</a><a id="7270" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7272" href="Cat.Base.html#3006" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7274" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="7281" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7284" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="7286" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7289" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="7291" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="x ≡ y → y ≡ x" id="7294" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="7298" class="Symbol">(</a><a data-type="(r : is-abelian C) (f g : Hom C B₁ C) (h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) h) ((C ∘ g) h)
≡
(C ∘
 has-ab (has-additive (has-is-preab r)) .Group-on-hom B₁ C ._⋆_ f g)
h" id="7299" href="Cat.Abelian.Base.html#1800" class="Function">∘-linear-l</a> <a id="7310" class="Symbol">_</a> <a id="7312" class="Symbol">_</a> <a id="7314" class="Symbol">_)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="7317" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="7325" class="Symbol">(_</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="7328" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="7330" class="Symbol">(</a><a id="7331" href="Cat.Abelian.Base.html#7224" class="Bound">inj1</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7336" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" id="7338" href="Cat.Diagram.Product.html#2807" class="Function">Prod.π₂</a><a id="7345" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7347" href="Cat.Base.html#3006" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7349" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="7356" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7359" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="7361" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7364" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span><a id="7365" class="Symbol">)</a>            <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="7378" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ a) f ≡ f" id="7381" href="Cat.Reasoning.html#1009" class="Function">Hom.eliml</a> <a id="7391" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" id="7392" href="Cat.Reasoning.html#1678" class="Function">pullr</a> <a data-type="(r : Product C A B₁) →
(C ∘ r .π₁) (has-is-product r .⟨_,_⟩ p1 p2) ≡ p1" id="7398" href="Cat.Diagram.Product.html#1918" class="Function">Prod.π₁∘factor</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="7413" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ f) (0m r) ≡ 0m r" id="7415" href="Cat.Abelian.Base.html#2470" class="Function">∘-zero-r</a><a id="7423" class="Symbol">)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="7425" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="7433" class="Symbol">(</a><a id="7434" href="Cat.Abelian.Base.html#7224" class="Bound">inj1</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7439" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" id="7441" href="Cat.Diagram.Product.html#2807" class="Function">Prod.π₂</a><a id="7448" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7450" href="Cat.Base.html#3006" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7452" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="7459" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7462" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="7464" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7467" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span>                  <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="7486" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ (C ∘ f) h) i ≡ f" id="7489" href="Cat.Reasoning.html#2731" class="Function">cancelr</a> <a data-type="(r : Product C A B₁) →
(C ∘ r .π₂) (has-is-product r .⟨_,_⟩ p1 p2) ≡ p2" id="7497" href="Cat.Diagram.Product.html#1984" class="Function">Prod.π₂∘factor</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="7512" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="7520" href="Cat.Abelian.Base.html#7224" class="Bound">inj1</a>                                                 <a data-type="(x : A) → x ≡ x" id="7573" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
</pre>
<p>For uniqueness, we use distributivity of composition over addition of morphisms and the universal property of the product to establish the desired equation. Check it out:</p>
<pre class="Agda">    <a id="7764" href="Cat.Abelian.Base.html#6570" class="Function">coprod</a> <a id="7771" class="Symbol">.</a><a data-type="(r : Coproduct C A B₁) → is-coproduct C (r .in₀) (r .in₁)" id="7772" href="Cat.Diagram.Coproduct.html#1874" class="Field">has-is-coproduct</a> <a id="7789" class="Symbol">.</a><a data-type="(r : Coproduct C A B₁) (other : Hom C (r .coapex) Q) →
(C ∘ other) (r .in₀) ≡ inj0 →
(C ∘ other) (r .in₁) ≡ inj1 →
other ≡ has-is-coproduct r .[_,_] inj0 inj1" id="7790" href="Cat.Diagram.Coproduct.html#1234" class="Field">unique</a> <a id="7797" class="Symbol">{</a><a id="7798" class="Argument">inj0</a> <a id="7803" class="Symbol">=</a> <a id="7805" href="Cat.Abelian.Base.html#7805" class="Bound">inj0</a><a id="7809" class="Symbol">}</a> <a id="7811" class="Symbol">{</a><a id="7812" href="Cat.Abelian.Base.html#7812" class="Bound">inj1</a><a id="7816" class="Symbol">}</a> <a id="7818" href="Cat.Abelian.Base.html#7818" class="Bound">other</a> <a id="7824" href="Cat.Abelian.Base.html#7824" class="Bound">p</a> <a id="7826" href="Cat.Abelian.Base.html#7826" class="Bound">q</a> <a id="7828" class="Symbol">=</a> <a data-type="x ≡ y → y ≡ x" id="7830" href="1Lab.Path.html#10558" class="Function">sym</a> <a data-type="((x : A) → B₁ x) → (x : A) → B₁ x" id="7834" href="1Lab.Type.html#2481" class="Function Operator">$</a>
      <a id="7842" href="Cat.Abelian.Base.html#7805" class="Bound">inj0</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7847" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) A" id="7849" href="Cat.Diagram.Product.html#2787" class="Function">Prod.π₁</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="7857" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="7859" href="Cat.Abelian.Base.html#7812" class="Bound">inj1</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7864" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" id="7866" href="Cat.Diagram.Product.html#2807" class="Function">Prod.π₂</a>                                             <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="7918" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" id="7921" href="1Lab.Path.html#21189" class="Function">ap₂</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="7925" href="Cat.Abelian.Base.html#1445" class="Function Operator">_+_</a> <a id="7929" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (c≡ab : c ≡ (C ∘ a) b) →
(C ∘ c) f ≡ (C ∘ a) ((C ∘ b) f)" id="7930" href="Cat.Reasoning.html#1844" class="Function">pushl</a> <a id="7936" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="7937" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="7941" href="Cat.Abelian.Base.html#7824" class="Bound">p</a><a id="7942" class="Symbol">))</a> <a id="7945" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (c≡ab : c ≡ (C ∘ a) b) →
(C ∘ c) f ≡ (C ∘ a) ((C ∘ b) f)" id="7946" href="Cat.Reasoning.html#1844" class="Function">pushl</a> <a id="7952" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="7953" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="7957" href="Cat.Abelian.Base.html#7826" class="Bound">q</a><a id="7958" class="Symbol">))</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="7961" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="7969" class="Symbol">(</a><a id="7970" href="Cat.Abelian.Base.html#7818" class="Bound">other</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7976" href="Cat.Base.html#3006" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7978" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="7985" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7988" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="7990" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7993" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7995" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) A" id="7997" href="Cat.Diagram.Product.html#2787" class="Function">Prod.π₁</a><a id="8004" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8006" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="8008" class="Symbol">(</a><a id="8009" href="Cat.Abelian.Base.html#7818" class="Bound">other</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8015" href="Cat.Base.html#3006" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8017" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8024" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8027" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="8029" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8032" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8034" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" id="8036" href="Cat.Diagram.Product.html#2807" class="Function">Prod.π₂</a><a id="8043" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="8045" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(r : is-abelian C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) g) ((C ∘ f) h)
≡
(C ∘ f)
(has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g
 h)" id="8048" href="Cat.Abelian.Base.html#1903" class="Function">∘-linear-r</a> <a id="8059" class="Symbol">_</a> <a id="8061" class="Symbol">_</a> <a id="8063" class="Symbol">_</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="8065" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="8073" href="Cat.Abelian.Base.html#7818" class="Bound">other</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8079" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="8081" class="Symbol">(</a><span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8082" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="8089" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8092" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8094" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8097" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8099" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) A" id="8101" href="Cat.Diagram.Product.html#2787" class="Function">Prod.π₁</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8109" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8111" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8118" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8121" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="8123" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8126" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8128" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" id="8130" href="Cat.Diagram.Product.html#2807" class="Function">Prod.π₂</a><a id="8137" class="Symbol">)</a>           <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="8149" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" id="8152" href="Cat.Reasoning.html#1108" class="Function">elimr</a> <a id="8158" href="Cat.Abelian.Base.html#8270" class="Function">lemma</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="8164" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="8172" href="Cat.Abelian.Base.html#7818" class="Bound">other</a>                                                                       <a data-type="(x : A) → x ≡ x" id="8248" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
      <a id="8256" class="Keyword">where</a>
        <a id="8270" href="Cat.Abelian.Base.html#8270" class="Function">lemma</a> <a id="8276" class="Symbol">:</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8278" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="8285" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8288" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8290" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8293" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8295" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) A" id="8297" href="Cat.Diagram.Product.html#2787" class="Function">Prod.π₁</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8305" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8307" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8314" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8317" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="8319" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8322" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8324" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" id="8326" href="Cat.Diagram.Product.html#2807" class="Function">Prod.π₂</a>
              <a data-type="A → A → Type ℓ" id="8348" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="8350" href="Cat.Base.html#2976" class="Function">id</a>
        <a id="8361" href="Cat.Abelian.Base.html#8270" class="Function">lemma</a> <a id="8367" class="Symbol">=</a> <a data-type="(r : Product C A B₁) →
(C ∘ r .π₁) o1 ≡ pr1 →
(C ∘ r .π₂) o1 ≡ pr2 →
(C ∘ r .π₁) o2 ≡ pr1 → (C ∘ r .π₂) o2 ≡ pr2 → o1 ≡ o2" id="8369" href="Cat.Diagram.Product.html#2211" class="Function">Prod.unique₂</a> <a id="8382" class="Symbol">{</a><a id="8383" class="Argument">pr1</a> <a id="8387" class="Symbol">=</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) A" id="8389" href="Cat.Diagram.Product.html#2787" class="Function">Prod.π₁</a><a id="8396" class="Symbol">}</a> <a id="8398" class="Symbol">{</a><a id="8399" class="Argument">pr2</a> <a id="8403" class="Symbol">=</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" id="8405" href="Cat.Diagram.Product.html#2807" class="Function">Prod.π₂</a><a id="8412" class="Symbol">}</a>
          <a id="8424" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="8425" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="8429" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) g) ((C ∘ f) h)
≡
(C ∘ f)
(has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g
 h)" id="8430" href="Cat.Abelian.Base.html#1903" class="Function">∘-linear-r</a> <a id="8441" class="Symbol">_</a> <a id="8443" class="Symbol">_</a> <a id="8445" class="Symbol">_)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="8448" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" id="8450" href="1Lab.Path.html#21189" class="Function">ap₂</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8454" href="Cat.Abelian.Base.html#1445" class="Function Operator">_+_</a> <a id="8458" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ h) ((C ∘ i) f) ≡ f" id="8459" href="Cat.Reasoning.html#2621" class="Function">cancell</a> <a data-type="(r : Product C A B₁) →
(C ∘ r .π₁) (has-is-product r .⟨_,_⟩ p1 p2) ≡ p1" id="8467" href="Cat.Diagram.Product.html#1918" class="Function">Prod.π₁∘factor</a><a id="8481" class="Symbol">)</a> <a id="8483" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ a) ((C ∘ b) f) ≡ (C ∘ c) f" id="8484" href="Cat.Reasoning.html#1548" class="Function">pulll</a> <a data-type="(r : Product C A B₁) →
(C ∘ r .π₁) (has-is-product r .⟨_,_⟩ p1 p2) ≡ p1" id="8490" href="Cat.Diagram.Product.html#1918" class="Function">Prod.π₁∘factor</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="8505" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ 0m r) f ≡ 0m r" id="8507" href="Cat.Abelian.Base.html#2885" class="Function">∘-zero-l</a><a id="8515" class="Symbol">)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="8517" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" id="8519" href="Cat.Reasoning.html#1108" class="Function">Hom.elimr</a> <a data-type="x ≡ x" id="8529" href="1Lab.Path.html#3593" class="Function">refl</a><a id="8533" class="Symbol">)</a>
          <a id="8545" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="8546" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="8550" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) g) ((C ∘ f) h)
≡
(C ∘ f)
(has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g
 h)" id="8551" href="Cat.Abelian.Base.html#1903" class="Function">∘-linear-r</a> <a id="8562" class="Symbol">_</a> <a id="8564" class="Symbol">_</a> <a id="8566" class="Symbol">_)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="8569" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" id="8571" href="1Lab.Path.html#21189" class="Function">ap₂</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8575" href="Cat.Abelian.Base.html#1445" class="Function Operator">_+_</a> <a id="8579" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ a) ((C ∘ b) f) ≡ (C ∘ c) f" id="8580" href="Cat.Reasoning.html#1548" class="Function">pulll</a> <a data-type="(r : Product C A B₁) →
(C ∘ r .π₂) (has-is-product r .⟨_,_⟩ p1 p2) ≡ p2" id="8586" href="Cat.Diagram.Product.html#1984" class="Function">Prod.π₂∘factor</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="8601" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ 0m r) f ≡ 0m r" id="8603" href="Cat.Abelian.Base.html#2885" class="Function">∘-zero-l</a><a id="8611" class="Symbol">)</a> <a id="8613" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ h) ((C ∘ i) f) ≡ f" id="8614" href="Cat.Reasoning.html#2621" class="Function">cancell</a> <a data-type="(r : Product C A B₁) →
(C ∘ r .π₂) (has-is-product r .⟨_,_⟩ p1 p2) ≡ p2" id="8622" href="Cat.Diagram.Product.html#1984" class="Function">Prod.π₂∘factor</a><a id="8636" class="Symbol">)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="8638" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ a) f ≡ f" id="8640" href="Cat.Reasoning.html#1009" class="Function">Hom.eliml</a> <a data-type="x ≡ x" id="8650" href="1Lab.Path.html#3593" class="Function">refl</a><a id="8654" class="Symbol">)</a>
          <a id="8666" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" id="8667" href="Cat.Reasoning.html#1108" class="Function">elimr</a> <a data-type="x ≡ x" id="8673" href="1Lab.Path.html#3593" class="Function">refl</a><a id="8677" class="Symbol">)</a>
          <a id="8689" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" id="8690" href="Cat.Reasoning.html#1108" class="Function">elimr</a> <a data-type="x ≡ x" id="8696" href="1Lab.Path.html#3593" class="Function">refl</a><a id="8700" class="Symbol">)</a>
</pre>
<h1 id="pre-abelian-abelian-categories"><a href="#pre-abelian-abelian-categories" class="header-link">Pre-abelian &amp; abelian categories<span class="header-link-emoji">🔗</span></a></h1>
<p>An additive category is <strong>pre-abelian</strong> when it additionally has <a href="Cat.Diagram.Kernel.html">kernels</a> and cokernels, hence binary <a href="Cat.Diagram.Equaliser.html">equalisers</a> and <a href="Cat.Diagram.Coequaliser.html">coequalisers</a> where one of the maps is zero.</p>
<pre class="Agda"><a id="9040" class="Keyword">record</a> <a id="is-pre-abelian"></a><a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="9047" href="Cat.Abelian.Base.html#9047" class="Record">is-pre-abelian</a> <a id="9062" class="Symbol">{</a><a id="9063" href="Cat.Abelian.Base.html#9063" class="Bound">o</a> <a id="9065" href="Cat.Abelian.Base.html#9065" class="Bound">ℓ</a><a id="9066" class="Symbol">}</a> <a id="9068" class="Symbol">(</a><a id="9069" href="Cat.Abelian.Base.html#9069" class="Bound">C</a> <a id="9071" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="9073" href="Cat.Base.html#704" class="Record">Precategory</a> <a id="9085" href="Cat.Abelian.Base.html#9063" class="Bound">o</a> <a id="9087" href="Cat.Abelian.Base.html#9065" class="Bound">ℓ</a><a id="9088" class="Symbol">)</a> <a id="9090" class="Symbol">:</a> <a id="9092" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="9097" class="Symbol">(</a><a id="9098" href="Cat.Abelian.Base.html#9063" class="Bound">o</a> <a data-type="Level → Level → Level" id="9100" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a data-type="Level → Level" id="9102" href="Agda.Primitive.html#780" class="Primitive">lsuc</a> <a id="9107" href="Cat.Abelian.Base.html#9065" class="Bound">ℓ</a><a id="9108" class="Symbol">)</a> <a id="9110" class="Keyword">where</a>
  <a id="9118" class="Keyword">field</a> <a id="is-pre-abelian.has-additive"></a><a data-type="(r : is-abelian C) → is-additive C" id="9124" href="Cat.Abelian.Base.html#9124" class="Field">has-additive</a> <a id="9137" class="Symbol">:</a> <a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="9139" href="Cat.Abelian.Base.html#5321" class="Record">is-additive</a> <a id="9151" href="Cat.Abelian.Base.html#9069" class="Bound">C</a>
  <a id="9155" class="Keyword">open</a> <a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="9160" href="Cat.Abelian.Base.html#5321" class="Module">is-additive</a> <a data-type="(r : is-abelian C) → is-additive C" id="9172" href="Cat.Abelian.Base.html#9124" class="Field">has-additive</a> <a id="9185" class="Keyword">public</a>
  <a id="9194" class="Keyword">field</a>
    <a id="is-pre-abelian.kernel"></a><a data-type="(r : is-abelian C) (f : Hom (has-is-preab r .has-additive) A B₁) →
Kernel C (∅ r) f" id="9204" href="Cat.Abelian.Base.html#9204" class="Field">kernel</a>   <a id="9213" class="Symbol">:</a> <a id="9215" class="Symbol">∀</a> <a id="9217" class="Symbol">{</a><a id="9218" href="Cat.Abelian.Base.html#9218" class="Bound">A</a> <a id="9220" href="Cat.Abelian.Base.html#9220" class="Bound">B</a><a id="9221" class="Symbol">}</a> <a id="9223" class="Symbol">(</a><a id="9224" href="Cat.Abelian.Base.html#9224" class="Bound">f</a> <a id="9226" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="9228" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="9232" href="Cat.Abelian.Base.html#9218" class="Bound">A</a> <a id="9234" href="Cat.Abelian.Base.html#9220" class="Bound">B</a><a id="9235" class="Symbol">)</a> <a id="9237" class="Symbol">→</a> <a data-type="(C : Precategory o ℓ) (∅ : Zero C) (f : Hom C a b) → Type (o ⊔ ℓ)" id="9239" href="Cat.Diagram.Equaliser.Kernel.html#1023" class="Record">Kernel</a> <a id="9246" href="Cat.Abelian.Base.html#9069" class="Bound">C</a> <a data-type="(r : is-abelian C) → Zero r" id="9248" href="Cat.Abelian.Base.html#5530" class="Function">∅</a> <a id="9250" href="Cat.Abelian.Base.html#9224" class="Bound">f</a>
    <a id="is-pre-abelian.cokernel"></a><a data-type="(r : is-abelian C) (f : Hom (has-is-preab r .has-additive) A B₁) →
Coequaliser r (0m r) f" id="9256" href="Cat.Abelian.Base.html#9256" class="Field">cokernel</a> <a id="9265" class="Symbol">:</a> <a id="9267" class="Symbol">∀</a> <a id="9269" class="Symbol">{</a><a id="9270" href="Cat.Abelian.Base.html#9270" class="Bound">A</a> <a id="9272" href="Cat.Abelian.Base.html#9272" class="Bound">B</a><a id="9273" class="Symbol">}</a> <a id="9275" class="Symbol">(</a><a id="9276" href="Cat.Abelian.Base.html#9276" class="Bound">f</a> <a id="9278" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="9280" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="9284" href="Cat.Abelian.Base.html#9270" class="Bound">A</a> <a id="9286" href="Cat.Abelian.Base.html#9272" class="Bound">B</a><a id="9287" class="Symbol">)</a> <a id="9289" class="Symbol">→</a> <a data-type="(C : Precategory o ℓ) (f g : Hom C A B₁) → Type (o ⊔ ℓ)" id="9291" href="Cat.Diagram.Coequaliser.html#1495" class="Record">Coequaliser</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="9303" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a id="9306" href="Cat.Abelian.Base.html#9276" class="Bound">f</a>

  <a id="9311" class="Keyword">module</a> <a id="is-pre-abelian.Ker"></a><a id="9318" href="Cat.Abelian.Base.html#9318" class="Module">Ker</a> <a id="9322" class="Symbol">{</a><a id="9323" href="Cat.Abelian.Base.html#9323" class="Bound">A</a> <a id="9325" href="Cat.Abelian.Base.html#9325" class="Bound">B</a><a id="9326" class="Symbol">}</a> <a id="9328" class="Symbol">(</a><a id="9329" href="Cat.Abelian.Base.html#9329" class="Bound">f</a> <a id="9331" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="9333" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="9337" href="Cat.Abelian.Base.html#9323" class="Bound">A</a> <a id="9339" href="Cat.Abelian.Base.html#9325" class="Bound">B</a><a id="9340" class="Symbol">)</a> <a id="9342" class="Symbol">=</a> <a data-type="(C : Precategory o ℓ) (∅ : Zero C) (f : Hom C a b) → Type (o ⊔ ℓ)" id="9344" href="Cat.Diagram.Equaliser.Kernel.html#1023" class="Module">Kernel</a> <a id="9351" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom (has-is-preab r .has-additive) A B₁) →
Kernel C (∅ r) f" id="9352" href="Cat.Abelian.Base.html#9204" class="Field">kernel</a> <a id="9359" href="Cat.Abelian.Base.html#9329" class="Bound">f</a><a id="9360" class="Symbol">)</a>
  <a id="9364" class="Keyword">module</a> <a id="is-pre-abelian.Coker"></a><a id="9371" href="Cat.Abelian.Base.html#9371" class="Module">Coker</a> <a id="9377" class="Symbol">{</a><a id="9378" href="Cat.Abelian.Base.html#9378" class="Bound">A</a> <a id="9380" href="Cat.Abelian.Base.html#9380" class="Bound">B</a><a id="9381" class="Symbol">}</a> <a id="9383" class="Symbol">(</a><a id="9384" href="Cat.Abelian.Base.html#9384" class="Bound">f</a> <a id="9386" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="9388" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="9392" href="Cat.Abelian.Base.html#9378" class="Bound">A</a> <a id="9394" href="Cat.Abelian.Base.html#9380" class="Bound">B</a><a id="9395" class="Symbol">)</a> <a id="9397" class="Symbol">=</a> <a data-type="(C : Precategory o ℓ) (f g : Hom C A B₁) → Type (o ⊔ ℓ)" id="9399" href="Cat.Diagram.Coequaliser.html#1495" class="Module">Coequaliser</a> <a id="9411" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom (has-is-preab r .has-additive) A B₁) →
Coequaliser r (0m r) f" id="9412" href="Cat.Abelian.Base.html#9256" class="Field">cokernel</a> <a id="9421" href="Cat.Abelian.Base.html#9384" class="Bound">f</a><a id="9422" class="Symbol">)</a>
</pre>
<p>Every morphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mi>f</mi></mpadded></mover><mi>B</mi></mrow><annotation encoding="application/x-tex">A \xto{f} B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1191em;vertical-align:-0.011em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1081em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> in a preabelian category admits a canonical decomposition as</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mover><mo stretchy="true" minsize="3.0em">↠</mo><mpadded width="+0.6em" lspace="0.3em"><mi>p</mi></mpadded></mover><mi mathvariant="normal">coker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>ker</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">)</mo><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mpadded></mover><mi>ker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">coker</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">)</mo><mover><mo stretchy="true" minsize="3.0em">↪</mo><mpadded width="+0.6em" lspace="0.3em"><mi>i</mi></mpadded></mover><mi>B</mi><mtext>,</mtext></mrow><annotation encoding="application/x-tex">
A \xepi{p} \coker (\ker f) \xto{f&#39;} \ker (\coker f) \xmono{i} B\text{,}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8294em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8294em;"><span style="top:-3.228em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="svg-align" style="top:-2.783em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.334em;min-width:0.888em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.334em" viewBox="0 0 400000 334" preserveAspectRatio="xMaxYMin slice"><path d="M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z"></path></svg></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4515em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mopen">(</span><span class="mop">ker</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2015em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3337em;vertical-align:-0.25em;"></span><span class="mop">ker</span><span class="mopen">(</span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0837em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="stretchy" style="height:0.522em;min-width:1.08em;"><span class="halfarrow-left" style="height:0.522em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMinYMin slice"><path d="M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z"></path></svg></span><span class="halfarrow-right" style="height:0.522em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"></path></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord text"><span class="mord">,</span></span></span></span></span></span></p>
<p>where, as indicated, the map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> is an epimorphism (indeed a <a href="Cat.Diagram.Coequaliser.RegularEpi.html">regular epimorphism</a>, since it is a cokernel) and the map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> is a <a href="Cat.Diagram.Equaliser.RegularMono.html">regular monomorphism</a>.</p>
<pre class="Agda">  <a id="is-pre-abelian.decompose"></a><a data-type="(r : is-abelian C) (f : Hom (has-is-preab r) A B₁) →
Σ
(λ f′ →
   f ≡
   (has-is-preab r ∘
    kernel (has-is-preab r) (coeq (has-is-preab r) f))
   ((has-is-preab r ∘ f′)
    (coeq (has-is-preab r) (kernel (has-is-preab r) f))))" id="9890" href="Cat.Abelian.Base.html#9890" class="Function">decompose</a>
    <a id="9904" class="Symbol">:</a> <a id="9906" class="Symbol">∀</a> <a id="9908" class="Symbol">{</a><a id="9909" href="Cat.Abelian.Base.html#9909" class="Bound">A</a> <a id="9911" href="Cat.Abelian.Base.html#9911" class="Bound">B</a><a id="9912" class="Symbol">}</a> <a id="9914" class="Symbol">(</a><a id="9915" href="Cat.Abelian.Base.html#9915" class="Bound">f</a> <a id="9917" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="9919" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="9923" href="Cat.Abelian.Base.html#9909" class="Bound">A</a> <a id="9925" href="Cat.Abelian.Base.html#9911" class="Bound">B</a><a id="9926" class="Symbol">)</a>
    <a id="9932" class="Symbol">→</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="9934" href="1Lab.Type.html#1573" class="Function">Σ[</a> <a id="9937" href="Cat.Abelian.Base.html#9937" class="Bound">f′</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="9940" href="1Lab.Type.html#1573" class="Function">∈</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="9942" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="9946" class="Symbol">(</a><a data-type="Coequaliser C f g → Ob C" id="9947" href="Cat.Diagram.Coequaliser.html#1557" class="Function">Coker.coapex</a> <a id="9960" class="Symbol">(</a><a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="9961" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="9972" href="Cat.Abelian.Base.html#9915" class="Bound">f</a><a id="9973" class="Symbol">))</a> <a id="9976" class="Symbol">(</a><a data-type="Kernel C ∅ f → Ob C" id="9977" href="Cat.Diagram.Equaliser.Kernel.html#1088" class="Function">Ker.ker</a> <a id="9985" class="Symbol">(</a><a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="9986" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="9997" href="Cat.Abelian.Base.html#9915" class="Bound">f</a><a id="9998" class="Symbol">))</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="10001" href="1Lab.Type.html#1573" class="Function">]</a>
       <a id="10010" class="Symbol">(</a><a id="10011" href="Cat.Abelian.Base.html#9915" class="Bound">f</a> <a data-type="A → A → Type ℓ" id="10013" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="10015" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="10026" class="Symbol">(</a><a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="10027" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="10038" href="Cat.Abelian.Base.html#9915" class="Bound">f</a><a id="10039" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="10041" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="10043" href="Cat.Abelian.Base.html#9937" class="Bound">f′</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="10046" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="10048" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="10059" class="Symbol">(</a><a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="10060" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="10071" href="Cat.Abelian.Base.html#9915" class="Bound">f</a><a id="10072" class="Symbol">))</a>
  <a data-type="(r : is-abelian C) (f : Hom (has-is-preab r) A B₁) →
Σ
(λ f′ →
   f ≡
   (has-is-preab r ∘
    kernel (has-is-preab r) (coeq (has-is-preab r) f))
   ((has-is-preab r ∘ f′)
    (coeq (has-is-preab r) (kernel (has-is-preab r) f))))" id="10077" href="Cat.Abelian.Base.html#9890" class="Function">decompose</a> <a id="10087" class="Symbol">{</a><a id="10088" href="Cat.Abelian.Base.html#10088" class="Bound">A</a><a id="10089" class="Symbol">}</a> <a id="10091" class="Symbol">{</a><a id="10092" href="Cat.Abelian.Base.html#10092" class="Bound">B</a><a id="10093" class="Symbol">}</a> <a id="10095" href="Cat.Abelian.Base.html#10095" class="Bound">f</a> <a id="10097" class="Symbol">=</a> <a id="10099" href="Cat.Abelian.Base.html#10503" class="Function">map</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="10103" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="x ≡ y → y ≡ x" id="10105" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="10109" href="Cat.Abelian.Base.html#11380" class="Function">path</a>
    <a id="10118" class="Keyword">where</a>
      <a id="10130" href="Cat.Abelian.Base.html#10130" class="Function">proj′</a> <a id="10136" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="10138" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="10142" class="Symbol">(</a><a data-type="Coequaliser C f g → Ob C" id="10143" href="Cat.Diagram.Coequaliser.html#1557" class="Function">Coker.coapex</a> <a id="10156" class="Symbol">(</a><a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="10157" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="10168" href="Cat.Abelian.Base.html#10095" class="Bound">f</a><a id="10169" class="Symbol">))</a> <a id="10172" href="Cat.Abelian.Base.html#10092" class="Bound">B</a>
      <a id="10180" href="Cat.Abelian.Base.html#10130" class="Function">proj′</a> <a id="10186" class="Symbol">=</a> <a data-type="(r : Coequaliser C f g) →
(C ∘ e′) f ≡ (C ∘ e′) g → Hom C (r .coapex) F" id="10188" href="Cat.Diagram.Coequaliser.html#764" class="Function">Coker.coequalise</a> <a id="10205" class="Symbol">(</a><a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="10206" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="10217" href="Cat.Abelian.Base.html#10095" class="Bound">f</a><a id="10218" class="Symbol">)</a> <a id="10220" class="Symbol">{</a><a id="10221" class="Argument">e′</a> <a id="10224" class="Symbol">=</a> <a id="10226" href="Cat.Abelian.Base.html#10095" class="Bound">f</a><a id="10227" class="Symbol">}</a> <a data-type="((x : A) → B₁ x) → (x : A) → B₁ x" id="10229" href="1Lab.Type.html#2481" class="Function Operator">$</a> <a data-type="x ≡ y → y ≡ x" id="10231" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="10235" href="Cat.Abelian.Base.html#10291" class="Function">path</a>
</pre>
<!--
<pre class="Agda">        <a id="10266" class="Keyword">where</a> <a id="10272" class="Keyword">abstract</a>
          <a id="10291" href="Cat.Abelian.Base.html#10291" class="Function">path</a> <a id="10296" class="Symbol">:</a> <a id="10298" href="Cat.Abelian.Base.html#10095" class="Bound">f</a> <a id="10300" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="10302" href="Cat.Abelian.Base.html#9204" class="Field">kernel</a> <a id="10309" href="Cat.Abelian.Base.html#10095" class="Bound">f</a> <a id="10311" class="Symbol">.</a><a id="10312" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Field">Kernel.kernel</a> <a id="10326" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10328" href="Cat.Abelian.Base.html#10095" class="Bound">f</a> <a id="10330" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="10332" href="Cat.Abelian.Base.html#1533" class="Function">0m</a>
          <a id="10345" href="Cat.Abelian.Base.html#10291" class="Function">path</a> <a id="10350" class="Symbol">=</a> <a id="10352" href="Cat.Diagram.Equaliser.html#687" class="Function">Ker.equal</a> <a id="10362" href="Cat.Abelian.Base.html#10095" class="Bound">f</a>
            <a id="10376" href="1Lab.Path.html#38305" class="Function Operator">··</a> <a id="10379" href="Cat.Diagram.Zero.html#1167" class="Function">∅.zero-∘r</a> <a id="10389" class="Symbol">_</a>
            <a id="10403" href="1Lab.Path.html#38305" class="Function Operator">··</a> <a id="10406" href="1Lab.Path.html#21189" class="Function">ap₂</a> <a id="10410" href="Cat.Base.html#3006" class="Function Operator">_∘_</a> <a id="10414" class="Symbol">(</a><a id="10415" href="Cat.Diagram.Initial.html#456" class="Function">∅.has⊥</a> <a id="10422" class="Symbol">_</a> <a id="10424" class="Symbol">.</a><a id="10425" href="1Lab.HLevel.html#1416" class="Field">paths</a> <a id="10431" href="Cat.Abelian.Base.html#1533" class="Function">0m</a><a id="10433" class="Symbol">)</a> <a id="10435" href="1Lab.Path.html#3593" class="Function">refl</a>
            <a id="10452" href="1Lab.Path.html#38305" class="Function Operator">··</a> <a id="10455" href="Cat.Abelian.Base.html#2885" class="Function">∘-zero-l</a> <a id="10464" href="1Lab.Path.html#38305" class="Function Operator">··</a> <a id="10467" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="10471" href="Cat.Abelian.Base.html#2470" class="Function">∘-zero-r</a>
</pre>-->
<pre class="Agda">      <a id="10503" href="Cat.Abelian.Base.html#10503" class="Function">map</a> <a id="10507" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="10509" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="10513" class="Symbol">(</a><a data-type="Coequaliser C f g → Ob C" id="10514" href="Cat.Diagram.Coequaliser.html#1557" class="Function">Coker.coapex</a> <a id="10527" class="Symbol">(</a><a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="10528" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="10539" href="Cat.Abelian.Base.html#10095" class="Bound">f</a><a id="10540" class="Symbol">))</a> <a id="10543" class="Symbol">(</a><a data-type="Kernel C ∅ f → Ob C" id="10544" href="Cat.Diagram.Equaliser.Kernel.html#1088" class="Function">Ker.ker</a> <a id="10552" class="Symbol">(</a><a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="10553" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="10564" href="Cat.Abelian.Base.html#10095" class="Bound">f</a><a id="10565" class="Symbol">))</a>
      <a id="10574" href="Cat.Abelian.Base.html#10503" class="Function">map</a> <a id="10578" class="Symbol">=</a> <a data-type="(r : Kernel C ∅ f) →
(C ∘ f) e′ ≡ (C ∘ zero→ ∅) e′ → Hom C F (r .ker)" id="10580" href="Cat.Diagram.Equaliser.html#721" class="Function">Ker.limiting</a> <a id="10593" class="Symbol">(</a><a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="10594" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="10605" href="Cat.Abelian.Base.html#10095" class="Bound">f</a><a id="10606" class="Symbol">)</a> <a id="10608" class="Symbol">{</a><a id="10609" class="Argument">e′</a> <a id="10612" class="Symbol">=</a> <a id="10614" href="Cat.Abelian.Base.html#10130" class="Function">proj′</a><a id="10619" class="Symbol">}</a> <a data-type="((x : A) → B₁ x) → (x : A) → B₁ x" id="10621" href="1Lab.Type.html#2481" class="Function Operator">$</a> <a data-type="x ≡ y → y ≡ x" id="10623" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="10627" href="Cat.Abelian.Base.html#10945" class="Function">path</a>
</pre>
<p>The existence of the map <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">f&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>,</span> and indeed of the maps <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> and <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>,</span> follow from the universal properties of kernels and cokernels. The map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> is the canonical quotient map <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi mathvariant="normal">coker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A \to \coker(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>,</span> and the map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> is the canonical subobject inclusion <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\ker(f) \to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">ker</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>.</span></p>
<!--
<pre class="Agda">        <a id="10920" class="Keyword">where</a> <a id="10926" class="Keyword">abstract</a>
          <a id="10945" href="Cat.Abelian.Base.html#10945" class="Function">path</a> <a id="10950" class="Symbol">:</a> <a id="10952" href="Cat.Diagram.Zero.html#1010" class="Function">∅.zero→</a> <a id="10960" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="10962" href="Cat.Abelian.Base.html#10130" class="Function">proj′</a> <a id="10968" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10970" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="10981" href="Cat.Abelian.Base.html#10095" class="Bound">f</a> <a id="10983" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="10985" href="Cat.Abelian.Base.html#10130" class="Function">proj′</a>
          <a id="11001" href="Cat.Abelian.Base.html#10945" class="Function">path</a> <a id="11006" class="Symbol">=</a> <a id="11008" href="Cat.Diagram.Coequaliser.html#1087" class="Function">Coker.unique₂</a> <a id="11022" class="Symbol">(</a><a id="11023" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="11034" href="Cat.Abelian.Base.html#10095" class="Bound">f</a><a id="11035" class="Symbol">)</a>
            <a id="11049" class="Symbol">{</a><a id="11050" class="Argument">e′</a> <a id="11053" class="Symbol">=</a> <a id="11055" href="Cat.Abelian.Base.html#1533" class="Function">0m</a><a id="11057" class="Symbol">}</a> <a id="11059" class="Symbol">{</a><a id="11060" class="Argument">p</a> <a id="11062" class="Symbol">=</a> <a id="11064" href="Cat.Abelian.Base.html#2470" class="Function">∘-zero-r</a> <a id="11073" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a id="11075" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="11079" href="Cat.Abelian.Base.html#2885" class="Function">∘-zero-l</a><a id="11087" class="Symbol">}</a>
            <a id="11101" class="Symbol">(</a><a id="11102" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="11106" class="Symbol">(</a> <a id="11108" href="Cat.Reasoning.html#1844" class="Function">pushl</a> <a id="11114" class="Symbol">(</a><a id="11115" href="Cat.Diagram.Zero.html#1167" class="Function">∅.zero-∘r</a> <a id="11125" class="Symbol">_)</a> <a id="11128" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a id="11130" href="Cat.Reasoning.html#1548" class="Function">pulll</a> <a id="11136" class="Symbol">(</a> <a id="11138" href="1Lab.Path.html#21189" class="Function">ap₂</a> <a id="11142" href="Cat.Base.html#3006" class="Function Operator">_∘_</a> <a id="11146" href="1Lab.Path.html#3593" class="Function">refl</a> <a id="11151" class="Symbol">(</a><a id="11152" href="Cat.Diagram.Terminal.html#461" class="Function">∅.has⊤</a> <a id="11159" class="Symbol">_</a> <a id="11161" class="Symbol">.</a><a id="11162" href="1Lab.HLevel.html#1416" class="Field">paths</a> <a id="11168" href="Cat.Abelian.Base.html#1533" class="Function">0m</a><a id="11170" class="Symbol">)</a>
                                               <a id="11219" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a id="11221" href="Cat.Abelian.Base.html#2470" class="Function">∘-zero-r</a><a id="11229" class="Symbol">)</a>
                 <a id="11248" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a id="11250" href="Cat.Abelian.Base.html#2885" class="Function">∘-zero-l</a><a id="11258" class="Symbol">))</a>
            <a id="11273" class="Symbol">(</a><a id="11274" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="11278" class="Symbol">(</a> <a id="11280" href="Cat.Reasoning.html#1678" class="Function">pullr</a> <a id="11286" class="Symbol">(</a><a id="11287" href="Cat.Diagram.Coequaliser.html#834" class="Function">Coker.universal</a> <a id="11303" class="Symbol">(</a><a id="11304" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="11315" href="Cat.Abelian.Base.html#10095" class="Bound">f</a><a id="11316" class="Symbol">))</a> <a id="11319" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a id="11321" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="11325" class="Symbol">(</a><a id="11326" href="Cat.Diagram.Coequaliser.html#727" class="Function">Coker.coequal</a> <a id="11340" class="Symbol">_)</a>
                 <a id="11360" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a id="11362" href="Cat.Abelian.Base.html#2470" class="Function">∘-zero-r</a><a id="11370" class="Symbol">))</a>

      <a id="11380" href="Cat.Abelian.Base.html#11380" class="Function">path</a> <a id="11385" class="Symbol">=</a>
        <a id="11395" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="11406" class="Symbol">(</a><a id="11407" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="11418" href="Cat.Abelian.Base.html#10095" class="Bound">f</a><a id="11419" class="Symbol">)</a> <a id="11421" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="11423" href="Cat.Abelian.Base.html#10503" class="Function">map</a> <a id="11427" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="11429" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="11440" class="Symbol">(</a><a id="11441" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="11452" href="Cat.Abelian.Base.html#10095" class="Bound">f</a><a id="11453" class="Symbol">)</a> <a id="11455" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a id="11458" href="Cat.Reasoning.html#1548" class="Function">pulll</a> <a id="11464" class="Symbol">(</a><a id="11465" href="Cat.Diagram.Equaliser.html#790" class="Function">Ker.universal</a> <a id="11479" class="Symbol">_)</a> <a id="11482" href="1Lab.Path.html#46629" class="Function">⟩</a>
        <a id="11492" href="Cat.Abelian.Base.html#10130" class="Function">proj′</a> <a id="11498" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="11500" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="11511" class="Symbol">(</a><a id="11512" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="11523" href="Cat.Abelian.Base.html#10095" class="Bound">f</a><a id="11524" class="Symbol">)</a>                           <a id="11552" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a id="11555" href="Cat.Diagram.Coequaliser.html#834" class="Function">Coker.universal</a> <a id="11571" class="Symbol">_</a> <a id="11573" href="1Lab.Path.html#46629" class="Function">⟩</a>
        <a id="11583" href="Cat.Abelian.Base.html#10095" class="Bound">f</a>                                                           <a id="11643" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
</pre>-->
<p>A pre-abelian category is <strong>abelian</strong> when the map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">f&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> in the above decomposition is an isomorphism.</p>
<pre class="Agda"><a id="11765" class="Keyword">record</a> <a id="is-abelian"></a><a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="11772" href="Cat.Abelian.Base.html#11772" class="Record">is-abelian</a> <a id="11783" class="Symbol">{</a><a id="11784" href="Cat.Abelian.Base.html#11784" class="Bound">o</a> <a id="11786" href="Cat.Abelian.Base.html#11786" class="Bound">ℓ</a><a id="11787" class="Symbol">}</a> <a id="11789" class="Symbol">(</a><a id="11790" href="Cat.Abelian.Base.html#11790" class="Bound">C</a> <a id="11792" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="11794" href="Cat.Base.html#704" class="Record">Precategory</a> <a id="11806" href="Cat.Abelian.Base.html#11784" class="Bound">o</a> <a id="11808" href="Cat.Abelian.Base.html#11786" class="Bound">ℓ</a><a id="11809" class="Symbol">)</a> <a id="11811" class="Symbol">:</a> <a id="11813" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="11818" class="Symbol">(</a><a id="11819" href="Cat.Abelian.Base.html#11784" class="Bound">o</a> <a data-type="Level → Level → Level" id="11821" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a data-type="Level → Level" id="11823" href="Agda.Primitive.html#780" class="Primitive">lsuc</a> <a id="11828" href="Cat.Abelian.Base.html#11786" class="Bound">ℓ</a><a id="11829" class="Symbol">)</a> <a id="11831" class="Keyword">where</a>
  <a id="11839" class="Keyword">field</a> <a id="is-abelian.has-is-preab"></a><a data-type="is-abelian C → is-pre-abelian C" id="11845" href="Cat.Abelian.Base.html#11845" class="Field">has-is-preab</a> <a id="11858" class="Symbol">:</a> <a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="11860" href="Cat.Abelian.Base.html#9047" class="Record">is-pre-abelian</a> <a id="11875" href="Cat.Abelian.Base.html#11790" class="Bound">C</a>
  <a id="11879" class="Keyword">open</a> <a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="11884" href="Cat.Abelian.Base.html#9047" class="Module">is-pre-abelian</a> <a data-type="is-abelian C → is-pre-abelian C" id="11899" href="Cat.Abelian.Base.html#11845" class="Field">has-is-preab</a> <a id="11912" class="Keyword">public</a>
  <a id="11921" class="Keyword">field</a>
    <a id="is-abelian.coker-ker≃ker-coker"></a><a data-type="(r : is-abelian C) (f : Hom (r .has-is-preab) A B₁) →
is-invertible r (decompose r f .fst)" id="11931" href="Cat.Abelian.Base.html#11931" class="Field">coker-ker≃ker-coker</a>
      <a id="11957" class="Symbol">:</a> <a id="11959" class="Symbol">∀</a> <a id="11961" class="Symbol">{</a><a id="11962" href="Cat.Abelian.Base.html#11962" class="Bound">A</a> <a id="11964" href="Cat.Abelian.Base.html#11964" class="Bound">B</a><a id="11965" class="Symbol">}</a> <a id="11967" class="Symbol">(</a><a id="11968" href="Cat.Abelian.Base.html#11968" class="Bound">f</a> <a id="11970" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="11972" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="11976" href="Cat.Abelian.Base.html#11962" class="Bound">A</a> <a id="11978" href="Cat.Abelian.Base.html#11964" class="Bound">B</a><a id="11979" class="Symbol">)</a> <a id="11981" class="Symbol">→</a> <a data-type="(C : Precategory o h) (f : Hom C a b) → Type (o ⊔ h)" id="11983" href="Cat.Morphism.html#1930" class="Record">is-invertible</a> <a id="11997" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom (has-is-preab r) A B₁) →
Σ
(λ f′ →
   f ≡
   (has-is-preab r ∘
    kernel (has-is-preab r) (coeq (has-is-preab r) f))
   ((has-is-preab r ∘ f′)
    (coeq (has-is-preab r) (kernel (has-is-preab r) f))))" id="11998" href="Cat.Abelian.Base.html#9890" class="Function">decompose</a> <a id="12008" href="Cat.Abelian.Base.html#11968" class="Bound">f</a> <a id="12010" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="12011" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="12014" class="Symbol">)</a>
</pre>
  </article>
</div>

</main>
</body>
</html>
