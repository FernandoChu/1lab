<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>Cat.Abelian.Base - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />
  <link rel="stylesheet" href="/css/agda-cats.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Cat.Abelian.Base - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="Cat.Abelian.Base - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script src="/equations.js"></script>
  <script src="/highlight-hover.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

  <!-- Google font embeds -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&amp;family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&amp;display=swap" rel="stylesheet">
</head>

<body>
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">Cat.Abelian.Base</a>
              </h3>

      <!-- Cube logo -->
      <a id="logo" href="/">
        <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />
      </a>

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#abelian-categories"><a href="#abelian-categories" class="header-link">Abelian categories<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#ab-enriched-categories"><a href="#ab-enriched-categories" class="header-link">Ab-enriched categories<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#additive-categories"><a href="#additive-categories" class="header-link">Additive categories<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#pre-abelian-abelian-categories"><a href="#pre-abelian-abelian-categories" class="header-link">Pre-abelian &amp; abelian categories<span class="header-link-emoji">🔗</span></a></a></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
              <a href="/">back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/f6813af9f875ba688b45dfdae625653a0833e541/src/Cat/Abelian/Base.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="/">back to index</a>
      </div>
      
      <!-- Font toggle checkbox -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="Algebra.Magma.Unital.html" class="Module">Algebra.Magma.Unital</a>
<a id="42" class="Keyword">open</a> <a id="47" class="Keyword">import</a> <a id="54" href="Algebra.Group.Ab.html" class="Module">Algebra.Group.Ab</a>
<a id="71" class="Keyword">open</a> <a id="76" class="Keyword">import</a> <a id="83" href="Algebra.Prelude.html" class="Module">Algebra.Prelude</a>
<a id="99" class="Keyword">open</a> <a id="104" class="Keyword">import</a> <a id="111" href="Algebra.Monoid.html" class="Module">Algebra.Monoid</a>
<a id="126" class="Keyword">open</a> <a id="131" class="Keyword">import</a> <a id="138" href="Algebra.Group.html" class="Module">Algebra.Group</a>

<a id="153" class="Keyword">open</a> <a id="158" class="Keyword">import</a> <a id="165" href="Cat.Diagram.Equaliser.Kernel.html" class="Module">Cat.Diagram.Equaliser.Kernel</a>

<a id="195" class="Keyword">import</a> <a id="202" href="Algebra.Group.Cat.Base.html" class="Module">Algebra.Group.Cat.Base</a> <a id="225" class="Symbol">as</a> <a id="228" class="Module">Grp</a>

<a id="233" class="Keyword">module</a> <a id="240" href="Cat.Abelian.Base.html" class="Module">Cat.Abelian.Base</a> <a id="257" class="Keyword">where</a>
</pre>
<h1 id="abelian-categories"><a href="#abelian-categories" class="header-link">Abelian categories<span class="header-link-emoji">🔗</span></a></h1>
<p>This module defines the sequence of properties which “work up to” abelian categories: Ab-enriched categories, pre-additive categories, pre-abelian categories, and abelian categories. Each concept builds on the last by adding a new categorical property on top of a precategory.</p>
<h2 id="ab-enriched-categories"><a href="#ab-enriched-categories" class="header-link">Ab-enriched categories<span class="header-link-emoji">🔗</span></a></h2>
<p>An <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">\Ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathbf">Ab</span></span></span></span></span>-enriched</span> category is one where each <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>hom</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\hom</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mop">hom</span></span></span></span> set carries the structure of an <a href="Algebra.Group.Ab.html">Abelian group</a>, such that the composition map is <em>bilinear</em>, hence extending to an Abelian group homomorphism</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo><mo>⊗</mo><mi>hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>→</mo><mi>hom</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo><mtext>,</mtext></mrow><annotation encoding="application/x-tex">
\hom(b, c) \otimes \hom(a, b) \to \hom(a, c)\text{,}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">hom</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">hom</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">hom</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span><span class="mord text"><span class="mord">,</span></span></span></span></span></span></p>
<p>where the term on the left is the <a href="Algebra.Group.Ab.html#the-tensor-product">tensor product</a> of the corresponding <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>hom</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\hom</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mop">hom</span></span></span></span>-groups.</span> As the name implies, every such category has a canonical <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">\Ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathbf">Ab</span></span></span></span></span>-enrichment</span> (made monoidal using <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mo>⊗</mo><mo>−</mo></mrow><annotation encoding="application/x-tex">- \otimes -</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⊗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">−</span></span></span></span>),</span> but we do not use the language of enriched category theory in our development of Abelian categories.</p>
<pre class="Agda"><a id="1295" class="Keyword">record</a> <a id="Ab-category"></a><a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="1302" href="Cat.Abelian.Base.html#1302" class="Record">Ab-category</a> <a id="1314" class="Symbol">{</a><a id="1315" href="Cat.Abelian.Base.html#1315" class="Bound">o</a> <a id="1317" href="Cat.Abelian.Base.html#1317" class="Bound">ℓ</a><a id="1318" class="Symbol">}</a> <a id="1320" class="Symbol">(</a><a id="1321" href="Cat.Abelian.Base.html#1321" class="Bound">C</a> <a id="1323" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="1325" href="Cat.Base.html#704" class="Record">Precategory</a> <a id="1337" href="Cat.Abelian.Base.html#1315" class="Bound">o</a> <a id="1339" href="Cat.Abelian.Base.html#1317" class="Bound">ℓ</a><a id="1340" class="Symbol">)</a> <a id="1342" class="Symbol">:</a> <a id="1344" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="1349" class="Symbol">(</a><a id="1350" href="Cat.Abelian.Base.html#1315" class="Bound">o</a> <a data-type="Level → Level → Level" id="1352" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a data-type="Level → Level" id="1354" href="Agda.Primitive.html#780" class="Primitive">lsuc</a> <a id="1359" href="Cat.Abelian.Base.html#1317" class="Bound">ℓ</a><a id="1360" class="Symbol">)</a> <a id="1362" class="Keyword">where</a>
  <a id="1370" class="Keyword">open</a> <a id="1375" href="Algebra.Prelude.html#883" class="Module">Cat</a> <a id="1379" href="Cat.Abelian.Base.html#1321" class="Bound">C</a> <a id="1381" class="Keyword">public</a>
  <a id="1390" class="Keyword">field</a>
    <a id="Ab-category.Group-on-hom"></a><a data-type="(r : is-abelian C) (A B₁ : C .Ob) → Group-on (Hom C A B₁)" id="1400" href="Cat.Abelian.Base.html#1400" class="Field">Group-on-hom</a> <a id="1413" class="Symbol">:</a> <a id="1415" class="Symbol">∀</a> <a id="1417" href="Cat.Abelian.Base.html#1417" class="Bound">A</a> <a id="1419" href="Cat.Abelian.Base.html#1419" class="Bound">B</a> <a id="1421" class="Symbol">→</a> <a data-type="(A : Type ℓ) → Type ℓ" id="1423" href="Algebra.Group.html#5688" class="Record">Group-on</a> <a id="1432" class="Symbol">(</a><a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1433" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="1437" href="Cat.Abelian.Base.html#1417" class="Bound">A</a> <a id="1439" href="Cat.Abelian.Base.html#1419" class="Bound">B</a><a id="1440" class="Symbol">)</a>

  <a id="Ab-category._+_"></a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="1445" href="Cat.Abelian.Base.html#1445" class="Function Operator">_+_</a> <a id="1449" class="Symbol">:</a> <a id="1451" class="Symbol">∀</a> <a id="1453" class="Symbol">{</a><a id="1454" href="Cat.Abelian.Base.html#1454" class="Bound">A</a> <a id="1456" href="Cat.Abelian.Base.html#1456" class="Bound">B</a><a id="1457" class="Symbol">}</a> <a id="1459" class="Symbol">(</a><a id="1460" href="Cat.Abelian.Base.html#1460" class="Bound">f</a> <a id="1462" href="Cat.Abelian.Base.html#1462" class="Bound">g</a> <a id="1464" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1466" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="1470" href="Cat.Abelian.Base.html#1454" class="Bound">A</a> <a id="1472" href="Cat.Abelian.Base.html#1456" class="Bound">B</a><a id="1473" class="Symbol">)</a> <a id="1475" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1477" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="1481" href="Cat.Abelian.Base.html#1454" class="Bound">A</a> <a id="1483" href="Cat.Abelian.Base.html#1456" class="Bound">B</a>
  <a id="1487" href="Cat.Abelian.Base.html#1487" class="Bound">f</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="1489" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="1491" href="Cat.Abelian.Base.html#1491" class="Bound">g</a> <a id="1493" class="Symbol">=</a> <a data-type="(r : is-abelian C) (A B₁ : C .Ob) → Group-on (Hom C A B₁)" id="1495" href="Cat.Abelian.Base.html#1400" class="Field">Group-on-hom</a> <a id="1508" class="Symbol">_</a> <a id="1510" class="Symbol">_</a> <a id="1512" class="Symbol">.</a><a data-type="(G : AbGroup ℓ) → G .object .fst → G .object .fst → G .object .fst" id="1513" href="Algebra.Group.html#5741" class="Field Operator">Group-on._⋆_</a> <a id="1526" href="Cat.Abelian.Base.html#1487" class="Bound">f</a> <a id="1528" href="Cat.Abelian.Base.html#1491" class="Bound">g</a>

  <a id="Ab-category.0m"></a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="1533" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a id="1536" class="Symbol">:</a> <a id="1538" class="Symbol">∀</a> <a id="1540" class="Symbol">{</a><a id="1541" href="Cat.Abelian.Base.html#1541" class="Bound">A</a> <a id="1543" href="Cat.Abelian.Base.html#1543" class="Bound">B</a><a id="1544" class="Symbol">}</a> <a id="1546" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1548" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="1552" href="Cat.Abelian.Base.html#1541" class="Bound">A</a> <a id="1554" href="Cat.Abelian.Base.html#1543" class="Bound">B</a>
  <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="1558" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a id="1561" class="Symbol">=</a> <a data-type="(r : is-abelian C) (A B₁ : C .Ob) → Group-on (Hom C A B₁)" id="1563" href="Cat.Abelian.Base.html#1400" class="Field">Group-on-hom</a> <a id="1576" class="Symbol">_</a> <a id="1578" class="Symbol">_</a> <a id="1580" class="Symbol">.</a><a data-type="(G : AbGroup ℓ) → G .object .fst" id="1581" href="Algebra.Group.html#1060" class="Function">Group-on.unit</a>

  <a id="1598" class="Keyword">field</a>
    <a id="Ab-category.Hom-grp-ab"></a><a data-type="(r : is-abelian C) (A B₁ : C .Ob) (f g : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ f g
≡
has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g f" id="1608" href="Cat.Abelian.Base.html#1608" class="Field">Hom-grp-ab</a> <a id="1619" class="Symbol">:</a> <a id="1621" class="Symbol">∀</a> <a id="1623" href="Cat.Abelian.Base.html#1623" class="Bound">A</a> <a id="1625" href="Cat.Abelian.Base.html#1625" class="Bound">B</a> <a id="1627" class="Symbol">(</a><a id="1628" href="Cat.Abelian.Base.html#1628" class="Bound">f</a> <a id="1630" href="Cat.Abelian.Base.html#1630" class="Bound">g</a> <a id="1632" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1634" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="1638" href="Cat.Abelian.Base.html#1623" class="Bound">A</a> <a id="1640" href="Cat.Abelian.Base.html#1625" class="Bound">B</a><a id="1641" class="Symbol">)</a> <a id="1643" class="Symbol">→</a> <a id="1645" href="Cat.Abelian.Base.html#1628" class="Bound">f</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="1647" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="1649" href="Cat.Abelian.Base.html#1630" class="Bound">g</a> <a data-type="A → A → Type ℓ" id="1651" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="1653" href="Cat.Abelian.Base.html#1630" class="Bound">g</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="1655" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="1657" href="Cat.Abelian.Base.html#1628" class="Bound">f</a>

  <a id="Ab-category.Hom-grp"></a><a data-type="(r : is-abelian C) (A : C .Ob) → C .Ob → AbGroup ℓ" id="1662" href="Cat.Abelian.Base.html#1662" class="Function">Hom-grp</a> <a id="1670" class="Symbol">:</a> <a id="1672" class="Symbol">∀</a> <a id="1674" href="Cat.Abelian.Base.html#1674" class="Bound">A</a> <a id="1676" href="Cat.Abelian.Base.html#1676" class="Bound">B</a> <a id="1678" class="Symbol">→</a> <a data-type="(ℓ : Level) → Type (lsuc ℓ)" id="1680" href="Algebra.Group.Ab.html#1602" class="Function">AbGroup</a> <a id="1688" href="Cat.Abelian.Base.html#1317" class="Bound">ℓ</a>
  <a data-type="(r : is-abelian C) (A : C .Ob) → C .Ob → AbGroup ℓ" id="1692" href="Cat.Abelian.Base.html#1662" class="Function">Hom-grp</a> <a id="1700" href="Cat.Abelian.Base.html#1700" class="Bound">A</a> <a id="1702" href="Cat.Abelian.Base.html#1702" class="Bound">B</a> <a id="1704" class="Symbol">=</a> <a id="1706" class="Symbol">(</a><a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1707" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="1711" href="Cat.Abelian.Base.html#1700" class="Bound">A</a> <a id="1713" href="Cat.Abelian.Base.html#1702" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="1715" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="(r : is-abelian C) (A B₁ : C .Ob) → Group-on (Hom C A B₁)" id="1717" href="Cat.Abelian.Base.html#1400" class="Field">Group-on-hom</a> <a id="1730" href="Cat.Abelian.Base.html#1700" class="Bound">A</a> <a id="1732" href="Cat.Abelian.Base.html#1702" class="Bound">B</a><a id="1733" class="Symbol">)</a> <a data-type="(object₁ : Ob C) (witness₁ : P object₁) → Restrict-ob P" id="1735" href="Cat.Functor.FullSubcategory.html#1047" class="InductiveConstructor Operator">,</a> <a data-type="(r : is-abelian C) (A B₁ : C .Ob) (f g : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ f g
≡
has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g f" id="1737" href="Cat.Abelian.Base.html#1608" class="Field">Hom-grp-ab</a> <a id="1748" href="Cat.Abelian.Base.html#1700" class="Bound">A</a> <a id="1750" href="Cat.Abelian.Base.html#1702" class="Bound">B</a>

  <a id="1755" class="Keyword">field</a>
    <a id="1765" class="Comment">-- Composition is multilinear:</a>
    <a id="Ab-category.∘-linear-l"></a><a data-type="(r : is-abelian C) (f g : Hom C B₁ C) (h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) h) ((C ∘ g) h)
≡
(C ∘
 has-ab (has-additive (has-is-preab r)) .Group-on-hom B₁ C ._⋆_ f g)
h" id="1800" href="Cat.Abelian.Base.html#1800" class="Field">∘-linear-l</a>
      <a id="1817" class="Symbol">:</a> <a id="1819" class="Symbol">∀</a> <a id="1821" class="Symbol">{</a><a id="1822" href="Cat.Abelian.Base.html#1822" class="Bound">A</a> <a id="1824" href="Cat.Abelian.Base.html#1824" class="Bound">B</a> <a id="1826" href="Cat.Abelian.Base.html#1826" class="Bound">C</a><a id="1827" class="Symbol">}</a> <a id="1829" class="Symbol">(</a><a id="1830" href="Cat.Abelian.Base.html#1830" class="Bound">f</a> <a id="1832" href="Cat.Abelian.Base.html#1832" class="Bound">g</a> <a id="1834" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1836" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="1840" href="Cat.Abelian.Base.html#1824" class="Bound">B</a> <a id="1842" href="Cat.Abelian.Base.html#1826" class="Bound">C</a><a id="1843" class="Symbol">)</a> <a id="1845" class="Symbol">(</a><a id="1846" href="Cat.Abelian.Base.html#1846" class="Bound">h</a> <a id="1848" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1850" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="1854" href="Cat.Abelian.Base.html#1822" class="Bound">A</a> <a id="1856" href="Cat.Abelian.Base.html#1824" class="Bound">B</a><a id="1857" class="Symbol">)</a>
      <a id="1865" class="Symbol">→</a> <a id="1867" class="Symbol">(</a><a id="1868" href="Cat.Abelian.Base.html#1830" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="1870" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="1872" href="Cat.Abelian.Base.html#1846" class="Bound">h</a><a id="1873" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="1875" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="1877" class="Symbol">(</a><a id="1878" href="Cat.Abelian.Base.html#1832" class="Bound">g</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="1880" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="1882" href="Cat.Abelian.Base.html#1846" class="Bound">h</a><a id="1883" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="1885" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="1887" class="Symbol">(</a><a id="1888" href="Cat.Abelian.Base.html#1830" class="Bound">f</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="1890" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="1892" href="Cat.Abelian.Base.html#1832" class="Bound">g</a><a id="1893" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="1895" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="1897" href="Cat.Abelian.Base.html#1846" class="Bound">h</a>
    <a id="Ab-category.∘-linear-r"></a><a data-type="(r : is-abelian C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) g) ((C ∘ f) h)
≡
(C ∘ f)
(has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g
 h)" id="1903" href="Cat.Abelian.Base.html#1903" class="Field">∘-linear-r</a>
      <a id="1920" class="Symbol">:</a> <a id="1922" class="Symbol">∀</a> <a id="1924" class="Symbol">{</a><a id="1925" href="Cat.Abelian.Base.html#1925" class="Bound">A</a> <a id="1927" href="Cat.Abelian.Base.html#1927" class="Bound">B</a> <a id="1929" href="Cat.Abelian.Base.html#1929" class="Bound">C</a><a id="1930" class="Symbol">}</a> <a id="1932" class="Symbol">(</a><a id="1933" href="Cat.Abelian.Base.html#1933" class="Bound">f</a> <a id="1935" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1937" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="1941" href="Cat.Abelian.Base.html#1927" class="Bound">B</a> <a id="1943" href="Cat.Abelian.Base.html#1929" class="Bound">C</a><a id="1944" class="Symbol">)</a> <a id="1946" class="Symbol">(</a><a id="1947" href="Cat.Abelian.Base.html#1947" class="Bound">g</a> <a id="1949" href="Cat.Abelian.Base.html#1949" class="Bound">h</a> <a id="1951" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1953" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="1957" href="Cat.Abelian.Base.html#1925" class="Bound">A</a> <a id="1959" href="Cat.Abelian.Base.html#1927" class="Bound">B</a><a id="1960" class="Symbol">)</a>
      <a id="1968" class="Symbol">→</a> <a id="1970" class="Symbol">(</a><a id="1971" href="Cat.Abelian.Base.html#1933" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="1973" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="1975" href="Cat.Abelian.Base.html#1947" class="Bound">g</a><a id="1976" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="1978" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="1980" class="Symbol">(</a><a id="1981" href="Cat.Abelian.Base.html#1933" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="1983" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="1985" href="Cat.Abelian.Base.html#1949" class="Bound">h</a><a id="1986" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="1988" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="1990" href="Cat.Abelian.Base.html#1933" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="1992" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="1994" class="Symbol">(</a><a id="1995" href="Cat.Abelian.Base.html#1947" class="Bound">g</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="1997" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="1999" href="Cat.Abelian.Base.html#1949" class="Bound">h</a><a id="2000" class="Symbol">)</a>

  <a id="Ab-category.∘map"></a><a data-type="(r : is-abelian C) →
Hom (Hom-grp r B₁ C ⊗ Hom-grp r A B₁) (Hom-grp r A C)" id="2005" href="Cat.Abelian.Base.html#2005" class="Function">∘map</a> <a id="2010" class="Symbol">:</a> <a id="2012" class="Symbol">∀</a> <a id="2014" class="Symbol">{</a><a id="2015" href="Cat.Abelian.Base.html#2015" class="Bound">A</a> <a id="2017" href="Cat.Abelian.Base.html#2017" class="Bound">B</a> <a id="2019" href="Cat.Abelian.Base.html#2019" class="Bound">C</a><a id="2020" class="Symbol">}</a> <a id="2022" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="2024" href="Cat.Base.html#1436" class="Function">Ab.Hom</a> <a id="2031" class="Symbol">(</a><a data-type="(r : is-abelian C) (A : C .Ob) → C .Ob → AbGroup ℓ" id="2032" href="Cat.Abelian.Base.html#1662" class="Function">Hom-grp</a> <a id="2040" href="Cat.Abelian.Base.html#2017" class="Bound">B</a> <a id="2042" href="Cat.Abelian.Base.html#2019" class="Bound">C</a> <a data-type="(A B₁ : AbGroup ℓ) → AbGroup ℓ" id="2044" href="Algebra.Group.Ab.html#8398" class="Function Operator">⊗</a> <a data-type="(r : is-abelian C) (A : C .Ob) → C .Ob → AbGroup ℓ" id="2046" href="Cat.Abelian.Base.html#1662" class="Function">Hom-grp</a> <a id="2054" href="Cat.Abelian.Base.html#2015" class="Bound">A</a> <a id="2056" href="Cat.Abelian.Base.html#2017" class="Bound">B</a><a id="2057" class="Symbol">)</a> <a id="2059" class="Symbol">(</a><a data-type="(r : is-abelian C) (A : C .Ob) → C .Ob → AbGroup ℓ" id="2060" href="Cat.Abelian.Base.html#1662" class="Function">Hom-grp</a> <a id="2068" href="Cat.Abelian.Base.html#2015" class="Bound">A</a> <a id="2070" href="Cat.Abelian.Base.html#2019" class="Bound">C</a><a id="2071" class="Symbol">)</a>
  <a data-type="(r : is-abelian C) →
Hom (Hom-grp r B₁ C ⊗ Hom-grp r A B₁) (Hom-grp r A C)" id="2075" href="Cat.Abelian.Base.html#2005" class="Function">∘map</a> <a id="2080" class="Symbol">{</a><a id="2081" href="Cat.Abelian.Base.html#2081" class="Bound">A</a><a id="2082" class="Symbol">}</a> <a id="2084" class="Symbol">{</a><a id="2085" href="Cat.Abelian.Base.html#2085" class="Bound">B</a><a id="2086" class="Symbol">}</a> <a id="2088" class="Symbol">{</a><a id="2089" href="Cat.Abelian.Base.html#2089" class="Bound">C</a><a id="2090" class="Symbol">}</a> <a id="2092" class="Symbol">=</a>
    <a data-type="(f : ₀ A → ₀ B₁ → ₀ C) →
((x y : A .object .fst) (z : ₀ B₁) →
 f ((A ⋆ x) y) z ≡ (C ⋆ f x z) (f y z)) →
((x y : B₁ .object .fst) (z : ₀ A) →
 f z ((B₁ ⋆ x) y) ≡ (C ⋆ f z x) (f z y)) →
Hom (A ⊗ B₁) C" id="2098" href="Algebra.Group.Ab.html#10577" class="Function">from-multilinear-map</a> <a id="2119" class="Symbol">{</a><a id="2120" class="Argument">A</a> <a id="2122" class="Symbol">=</a> <a data-type="(r : is-abelian C) (A : C .Ob) → C .Ob → AbGroup ℓ" id="2124" href="Cat.Abelian.Base.html#1662" class="Function">Hom-grp</a> <a id="2132" href="Cat.Abelian.Base.html#2085" class="Bound">B</a> <a id="2134" href="Cat.Abelian.Base.html#2089" class="Bound">C</a><a id="2135" class="Symbol">}</a> <a id="2137" class="Symbol">{</a><a id="2138" class="Argument">B</a> <a id="2140" class="Symbol">=</a> <a data-type="(r : is-abelian C) (A : C .Ob) → C .Ob → AbGroup ℓ" id="2142" href="Cat.Abelian.Base.html#1662" class="Function">Hom-grp</a> <a id="2150" href="Cat.Abelian.Base.html#2081" class="Bound">A</a> <a id="2152" href="Cat.Abelian.Base.html#2085" class="Bound">B</a><a id="2153" class="Symbol">}</a> <a id="2155" class="Symbol">{</a><a id="2156" class="Argument">C</a> <a id="2158" class="Symbol">=</a> <a data-type="(r : is-abelian C) (A : C .Ob) → C .Ob → AbGroup ℓ" id="2160" href="Cat.Abelian.Base.html#1662" class="Function">Hom-grp</a> <a id="2168" href="Cat.Abelian.Base.html#2081" class="Bound">A</a> <a id="2170" href="Cat.Abelian.Base.html#2089" class="Bound">C</a><a id="2171" class="Symbol">}</a>
      <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2179" href="Cat.Base.html#3006" class="Function Operator">_∘_</a>
      <a id="2189" class="Symbol">(λ</a> <a id="2192" href="Cat.Abelian.Base.html#2192" class="Bound">f</a> <a id="2194" href="Cat.Abelian.Base.html#2194" class="Bound">g</a> <a id="2196" href="Cat.Abelian.Base.html#2196" class="Bound">h</a> <a id="2198" class="Symbol">→</a> <a data-type="x ≡ y → y ≡ x" id="2200" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="2204" class="Symbol">(</a><a data-type="(r : is-abelian C) (f g : Hom C B₁ C) (h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) h) ((C ∘ g) h)
≡
(C ∘
 has-ab (has-additive (has-is-preab r)) .Group-on-hom B₁ C ._⋆_ f g)
h" id="2205" href="Cat.Abelian.Base.html#1800" class="Field">∘-linear-l</a> <a id="2216" class="Symbol">_</a> <a id="2218" class="Symbol">_</a> <a id="2220" class="Symbol">_))</a>
      <a id="2230" class="Symbol">(λ</a> <a id="2233" href="Cat.Abelian.Base.html#2233" class="Bound">f</a> <a id="2235" href="Cat.Abelian.Base.html#2235" class="Bound">g</a> <a id="2237" href="Cat.Abelian.Base.html#2237" class="Bound">h</a> <a id="2239" class="Symbol">→</a> <a data-type="x ≡ y → y ≡ x" id="2241" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="2245" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) g) ((C ∘ f) h)
≡
(C ∘ f)
(has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g
 h)" id="2246" href="Cat.Abelian.Base.html#1903" class="Field">∘-linear-r</a> <a id="2257" class="Symbol">_</a> <a id="2259" class="Symbol">_</a> <a id="2261" class="Symbol">_))</a>

  <a id="2268" class="Keyword">module</a> <a id="Ab-category.Hom"></a><a id="2275" href="Cat.Abelian.Base.html#2275" class="Module">Hom</a> <a id="2279" class="Symbol">{</a><a id="2280" href="Cat.Abelian.Base.html#2280" class="Bound">A</a> <a id="2282" href="Cat.Abelian.Base.html#2282" class="Bound">B</a><a id="2283" class="Symbol">}</a> <a id="2285" class="Symbol">=</a> <a id="2287" href="Algebra.Group.Ab.html#1916" class="Module">AbGrp</a> <a id="2293" class="Symbol">(</a><a data-type="(r : is-abelian C) (A : C .Ob) → C .Ob → AbGroup ℓ" id="2294" href="Cat.Abelian.Base.html#1662" class="Function">Hom-grp</a> <a id="2302" href="Cat.Abelian.Base.html#2280" class="Bound">A</a> <a id="2304" href="Cat.Abelian.Base.html#2282" class="Bound">B</a><a id="2305" class="Symbol">)</a>
  <a id="2309" class="Keyword">open</a> <a id="2314" href="Cat.Abelian.Base.html#2275" class="Module">Hom</a>
    <a id="2322" class="Keyword">using</a> <a id="2328" class="Symbol">(</a><a data-type="(G : AbGroup ℓ) →
(has-is-group (G .object .snd) — x) y ≡
unit (has-is-group (G .object .snd)) →
x ≡ y" id="2329" href="Algebra.Group.html#2225" class="Function">zero-diff</a><a id="2338" class="Symbol">)</a>
    <a id="2344" class="Keyword">renaming</a> <a id="2353" class="Symbol">(</a><a data-type="(G : AbGroup ℓ) → G .object .fst → G .object .fst → G .object .fst" id="2354" href="Algebra.Group.html#1488" class="Function Operator">_—_</a> <a id="2358" class="Symbol">to</a> <a id="2361" class="Function Operator">_-_</a><a id="2364" class="Symbol">)</a>
    <a id="2370" class="Keyword">public</a>
</pre>
<p>Note that from multilinearity of composition, it follows that <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>f</mi><mo>=</mo><mi>f</mi><mn>0</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">0f = f0 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>:</span></p>
<pre class="Agda">  <a id="Ab-category.∘-zero-r"></a><a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ f) (0m r) ≡ 0m r" id="2470" href="Cat.Abelian.Base.html#2470" class="Function">∘-zero-r</a> <a id="2479" class="Symbol">:</a> <a id="2481" class="Symbol">∀</a> <a id="2483" class="Symbol">{</a><a id="2484" href="Cat.Abelian.Base.html#2484" class="Bound">A</a> <a id="2486" href="Cat.Abelian.Base.html#2486" class="Bound">B</a> <a id="2488" href="Cat.Abelian.Base.html#2488" class="Bound">C</a><a id="2489" class="Symbol">}</a> <a id="2491" class="Symbol">{</a><a id="2492" href="Cat.Abelian.Base.html#2492" class="Bound">f</a> <a id="2494" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="2496" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="2500" href="Cat.Abelian.Base.html#2486" class="Bound">B</a> <a id="2502" href="Cat.Abelian.Base.html#2488" class="Bound">C</a><a id="2503" class="Symbol">}</a> <a id="2505" class="Symbol">→</a> <a id="2507" href="Cat.Abelian.Base.html#2492" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2509" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2511" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a id="2514" class="Symbol">{</a><a id="2515" href="Cat.Abelian.Base.html#2484" class="Bound">A</a><a id="2516" class="Symbol">}</a> <a id="2518" class="Symbol">{</a><a id="2519" href="Cat.Abelian.Base.html#2486" class="Bound">B</a><a id="2520" class="Symbol">}</a> <a data-type="A → A → Type ℓ" id="2522" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2524" href="Cat.Abelian.Base.html#1533" class="Function">0m</a>
  <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ f) (0m r) ≡ 0m r" id="2529" href="Cat.Abelian.Base.html#2470" class="Function">∘-zero-r</a> <a id="2538" class="Symbol">{</a><a id="2539" class="Argument">f</a> <a id="2541" class="Symbol">=</a> <a id="2543" href="Cat.Abelian.Base.html#2543" class="Bound">f</a><a id="2544" class="Symbol">}</a> <a id="2546" class="Symbol">=</a>
    <a id="2552" href="Cat.Abelian.Base.html#2543" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2554" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2556" href="Cat.Abelian.Base.html#1533" class="Function">0m</a>                     <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2579" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → f ≡ (C ∘ f) a" id="2582" href="Cat.Reasoning.html#1250" class="Function">Hom.intror</a> <a data-type="(G : AbGroup ℓ) →
G .object .snd ._⋆_ x (has-is-group (G .object .snd) .inverse x) ≡
has-is-group (G .object .snd) .unit" id="2593" href="Algebra.Group.html#1387" class="Function">Hom.inverser</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2606" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="2612" href="Cat.Abelian.Base.html#2543" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2614" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2616" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2619" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="2621" class="Symbol">(</a><a id="2622" href="Cat.Abelian.Base.html#2543" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2624" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2626" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : is-abelian C) →
Hom-grp r A B₁ .object .fst →
Hom-grp r A B₁ .object .fst → Hom-grp r A B₁ .object .fst" id="2629" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="2631" href="Cat.Abelian.Base.html#2543" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2633" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2635" href="Cat.Abelian.Base.html#1533" class="Function">0m</a><a id="2637" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2639" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="is-semigroup _⋆₁_ → (x ⋆₁ (y ⋆₁ z)) ≡ ((x ⋆₁ y) ⋆₁ z)" id="2642" href="Algebra.Semigroup.html#453" class="Function">Hom.associative</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2658" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="2664" class="Symbol">(</a><a id="2665" href="Cat.Abelian.Base.html#2543" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2667" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2669" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2672" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="2674" href="Cat.Abelian.Base.html#2543" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2676" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2678" href="Cat.Abelian.Base.html#1533" class="Function">0m</a><a id="2680" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom-grp r A B₁ .object .fst →
Hom-grp r A B₁ .object .fst → Hom-grp r A B₁ .object .fst" id="2682" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="2684" href="Cat.Abelian.Base.html#2543" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2686" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2688" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2691" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="2694" href="1Lab.Path.html#20756" class="Function">ap</a> <a id="2697" class="Symbol">(</a><a data-type="(r : is-abelian C) →
Hom-grp r A B₁ .object .fst →
Hom-grp r A B₁ .object .fst → Hom-grp r A B₁ .object .fst" id="2698" href="Cat.Abelian.Base.html#2361" class="Function Operator">_-</a> <a id="2701" href="Cat.Abelian.Base.html#2543" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2703" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2705" href="Cat.Abelian.Base.html#1533" class="Function">0m</a><a id="2707" class="Symbol">)</a> <a id="2709" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) g) ((C ∘ f) h)
≡
(C ∘ f)
(has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g
 h)" id="2710" href="Cat.Abelian.Base.html#1903" class="Field">∘-linear-r</a> <a id="2721" class="Symbol">_</a> <a id="2723" class="Symbol">_</a> <a id="2725" class="Symbol">_)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2728" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="2734" class="Symbol">(</a><a id="2735" href="Cat.Abelian.Base.html#2543" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2737" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="2739" class="Symbol">(</a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2740" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2743" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2745" href="Cat.Abelian.Base.html#1533" class="Function">0m</a><a id="2747" class="Symbol">))</a> <a data-type="(r : is-abelian C) →
Hom-grp r A B₁ .object .fst →
Hom-grp r A B₁ .object .fst → Hom-grp r A B₁ .object .fst" id="2750" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="2752" href="Cat.Abelian.Base.html#2543" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2754" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2756" href="Cat.Abelian.Base.html#1533" class="Function">0m</a>   <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2761" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="2764" href="1Lab.Path.html#20756" class="Function">ap</a> <a id="2767" class="Symbol">((</a><a data-type="(r : is-abelian C) →
Hom-grp r A B₁ .object .fst →
Hom-grp r A B₁ .object .fst → Hom-grp r A B₁ .object .fst" id="2769" href="Cat.Abelian.Base.html#2361" class="Function Operator">_-</a> <a id="2772" href="Cat.Abelian.Base.html#2543" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2774" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2776" href="Cat.Abelian.Base.html#1533" class="Function">0m</a><a id="2778" class="Symbol">)</a> <a id="2780" href="Cat.Prelude.html#232" class="Function Operator">⊙</a> <a id="2782" class="Symbol">(</a><a id="2783" href="Cat.Abelian.Base.html#2543" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2785" href="Cat.Base.html#3006" class="Function Operator">∘_</a><a id="2787" class="Symbol">))</a> <a data-type="(r : Monoid-on A) → r ._⋆_ (r .identity) x ≡ x" id="2790" href="Algebra.Monoid.html#1088" class="Function">Hom.idl</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2798" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="2804" class="Symbol">(</a><a id="2805" href="Cat.Abelian.Base.html#2543" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2807" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2809" href="Cat.Abelian.Base.html#1533" class="Function">0m</a><a id="2811" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom-grp r A B₁ .object .fst →
Hom-grp r A B₁ .object .fst → Hom-grp r A B₁ .object .fst" id="2813" href="Cat.Abelian.Base.html#2361" class="Function Operator">-</a> <a id="2815" href="Cat.Abelian.Base.html#2543" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2817" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2819" href="Cat.Abelian.Base.html#1533" class="Function">0m</a>          <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2831" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(G : AbGroup ℓ) →
G .object .snd ._⋆_ x (has-is-group (G .object .snd) .inverse x) ≡
has-is-group (G .object .snd) .unit" id="2834" href="Algebra.Group.html#1387" class="Function">Hom.inverser</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2847" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2853" href="Cat.Abelian.Base.html#1533" class="Function">0m</a>                         <a data-type="(x : A) → x ≡ x" id="2880" href="1Lab.Path.html#46957" class="Function Operator">∎</a>

  <a id="Ab-category.∘-zero-l"></a><a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ 0m r) f ≡ 0m r" id="2885" href="Cat.Abelian.Base.html#2885" class="Function">∘-zero-l</a> <a id="2894" class="Symbol">:</a> <a id="2896" class="Symbol">∀</a> <a id="2898" class="Symbol">{</a><a id="2899" href="Cat.Abelian.Base.html#2899" class="Bound">A</a> <a id="2901" href="Cat.Abelian.Base.html#2901" class="Bound">B</a> <a id="2903" href="Cat.Abelian.Base.html#2903" class="Bound">C</a><a id="2904" class="Symbol">}</a> <a id="2906" class="Symbol">{</a><a id="2907" href="Cat.Abelian.Base.html#2907" class="Bound">f</a> <a id="2909" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="2911" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="2915" href="Cat.Abelian.Base.html#2899" class="Bound">A</a> <a id="2917" href="Cat.Abelian.Base.html#2901" class="Bound">B</a><a id="2918" class="Symbol">}</a> <a id="2920" class="Symbol">→</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2922" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2925" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="2927" href="Cat.Abelian.Base.html#2907" class="Bound">f</a> <a data-type="A → A → Type ℓ" id="2929" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2931" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a id="2934" class="Symbol">{</a><a id="2935" href="Cat.Abelian.Base.html#2899" class="Bound">A</a><a id="2936" class="Symbol">}</a> <a id="2938" class="Symbol">{</a><a id="2939" href="Cat.Abelian.Base.html#2903" class="Bound">C</a><a id="2940" class="Symbol">}</a>
  <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ 0m r) f ≡ 0m r" id="2944" href="Cat.Abelian.Base.html#2885" class="Function">∘-zero-l</a> <a id="2953" class="Symbol">{</a><a id="2954" class="Argument">f</a> <a id="2956" class="Symbol">=</a> <a id="2958" href="Cat.Abelian.Base.html#2958" class="Bound">f</a><a id="2959" class="Symbol">}</a> <a id="2961" class="Symbol">=</a>
    <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="2967" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2970" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="2972" href="Cat.Abelian.Base.html#2958" class="Bound">f</a>                                   <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3008" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → f ≡ (C ∘ a) f" id="3011" href="Cat.Reasoning.html#1207" class="Function">Hom.introl</a> <a data-type="(G : AbGroup ℓ) →
G .object .snd ._⋆_ (has-is-group (G .object .snd) .inverse x) x ≡
has-is-group (G .object .snd) .unit" id="3022" href="Algebra.Group.html#1341" class="Function">Hom.inversel</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3035" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="3041" class="Symbol">(</a><a data-type="(G : AbGroup ℓ) → G .object .fst → G .object .fst" id="3042" href="Algebra.Group.html#1320" class="Function">Hom.inverse</a> <a id="3054" class="Symbol">(</a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3055" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3058" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3060" href="Cat.Abelian.Base.html#2958" class="Bound">f</a><a id="3061" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3063" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3065" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3068" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3070" href="Cat.Abelian.Base.html#2958" class="Bound">f</a><a id="3071" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3073" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3075" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3078" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3080" href="Cat.Abelian.Base.html#2958" class="Bound">f</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3082" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="x ≡ y → y ≡ x" id="3085" href="1Lab.Path.html#10558" class="Function">sym</a> <a data-type="is-semigroup _⋆₁_ → (x ⋆₁ (y ⋆₁ z)) ≡ ((x ⋆₁ y) ⋆₁ z)" id="3089" href="Algebra.Semigroup.html#453" class="Function">Hom.associative</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3105" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a data-type="(G : AbGroup ℓ) → G .object .fst → G .object .fst" id="3111" href="Algebra.Group.html#1320" class="Function">Hom.inverse</a> <a id="3123" class="Symbol">(</a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3124" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3127" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3129" href="Cat.Abelian.Base.html#2958" class="Bound">f</a><a id="3130" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3132" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="3134" class="Symbol">(</a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3135" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3138" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3140" href="Cat.Abelian.Base.html#2958" class="Bound">f</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3142" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3144" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3147" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3149" href="Cat.Abelian.Base.html#2958" class="Bound">f</a><a id="3150" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3152" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="3155" href="1Lab.Path.html#20756" class="Function">ap</a> <a id="3158" class="Symbol">(</a><a data-type="(G : AbGroup ℓ) → G .object .fst → G .object .fst" id="3159" href="Algebra.Group.html#1320" class="Function">Hom.inverse</a> <a id="3171" class="Symbol">(</a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3172" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3175" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3177" href="Cat.Abelian.Base.html#2958" class="Bound">f</a><a id="3178" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3180" href="Cat.Abelian.Base.html#1445" class="Function Operator">+_</a><a id="3182" class="Symbol">)</a> <a id="3184" class="Symbol">(</a><a data-type="(r : is-abelian C) (f g : Hom C B₁ C) (h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) h) ((C ∘ g) h)
≡
(C ∘
 has-ab (has-additive (has-is-preab r)) .Group-on-hom B₁ C ._⋆_ f g)
h" id="3185" href="Cat.Abelian.Base.html#1800" class="Field">∘-linear-l</a> <a id="3196" class="Symbol">_</a> <a id="3198" class="Symbol">_</a> <a id="3200" class="Symbol">_)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3203" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a data-type="(G : AbGroup ℓ) → G .object .fst → G .object .fst" id="3209" href="Algebra.Group.html#1320" class="Function">Hom.inverse</a> <a id="3221" class="Symbol">(</a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3222" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3225" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3227" href="Cat.Abelian.Base.html#2958" class="Bound">f</a><a id="3228" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3230" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="3232" class="Symbol">((</a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3234" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3237" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3239" href="Cat.Abelian.Base.html#1533" class="Function">0m</a><a id="3241" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3243" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3245" href="Cat.Abelian.Base.html#2958" class="Bound">f</a><a id="3246" class="Symbol">)</a>   <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3250" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="3253" href="1Lab.Path.html#20756" class="Function">ap</a> <a id="3256" class="Symbol">((</a><a data-type="(G : AbGroup ℓ) → G .object .fst → G .object .fst" id="3258" href="Algebra.Group.html#1320" class="Function">Hom.inverse</a> <a id="3270" class="Symbol">(</a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3271" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3274" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3276" href="Cat.Abelian.Base.html#2958" class="Bound">f</a><a id="3277" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3279" href="Cat.Abelian.Base.html#1445" class="Function Operator">+_</a><a id="3281" class="Symbol">)</a> <a id="3283" href="Cat.Prelude.html#232" class="Function Operator">⊙</a> <a id="3285" class="Symbol">(</a><a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3286" href="Cat.Base.html#3006" class="Function Operator">_∘</a> <a id="3289" href="Cat.Abelian.Base.html#2958" class="Bound">f</a><a id="3290" class="Symbol">))</a> <a data-type="(r : Monoid-on A) → r ._⋆_ (r .identity) x ≡ x" id="3293" href="Algebra.Monoid.html#1088" class="Function">Hom.idl</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3301" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a data-type="(G : AbGroup ℓ) → G .object .fst → G .object .fst" id="3307" href="Algebra.Group.html#1320" class="Function">Hom.inverse</a> <a id="3319" class="Symbol">(</a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3320" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3323" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3325" href="Cat.Abelian.Base.html#2958" class="Bound">f</a><a id="3326" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3328" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="3330" class="Symbol">(</a><a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3331" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3334" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="3336" href="Cat.Abelian.Base.html#2958" class="Bound">f</a><a id="3337" class="Symbol">)</a>          <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3348" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(G : AbGroup ℓ) →
G .object .snd ._⋆_ (has-is-group (G .object .snd) .inverse x) x ≡
has-is-group (G .object .snd) .unit" id="3351" href="Algebra.Group.html#1341" class="Function">Hom.inversel</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3364" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3370" href="Cat.Abelian.Base.html#1533" class="Function">0m</a>                                       <a data-type="(x : A) → x ≡ x" id="3411" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
</pre>
<p>Before moving on, we note the following property of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">\Ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathbf">Ab</span></span></span></span></span>-categories:</span> If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> is an object s.t. <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mi>A</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\id{id}_{A} = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">id</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>,</span> then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> is a zero object.</p>
<pre class="Agda"><a id="3568" class="Keyword">module</a> <a id="3575" href="Cat.Abelian.Base.html#3575" class="Module">_</a> <a id="3577" class="Symbol">{</a><a id="3578" href="Cat.Abelian.Base.html#3578" class="Bound">o</a> <a id="3580" href="Cat.Abelian.Base.html#3580" class="Bound">ℓ</a><a id="3581" class="Symbol">}</a> <a id="3583" class="Symbol">{</a><a id="3584" href="Cat.Abelian.Base.html#3584" class="Bound">C</a> <a id="3586" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="3588" href="Cat.Base.html#704" class="Record">Precategory</a> <a id="3600" href="Cat.Abelian.Base.html#3578" class="Bound">o</a> <a id="3602" href="Cat.Abelian.Base.html#3580" class="Bound">ℓ</a><a id="3603" class="Symbol">}</a> <a id="3605" class="Symbol">(</a><a id="3606" href="Cat.Abelian.Base.html#3606" class="Bound">A</a> <a id="3608" class="Symbol">:</a> <a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="3610" href="Cat.Abelian.Base.html#1302" class="Record">Ab-category</a> <a id="3622" href="Cat.Abelian.Base.html#3584" class="Bound">C</a><a id="3623" class="Symbol">)</a> <a id="3625" class="Keyword">where</a>
  <a id="3633" class="Keyword">private</a> <a id="3641" class="Keyword">module</a> <a id="3648" href="Cat.Abelian.Base.html#3648" class="Module">A</a> <a id="3650" class="Symbol">=</a> <a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="3652" href="Cat.Abelian.Base.html#1302" class="Module">Ab-category</a> <a id="3664" href="Cat.Abelian.Base.html#3606" class="Bound">A</a>

  <a data-type="(A : Ab-category C) → id A ≡ 0m A → is-zero A A₁" id="3669" href="Cat.Abelian.Base.html#3669" class="Function">id-zero→zero</a> <a id="3682" class="Symbol">:</a> <a id="3684" class="Symbol">∀</a> <a id="3686" class="Symbol">{</a><a id="3687" href="Cat.Abelian.Base.html#3687" class="Bound">A</a><a id="3688" class="Symbol">}</a> <a id="3690" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="3692" href="Cat.Base.html#2976" class="Function">A.id</a> <a id="3697" class="Symbol">{</a><a id="3698" href="Cat.Abelian.Base.html#3687" class="Bound">A</a><a id="3699" class="Symbol">}</a> <a data-type="A → A → Type ℓ" id="3701" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3703" href="Cat.Abelian.Base.html#1533" class="Function">A.0m</a> <a id="3708" class="Symbol">→</a> <a data-type="(C : Precategory o h) (ob : Ob C) → Type (o ⊔ h)" id="3710" href="Cat.Diagram.Zero.html#408" class="Record">A.is-zero</a> <a id="3720" href="Cat.Abelian.Base.html#3687" class="Bound">A</a>
  <a data-type="(A : Ab-category C) → id A ≡ 0m A → is-zero A A₁" id="3724" href="Cat.Abelian.Base.html#3669" class="Function">id-zero→zero</a> <a id="3737" href="Cat.Abelian.Base.html#3737" class="Bound">idm</a> <a id="3741" class="Symbol">.</a><a data-type="(r : Zero C) → is-initial C (r .∅)" id="3742" href="Cat.Diagram.Zero.html#459" class="Field">A.is-zero.has-is-initial</a> <a id="3767" href="Cat.Abelian.Base.html#3767" class="Bound">B</a> <a id="3769" class="Symbol">=</a> <a data-type="(centre₁ : A) (paths₁ : (x : A) → centre₁ ≡ x) → is-contr A" id="3771" href="1Lab.HLevel.html#1383" class="InductiveConstructor">contr</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3777" href="Cat.Abelian.Base.html#1533" class="Function">A.0m</a> <a id="3782" class="Symbol">λ</a> <a id="3784" href="Cat.Abelian.Base.html#3784" class="Bound">h</a> <a id="3786" class="Symbol">→</a> <a data-type="x ≡ y → y ≡ x" id="3788" href="1Lab.Path.html#10558" class="Function">sym</a> <a data-type="((x : A) → B₁ x) → (x : A) → B₁ x" id="3792" href="1Lab.Type.html#2481" class="Function Operator">$</a>
    <a id="3798" href="Cat.Abelian.Base.html#3784" class="Bound">h</a>                                <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3831" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → f ≡ (C ∘ f) a" id="3834" href="Cat.Reasoning.html#1250" class="Function">A.intror</a> <a data-type="x ≡ x" id="3843" href="1Lab.Path.html#3593" class="Function">refl</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3848" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="3854" href="Cat.Abelian.Base.html#3784" class="Bound">h</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3856" href="Cat.Base.html#3006" class="Function Operator">A.∘</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="3860" href="Cat.Base.html#2976" class="Function">A.id</a>                       <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3887" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) → g ≡ h → (C ∘ f) g ≡ (C ∘ f) h" id="3890" href="Cat.Reasoning.html#4627" class="Function Operator">A.refl⟩∘⟨</a> <a id="3900" href="Cat.Abelian.Base.html#3737" class="Bound">idm</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3904" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="3910" href="Cat.Abelian.Base.html#3784" class="Bound">h</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3912" href="Cat.Base.html#3006" class="Function Operator">A.∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3916" href="Cat.Abelian.Base.html#1533" class="Function">A.0m</a>                       <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3943" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ f) (0m r) ≡ 0m r" id="3946" href="Cat.Abelian.Base.html#2470" class="Function">A.∘-zero-r</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3957" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="3963" href="Cat.Abelian.Base.html#1533" class="Function">A.0m</a>                             <a data-type="(x : A) → x ≡ x" id="3996" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
  <a data-type="(A : Ab-category C) → id A ≡ 0m A → is-zero A A₁" id="4000" href="Cat.Abelian.Base.html#3669" class="Function">id-zero→zero</a> <a id="4013" href="Cat.Abelian.Base.html#4013" class="Bound">idm</a> <a id="4017" class="Symbol">.</a><a data-type="(r : Zero C) → is-terminal C (r .∅)" id="4018" href="Cat.Diagram.Zero.html#495" class="Field">A.is-zero.has-is-terminal</a> <a id="4044" href="Cat.Abelian.Base.html#4044" class="Bound">x</a> <a id="4046" class="Symbol">=</a> <a data-type="(centre₁ : A) (paths₁ : (x : A) → centre₁ ≡ x) → is-contr A" id="4048" href="1Lab.HLevel.html#1383" class="InductiveConstructor">contr</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="4054" href="Cat.Abelian.Base.html#1533" class="Function">A.0m</a> <a id="4059" class="Symbol">λ</a> <a id="4061" href="Cat.Abelian.Base.html#4061" class="Bound">h</a> <a id="4063" class="Symbol">→</a> <a data-type="x ≡ y → y ≡ x" id="4065" href="1Lab.Path.html#10558" class="Function">sym</a> <a data-type="((x : A) → B₁ x) → (x : A) → B₁ x" id="4069" href="1Lab.Type.html#2481" class="Function Operator">$</a>
    <a id="4075" href="Cat.Abelian.Base.html#4061" class="Bound">h</a>                              <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="4106" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → f ≡ (C ∘ a) f" id="4109" href="Cat.Reasoning.html#1207" class="Function">A.introl</a> <a data-type="x ≡ x" id="4118" href="1Lab.Path.html#3593" class="Function">refl</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="4123" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a data-type="(r : Precategory o h) → r .Hom x x" id="4129" href="Cat.Base.html#2976" class="Function">A.id</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="4134" href="Cat.Base.html#3006" class="Function Operator">A.∘</a> <a id="4138" href="Cat.Abelian.Base.html#4061" class="Bound">h</a>                     <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="4160" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a id="4163" href="Cat.Abelian.Base.html#4013" class="Bound">idm</a> <a data-type="(C : Precategory o ℓ) → f ≡ h → (C ∘ f) g ≡ (C ∘ h) g" id="4167" href="Cat.Reasoning.html#4694" class="Function Operator">A.⟩∘⟨refl</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="4177" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="4183" href="Cat.Abelian.Base.html#1533" class="Function">A.0m</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="4188" href="Cat.Base.html#3006" class="Function Operator">A.∘</a> <a id="4192" href="Cat.Abelian.Base.html#4061" class="Bound">h</a>                     <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="4214" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ 0m r) f ≡ 0m r" id="4217" href="Cat.Abelian.Base.html#2885" class="Function">A.∘-zero-l</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="4228" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="4234" href="Cat.Abelian.Base.html#1533" class="Function">A.0m</a>                           <a data-type="(x : A) → x ≡ x" id="4265" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
</pre>
<p>Perhaps the simplest example of an <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">\Ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathbf">Ab</span></span></span></span></span>-category</span> is.. any ring! In the same way that a monoid is a category with one object, and a group is a groupoid with one object, a ring is a <em>ringoid</em> with one object; Ringoid being another word for <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">\Ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathbf">Ab</span></span></span></span></span>-category,</span> rather than a horizontal categorification of the drummer for the Beatles. The next simplest example is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">\Ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathbf">Ab</span></span></span></span></span> itself:</p>
<pre class="Agda"><a id="4653" class="Keyword">module</a> <a id="4660" href="Cat.Abelian.Base.html#4660" class="Module">_</a> <a id="4662" class="Keyword">where</a>
  <a id="4670" class="Keyword">open</a> <a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="4675" href="Cat.Abelian.Base.html#1302" class="Module">Ab-category</a>
  <a data-type="Ab-category (Ab ℓ)" id="4689" href="Cat.Abelian.Base.html#4689" class="Function">Ab-ab-category</a> <a id="4704" class="Symbol">:</a> <a id="4706" class="Symbol">∀</a> <a id="4708" class="Symbol">{</a><a id="4709" href="Cat.Abelian.Base.html#4709" class="Bound">ℓ</a><a id="4710" class="Symbol">}</a> <a id="4712" class="Symbol">→</a> <a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="4714" href="Cat.Abelian.Base.html#1302" class="Record">Ab-category</a> <a id="4726" class="Symbol">(</a><a data-type="(ℓ : Level) → Precategory (lsuc ℓ) ℓ" id="4727" href="Algebra.Group.Ab.html#1491" class="Function">Ab</a> <a id="4730" href="Cat.Abelian.Base.html#4709" class="Bound">ℓ</a><a id="4731" class="Symbol">)</a>
  <a data-type="Ab-category (Ab ℓ)" id="4735" href="Cat.Abelian.Base.html#4689" class="Function">Ab-ab-category</a> <a id="4750" class="Symbol">.</a><a data-type="(r : is-abelian C) (A B₁ : C .Ob) → Group-on (Hom C A B₁)" id="4751" href="Cat.Abelian.Base.html#1400" class="Field">Group-on-hom</a> <a id="4764" href="Cat.Abelian.Base.html#4764" class="Bound">A</a> <a id="4766" href="Cat.Abelian.Base.html#4766" class="Bound">B</a> <a id="4768" class="Symbol">=</a> <a data-type="(A B₁ : AbGroup ℓ) → AbGroup ℓ" id="4770" href="Algebra.Group.Ab.html#3543" class="Function">Hom-group</a> <a id="4780" href="Cat.Abelian.Base.html#4764" class="Bound">A</a> <a id="4782" href="Cat.Abelian.Base.html#4766" class="Bound">B</a> <a id="4784" class="Symbol">.</a><a data-type="Restrict-ob P → Ob C" id="4785" href="Cat.Functor.FullSubcategory.html#1063" class="Field">object</a> <a id="4792" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="4793" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a>
  <a data-type="Ab-category (Ab ℓ)" id="4799" href="Cat.Abelian.Base.html#4689" class="Function">Ab-ab-category</a> <a id="4814" class="Symbol">.</a><a data-type="(r : is-abelian C) (A B₁ : C .Ob) (f g : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ f g
≡
has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g f" id="4815" href="Cat.Abelian.Base.html#1608" class="Field">Hom-grp-ab</a> <a id="4826" href="Cat.Abelian.Base.html#4826" class="Bound">A</a> <a id="4828" href="Cat.Abelian.Base.html#4828" class="Bound">B</a> <a id="4830" class="Symbol">=</a> <a data-type="(A B₁ : AbGroup ℓ) → AbGroup ℓ" id="4832" href="Algebra.Group.Ab.html#3543" class="Function">Hom-group</a> <a id="4842" href="Cat.Abelian.Base.html#4826" class="Bound">A</a> <a id="4844" href="Cat.Abelian.Base.html#4828" class="Bound">B</a> <a id="4846" class="Symbol">.</a><a data-type="(r : Restrict-ob P) → P (r .object)" id="4847" href="Cat.Functor.FullSubcategory.html#1081" class="Field">witness</a>
  <a data-type="Ab-category (Ab ℓ)" id="4857" href="Cat.Abelian.Base.html#4689" class="Function">Ab-ab-category</a> <a id="4872" class="Symbol">.</a><a data-type="(r : is-abelian C) (f g : Hom C B₁ C) (h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) h) ((C ∘ g) h)
≡
(C ∘
 has-ab (has-additive (has-is-preab r)) .Group-on-hom B₁ C ._⋆_ f g)
h" id="4873" href="Cat.Abelian.Base.html#1800" class="Field">∘-linear-l</a> <a id="4884" href="Cat.Abelian.Base.html#4884" class="Bound">f</a> <a id="4886" href="Cat.Abelian.Base.html#4886" class="Bound">g</a> <a id="4888" href="Cat.Abelian.Base.html#4888" class="Bound">h</a> <a id="4890" class="Symbol">=</a> <a data-type="is-faithful Forget" id="4892" href="Algebra.Group.Cat.Base.html#1867" class="Function">Grp.Forget-is-faithful</a> <a data-type="x ≡ x" id="4915" href="1Lab.Path.html#3593" class="Function">refl</a>
  <a data-type="Ab-category (Ab ℓ)" id="4922" href="Cat.Abelian.Base.html#4689" class="Function">Ab-ab-category</a> <a id="4937" class="Symbol">.</a><a data-type="(r : is-abelian C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) g) ((C ∘ f) h)
≡
(C ∘ f)
(has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g
 h)" id="4938" href="Cat.Abelian.Base.html#1903" class="Field">∘-linear-r</a> <a id="4949" href="Cat.Abelian.Base.html#4949" class="Bound">f</a> <a id="4951" href="Cat.Abelian.Base.html#4951" class="Bound">g</a> <a id="4953" href="Cat.Abelian.Base.html#4953" class="Bound">h</a> <a id="4955" class="Symbol">=</a> <a data-type="is-faithful Forget" id="4957" href="Algebra.Group.Cat.Base.html#1867" class="Function">Grp.Forget-is-faithful</a> <a data-type="((x : A) → B₁ x) → (x : A) → B₁ x" id="4980" href="1Lab.Type.html#2481" class="Function Operator">$</a> <a data-type="((x : A) → f x ≡ g x) → f ≡ g" id="4982" href="1Lab.Path.html#58486" class="Function">funext</a> <a id="4989" class="Symbol">λ</a> <a id="4991" href="Cat.Abelian.Base.html#4991" class="Bound">x</a> <a id="4993" class="Symbol">→</a>
    <a data-type="x ≡ y → y ≡ x" id="4999" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="5003" class="Symbol">(</a><a id="5004" href="Cat.Abelian.Base.html#4949" class="Bound">f</a> <a id="5006" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="5007" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="5011" class="Symbol">.</a><a data-type="Group-hom A B₁ e →
(x y : A .fst) → e (A .snd ._⋆_ x y) ≡ B₁ .snd ._⋆_ (e x) (e y)" id="5012" href="Algebra.Group.html#6284" class="Field">Group-hom.pres-⋆</a> <a id="5029" class="Symbol">_</a> <a id="5031" class="Symbol">_)</a>
</pre>
<h1 id="additive-categories"><a href="#additive-categories" class="header-link">Additive categories<span class="header-link-emoji">🔗</span></a></h1>
<p>An <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi><mi mathvariant="bold">b</mi></mrow><annotation encoding="application/x-tex">\Ab</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathbf">Ab</span></span></span></span></span>-category</span> is <strong>additive</strong> when its underlying category has a terminal object and finite products; By the yoga above, this implies that the terminal object is also a zero object, and the finite products coincide with finite coproducts.</p>
<pre class="Agda"><a id="5314" class="Keyword">record</a> <a id="is-additive"></a><a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="5321" href="Cat.Abelian.Base.html#5321" class="Record">is-additive</a> <a id="5333" class="Symbol">{</a><a id="5334" href="Cat.Abelian.Base.html#5334" class="Bound">o</a> <a id="5336" href="Cat.Abelian.Base.html#5336" class="Bound">ℓ</a><a id="5337" class="Symbol">}</a> <a id="5339" class="Symbol">(</a><a id="5340" href="Cat.Abelian.Base.html#5340" class="Bound">C</a> <a id="5342" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="5344" href="Cat.Base.html#704" class="Record">Precategory</a> <a id="5356" href="Cat.Abelian.Base.html#5334" class="Bound">o</a> <a id="5358" href="Cat.Abelian.Base.html#5336" class="Bound">ℓ</a><a id="5359" class="Symbol">)</a> <a id="5361" class="Symbol">:</a> <a id="5363" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="5368" class="Symbol">(</a><a id="5369" href="Cat.Abelian.Base.html#5334" class="Bound">o</a> <a data-type="Level → Level → Level" id="5371" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a data-type="Level → Level" id="5373" href="Agda.Primitive.html#780" class="Primitive">lsuc</a> <a id="5378" href="Cat.Abelian.Base.html#5336" class="Bound">ℓ</a><a id="5379" class="Symbol">)</a> <a id="5381" class="Keyword">where</a>
  <a id="5389" class="Keyword">field</a> <a id="is-additive.has-ab"></a><a data-type="(r : is-abelian C) → Ab-category C" id="5395" href="Cat.Abelian.Base.html#5395" class="Field">has-ab</a> <a id="5402" class="Symbol">:</a> <a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="5404" href="Cat.Abelian.Base.html#1302" class="Record">Ab-category</a> <a id="5416" href="Cat.Abelian.Base.html#5340" class="Bound">C</a>
  <a id="5420" class="Keyword">open</a> <a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="5425" href="Cat.Abelian.Base.html#1302" class="Module">Ab-category</a> <a data-type="(r : is-abelian C) → Ab-category C" id="5437" href="Cat.Abelian.Base.html#5395" class="Field">has-ab</a> <a id="5444" class="Keyword">public</a>

  <a id="5454" class="Keyword">field</a>
    <a id="is-additive.has-terminal"></a><a data-type="(r : is-abelian C) → Terminal r" id="5464" href="Cat.Abelian.Base.html#5464" class="Field">has-terminal</a> <a id="5477" class="Symbol">:</a> <a data-type="(C : Precategory o h) → Type (o ⊔ h)" id="5479" href="Cat.Diagram.Terminal.html#406" class="Record">Terminal</a>
    <a id="is-additive.has-prods"></a><a data-type="(r : is-abelian C) (A B₁ : Ob C) → Product r A B₁" id="5492" href="Cat.Abelian.Base.html#5492" class="Field">has-prods</a>    <a id="5505" class="Symbol">:</a> <a id="5507" class="Symbol">∀</a> <a id="5509" href="Cat.Abelian.Base.html#5509" class="Bound">A</a> <a id="5511" href="Cat.Abelian.Base.html#5511" class="Bound">B</a> <a id="5513" class="Symbol">→</a> <a data-type="(C : Precategory o h) (A B₁ : Ob C) → Type (o ⊔ h)" id="5515" href="Cat.Diagram.Product.html#2703" class="Record">Product</a> <a id="5523" href="Cat.Abelian.Base.html#5509" class="Bound">A</a> <a id="5525" href="Cat.Abelian.Base.html#5511" class="Bound">B</a>

  <a id="is-additive.∅"></a><a data-type="(r : is-abelian C) → Zero r" id="5530" href="Cat.Abelian.Base.html#5530" class="Function">∅</a> <a id="5532" class="Symbol">:</a> <a data-type="(C : Precategory o h) → Type (o ⊔ h)" id="5534" href="Cat.Diagram.Zero.html#536" class="Record">Zero</a>
  <a data-type="(r : is-abelian C) → Zero r" id="5541" href="Cat.Abelian.Base.html#5530" class="Function">∅</a> <a id="5543" class="Symbol">.</a><a data-type="Zero C → Ob C" id="5544" href="Cat.Diagram.Zero.html#574" class="Field">Zero.∅</a> <a id="5551" class="Symbol">=</a> <a data-type="(r : is-abelian C) → Terminal r" id="5553" href="Cat.Abelian.Base.html#5464" class="Field">has-terminal</a> <a id="5566" class="Symbol">.</a><a data-type="Terminal C → Ob C" id="5567" href="Cat.Diagram.Terminal.html#448" class="Field">Terminal.top</a>
  <a data-type="(r : is-abelian C) → Zero r" id="5582" href="Cat.Abelian.Base.html#5530" class="Function">∅</a> <a id="5584" class="Symbol">.</a><a data-type="(r : Zero C) → is-zero C (r .∅)" id="5585" href="Cat.Diagram.Zero.html#591" class="Field">Zero.has-is-zero</a> <a id="5602" class="Symbol">=</a> <a data-type="(A : Ab-category C) → id A ≡ 0m A → is-zero A A₁" id="5604" href="Cat.Abelian.Base.html#3669" class="Function">id-zero→zero</a> <a data-type="(r : is-abelian C) → Ab-category C" id="5617" href="Cat.Abelian.Base.html#5395" class="Field">has-ab</a> <a data-type="((x : A) → B₁ x) → (x : A) → B₁ x" id="5624" href="1Lab.Type.html#2481" class="Function Operator">$</a>
    <a data-type="is-contr A → is-prop A" id="5630" href="1Lab.HLevel.html#3818" class="Function">is-contr→is-prop</a> <a id="5647" class="Symbol">(</a><a data-type="(r : is-abelian C) → Terminal r" id="5648" href="Cat.Abelian.Base.html#5464" class="Field">has-terminal</a> <a id="5661" class="Symbol">.</a><a data-type="(r : Terminal C) → is-terminal C (r .top)" id="5662" href="Cat.Diagram.Terminal.html#461" class="Field">Terminal.has⊤</a> <a id="5676" class="Symbol">_)</a> <a id="5679" class="Symbol">_</a> <a id="5681" class="Symbol">_</a>
  <a id="5685" class="Keyword">module</a> <a id="is-additive.∅"></a><a id="5692" href="Cat.Abelian.Base.html#5692" class="Module">∅</a> <a id="5694" class="Symbol">=</a> <a data-type="(C : Precategory o h) → Type (o ⊔ h)" id="5696" href="Cat.Diagram.Zero.html#536" class="Module">Zero</a> <a data-type="(r : is-abelian C) → Zero r" id="5701" href="Cat.Abelian.Base.html#5530" class="Function">∅</a>

  <a id="is-additive.0m-unique"></a><a data-type="(r : is-abelian C) → zero→ r ≡ 0m r" id="5706" href="Cat.Abelian.Base.html#5706" class="Function">0m-unique</a> <a id="5716" class="Symbol">:</a> <a id="5718" class="Symbol">∀</a> <a id="5720" class="Symbol">{</a><a id="5721" href="Cat.Abelian.Base.html#5721" class="Bound">A</a> <a id="5723" href="Cat.Abelian.Base.html#5723" class="Bound">B</a><a id="5724" class="Symbol">}</a> <a id="5726" class="Symbol">→</a> <a data-type="Zero C → Hom C x y" id="5728" href="Cat.Diagram.Zero.html#1010" class="Function">∅.zero→</a> <a id="5736" class="Symbol">{</a><a id="5737" href="Cat.Abelian.Base.html#5721" class="Bound">A</a><a id="5738" class="Symbol">}</a> <a id="5740" class="Symbol">{</a><a id="5741" href="Cat.Abelian.Base.html#5723" class="Bound">B</a><a id="5742" class="Symbol">}</a> <a data-type="A → A → Type ℓ" id="5744" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="5746" href="Cat.Abelian.Base.html#1533" class="Function">0m</a>
  <a data-type="(r : is-abelian C) → zero→ r ≡ 0m r" id="5751" href="Cat.Abelian.Base.html#5706" class="Function">0m-unique</a> <a id="5761" class="Symbol">=</a> <a data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" id="5763" href="1Lab.Path.html#21189" class="Function">ap₂</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="5767" href="Cat.Base.html#3006" class="Function Operator">_∘_</a> <a id="5771" class="Symbol">(</a><a data-type="(r : Initial C) → is-initial C (r .bot)" id="5772" href="Cat.Diagram.Initial.html#456" class="Function">∅.has⊥</a> <a id="5779" class="Symbol">_</a> <a id="5781" class="Symbol">.</a><a data-type="(r : is-contr A) (x : A) → r .centre ≡ x" id="5782" href="1Lab.HLevel.html#1416" class="Field">paths</a> <a id="5788" class="Symbol">_)</a> <a data-type="x ≡ x" id="5791" href="1Lab.Path.html#3593" class="Function">refl</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="5796" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ 0m r) f ≡ 0m r" id="5798" href="Cat.Abelian.Base.html#2885" class="Function">∘-zero-l</a>
</pre>
<p>Coincidence of finite products and finite coproducts leads to an object commonly called a (finite) <strong>biproduct</strong>. The coproduct coprojections are given by the pair of maps</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo>×</mo><mn>0</mn><mo stretchy="false">)</mo><mo>:</mo><mi>A</mi><mo>→</mo><mi>A</mi><mo>×</mo><mi>B</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo stretchy="false">(</mo><mn>0</mn><mo>×</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo stretchy="false">)</mo><mo>:</mo><mi>B</mi><mo>→</mo><mi>A</mi><mo>×</mo><mi>B</mi><mtext>,</mtext></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{align*}
&amp;(\id{id} \times 0) : A \to A \times B \\
&amp;(0 \times \id{id}) : B \to A \times B\text{,}
\end{align*}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.75em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.75em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">id</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathrm">id</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord text"><span class="mord">,</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.25em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>respectively, and the comultiplication of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> is given by <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><msub><mi>π</mi><mn>1</mn></msub><mo>+</mo><mi>g</mi><msub><mi>π</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">f\pi_1 + g\pi_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span> We can calculate, for the first coprojection followed by comultiplication,</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo stretchy="false">(</mo><mi>f</mi><msub><mi>π</mi><mn>1</mn></msub><mo>+</mo><mi>g</mi><msub><mi>π</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo>×</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>f</mi><msub><mi>π</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo>×</mo><mn>0</mn><mo stretchy="false">)</mo><mo>+</mo><mi>g</mi><msub><mi>π</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo>×</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>f</mi><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo>+</mo><mi>g</mi><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>f</mi><mo>×</mo><mo separator="true" lspace="0em" rspace="0em">,</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{align*}
&amp; (f\pi_1+g\pi_2)(\id{id}\times 0) \\
=&amp; f\pi_1(\id{id}\times 0) + g\pi_2(\id{id}\times 0) \\
=&amp; f\id{id} + g0 \\
=&amp; f\times{,}
\end{align*}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6em;vertical-align:-2.75em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">=</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">=</span></span></span><span style="top:-0.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">=</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">id</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">id</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">id</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathrm">id</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord">0</span></span></span><span style="top:-0.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mpunct">,</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>and analogously for the second coprojection followed by comultiplication.</p>
<pre class="Agda">  <a id="is-additive.has-coprods"></a><a data-type="(r : is-abelian C) (A B₁ : Ob C) → Coproduct r A B₁" id="6518" href="Cat.Abelian.Base.html#6518" class="Function">has-coprods</a> <a id="6530" class="Symbol">:</a> <a id="6532" class="Symbol">∀</a> <a id="6534" href="Cat.Abelian.Base.html#6534" class="Bound">A</a> <a id="6536" href="Cat.Abelian.Base.html#6536" class="Bound">B</a> <a id="6538" class="Symbol">→</a> <a data-type="(C : Precategory o h) (A B₁ : Ob C) → Type (o ⊔ h)" id="6540" href="Cat.Diagram.Coproduct.html#1758" class="Record">Coproduct</a> <a id="6550" href="Cat.Abelian.Base.html#6534" class="Bound">A</a> <a id="6552" href="Cat.Abelian.Base.html#6536" class="Bound">B</a>
  <a data-type="(r : is-abelian C) (A B₁ : Ob C) → Coproduct r A B₁" id="6556" href="Cat.Abelian.Base.html#6518" class="Function">has-coprods</a> <a id="6568" href="Cat.Abelian.Base.html#6568" class="Bound">A</a> <a id="6570" href="Cat.Abelian.Base.html#6570" class="Bound">B</a> <a id="6572" class="Symbol">=</a> <a id="6574" href="Cat.Abelian.Base.html#6674" class="Function">coprod</a> <a id="6581" class="Keyword">where</a>
    <a id="6591" class="Keyword">open</a> <a data-type="(C : Precategory o h) (A B₁ : Ob C) → Type (o ⊔ h)" id="6596" href="Cat.Diagram.Coproduct.html#1758" class="Module">Coproduct</a>
    <a id="6610" class="Keyword">open</a> <a data-type="(C : Precategory o h) (in₀ : Hom C A P) (in₁ : Hom C B₁ P) →
Type (o ⊔ h)" id="6615" href="Cat.Diagram.Coproduct.html#924" class="Module">is-coproduct</a>
    <a id="6632" class="Keyword">module</a> <a id="6639" href="Cat.Abelian.Base.html#6639" class="Module">Prod</a> <a id="6644" class="Symbol">=</a> <a data-type="(C : Precategory o h) (A B₁ : Ob C) → Type (o ⊔ h)" id="6646" href="Cat.Diagram.Product.html#2703" class="Module">Product</a> <a id="6654" class="Symbol">(</a><a data-type="(r : is-abelian C) (A B₁ : Ob C) → Product r A B₁" id="6655" href="Cat.Abelian.Base.html#5492" class="Field">has-prods</a> <a id="6665" href="Cat.Abelian.Base.html#6568" class="Bound">A</a> <a id="6667" href="Cat.Abelian.Base.html#6570" class="Bound">B</a><a id="6668" class="Symbol">)</a>
    <a id="6674" href="Cat.Abelian.Base.html#6674" class="Function">coprod</a> <a id="6681" class="Symbol">:</a> <a data-type="(C : Precategory o h) (A B₁ : Ob C) → Type (o ⊔ h)" id="6683" href="Cat.Diagram.Coproduct.html#1758" class="Record">Coproduct</a> <a id="6693" href="Cat.Abelian.Base.html#6568" class="Bound">A</a> <a id="6695" href="Cat.Abelian.Base.html#6570" class="Bound">B</a>
    <a id="6701" href="Cat.Abelian.Base.html#6674" class="Function">coprod</a> <a id="6708" class="Symbol">.</a><a data-type="Coproduct C A B₁ → Ob C" id="6709" href="Cat.Diagram.Coproduct.html#1812" class="Field">coapex</a> <a id="6716" class="Symbol">=</a> <a data-type="Product C A B₁ → Ob C" id="6718" href="Cat.Diagram.Product.html#2773" class="Function">Prod.apex</a>
    <a id="6732" href="Cat.Abelian.Base.html#6674" class="Function">coprod</a> <a id="6739" class="Symbol">.</a><a data-type="(r : Coproduct C A B₁) → Hom C A (r .coapex)" id="6740" href="Cat.Diagram.Coproduct.html#1828" class="Field">in₀</a> <a id="6744" class="Symbol">=</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="6746" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="6753" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="6756" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="6758" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="6761" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span>
    <a id="6767" href="Cat.Abelian.Base.html#6674" class="Function">coprod</a> <a id="6774" class="Symbol">.</a><a data-type="(r : Coproduct C A B₁) → Hom C B₁ (r .coapex)" id="6775" href="Cat.Diagram.Coproduct.html#1851" class="Field">in₁</a> <a id="6779" class="Symbol">=</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="6781" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="6788" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="6791" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="6793" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="6796" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span>
    <a id="6802" href="Cat.Abelian.Base.html#6674" class="Function">coprod</a> <a id="6809" class="Symbol">.</a><a data-type="(r : Coproduct C A B₁) → is-coproduct C (r .in₀) (r .in₁)" id="6810" href="Cat.Diagram.Coproduct.html#1874" class="Field">has-is-coproduct</a> <a id="6827" class="Symbol">.</a><a data-type="(r : Coproduct C A B₁) →
Hom C A Q → Hom C B₁ Q → Hom C (r .coapex) Q" id="6828" href="Cat.Diagram.Coproduct.html#1010" class="Field Operator">[_,_]</a> <a id="6834" href="Cat.Abelian.Base.html#6834" class="Bound">f</a> <a id="6836" href="Cat.Abelian.Base.html#6836" class="Bound">g</a> <a id="6838" class="Symbol">=</a> <a id="6840" href="Cat.Abelian.Base.html#6834" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="6842" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) A" id="6844" href="Cat.Diagram.Product.html#2787" class="Function">Prod.π₁</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="6852" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="6854" href="Cat.Abelian.Base.html#6836" class="Bound">g</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="6856" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" id="6858" href="Cat.Diagram.Product.html#2807" class="Function">Prod.π₂</a>
    <a id="6870" href="Cat.Abelian.Base.html#6674" class="Function">coprod</a> <a id="6877" class="Symbol">.</a><a data-type="(r : Coproduct C A B₁) → is-coproduct C (r .in₀) (r .in₁)" id="6878" href="Cat.Diagram.Coproduct.html#1874" class="Field">has-is-coproduct</a> <a id="6895" class="Symbol">.</a><a data-type="(r : Coproduct C A B₁) →
(C ∘ has-is-coproduct r .[_,_] inj0 inj1) (r .in₀) ≡ inj0" id="6896" href="Cat.Diagram.Coproduct.html#1077" class="Field">in₀∘factor</a> <a id="6907" class="Symbol">{</a><a id="6908" class="Argument">inj0</a> <a id="6913" class="Symbol">=</a> <a id="6915" href="Cat.Abelian.Base.html#6915" class="Bound">inj0</a><a id="6919" class="Symbol">}</a> <a id="6921" class="Symbol">{</a><a id="6922" href="Cat.Abelian.Base.html#6922" class="Bound">inj1</a><a id="6926" class="Symbol">}</a> <a id="6928" class="Symbol">=</a>
      <a id="6936" class="Symbol">(</a><a id="6937" href="Cat.Abelian.Base.html#6915" class="Bound">inj0</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="6942" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) A" id="6944" href="Cat.Diagram.Product.html#2787" class="Function">Prod.π₁</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="6952" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="6954" href="Cat.Abelian.Base.html#6922" class="Bound">inj1</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="6959" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" id="6961" href="Cat.Diagram.Product.html#2807" class="Function">Prod.π₂</a><a id="6968" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="6970" href="Cat.Base.html#3006" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="6972" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="6979" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="6982" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="6984" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="6987" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="6989" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="x ≡ y → y ≡ x" id="6992" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="6996" class="Symbol">(</a><a data-type="(r : is-abelian C) (f g : Hom C B₁ C) (h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) h) ((C ∘ g) h)
≡
(C ∘
 has-ab (has-additive (has-is-preab r)) .Group-on-hom B₁ C ._⋆_ f g)
h" id="6997" href="Cat.Abelian.Base.html#1800" class="Function">∘-linear-l</a> <a id="7008" class="Symbol">_</a> <a id="7010" class="Symbol">_</a> <a id="7012" class="Symbol">_)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="7015" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="7023" class="Symbol">((</a><a id="7025" href="Cat.Abelian.Base.html#6915" class="Bound">inj0</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7030" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) A" id="7032" href="Cat.Diagram.Product.html#2787" class="Function">Prod.π₁</a><a id="7039" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7041" href="Cat.Base.html#3006" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7043" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="7050" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7053" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="7055" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7058" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="7060" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="7062" class="Symbol">_)</a>            <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="7076" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" id="7079" href="Cat.Reasoning.html#1108" class="Function">Hom.elimr</a> <a id="7089" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" id="7090" href="Cat.Reasoning.html#1678" class="Function">pullr</a> <a data-type="(r : Product C A B₁) →
(C ∘ r .π₂) (has-is-product r .⟨_,_⟩ p1 p2) ≡ p2" id="7096" href="Cat.Diagram.Product.html#1984" class="Function">Prod.π₂∘factor</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="7111" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ f) (0m r) ≡ 0m r" id="7113" href="Cat.Abelian.Base.html#2470" class="Function">∘-zero-r</a><a id="7121" class="Symbol">)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="7123" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="7131" class="Symbol">(</a><a id="7132" href="Cat.Abelian.Base.html#6915" class="Bound">inj0</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7137" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) A" id="7139" href="Cat.Diagram.Product.html#2787" class="Function">Prod.π₁</a><a id="7146" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7148" href="Cat.Base.html#3006" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7150" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="7157" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7160" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="7162" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7165" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span>                  <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="7184" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ (C ∘ f) h) i ≡ f" id="7187" href="Cat.Reasoning.html#2731" class="Function">cancelr</a> <a data-type="(r : Product C A B₁) →
(C ∘ r .π₁) (has-is-product r .⟨_,_⟩ p1 p2) ≡ p1" id="7195" href="Cat.Diagram.Product.html#1918" class="Function">Prod.π₁∘factor</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="7210" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="7218" href="Cat.Abelian.Base.html#6915" class="Bound">inj0</a>                                                <a data-type="(x : A) → x ≡ x" id="7270" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
    <a id="7276" href="Cat.Abelian.Base.html#6674" class="Function">coprod</a> <a id="7283" class="Symbol">.</a><a data-type="(r : Coproduct C A B₁) → is-coproduct C (r .in₀) (r .in₁)" id="7284" href="Cat.Diagram.Coproduct.html#1874" class="Field">has-is-coproduct</a> <a id="7301" class="Symbol">.</a><a data-type="(r : Coproduct C A B₁) →
(C ∘ has-is-coproduct r .[_,_] inj0 inj1) (r .in₁) ≡ inj1" id="7302" href="Cat.Diagram.Coproduct.html#1155" class="Field">in₁∘factor</a> <a id="7313" class="Symbol">{</a><a id="7314" class="Argument">inj0</a> <a id="7319" class="Symbol">=</a> <a id="7321" href="Cat.Abelian.Base.html#7321" class="Bound">inj0</a><a id="7325" class="Symbol">}</a> <a id="7327" class="Symbol">{</a><a id="7328" href="Cat.Abelian.Base.html#7328" class="Bound">inj1</a><a id="7332" class="Symbol">}</a> <a id="7334" class="Symbol">=</a>
      <a id="7342" class="Symbol">(</a><a id="7343" href="Cat.Abelian.Base.html#7321" class="Bound">inj0</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7348" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) A" id="7350" href="Cat.Diagram.Product.html#2787" class="Function">Prod.π₁</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="7358" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="7360" href="Cat.Abelian.Base.html#7328" class="Bound">inj1</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7365" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" id="7367" href="Cat.Diagram.Product.html#2807" class="Function">Prod.π₂</a><a id="7374" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7376" href="Cat.Base.html#3006" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7378" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="7385" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7388" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="7390" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7393" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="7395" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="x ≡ y → y ≡ x" id="7398" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="7402" class="Symbol">(</a><a data-type="(r : is-abelian C) (f g : Hom C B₁ C) (h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) h) ((C ∘ g) h)
≡
(C ∘
 has-ab (has-additive (has-is-preab r)) .Group-on-hom B₁ C ._⋆_ f g)
h" id="7403" href="Cat.Abelian.Base.html#1800" class="Function">∘-linear-l</a> <a id="7414" class="Symbol">_</a> <a id="7416" class="Symbol">_</a> <a id="7418" class="Symbol">_)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="7421" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="7429" class="Symbol">(_</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="7432" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="7434" class="Symbol">(</a><a id="7435" href="Cat.Abelian.Base.html#7328" class="Bound">inj1</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7440" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" id="7442" href="Cat.Diagram.Product.html#2807" class="Function">Prod.π₂</a><a id="7449" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7451" href="Cat.Base.html#3006" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7453" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="7460" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7463" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="7465" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7468" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span><a id="7469" class="Symbol">)</a>            <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="7482" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ a) f ≡ f" id="7485" href="Cat.Reasoning.html#1009" class="Function">Hom.eliml</a> <a id="7495" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" id="7496" href="Cat.Reasoning.html#1678" class="Function">pullr</a> <a data-type="(r : Product C A B₁) →
(C ∘ r .π₁) (has-is-product r .⟨_,_⟩ p1 p2) ≡ p1" id="7502" href="Cat.Diagram.Product.html#1918" class="Function">Prod.π₁∘factor</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="7517" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ f) (0m r) ≡ 0m r" id="7519" href="Cat.Abelian.Base.html#2470" class="Function">∘-zero-r</a><a id="7527" class="Symbol">)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="7529" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="7537" class="Symbol">(</a><a id="7538" href="Cat.Abelian.Base.html#7328" class="Bound">inj1</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7543" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" id="7545" href="Cat.Diagram.Product.html#2807" class="Function">Prod.π₂</a><a id="7552" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7554" href="Cat.Base.html#3006" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7556" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="7563" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7566" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="7568" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="7571" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span>                  <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="7590" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ (C ∘ f) h) i ≡ f" id="7593" href="Cat.Reasoning.html#2731" class="Function">cancelr</a> <a data-type="(r : Product C A B₁) →
(C ∘ r .π₂) (has-is-product r .⟨_,_⟩ p1 p2) ≡ p2" id="7601" href="Cat.Diagram.Product.html#1984" class="Function">Prod.π₂∘factor</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="7616" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="7624" href="Cat.Abelian.Base.html#7328" class="Bound">inj1</a>                                                 <a data-type="(x : A) → x ≡ x" id="7677" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
</pre>
<p>For uniqueness, we use distributivity of composition over addition of morphisms and the universal property of the product to establish the desired equation. Check it out:</p>
<pre class="Agda">    <a id="7868" href="Cat.Abelian.Base.html#6674" class="Function">coprod</a> <a id="7875" class="Symbol">.</a><a data-type="(r : Coproduct C A B₁) → is-coproduct C (r .in₀) (r .in₁)" id="7876" href="Cat.Diagram.Coproduct.html#1874" class="Field">has-is-coproduct</a> <a id="7893" class="Symbol">.</a><a data-type="(r : Coproduct C A B₁) (other : Hom C (r .coapex) Q) →
(C ∘ other) (r .in₀) ≡ inj0 →
(C ∘ other) (r .in₁) ≡ inj1 →
other ≡ has-is-coproduct r .[_,_] inj0 inj1" id="7894" href="Cat.Diagram.Coproduct.html#1234" class="Field">unique</a> <a id="7901" class="Symbol">{</a><a id="7902" class="Argument">inj0</a> <a id="7907" class="Symbol">=</a> <a id="7909" href="Cat.Abelian.Base.html#7909" class="Bound">inj0</a><a id="7913" class="Symbol">}</a> <a id="7915" class="Symbol">{</a><a id="7916" href="Cat.Abelian.Base.html#7916" class="Bound">inj1</a><a id="7920" class="Symbol">}</a> <a id="7922" href="Cat.Abelian.Base.html#7922" class="Bound">other</a> <a id="7928" href="Cat.Abelian.Base.html#7928" class="Bound">p</a> <a id="7930" href="Cat.Abelian.Base.html#7930" class="Bound">q</a> <a id="7932" class="Symbol">=</a> <a data-type="x ≡ y → y ≡ x" id="7934" href="1Lab.Path.html#10558" class="Function">sym</a> <a data-type="((x : A) → B₁ x) → (x : A) → B₁ x" id="7938" href="1Lab.Type.html#2481" class="Function Operator">$</a>
      <a id="7946" href="Cat.Abelian.Base.html#7909" class="Bound">inj0</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7951" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) A" id="7953" href="Cat.Diagram.Product.html#2787" class="Function">Prod.π₁</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="7961" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="7963" href="Cat.Abelian.Base.html#7916" class="Bound">inj1</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7968" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" id="7970" href="Cat.Diagram.Product.html#2807" class="Function">Prod.π₂</a>                                             <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="8022" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" id="8025" href="1Lab.Path.html#21189" class="Function">ap₂</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8029" href="Cat.Abelian.Base.html#1445" class="Function Operator">_+_</a> <a id="8033" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (c≡ab : c ≡ (C ∘ a) b) →
(C ∘ c) f ≡ (C ∘ a) ((C ∘ b) f)" id="8034" href="Cat.Reasoning.html#1844" class="Function">pushl</a> <a id="8040" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="8041" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="8045" href="Cat.Abelian.Base.html#7928" class="Bound">p</a><a id="8046" class="Symbol">))</a> <a id="8049" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (c≡ab : c ≡ (C ∘ a) b) →
(C ∘ c) f ≡ (C ∘ a) ((C ∘ b) f)" id="8050" href="Cat.Reasoning.html#1844" class="Function">pushl</a> <a id="8056" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="8057" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="8061" href="Cat.Abelian.Base.html#7930" class="Bound">q</a><a id="8062" class="Symbol">))</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="8065" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="8073" class="Symbol">(</a><a id="8074" href="Cat.Abelian.Base.html#7922" class="Bound">other</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8080" href="Cat.Base.html#3006" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8082" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="8089" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8092" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8094" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8097" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8099" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) A" id="8101" href="Cat.Diagram.Product.html#2787" class="Function">Prod.π₁</a><a id="8108" class="Symbol">)</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8110" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <a id="8112" class="Symbol">(</a><a id="8113" href="Cat.Abelian.Base.html#7922" class="Bound">other</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8119" href="Cat.Base.html#3006" class="Function Operator">∘</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8121" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8128" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8131" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="8133" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8136" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8138" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" id="8140" href="Cat.Diagram.Product.html#2807" class="Function">Prod.π₂</a><a id="8147" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="8149" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(r : is-abelian C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) g) ((C ∘ f) h)
≡
(C ∘ f)
(has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g
 h)" id="8152" href="Cat.Abelian.Base.html#1903" class="Function">∘-linear-r</a> <a id="8163" class="Symbol">_</a> <a id="8165" class="Symbol">_</a> <a id="8167" class="Symbol">_</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="8169" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="8177" href="Cat.Abelian.Base.html#7922" class="Bound">other</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8183" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="8185" class="Symbol">(</a><span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8186" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="8193" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8196" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8198" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8201" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8203" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) A" id="8205" href="Cat.Diagram.Product.html#2787" class="Function">Prod.π₁</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8213" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8215" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8222" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8225" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="8227" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8230" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8232" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" id="8234" href="Cat.Diagram.Product.html#2807" class="Function">Prod.π₂</a><a id="8241" class="Symbol">)</a>           <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="8253" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" id="8256" href="Cat.Reasoning.html#1108" class="Function">elimr</a> <a id="8262" href="Cat.Abelian.Base.html#8374" class="Function">lemma</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="8268" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="8276" href="Cat.Abelian.Base.html#7922" class="Bound">other</a>                                                                       <a data-type="(x : A) → x ≡ x" id="8352" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
      <a id="8360" class="Keyword">where</a>
        <a id="8374" href="Cat.Abelian.Base.html#8374" class="Function">lemma</a> <a id="8380" class="Symbol">:</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8382" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="8389" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8392" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8394" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8397" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8399" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) A" id="8401" href="Cat.Diagram.Product.html#2787" class="Function">Prod.π₁</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8409" href="Cat.Abelian.Base.html#1445" class="Function Operator">+</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8411" href="Cat.Diagram.Product.html#1856" class="Function Operator">Prod.⟨</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8418" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8421" href="Cat.Diagram.Product.html#1856" class="Function Operator">,</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="8423" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="8426" href="Cat.Diagram.Product.html#1856" class="Function Operator">⟩</a></span><span class="alternate Function Operator">Prod.</span></span> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8428" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" id="8430" href="Cat.Diagram.Product.html#2807" class="Function">Prod.π₂</a>
              <a data-type="A → A → Type ℓ" id="8452" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="8454" href="Cat.Base.html#2976" class="Function">id</a>
        <a id="8465" href="Cat.Abelian.Base.html#8374" class="Function">lemma</a> <a id="8471" class="Symbol">=</a> <a data-type="(r : Product C A B₁) →
(C ∘ r .π₁) o1 ≡ pr1 →
(C ∘ r .π₂) o1 ≡ pr2 →
(C ∘ r .π₁) o2 ≡ pr1 → (C ∘ r .π₂) o2 ≡ pr2 → o1 ≡ o2" id="8473" href="Cat.Diagram.Product.html#2211" class="Function">Prod.unique₂</a> <a id="8486" class="Symbol">{</a><a id="8487" class="Argument">pr1</a> <a id="8491" class="Symbol">=</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) A" id="8493" href="Cat.Diagram.Product.html#2787" class="Function">Prod.π₁</a><a id="8500" class="Symbol">}</a> <a id="8502" class="Symbol">{</a><a id="8503" class="Argument">pr2</a> <a id="8507" class="Symbol">=</a> <a data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" id="8509" href="Cat.Diagram.Product.html#2807" class="Function">Prod.π₂</a><a id="8516" class="Symbol">}</a>
          <a id="8528" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="8529" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="8533" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) g) ((C ∘ f) h)
≡
(C ∘ f)
(has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g
 h)" id="8534" href="Cat.Abelian.Base.html#1903" class="Function">∘-linear-r</a> <a id="8545" class="Symbol">_</a> <a id="8547" class="Symbol">_</a> <a id="8549" class="Symbol">_)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="8552" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" id="8554" href="1Lab.Path.html#21189" class="Function">ap₂</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8558" href="Cat.Abelian.Base.html#1445" class="Function Operator">_+_</a> <a id="8562" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ h) ((C ∘ i) f) ≡ f" id="8563" href="Cat.Reasoning.html#2621" class="Function">cancell</a> <a data-type="(r : Product C A B₁) →
(C ∘ r .π₁) (has-is-product r .⟨_,_⟩ p1 p2) ≡ p1" id="8571" href="Cat.Diagram.Product.html#1918" class="Function">Prod.π₁∘factor</a><a id="8585" class="Symbol">)</a> <a id="8587" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ a) ((C ∘ b) f) ≡ (C ∘ c) f" id="8588" href="Cat.Reasoning.html#1548" class="Function">pulll</a> <a data-type="(r : Product C A B₁) →
(C ∘ r .π₁) (has-is-product r .⟨_,_⟩ p1 p2) ≡ p1" id="8594" href="Cat.Diagram.Product.html#1918" class="Function">Prod.π₁∘factor</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="8609" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ 0m r) f ≡ 0m r" id="8611" href="Cat.Abelian.Base.html#2885" class="Function">∘-zero-l</a><a id="8619" class="Symbol">)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="8621" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" id="8623" href="Cat.Reasoning.html#1108" class="Function">Hom.elimr</a> <a data-type="x ≡ x" id="8633" href="1Lab.Path.html#3593" class="Function">refl</a><a id="8637" class="Symbol">)</a>
          <a id="8649" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="8650" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="8654" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom C B₁ C) (g h : Hom C A B₁) →
has-ab (has-additive (has-is-preab r)) .Group-on-hom A C ._⋆_
((C ∘ f) g) ((C ∘ f) h)
≡
(C ∘ f)
(has-ab (has-additive (has-is-preab r)) .Group-on-hom A B₁ ._⋆_ g
 h)" id="8655" href="Cat.Abelian.Base.html#1903" class="Function">∘-linear-r</a> <a id="8666" class="Symbol">_</a> <a id="8668" class="Symbol">_</a> <a id="8670" class="Symbol">_)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="8673" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" id="8675" href="1Lab.Path.html#21189" class="Function">ap₂</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁ →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="8679" href="Cat.Abelian.Base.html#1445" class="Function Operator">_+_</a> <a id="8683" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ a) ((C ∘ b) f) ≡ (C ∘ c) f" id="8684" href="Cat.Reasoning.html#1548" class="Function">pulll</a> <a data-type="(r : Product C A B₁) →
(C ∘ r .π₂) (has-is-product r .⟨_,_⟩ p1 p2) ≡ p2" id="8690" href="Cat.Diagram.Product.html#1984" class="Function">Prod.π₂∘factor</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="8705" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ 0m r) f ≡ 0m r" id="8707" href="Cat.Abelian.Base.html#2885" class="Function">∘-zero-l</a><a id="8715" class="Symbol">)</a> <a id="8717" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ h) ((C ∘ i) f) ≡ f" id="8718" href="Cat.Reasoning.html#2621" class="Function">cancell</a> <a data-type="(r : Product C A B₁) →
(C ∘ r .π₂) (has-is-product r .⟨_,_⟩ p1 p2) ≡ p2" id="8726" href="Cat.Diagram.Product.html#1984" class="Function">Prod.π₂∘factor</a><a id="8740" class="Symbol">)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="8742" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ a) f ≡ f" id="8744" href="Cat.Reasoning.html#1009" class="Function">Hom.eliml</a> <a data-type="x ≡ x" id="8754" href="1Lab.Path.html#3593" class="Function">refl</a><a id="8758" class="Symbol">)</a>
          <a id="8770" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" id="8771" href="Cat.Reasoning.html#1108" class="Function">elimr</a> <a data-type="x ≡ x" id="8777" href="1Lab.Path.html#3593" class="Function">refl</a><a id="8781" class="Symbol">)</a>
          <a id="8793" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" id="8794" href="Cat.Reasoning.html#1108" class="Function">elimr</a> <a data-type="x ≡ x" id="8800" href="1Lab.Path.html#3593" class="Function">refl</a><a id="8804" class="Symbol">)</a>
</pre>
<h1 id="pre-abelian-abelian-categories"><a href="#pre-abelian-abelian-categories" class="header-link">Pre-abelian &amp; abelian categories<span class="header-link-emoji">🔗</span></a></h1>
<p>An additive category is <strong>pre-abelian</strong> when it additionally has <a href="Cat.Diagram.Kernel.html">kernels</a> and cokernels, hence binary <a href="Cat.Diagram.Equaliser.html">equalisers</a> and <a href="Cat.Diagram.Coequaliser.html">coequalisers</a> where one of the maps is zero.</p>
<pre class="Agda"><a id="9144" class="Keyword">record</a> <a id="is-pre-abelian"></a><a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="9151" href="Cat.Abelian.Base.html#9151" class="Record">is-pre-abelian</a> <a id="9166" class="Symbol">{</a><a id="9167" href="Cat.Abelian.Base.html#9167" class="Bound">o</a> <a id="9169" href="Cat.Abelian.Base.html#9169" class="Bound">ℓ</a><a id="9170" class="Symbol">}</a> <a id="9172" class="Symbol">(</a><a id="9173" href="Cat.Abelian.Base.html#9173" class="Bound">C</a> <a id="9175" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="9177" href="Cat.Base.html#704" class="Record">Precategory</a> <a id="9189" href="Cat.Abelian.Base.html#9167" class="Bound">o</a> <a id="9191" href="Cat.Abelian.Base.html#9169" class="Bound">ℓ</a><a id="9192" class="Symbol">)</a> <a id="9194" class="Symbol">:</a> <a id="9196" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="9201" class="Symbol">(</a><a id="9202" href="Cat.Abelian.Base.html#9167" class="Bound">o</a> <a data-type="Level → Level → Level" id="9204" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a data-type="Level → Level" id="9206" href="Agda.Primitive.html#780" class="Primitive">lsuc</a> <a id="9211" href="Cat.Abelian.Base.html#9169" class="Bound">ℓ</a><a id="9212" class="Symbol">)</a> <a id="9214" class="Keyword">where</a>
  <a id="9222" class="Keyword">field</a> <a id="is-pre-abelian.has-additive"></a><a data-type="(r : is-abelian C) → is-additive C" id="9228" href="Cat.Abelian.Base.html#9228" class="Field">has-additive</a> <a id="9241" class="Symbol">:</a> <a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="9243" href="Cat.Abelian.Base.html#5321" class="Record">is-additive</a> <a id="9255" href="Cat.Abelian.Base.html#9173" class="Bound">C</a>
  <a id="9259" class="Keyword">open</a> <a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="9264" href="Cat.Abelian.Base.html#5321" class="Module">is-additive</a> <a data-type="(r : is-abelian C) → is-additive C" id="9276" href="Cat.Abelian.Base.html#9228" class="Field">has-additive</a> <a id="9289" class="Keyword">public</a>
  <a id="9298" class="Keyword">field</a>
    <a id="is-pre-abelian.kernel"></a><a data-type="(r : is-abelian C) (f : Hom (has-is-preab r .has-additive) A B₁) →
Kernel C (∅ r) f" id="9308" href="Cat.Abelian.Base.html#9308" class="Field">kernel</a>   <a id="9317" class="Symbol">:</a> <a id="9319" class="Symbol">∀</a> <a id="9321" class="Symbol">{</a><a id="9322" href="Cat.Abelian.Base.html#9322" class="Bound">A</a> <a id="9324" href="Cat.Abelian.Base.html#9324" class="Bound">B</a><a id="9325" class="Symbol">}</a> <a id="9327" class="Symbol">(</a><a id="9328" href="Cat.Abelian.Base.html#9328" class="Bound">f</a> <a id="9330" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="9332" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="9336" href="Cat.Abelian.Base.html#9322" class="Bound">A</a> <a id="9338" href="Cat.Abelian.Base.html#9324" class="Bound">B</a><a id="9339" class="Symbol">)</a> <a id="9341" class="Symbol">→</a> <a data-type="(C : Precategory o ℓ) (∅ : Zero C) (f : Hom C a b) → Type (o ⊔ ℓ)" id="9343" href="Cat.Diagram.Equaliser.Kernel.html#1023" class="Record">Kernel</a> <a id="9350" href="Cat.Abelian.Base.html#9173" class="Bound">C</a> <a data-type="(r : is-abelian C) → Zero r" id="9352" href="Cat.Abelian.Base.html#5530" class="Function">∅</a> <a id="9354" href="Cat.Abelian.Base.html#9328" class="Bound">f</a>
    <a id="is-pre-abelian.cokernel"></a><a data-type="(r : is-abelian C) (f : Hom (has-is-preab r .has-additive) A B₁) →
Coequaliser r (0m r) f" id="9360" href="Cat.Abelian.Base.html#9360" class="Field">cokernel</a> <a id="9369" class="Symbol">:</a> <a id="9371" class="Symbol">∀</a> <a id="9373" class="Symbol">{</a><a id="9374" href="Cat.Abelian.Base.html#9374" class="Bound">A</a> <a id="9376" href="Cat.Abelian.Base.html#9376" class="Bound">B</a><a id="9377" class="Symbol">}</a> <a id="9379" class="Symbol">(</a><a id="9380" href="Cat.Abelian.Base.html#9380" class="Bound">f</a> <a id="9382" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="9384" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="9388" href="Cat.Abelian.Base.html#9374" class="Bound">A</a> <a id="9390" href="Cat.Abelian.Base.html#9376" class="Bound">B</a><a id="9391" class="Symbol">)</a> <a id="9393" class="Symbol">→</a> <a data-type="(C : Precategory o ℓ) (f g : Hom C A B₁) → Type (o ⊔ ℓ)" id="9395" href="Cat.Diagram.Coequaliser.html#1495" class="Record">Coequaliser</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="9407" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a id="9410" href="Cat.Abelian.Base.html#9380" class="Bound">f</a>

  <a id="9415" class="Keyword">module</a> <a id="is-pre-abelian.Ker"></a><a id="9422" href="Cat.Abelian.Base.html#9422" class="Module">Ker</a> <a id="9426" class="Symbol">{</a><a id="9427" href="Cat.Abelian.Base.html#9427" class="Bound">A</a> <a id="9429" href="Cat.Abelian.Base.html#9429" class="Bound">B</a><a id="9430" class="Symbol">}</a> <a id="9432" class="Symbol">(</a><a id="9433" href="Cat.Abelian.Base.html#9433" class="Bound">f</a> <a id="9435" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="9437" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="9441" href="Cat.Abelian.Base.html#9427" class="Bound">A</a> <a id="9443" href="Cat.Abelian.Base.html#9429" class="Bound">B</a><a id="9444" class="Symbol">)</a> <a id="9446" class="Symbol">=</a> <a data-type="(C : Precategory o ℓ) (∅ : Zero C) (f : Hom C a b) → Type (o ⊔ ℓ)" id="9448" href="Cat.Diagram.Equaliser.Kernel.html#1023" class="Module">Kernel</a> <a id="9455" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom (has-is-preab r .has-additive) A B₁) →
Kernel C (∅ r) f" id="9456" href="Cat.Abelian.Base.html#9308" class="Field">kernel</a> <a id="9463" href="Cat.Abelian.Base.html#9433" class="Bound">f</a><a id="9464" class="Symbol">)</a>
  <a id="9468" class="Keyword">module</a> <a id="is-pre-abelian.Coker"></a><a id="9475" href="Cat.Abelian.Base.html#9475" class="Module">Coker</a> <a id="9481" class="Symbol">{</a><a id="9482" href="Cat.Abelian.Base.html#9482" class="Bound">A</a> <a id="9484" href="Cat.Abelian.Base.html#9484" class="Bound">B</a><a id="9485" class="Symbol">}</a> <a id="9487" class="Symbol">(</a><a id="9488" href="Cat.Abelian.Base.html#9488" class="Bound">f</a> <a id="9490" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="9492" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="9496" href="Cat.Abelian.Base.html#9482" class="Bound">A</a> <a id="9498" href="Cat.Abelian.Base.html#9484" class="Bound">B</a><a id="9499" class="Symbol">)</a> <a id="9501" class="Symbol">=</a> <a data-type="(C : Precategory o ℓ) (f g : Hom C A B₁) → Type (o ⊔ ℓ)" id="9503" href="Cat.Diagram.Coequaliser.html#1495" class="Module">Coequaliser</a> <a id="9515" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom (has-is-preab r .has-additive) A B₁) →
Coequaliser r (0m r) f" id="9516" href="Cat.Abelian.Base.html#9360" class="Field">cokernel</a> <a id="9525" href="Cat.Abelian.Base.html#9488" class="Bound">f</a><a id="9526" class="Symbol">)</a>
</pre>
<p>Every morphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mi>f</mi></mpadded></mover><mi>B</mi></mrow><annotation encoding="application/x-tex">A \xto{f} B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1191em;vertical-align:-0.011em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1081em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> in a preabelian category admits a canonical decomposition as</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mover><mo stretchy="true" minsize="3.0em">↠</mo><mpadded width="+0.6em" lspace="0.3em"><mi>p</mi></mpadded></mover><mi mathvariant="normal">coker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>ker</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">)</mo><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mpadded></mover><mi>ker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">coker</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">)</mo><mover><mo stretchy="true" minsize="3.0em">↪</mo><mpadded width="+0.6em" lspace="0.3em"><mi>i</mi></mpadded></mover><mi>B</mi><mtext>,</mtext></mrow><annotation encoding="application/x-tex">
A \xepi{p} \coker (\ker f) \xto{f&#39;} \ker (\coker f) \xmono{i} B\text{,}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8294em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8294em;"><span style="top:-3.228em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="svg-align" style="top:-2.783em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.334em;min-width:0.888em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.334em" viewBox="0 0 400000 334" preserveAspectRatio="xMaxYMin slice"><path d="M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z"></path></svg></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.4515em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mopen">(</span><span class="mop">ker</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2015em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3337em;vertical-align:-0.25em;"></span><span class="mop">ker</span><span class="mopen">(</span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0837em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="stretchy" style="height:0.522em;min-width:1.08em;"><span class="halfarrow-left" style="height:0.522em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMinYMin slice"><path d="M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z"></path></svg></span><span class="halfarrow-right" style="height:0.522em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"></path></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord text"><span class="mord">,</span></span></span></span></span></span></p>
<p>where, as indicated, the map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> is an epimorphism (indeed a <a href="Cat.Diagram.Coequaliser.RegularEpi.html">regular epimorphism</a>, since it is a cokernel) and the map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> is a <a href="Cat.Diagram.Equaliser.RegularMono.html">regular monomorphism</a>.</p>
<pre class="Agda">  <a id="is-pre-abelian.decompose"></a><a data-type="(r : is-abelian C) (f : Hom (has-is-preab r) A B₁) →
Σ
(λ f′ →
   f ≡
   (has-is-preab r ∘
    kernel (has-is-preab r) (coeq (has-is-preab r) f))
   ((has-is-preab r ∘ f′)
    (coeq (has-is-preab r) (kernel (has-is-preab r) f))))" id="9994" href="Cat.Abelian.Base.html#9994" class="Function">decompose</a>
    <a id="10008" class="Symbol">:</a> <a id="10010" class="Symbol">∀</a> <a id="10012" class="Symbol">{</a><a id="10013" href="Cat.Abelian.Base.html#10013" class="Bound">A</a> <a id="10015" href="Cat.Abelian.Base.html#10015" class="Bound">B</a><a id="10016" class="Symbol">}</a> <a id="10018" class="Symbol">(</a><a id="10019" href="Cat.Abelian.Base.html#10019" class="Bound">f</a> <a id="10021" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="10023" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="10027" href="Cat.Abelian.Base.html#10013" class="Bound">A</a> <a id="10029" href="Cat.Abelian.Base.html#10015" class="Bound">B</a><a id="10030" class="Symbol">)</a>
    <a id="10036" class="Symbol">→</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="10038" href="1Lab.Type.html#1573" class="Function">Σ[</a> <a id="10041" href="Cat.Abelian.Base.html#10041" class="Bound">f′</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="10044" href="1Lab.Type.html#1573" class="Function">∈</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="10046" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="10050" class="Symbol">(</a><a data-type="Coequaliser C f g → Ob C" id="10051" href="Cat.Diagram.Coequaliser.html#1557" class="Function">Coker.coapex</a> <a id="10064" class="Symbol">(</a><a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="10065" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="10076" href="Cat.Abelian.Base.html#10019" class="Bound">f</a><a id="10077" class="Symbol">))</a> <a id="10080" class="Symbol">(</a><a data-type="Kernel C ∅ f → Ob C" id="10081" href="Cat.Diagram.Equaliser.Kernel.html#1088" class="Function">Ker.ker</a> <a id="10089" class="Symbol">(</a><a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="10090" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="10101" href="Cat.Abelian.Base.html#10019" class="Bound">f</a><a id="10102" class="Symbol">))</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="10105" href="1Lab.Type.html#1573" class="Function">]</a>
       <a id="10114" class="Symbol">(</a><a id="10115" href="Cat.Abelian.Base.html#10019" class="Bound">f</a> <a data-type="A → A → Type ℓ" id="10117" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="10119" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="10130" class="Symbol">(</a><a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="10131" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="10142" href="Cat.Abelian.Base.html#10019" class="Bound">f</a><a id="10143" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="10145" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="10147" href="Cat.Abelian.Base.html#10041" class="Bound">f′</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="10150" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="10152" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="10163" class="Symbol">(</a><a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="10164" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="10175" href="Cat.Abelian.Base.html#10019" class="Bound">f</a><a id="10176" class="Symbol">))</a>
  <a data-type="(r : is-abelian C) (f : Hom (has-is-preab r) A B₁) →
Σ
(λ f′ →
   f ≡
   (has-is-preab r ∘
    kernel (has-is-preab r) (coeq (has-is-preab r) f))
   ((has-is-preab r ∘ f′)
    (coeq (has-is-preab r) (kernel (has-is-preab r) f))))" id="10181" href="Cat.Abelian.Base.html#9994" class="Function">decompose</a> <a id="10191" class="Symbol">{</a><a id="10192" href="Cat.Abelian.Base.html#10192" class="Bound">A</a><a id="10193" class="Symbol">}</a> <a id="10195" class="Symbol">{</a><a id="10196" href="Cat.Abelian.Base.html#10196" class="Bound">B</a><a id="10197" class="Symbol">}</a> <a id="10199" href="Cat.Abelian.Base.html#10199" class="Bound">f</a> <a id="10201" class="Symbol">=</a> <a id="10203" href="Cat.Abelian.Base.html#10607" class="Function">map</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="10207" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="x ≡ y → y ≡ x" id="10209" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="10213" href="Cat.Abelian.Base.html#11484" class="Function">path</a>
    <a id="10222" class="Keyword">where</a>
      <a id="10234" href="Cat.Abelian.Base.html#10234" class="Function">proj′</a> <a id="10240" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="10242" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="10246" class="Symbol">(</a><a data-type="Coequaliser C f g → Ob C" id="10247" href="Cat.Diagram.Coequaliser.html#1557" class="Function">Coker.coapex</a> <a id="10260" class="Symbol">(</a><a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="10261" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="10272" href="Cat.Abelian.Base.html#10199" class="Bound">f</a><a id="10273" class="Symbol">))</a> <a id="10276" href="Cat.Abelian.Base.html#10196" class="Bound">B</a>
      <a id="10284" href="Cat.Abelian.Base.html#10234" class="Function">proj′</a> <a id="10290" class="Symbol">=</a> <a data-type="(r : Coequaliser C f g) →
(C ∘ e′) f ≡ (C ∘ e′) g → Hom C (r .coapex) F" id="10292" href="Cat.Diagram.Coequaliser.html#764" class="Function">Coker.coequalise</a> <a id="10309" class="Symbol">(</a><a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="10310" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="10321" href="Cat.Abelian.Base.html#10199" class="Bound">f</a><a id="10322" class="Symbol">)</a> <a id="10324" class="Symbol">{</a><a id="10325" class="Argument">e′</a> <a id="10328" class="Symbol">=</a> <a id="10330" href="Cat.Abelian.Base.html#10199" class="Bound">f</a><a id="10331" class="Symbol">}</a> <a data-type="((x : A) → B₁ x) → (x : A) → B₁ x" id="10333" href="1Lab.Type.html#2481" class="Function Operator">$</a> <a data-type="x ≡ y → y ≡ x" id="10335" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="10339" href="Cat.Abelian.Base.html#10395" class="Function">path</a>
</pre>
<!--
<pre class="Agda">        <a id="10370" class="Keyword">where</a> <a id="10376" class="Keyword">abstract</a>
          <a id="10395" href="Cat.Abelian.Base.html#10395" class="Function">path</a> <a id="10400" class="Symbol">:</a> <a id="10402" href="Cat.Abelian.Base.html#10199" class="Bound">f</a> <a id="10404" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="10406" href="Cat.Abelian.Base.html#9308" class="Field">kernel</a> <a id="10413" href="Cat.Abelian.Base.html#10199" class="Bound">f</a> <a id="10415" class="Symbol">.</a><a id="10416" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Field">Kernel.kernel</a> <a id="10430" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10432" href="Cat.Abelian.Base.html#10199" class="Bound">f</a> <a id="10434" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="10436" href="Cat.Abelian.Base.html#1533" class="Function">0m</a>
          <a id="10449" href="Cat.Abelian.Base.html#10395" class="Function">path</a> <a id="10454" class="Symbol">=</a> <a id="10456" href="Cat.Diagram.Equaliser.html#687" class="Function">Ker.equal</a> <a id="10466" href="Cat.Abelian.Base.html#10199" class="Bound">f</a>
            <a id="10480" href="1Lab.Path.html#38305" class="Function Operator">··</a> <a id="10483" href="Cat.Diagram.Zero.html#1167" class="Function">∅.zero-∘r</a> <a id="10493" class="Symbol">_</a>
            <a id="10507" href="1Lab.Path.html#38305" class="Function Operator">··</a> <a id="10510" href="1Lab.Path.html#21189" class="Function">ap₂</a> <a id="10514" href="Cat.Base.html#3006" class="Function Operator">_∘_</a> <a id="10518" class="Symbol">(</a><a id="10519" href="Cat.Diagram.Initial.html#456" class="Function">∅.has⊥</a> <a id="10526" class="Symbol">_</a> <a id="10528" class="Symbol">.</a><a id="10529" href="1Lab.HLevel.html#1416" class="Field">paths</a> <a id="10535" href="Cat.Abelian.Base.html#1533" class="Function">0m</a><a id="10537" class="Symbol">)</a> <a id="10539" href="1Lab.Path.html#3593" class="Function">refl</a>
            <a id="10556" href="1Lab.Path.html#38305" class="Function Operator">··</a> <a id="10559" href="Cat.Abelian.Base.html#2885" class="Function">∘-zero-l</a> <a id="10568" href="1Lab.Path.html#38305" class="Function Operator">··</a> <a id="10571" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="10575" href="Cat.Abelian.Base.html#2470" class="Function">∘-zero-r</a>
</pre>-->
<pre class="Agda">      <a id="10607" href="Cat.Abelian.Base.html#10607" class="Function">map</a> <a id="10611" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="10613" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="10617" class="Symbol">(</a><a data-type="Coequaliser C f g → Ob C" id="10618" href="Cat.Diagram.Coequaliser.html#1557" class="Function">Coker.coapex</a> <a id="10631" class="Symbol">(</a><a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="10632" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="10643" href="Cat.Abelian.Base.html#10199" class="Bound">f</a><a id="10644" class="Symbol">))</a> <a id="10647" class="Symbol">(</a><a data-type="Kernel C ∅ f → Ob C" id="10648" href="Cat.Diagram.Equaliser.Kernel.html#1088" class="Function">Ker.ker</a> <a id="10656" class="Symbol">(</a><a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="10657" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="10668" href="Cat.Abelian.Base.html#10199" class="Bound">f</a><a id="10669" class="Symbol">))</a>
      <a id="10678" href="Cat.Abelian.Base.html#10607" class="Function">map</a> <a id="10682" class="Symbol">=</a> <a data-type="(r : Kernel C ∅ f) →
(C ∘ f) e′ ≡ (C ∘ zero→ ∅) e′ → Hom C F (r .ker)" id="10684" href="Cat.Diagram.Equaliser.html#721" class="Function">Ker.limiting</a> <a id="10697" class="Symbol">(</a><a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="10698" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="10709" href="Cat.Abelian.Base.html#10199" class="Bound">f</a><a id="10710" class="Symbol">)</a> <a id="10712" class="Symbol">{</a><a id="10713" class="Argument">e′</a> <a id="10716" class="Symbol">=</a> <a id="10718" href="Cat.Abelian.Base.html#10234" class="Function">proj′</a><a id="10723" class="Symbol">}</a> <a data-type="((x : A) → B₁ x) → (x : A) → B₁ x" id="10725" href="1Lab.Type.html#2481" class="Function Operator">$</a> <a data-type="x ≡ y → y ≡ x" id="10727" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="10731" href="Cat.Abelian.Base.html#11049" class="Function">path</a>
</pre>
<p>The existence of the map <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">f&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>,</span> and indeed of the maps <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> and <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>,</span> follow from the universal properties of kernels and cokernels. The map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span> is the canonical quotient map <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi mathvariant="normal">coker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A \to \coker(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>,</span> and the map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> is the canonical subobject inclusion <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\ker(f) \to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">ker</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>.</span></p>
<!--
<pre class="Agda">        <a id="11024" class="Keyword">where</a> <a id="11030" class="Keyword">abstract</a>
          <a id="11049" href="Cat.Abelian.Base.html#11049" class="Function">path</a> <a id="11054" class="Symbol">:</a> <a id="11056" href="Cat.Diagram.Zero.html#1010" class="Function">∅.zero→</a> <a id="11064" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="11066" href="Cat.Abelian.Base.html#10234" class="Function">proj′</a> <a id="11072" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="11074" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="11085" href="Cat.Abelian.Base.html#10199" class="Bound">f</a> <a id="11087" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="11089" href="Cat.Abelian.Base.html#10234" class="Function">proj′</a>
          <a id="11105" href="Cat.Abelian.Base.html#11049" class="Function">path</a> <a id="11110" class="Symbol">=</a> <a id="11112" href="Cat.Diagram.Coequaliser.html#1087" class="Function">Coker.unique₂</a> <a id="11126" class="Symbol">(</a><a id="11127" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="11138" href="Cat.Abelian.Base.html#10199" class="Bound">f</a><a id="11139" class="Symbol">)</a>
            <a id="11153" class="Symbol">{</a><a id="11154" class="Argument">e′</a> <a id="11157" class="Symbol">=</a> <a id="11159" href="Cat.Abelian.Base.html#1533" class="Function">0m</a><a id="11161" class="Symbol">}</a> <a id="11163" class="Symbol">{</a><a id="11164" class="Argument">p</a> <a id="11166" class="Symbol">=</a> <a id="11168" href="Cat.Abelian.Base.html#2470" class="Function">∘-zero-r</a> <a id="11177" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a id="11179" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="11183" href="Cat.Abelian.Base.html#2885" class="Function">∘-zero-l</a><a id="11191" class="Symbol">}</a>
            <a id="11205" class="Symbol">(</a><a id="11206" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="11210" class="Symbol">(</a> <a id="11212" href="Cat.Reasoning.html#1844" class="Function">pushl</a> <a id="11218" class="Symbol">(</a><a id="11219" href="Cat.Diagram.Zero.html#1167" class="Function">∅.zero-∘r</a> <a id="11229" class="Symbol">_)</a> <a id="11232" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a id="11234" href="Cat.Reasoning.html#1548" class="Function">pulll</a> <a id="11240" class="Symbol">(</a> <a id="11242" href="1Lab.Path.html#21189" class="Function">ap₂</a> <a id="11246" href="Cat.Base.html#3006" class="Function Operator">_∘_</a> <a id="11250" href="1Lab.Path.html#3593" class="Function">refl</a> <a id="11255" class="Symbol">(</a><a id="11256" href="Cat.Diagram.Terminal.html#461" class="Function">∅.has⊤</a> <a id="11263" class="Symbol">_</a> <a id="11265" class="Symbol">.</a><a id="11266" href="1Lab.HLevel.html#1416" class="Field">paths</a> <a id="11272" href="Cat.Abelian.Base.html#1533" class="Function">0m</a><a id="11274" class="Symbol">)</a>
                                               <a id="11323" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a id="11325" href="Cat.Abelian.Base.html#2470" class="Function">∘-zero-r</a><a id="11333" class="Symbol">)</a>
                 <a id="11352" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a id="11354" href="Cat.Abelian.Base.html#2885" class="Function">∘-zero-l</a><a id="11362" class="Symbol">))</a>
            <a id="11377" class="Symbol">(</a><a id="11378" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="11382" class="Symbol">(</a> <a id="11384" href="Cat.Reasoning.html#1678" class="Function">pullr</a> <a id="11390" class="Symbol">(</a><a id="11391" href="Cat.Diagram.Coequaliser.html#834" class="Function">Coker.universal</a> <a id="11407" class="Symbol">(</a><a id="11408" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="11419" href="Cat.Abelian.Base.html#10199" class="Bound">f</a><a id="11420" class="Symbol">))</a> <a id="11423" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a id="11425" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="11429" class="Symbol">(</a><a id="11430" href="Cat.Diagram.Coequaliser.html#727" class="Function">Coker.coequal</a> <a id="11444" class="Symbol">_)</a>
                 <a id="11464" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a id="11466" href="Cat.Abelian.Base.html#2470" class="Function">∘-zero-r</a><a id="11474" class="Symbol">))</a>

      <a id="11484" href="Cat.Abelian.Base.html#11484" class="Function">path</a> <a id="11489" class="Symbol">=</a>
        <a id="11499" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="11510" class="Symbol">(</a><a id="11511" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="11522" href="Cat.Abelian.Base.html#10199" class="Bound">f</a><a id="11523" class="Symbol">)</a> <a id="11525" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="11527" href="Cat.Abelian.Base.html#10607" class="Function">map</a> <a id="11531" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="11533" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="11544" class="Symbol">(</a><a id="11545" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="11556" href="Cat.Abelian.Base.html#10199" class="Bound">f</a><a id="11557" class="Symbol">)</a> <a id="11559" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a id="11562" href="Cat.Reasoning.html#1548" class="Function">pulll</a> <a id="11568" class="Symbol">(</a><a id="11569" href="Cat.Diagram.Equaliser.html#790" class="Function">Ker.universal</a> <a id="11583" class="Symbol">_)</a> <a id="11586" href="1Lab.Path.html#46629" class="Function">⟩</a>
        <a id="11596" href="Cat.Abelian.Base.html#10234" class="Function">proj′</a> <a id="11602" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="11604" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="11615" class="Symbol">(</a><a id="11616" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="11627" href="Cat.Abelian.Base.html#10199" class="Bound">f</a><a id="11628" class="Symbol">)</a>                           <a id="11656" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a id="11659" href="Cat.Diagram.Coequaliser.html#834" class="Function">Coker.universal</a> <a id="11675" class="Symbol">_</a> <a id="11677" href="1Lab.Path.html#46629" class="Function">⟩</a>
        <a id="11687" href="Cat.Abelian.Base.html#10199" class="Bound">f</a>                                                           <a id="11747" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
</pre>-->
<p>A pre-abelian category is <strong>abelian</strong> when the map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">f&#39;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> in the above decomposition is an isomorphism.</p>
<pre class="Agda"><a id="11869" class="Keyword">record</a> <a id="is-abelian"></a><a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="11876" href="Cat.Abelian.Base.html#11876" class="Record">is-abelian</a> <a id="11887" class="Symbol">{</a><a id="11888" href="Cat.Abelian.Base.html#11888" class="Bound">o</a> <a id="11890" href="Cat.Abelian.Base.html#11890" class="Bound">ℓ</a><a id="11891" class="Symbol">}</a> <a id="11893" class="Symbol">(</a><a id="11894" href="Cat.Abelian.Base.html#11894" class="Bound">C</a> <a id="11896" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="11898" href="Cat.Base.html#704" class="Record">Precategory</a> <a id="11910" href="Cat.Abelian.Base.html#11888" class="Bound">o</a> <a id="11912" href="Cat.Abelian.Base.html#11890" class="Bound">ℓ</a><a id="11913" class="Symbol">)</a> <a id="11915" class="Symbol">:</a> <a id="11917" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="11922" class="Symbol">(</a><a id="11923" href="Cat.Abelian.Base.html#11888" class="Bound">o</a> <a data-type="Level → Level → Level" id="11925" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a data-type="Level → Level" id="11927" href="Agda.Primitive.html#780" class="Primitive">lsuc</a> <a id="11932" href="Cat.Abelian.Base.html#11890" class="Bound">ℓ</a><a id="11933" class="Symbol">)</a> <a id="11935" class="Keyword">where</a>
  <a id="11943" class="Keyword">field</a> <a id="is-abelian.has-is-preab"></a><a data-type="is-abelian C → is-pre-abelian C" id="11949" href="Cat.Abelian.Base.html#11949" class="Field">has-is-preab</a> <a id="11962" class="Symbol">:</a> <a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="11964" href="Cat.Abelian.Base.html#9151" class="Record">is-pre-abelian</a> <a id="11979" href="Cat.Abelian.Base.html#11894" class="Bound">C</a>
  <a id="11983" class="Keyword">open</a> <a data-type="(C : Precategory o ℓ) → Type (o ⊔ lsuc ℓ)" id="11988" href="Cat.Abelian.Base.html#9151" class="Module">is-pre-abelian</a> <a data-type="is-abelian C → is-pre-abelian C" id="12003" href="Cat.Abelian.Base.html#11949" class="Field">has-is-preab</a> <a id="12016" class="Keyword">public</a>
  <a id="12025" class="Keyword">field</a>
    <a id="is-abelian.coker-ker≃ker-coker"></a><a data-type="(r : is-abelian C) (f : Hom (r .has-is-preab) A B₁) →
is-invertible r (decompose r f .fst)" id="12035" href="Cat.Abelian.Base.html#12035" class="Field">coker-ker≃ker-coker</a>
      <a id="12061" class="Symbol">:</a> <a id="12063" class="Symbol">∀</a> <a id="12065" class="Symbol">{</a><a id="12066" href="Cat.Abelian.Base.html#12066" class="Bound">A</a> <a id="12068" href="Cat.Abelian.Base.html#12068" class="Bound">B</a><a id="12069" class="Symbol">}</a> <a id="12071" class="Symbol">(</a><a id="12072" href="Cat.Abelian.Base.html#12072" class="Bound">f</a> <a id="12074" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="12076" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="12080" href="Cat.Abelian.Base.html#12066" class="Bound">A</a> <a id="12082" href="Cat.Abelian.Base.html#12068" class="Bound">B</a><a id="12083" class="Symbol">)</a> <a id="12085" class="Symbol">→</a> <a data-type="(C : Precategory o h) (f : Hom C a b) → Type (o ⊔ h)" id="12087" href="Cat.Morphism.html#1930" class="Record">is-invertible</a> <a id="12101" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom (has-is-preab r) A B₁) →
Σ
(λ f′ →
   f ≡
   (has-is-preab r ∘
    kernel (has-is-preab r) (coeq (has-is-preab r) f))
   ((has-is-preab r ∘ f′)
    (coeq (has-is-preab r) (kernel (has-is-preab r) f))))" id="12102" href="Cat.Abelian.Base.html#9994" class="Function">decompose</a> <a id="12112" href="Cat.Abelian.Base.html#12072" class="Bound">f</a> <a id="12114" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="12115" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="12118" class="Symbol">)</a>
</pre>
<p>This implies in particular that any monomorphism is a kernel, and every epimorphism is a cokernel. Let’s investigate the case for “every mono is a kernel” first: Suppose that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>↪</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f : A \mono B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6943em;vertical-align:-0.011em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↪</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> is some monomorphism; We’ll show that it’s isomorphic to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">coker</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\ker (\coker f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">ker</span><span class="mopen">(</span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span> in the slice category <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">A</mi><mi mathvariant="normal">/</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">\ca{A}/B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal">A</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>.</span></p>
<pre class="Agda">  <a id="12436" class="Keyword">module</a> <a id="12443" href="Cat.Abelian.Base.html#12443" class="Module">_</a> <a id="12445" class="Symbol">{</a><a id="12446" href="Cat.Abelian.Base.html#12446" class="Bound">A</a> <a id="12448" href="Cat.Abelian.Base.html#12448" class="Bound">B</a><a id="12449" class="Symbol">}</a> <a id="12451" class="Symbol">(</a><a id="12452" href="Cat.Abelian.Base.html#12452" class="Bound">f</a> <a id="12454" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="12456" href="Cat.Base.html#1436" class="Function">Hom</a> <a id="12460" href="Cat.Abelian.Base.html#12446" class="Bound">A</a> <a id="12462" href="Cat.Abelian.Base.html#12448" class="Bound">B</a><a id="12463" class="Symbol">)</a> <a id="12465" class="Symbol">(</a><a id="12466" href="Cat.Abelian.Base.html#12466" class="Bound">monic</a> <a id="12472" class="Symbol">:</a> <a data-type="(C : Precategory o h) → Hom C a b → Type (o ⊔ h)" id="12474" href="Cat.Morphism.html#590" class="Function">is-monic</a> <a id="12483" href="Cat.Abelian.Base.html#12452" class="Bound">f</a><a id="12484" class="Symbol">)</a> <a id="12486" class="Keyword">where</a>
    <a id="12496" class="Keyword">private</a>
      <a id="12510" class="Keyword">module</a> <a id="12517" href="Cat.Abelian.Base.html#12517" class="Module">m</a> <a id="12519" class="Symbol">=</a> <a id="12521" href="Algebra.Prelude.html#883" class="Module">Cat</a> <a id="12525" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) → Ob C → Precategory (o ⊔ ℓ) ℓ" id="12526" href="Cat.Instances.Slice.html#4479" class="Function">Slice</a> <a id="12532" href="Cat.Abelian.Base.html#11894" class="Bound">C</a> <a id="12534" href="Cat.Abelian.Base.html#12448" class="Bound">B</a><a id="12535" class="Symbol">)</a>
</pre>
<p>The map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>ker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">coker</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A \to \ker (\coker f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">ker</span><span class="mopen">(</span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span> is obtained as the composite</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>A</mi><mover><mo stretchy="true" minsize="3.0em">↠</mo><mpadded width="+0.6em" lspace="0.3em"><mi>p</mi></mpadded></mover><mi mathvariant="normal">coker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>ker</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">)</mo><mo>≅</mo><mi>ker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">coker</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">)</mo><mtext>,</mtext></mrow><annotation encoding="application/x-tex">
A \xepi{p} \coker (\ker f) \cong \ker (\coker f)\text{,}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8294em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8294em;"><span style="top:-3.228em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span class="svg-align" style="top:-2.783em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.334em;min-width:0.888em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.334em" viewBox="0 0 400000 334" preserveAspectRatio="xMaxYMin slice"><path d="M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z"></path></svg></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mopen">(</span><span class="mop">ker</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">ker</span><span class="mopen">(</span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mord text"><span class="mord">,</span></span></span></span></span></span></p>
<p>where the isomorphism is our canonical map from before.</p>
<pre class="Agda">      <a id="12739" href="Cat.Abelian.Base.html#12739" class="Function">f→kercoker</a> <a id="12750" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="12752" href="Cat.Base.html#1436" class="Function">m.Hom</a> <a id="12758" class="Symbol">(</a><a data-type="(map₁ : Hom C domain c) → /-Obj c" id="12759" href="Cat.Instances.Slice.html#2264" class="InductiveConstructor">cut</a> <a id="12763" href="Cat.Abelian.Base.html#12452" class="Bound">f</a><a id="12764" class="Symbol">)</a> <a id="12766" class="Symbol">(</a><a data-type="(map₁ : Hom C domain c) → /-Obj c" id="12767" href="Cat.Instances.Slice.html#2264" class="InductiveConstructor">cut</a> <a id="12771" class="Symbol">(</a><a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="12772" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="12783" class="Symbol">(</a><a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="12784" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="12795" href="Cat.Abelian.Base.html#12452" class="Bound">f</a><a id="12796" class="Symbol">)))</a>
      <a id="12806" href="Cat.Abelian.Base.html#12739" class="Function">f→kercoker</a> <a id="12817" class="Symbol">.</a><a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="12818" href="Cat.Instances.Slice.html#2951" class="Field">/-Hom.map</a> <a id="12828" class="Symbol">=</a> <a data-type="(r : is-abelian C) (f : Hom (has-is-preab r) A B₁) →
Σ
(λ f′ →
   f ≡
   (has-is-preab r ∘
    kernel (has-is-preab r) (coeq (has-is-preab r) f))
   ((has-is-preab r ∘ f′)
    (coeq (has-is-preab r) (kernel (has-is-preab r) f))))" id="12830" href="Cat.Abelian.Base.html#9994" class="Function">decompose</a> <a id="12840" href="Cat.Abelian.Base.html#12452" class="Bound">f</a> <a id="12842" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="12843" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="12847" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="12849" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="12860" class="Symbol">(</a><a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="12861" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="12872" href="Cat.Abelian.Base.html#12452" class="Bound">f</a><a id="12873" class="Symbol">)</a>
      <a id="12881" href="Cat.Abelian.Base.html#12739" class="Function">f→kercoker</a> <a id="12892" class="Symbol">.</a><a data-type="(r : /-Hom a b) → (C ∘ map b) (r .map) ≡ a .map" id="12893" href="Cat.Instances.Slice.html#2992" class="Field">/-Hom.commutes</a> <a id="12908" class="Symbol">=</a> <a data-type="x ≡ y → y ≡ x" id="12910" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="12914" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom (has-is-preab r) A B₁) →
Σ
(λ f′ →
   f ≡
   (has-is-preab r ∘
    kernel (has-is-preab r) (coeq (has-is-preab r) f))
   ((has-is-preab r ∘ f′)
    (coeq (has-is-preab r) (kernel (has-is-preab r) f))))" id="12915" href="Cat.Abelian.Base.html#9994" class="Function">decompose</a> <a id="12925" href="Cat.Abelian.Base.html#12452" class="Bound">f</a> <a id="12927" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="12928" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="12931" class="Symbol">)</a>
</pre>
<p>Conversely, map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">coker</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">)</mo><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\ker (\coker f) \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">ker</span><span class="mopen">(</span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> is the composite</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>ker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">coker</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">)</mo><mo>≅</mo><mi mathvariant="normal">coker</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>ker</mi><mo>⁡</mo><mi>f</mi><mo stretchy="false">)</mo><mo>→</mo><mi>A</mi><mtext>,</mtext></mrow><annotation encoding="application/x-tex">
\ker (\coker f) \cong \coker (\ker f) \to A\text{,}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">ker</span><span class="mopen">(</span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">coker</span></span><span class="mopen">(</span><span class="mop">ker</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">A</span><span class="mord text"><span class="mord">,</span></span></span></span></span></span></p>
<p>where the second map arises from the universal property of the cokernel: We can map out of it with the map <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ker</mi><mo>⁡</mo><mi>f</mi><mo>↪</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\ker f \mono A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mop">ker</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↪</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>,</span> since (using that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> is mono), we have <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>=</mo><mi>ker</mi><mo>⁡</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">0 = \ker f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mop">ker</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> from <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mn>0</mn><mo>=</mo><mi>f</mi><mi>ker</mi><mo>⁡</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">f0 = f\ker f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">ker</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>.</span></p>
<pre class="Agda">      <a id="13269" href="Cat.Abelian.Base.html#13269" class="Function">kercoker→f</a> <a id="13280" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="13282" href="Cat.Base.html#1436" class="Function">m.Hom</a> <a id="13288" class="Symbol">(</a><a data-type="(map₁ : Hom C domain c) → /-Obj c" id="13289" href="Cat.Instances.Slice.html#2264" class="InductiveConstructor">cut</a> <a id="13293" class="Symbol">(</a><a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="13294" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="13305" class="Symbol">(</a><a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="13306" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="13317" href="Cat.Abelian.Base.html#12452" class="Bound">f</a><a id="13318" class="Symbol">)))</a> <a id="13322" class="Symbol">(</a><a data-type="(map₁ : Hom C domain c) → /-Obj c" id="13323" href="Cat.Instances.Slice.html#2264" class="InductiveConstructor">cut</a> <a id="13327" href="Cat.Abelian.Base.html#12452" class="Bound">f</a><a id="13328" class="Symbol">)</a>
      <a id="13336" href="Cat.Abelian.Base.html#13269" class="Function">kercoker→f</a> <a id="13347" class="Symbol">.</a><a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="13348" href="Cat.Instances.Slice.html#2951" class="Field">/-Hom.map</a> <a id="13358" class="Symbol">=</a>
        <a data-type="(r : Coequaliser C f g) →
(C ∘ e′) f ≡ (C ∘ e′) g → Hom C (r .coapex) F" id="13368" href="Cat.Diagram.Coequaliser.html#764" class="Function">Coker.coequalise</a> <a id="13385" class="Symbol">(</a><a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="13386" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="13397" href="Cat.Abelian.Base.html#12452" class="Bound">f</a><a id="13398" class="Symbol">)</a> <a id="13400" class="Symbol">{</a><a id="13401" class="Argument">e′</a> <a id="13404" class="Symbol">=</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="13406" href="Cat.Base.html#2976" class="Function">id</a><a id="13408" class="Symbol">}</a> <a id="13410" class="Symbol">(</a><a id="13411" href="Cat.Abelian.Base.html#12466" class="Bound">monic</a> <a id="13417" class="Symbol">_</a> <a id="13419" class="Symbol">_</a> <a id="13421" href="Cat.Abelian.Base.html#13513" class="Function">path</a><a id="13425" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="13427" href="Cat.Base.html#3006" class="Function Operator">∘</a>
          <a data-type="(r : is-abelian C) (f : Hom (r .has-is-preab) A B₁) →
is-invertible r (decompose r f .fst)" id="13439" href="Cat.Abelian.Base.html#12035" class="Field">coker-ker≃ker-coker</a> <a id="13459" href="Cat.Abelian.Base.html#12452" class="Bound">f</a> <a id="13461" class="Symbol">.</a><a data-type="is-invertible C f → Hom C b a" id="13462" href="Cat.Morphism.html#1991" class="Field">is-invertible.inv</a>
        <a id="13488" class="Keyword">where</a> <a id="13494" class="Keyword">abstract</a>
          <a id="13513" href="Cat.Abelian.Base.html#13513" class="Function">path</a> <a id="13518" class="Symbol">:</a> <a id="13520" href="Cat.Abelian.Base.html#12452" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="13522" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="13524" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="13527" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="13529" href="Cat.Abelian.Base.html#1533" class="Function">0m</a> <a data-type="A → A → Type ℓ" id="13532" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="13534" href="Cat.Abelian.Base.html#12452" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="13536" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="13538" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="13541" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="13543" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="13554" href="Cat.Abelian.Base.html#12452" class="Bound">f</a>
          <a id="13566" href="Cat.Abelian.Base.html#13513" class="Function">path</a> <a id="13571" class="Symbol">=</a>
            <a id="13585" href="Cat.Abelian.Base.html#12452" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="13587" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="13589" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="13592" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="13594" href="Cat.Abelian.Base.html#1533" class="Function">0m</a>              <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="13610" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="13613" href="1Lab.Path.html#20756" class="Function">ap</a> <a id="13616" class="Symbol">(</a><a id="13617" href="Cat.Abelian.Base.html#12452" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="13619" href="Cat.Base.html#3006" class="Function Operator">∘_</a><a id="13621" class="Symbol">)</a> <a id="13623" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ a) f ≡ f" id="13624" href="Cat.Reasoning.html#1009" class="Function">eliml</a> <a data-type="x ≡ x" id="13630" href="1Lab.Path.html#3593" class="Function">refl</a><a id="13634" class="Symbol">)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="13636" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ f) (0m r) ≡ 0m r" id="13638" href="Cat.Abelian.Base.html#2470" class="Function">∘-zero-r</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="13647" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
            <a data-type="(r : is-abelian C) →
Hom (has-ab (has-additive (has-is-preab r))) A B₁" id="13661" href="Cat.Abelian.Base.html#1533" class="Function">0m</a>                       <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" id="13686" href="1Lab.Path.html#46783" class="Function Operator">≡˘⟨</a> <a data-type="(r : Zero C) (f : Hom C x y) → (C ∘ zero→ r) f ≡ zero→ r" id="13690" href="Cat.Diagram.Zero.html#1167" class="Function">∅.zero-∘r</a> <a id="13700" class="Symbol">_</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="13702" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(r : is-abelian C) → zero→ r ≡ 0m r" id="13704" href="Cat.Abelian.Base.html#5706" class="Function">0m-unique</a> <a data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" id="13714" href="1Lab.Path.html#46783" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
            <a id="13728" class="Symbol">(</a><a data-type="Zero C → Hom C x y" id="13729" href="Cat.Diagram.Zero.html#1010" class="Function">∅.zero→</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="13737" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="13739" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="13750" href="Cat.Abelian.Base.html#12452" class="Bound">f</a><a id="13751" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" id="13753" href="1Lab.Path.html#46783" class="Function Operator">≡˘⟨</a> <a data-type="(r : Kernel C ∅ f) →
(C ∘ f) (r .kernel) ≡ (C ∘ zero→ ∅) (r .kernel)" id="13757" href="Cat.Diagram.Equaliser.html#687" class="Function">Ker.equal</a> <a id="13767" href="Cat.Abelian.Base.html#12452" class="Bound">f</a> <a data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" id="13769" href="1Lab.Path.html#46783" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
            <a id="13783" href="Cat.Abelian.Base.html#12452" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="13785" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="13787" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="13798" href="Cat.Abelian.Base.html#12452" class="Bound">f</a>         <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="13808" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="13811" href="1Lab.Path.html#20756" class="Function">ap</a> <a id="13814" class="Symbol">(</a><a id="13815" href="Cat.Abelian.Base.html#12452" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="13817" href="Cat.Base.html#3006" class="Function Operator">∘_</a><a id="13819" class="Symbol">)</a> <a id="13821" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → f ≡ (C ∘ a) f" id="13822" href="Cat.Reasoning.html#1207" class="Function">introl</a> <a data-type="x ≡ x" id="13829" href="1Lab.Path.html#3593" class="Function">refl</a><a id="13833" class="Symbol">)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="13835" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
            <a id="13849" href="Cat.Abelian.Base.html#12452" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="13851" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="13853" href="Cat.Base.html#2976" class="Function">id</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="13856" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="13858" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="13869" href="Cat.Abelian.Base.html#12452" class="Bound">f</a>    <a data-type="(x : A) → x ≡ x" id="13874" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
</pre>
<p>This is indeed a map in the slice using that both isomorphisms and coequalisers are epic to make progress.</p>
<pre class="Agda">      <a id="14003" href="Cat.Abelian.Base.html#13269" class="Function">kercoker→f</a> <a id="14014" class="Symbol">.</a><a data-type="(r : /-Hom a b) → (C ∘ map b) (r .map) ≡ a .map" id="14015" href="Cat.Instances.Slice.html#2992" class="Field">/-Hom.commutes</a> <a id="14030" class="Symbol">=</a> <a id="14032" href="Cat.Abelian.Base.html#14259" class="Function">path</a> <a id="14037" class="Keyword">where</a>
        <a id="14051" href="Cat.Abelian.Base.html#14051" class="Function">lemma</a> <a id="14057" class="Symbol">=</a>
          <a data-type="(C : Precategory o ℓ) (coequ : Hom C A E) →
is-coequaliser C f g coequ → is-epic C coequ" id="14069" href="Cat.Diagram.Coequaliser.html#1837" class="Function">is-coequaliser→is-epic</a> <a id="14092" class="Symbol">(</a><a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="14093" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="14104" class="Symbol">_)</a> <a id="14107" class="Symbol">(</a><a data-type="(r : Coequaliser C f g) → is-coequaliser C f g (r .coeq)" id="14108" href="Cat.Diagram.Coequaliser.html#1604" class="Function">Coker.has-is-coeq</a> <a id="14126" class="Symbol">_)</a> <a id="14129" class="Symbol">_</a> <a id="14131" class="Symbol">_</a> <a data-type="((x : A) → B₁ x) → (x : A) → B₁ x" id="14133" href="1Lab.Type.html#2481" class="Function Operator">$</a>
               <a data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" id="14150" href="Cat.Reasoning.html#1678" class="Function">pullr</a> <a id="14156" class="Symbol">(</a><a data-type="(r : Coequaliser C f g) →
(C ∘ has-is-coeq r .coequalise p) (r .coeq) ≡ e′" id="14157" href="Cat.Diagram.Coequaliser.html#834" class="Function">Coker.universal</a> <a id="14173" class="Symbol">_)</a>
            <a data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" id="14188" href="1Lab.Path.html#38305" class="Function Operator">··</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" id="14191" href="Cat.Reasoning.html#1108" class="Function">elimr</a> <a data-type="x ≡ x" id="14197" href="1Lab.Path.html#3593" class="Function">refl</a>
            <a data-type="w ≡ x → x ≡ y → y ≡ z → w ≡ z" id="14214" href="1Lab.Path.html#38305" class="Function Operator">··</a> <a id="14217" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom (has-is-preab r) A B₁) →
Σ
(λ f′ →
   f ≡
   (has-is-preab r ∘
    kernel (has-is-preab r) (coeq (has-is-preab r) f))
   ((has-is-preab r ∘ f′)
    (coeq (has-is-preab r) (kernel (has-is-preab r) f))))" id="14218" href="Cat.Abelian.Base.html#9994" class="Function">decompose</a> <a id="14228" href="Cat.Abelian.Base.html#12452" class="Bound">f</a> <a id="14230" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="14231" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="14235" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(r : Precategory o h) (f : r .Hom y z) (g : r .Hom x y)
(h : r .Hom w x) →
r ._∘_ f (r ._∘_ g h) ≡ r ._∘_ (r ._∘_ f g) h" id="14237" href="Cat.Base.html#3857" class="Function">assoc</a> <a id="14243" class="Symbol">_</a> <a id="14245" class="Symbol">_</a> <a id="14247" class="Symbol">_)</a>

        <a id="14259" href="Cat.Abelian.Base.html#14259" class="Function">path</a> <a id="14264" class="Symbol">=</a>
          <a data-type="(C : Precategory o h) → is-invertible C f → is-epic C f" id="14276" href="Cat.Morphism.html#7222" class="Function">invertible→epic</a> <a id="14292" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom (r .has-is-preab) A B₁) →
is-invertible r (decompose r f .fst)" id="14293" href="Cat.Abelian.Base.html#12035" class="Field">coker-ker≃ker-coker</a> <a id="14313" class="Symbol">_)</a> <a id="14316" class="Symbol">_</a> <a id="14318" class="Symbol">_</a> <a data-type="((x : A) → B₁ x) → (x : A) → B₁ x" id="14320" href="1Lab.Type.html#2481" class="Function Operator">$</a>
            <a id="14334" class="Symbol">(</a><a id="14335" href="Cat.Abelian.Base.html#12452" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="14337" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Coequaliser C f g) →
(C ∘ e′) f ≡ (C ∘ e′) g → Hom C (r .coapex) F" id="14339" href="Cat.Diagram.Coequaliser.html#764" class="Function">Coker.coequalise</a> <a id="14356" class="Symbol">_</a> <a id="14358" class="Symbol">_</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="14360" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="14362" class="Symbol">_)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="14365" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) (f : Hom (has-is-preab r) A B₁) →
Σ
(λ f′ →
   f ≡
   (has-is-preab r ∘
    kernel (has-is-preab r) (coeq (has-is-preab r) f))
   ((has-is-preab r ∘ f′)
    (coeq (has-is-preab r) (kernel (has-is-preab r) f))))" id="14367" href="Cat.Abelian.Base.html#9994" class="Function">decompose</a> <a id="14377" href="Cat.Abelian.Base.html#12452" class="Bound">f</a> <a id="14379" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="14380" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a>   <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="14386" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" id="14389" href="1Lab.Path.html#21189" class="Function">ap₂</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="14393" href="Cat.Base.html#3006" class="Function Operator">_∘_</a> <a id="14397" class="Symbol">(</a><a data-type="(r : Precategory o h) (f : r .Hom y z) (g : r .Hom x y)
(h : r .Hom w x) →
r ._∘_ f (r ._∘_ g h) ≡ r ._∘_ (r ._∘_ f g) h" id="14398" href="Cat.Base.html#3857" class="Function">assoc</a> <a id="14404" class="Symbol">_</a> <a id="14406" class="Symbol">_</a> <a id="14408" class="Symbol">_)</a> <a data-type="x ≡ x" id="14411" href="1Lab.Path.html#3593" class="Function">refl</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="14416" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
            <a id="14430" class="Symbol">((</a><a id="14432" href="Cat.Abelian.Base.html#12452" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="14434" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Coequaliser C f g) →
(C ∘ e′) f ≡ (C ∘ e′) g → Hom C (r .coapex) F" id="14436" href="Cat.Diagram.Coequaliser.html#764" class="Function">Coker.coequalise</a> <a id="14453" class="Symbol">_</a> <a id="14455" class="Symbol">_)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="14458" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="14460" class="Symbol">_)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="14463" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) (f : Hom (has-is-preab r) A B₁) →
Σ
(λ f′ →
   f ≡
   (has-is-preab r ∘
    kernel (has-is-preab r) (coeq (has-is-preab r) f))
   ((has-is-preab r ∘ f′)
    (coeq (has-is-preab r) (kernel (has-is-preab r) f))))" id="14465" href="Cat.Abelian.Base.html#9994" class="Function">decompose</a> <a id="14475" href="Cat.Abelian.Base.html#12452" class="Bound">f</a> <a id="14477" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="14478" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="14482" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ (C ∘ f) h) i ≡ f" id="14485" href="Cat.Reasoning.html#2731" class="Function">cancelr</a> <a id="14493" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom (r .has-is-preab) A B₁) →
is-invertible r (decompose r f .fst)" id="14494" href="Cat.Abelian.Base.html#12035" class="Field">coker-ker≃ker-coker</a> <a id="14514" class="Symbol">_</a> <a id="14516" class="Symbol">.</a><a data-type="(r : (C ≅ a) b) → (C ∘ r .from) (r .to) ≡ id C" id="14517" href="Cat.Morphism.html#1889" class="Function">is-invertible.invr</a><a id="14535" class="Symbol">)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="14537" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
            <a id="14551" href="Cat.Abelian.Base.html#12452" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="14553" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Coequaliser C f g) →
(C ∘ e′) f ≡ (C ∘ e′) g → Hom C (r .coapex) F" id="14555" href="Cat.Diagram.Coequaliser.html#764" class="Function">Coker.coequalise</a> <a id="14572" class="Symbol">_</a> <a id="14574" class="Symbol">_</a>                            <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="14603" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a id="14606" href="Cat.Abelian.Base.html#14051" class="Function">lemma</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="14612" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
            <a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="14626" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="14637" class="Symbol">_</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="14639" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) (f : Hom (has-is-preab r) A B₁) →
Σ
(λ f′ →
   f ≡
   (has-is-preab r ∘
    kernel (has-is-preab r) (coeq (has-is-preab r) f))
   ((has-is-preab r ∘ f′)
    (coeq (has-is-preab r) (kernel (has-is-preab r) f))))" id="14641" href="Cat.Abelian.Base.html#9994" class="Function">decompose</a> <a id="14651" href="Cat.Abelian.Base.html#12452" class="Bound">f</a> <a id="14653" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="14654" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a>                     <a data-type="(x : A) → x ≡ x" id="14678" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
</pre>
<p>Using the universal property of the cokernel (both uniqueness and universality), we establish that the maps defined above are inverses in <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">A</mi></mrow><annotation encoding="application/x-tex">\ca{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal">A</span></span></span></span>,</span> thus assemble into an isomorphism in the slice.</p>
<pre class="Agda">    <a data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
(Slice C B₁ ≅ cut f) (cut (kernel r (coeq r f)))" id="14894" href="Cat.Abelian.Base.html#14894" class="Function">mono→kernel</a> <a id="14906" class="Symbol">:</a> <a data-type="(map₁ : Hom C domain c) → /-Obj c" id="14908" href="Cat.Instances.Slice.html#2264" class="InductiveConstructor">cut</a> <a id="14912" href="Cat.Abelian.Base.html#12452" class="Bound">f</a> <a data-type="(C : Precategory o h) (a b : Ob C) → Type (o ⊔ h)" id="14914" href="Cat.Morphism.html#2208" class="Record Operator">m.≅</a> <a data-type="(map₁ : Hom C domain c) → /-Obj c" id="14918" href="Cat.Instances.Slice.html#2264" class="InductiveConstructor">cut</a> <a id="14922" class="Symbol">(</a><a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="14923" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="14934" class="Symbol">(</a><a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="14935" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="14946" href="Cat.Abelian.Base.html#12452" class="Bound">f</a><a id="14947" class="Symbol">))</a>
    <a data-type="(r : is-abelian C) (f : Hom r A B₁) (monic : is-monic r f) →
(Slice C B₁ ≅ cut f) (cut (kernel r (coeq r f)))" id="14954" href="Cat.Abelian.Base.html#14894" class="Function">mono→kernel</a> <a id="14966" class="Symbol">=</a> <a data-type="(C : Precategory o h) (f : Hom C a b) (g : Hom C b a) →
(C ∘ f) g ≡ id C → (C ∘ g) f ≡ id C → (C ≅ a) b" id="14968" href="Cat.Morphism.html#3719" class="Function">m.make-iso</a> <a id="14979" href="Cat.Abelian.Base.html#12739" class="Function">f→kercoker</a> <a id="14990" href="Cat.Abelian.Base.html#13269" class="Function">kercoker→f</a> <a id="15001" href="Cat.Abelian.Base.html#15028" class="Function">f→kc→f</a> <a id="15008" href="Cat.Abelian.Base.html#15644" class="Function">kc→f→kc</a> <a id="15016" class="Keyword">where</a>
      <a id="15028" href="Cat.Abelian.Base.html#15028" class="Function">f→kc→f</a> <a id="15035" class="Symbol">:</a> <a id="15037" href="Cat.Abelian.Base.html#12739" class="Function">f→kercoker</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="15048" href="Cat.Base.html#3006" class="Function Operator">m.∘</a> <a id="15052" href="Cat.Abelian.Base.html#13269" class="Function">kercoker→f</a> <a data-type="A → A → Type ℓ" id="15063" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="15065" href="Cat.Base.html#2976" class="Function">m.id</a>
      <a id="15076" href="Cat.Abelian.Base.html#15028" class="Function">f→kc→f</a> <a id="15083" class="Symbol">=</a> <a data-type="x .map ≡ y .map → x ≡ y" id="15085" href="Cat.Instances.Slice.html#3929" class="Function">/-Hom-path</a> <a data-type="((x : A) → B₁ x) → (x : A) → B₁ x" id="15096" href="1Lab.Type.html#2481" class="Function Operator">$</a>
        <a id="15106" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom (has-is-preab r) A B₁) →
Σ
(λ f′ →
   f ≡
   (has-is-preab r ∘
    kernel (has-is-preab r) (coeq (has-is-preab r) f))
   ((has-is-preab r ∘ f′)
    (coeq (has-is-preab r) (kernel (has-is-preab r) f))))" id="15107" href="Cat.Abelian.Base.html#9994" class="Function">decompose</a> <a id="15117" href="Cat.Abelian.Base.html#12452" class="Bound">f</a> <a id="15119" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="15120" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="15124" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="15126" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="15137" class="Symbol">_)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="15140" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Coequaliser C f g) →
(C ∘ e′) f ≡ (C ∘ e′) g → Hom C (r .coapex) F" id="15142" href="Cat.Diagram.Coequaliser.html#764" class="Function">Coker.coequalise</a> <a id="15159" class="Symbol">_</a> <a id="15161" class="Symbol">_</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="15163" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="15165" class="Symbol">_</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="15167" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ (C ∘ f) h) ((C ∘ i) g) ≡ (C ∘ f) g" id="15170" href="Cat.Reasoning.html#2947" class="Function">cancel-inner</a> <a id="15183" href="Cat.Abelian.Base.html#15402" class="Function">lemma</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="15189" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a data-type="(r : is-abelian C) (f : Hom (has-is-preab r) A B₁) →
Σ
(λ f′ →
   f ≡
   (has-is-preab r ∘
    kernel (has-is-preab r) (coeq (has-is-preab r) f))
   ((has-is-preab r ∘ f′)
    (coeq (has-is-preab r) (kernel (has-is-preab r) f))))" id="15199" href="Cat.Abelian.Base.html#9994" class="Function">decompose</a> <a id="15209" href="Cat.Abelian.Base.html#12452" class="Bound">f</a> <a id="15211" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="15212" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="15216" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="15218" class="Symbol">_</a>                                         <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="15260" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(r : is-abelian C) (f : Hom (r .has-is-preab) A B₁) →
is-invertible r (decompose r f .fst)" id="15263" href="Cat.Abelian.Base.html#12035" class="Field">coker-ker≃ker-coker</a> <a id="15283" href="Cat.Abelian.Base.html#12452" class="Bound">f</a> <a id="15285" class="Symbol">.</a><a data-type="(r : (C ≅ a) b) → (C ∘ r .to) (r .from) ≡ id C" id="15286" href="Cat.Morphism.html#1867" class="Function">is-invertible.invl</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="15305" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a data-type="(r : Precategory o h) → r .Hom x x" id="15315" href="Cat.Base.html#2976" class="Function">id</a>                                                           <a data-type="(x : A) → x ≡ x" id="15376" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
        <a id="15386" class="Keyword">where</a>
          <a id="15402" href="Cat.Abelian.Base.html#15402" class="Function">lemma</a> <a id="15408" class="Symbol">=</a> <a data-type="(r : Coequaliser C f g) →
e′ ≡ (C ∘ colim&#39;) (r .coeq) →
e′ ≡ (C ∘ colim&#39;&#39;) (r .coeq) → colim&#39; ≡ colim&#39;&#39;" id="15410" href="Cat.Diagram.Coequaliser.html#1087" class="Function">Coker.unique₂</a> <a id="15424" class="Symbol">_</a>
            <a id="15438" class="Symbol">{</a><a id="15439" class="Argument">e′</a> <a id="15442" class="Symbol">=</a> <a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="15444" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="15455" class="Symbol">(</a><a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="15456" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="15467" href="Cat.Abelian.Base.html#12452" class="Bound">f</a><a id="15468" class="Symbol">)}</a>
            <a id="15483" class="Symbol">{</a><a id="15484" class="Argument">p</a> <a id="15486" class="Symbol">=</a> <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ f) (0m r) ≡ 0m r" id="15488" href="Cat.Abelian.Base.html#2470" class="Function">∘-zero-r</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="15497" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="x ≡ y → y ≡ x" id="15499" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="15503" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="15504" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="15508" class="Symbol">(</a><a data-type="(r : Coequaliser C f g) → (C ∘ r .coeq) f ≡ (C ∘ r .coeq) g" id="15509" href="Cat.Diagram.Coequaliser.html#727" class="Function">Coker.coequal</a> <a id="15523" class="Symbol">_)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="15526" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(r : is-abelian C) →
(has-ab (has-additive (has-is-preab r)) ∘ f) (0m r) ≡ 0m r" id="15528" href="Cat.Abelian.Base.html#2470" class="Function">∘-zero-r</a><a id="15536" class="Symbol">)}</a>
            <a id="15551" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="15552" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="15556" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" id="15557" href="Cat.Reasoning.html#1678" class="Function">pullr</a> <a id="15563" class="Symbol">(</a><a data-type="(r : Coequaliser C f g) →
(C ∘ has-is-coeq r .coequalise p) (r .coeq) ≡ e′" id="15564" href="Cat.Diagram.Coequaliser.html#834" class="Function">Coker.universal</a> <a id="15580" class="Symbol">(</a><a data-type="(r : Kernel C ∅ f) → Hom C (r .ker) a" id="15581" href="Cat.Diagram.Equaliser.Kernel.html#1104" class="Function">Ker.kernel</a> <a id="15592" href="Cat.Abelian.Base.html#12452" class="Bound">f</a><a id="15593" class="Symbol">))</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="15596" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → (C ∘ f) a ≡ f" id="15598" href="Cat.Reasoning.html#1108" class="Function">elimr</a> <a data-type="x ≡ x" id="15604" href="1Lab.Path.html#3593" class="Function">refl</a><a id="15608" class="Symbol">))</a>
            <a id="15623" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → f ≡ (C ∘ a) f" id="15624" href="Cat.Reasoning.html#1207" class="Function">introl</a> <a data-type="x ≡ x" id="15631" href="1Lab.Path.html#3593" class="Function">refl</a><a id="15635" class="Symbol">)</a>

      <a id="15644" href="Cat.Abelian.Base.html#15644" class="Function">kc→f→kc</a> <a id="15652" class="Symbol">:</a> <a id="15654" href="Cat.Abelian.Base.html#13269" class="Function">kercoker→f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="15665" href="Cat.Base.html#3006" class="Function Operator">m.∘</a> <a id="15669" href="Cat.Abelian.Base.html#12739" class="Function">f→kercoker</a> <a data-type="A → A → Type ℓ" id="15680" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="15682" href="Cat.Base.html#2976" class="Function">m.id</a>
      <a id="15693" href="Cat.Abelian.Base.html#15644" class="Function">kc→f→kc</a> <a id="15701" class="Symbol">=</a> <a data-type="x .map ≡ y .map → x ≡ y" id="15703" href="Cat.Instances.Slice.html#3929" class="Function">/-Hom-path</a> <a data-type="((x : A) → B₁ x) → (x : A) → B₁ x" id="15714" href="1Lab.Type.html#2481" class="Function Operator">$</a>
        <a id="15724" class="Symbol">(</a><a data-type="(r : Coequaliser C f g) →
(C ∘ e′) f ≡ (C ∘ e′) g → Hom C (r .coapex) F" id="15725" href="Cat.Diagram.Coequaliser.html#764" class="Function">Coker.coequalise</a> <a id="15742" class="Symbol">_</a> <a id="15744" class="Symbol">_</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="15746" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a id="15748" class="Symbol">_)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="15751" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : is-abelian C) (f : Hom (has-is-preab r) A B₁) →
Σ
(λ f′ →
   f ≡
   (has-is-preab r ∘
    kernel (has-is-preab r) (coeq (has-is-preab r) f))
   ((has-is-preab r ∘ f′)
    (coeq (has-is-preab r) (kernel (has-is-preab r) f))))" id="15753" href="Cat.Abelian.Base.html#9994" class="Function">decompose</a> <a id="15763" href="Cat.Abelian.Base.html#12452" class="Bound">f</a> <a id="15765" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="15766" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="15770" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="15772" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="15783" class="Symbol">_</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="15785" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (inv₁ : (C ∘ h) i ≡ id C) →
(C ∘ (C ∘ f) h) ((C ∘ i) g) ≡ (C ∘ f) g" id="15788" href="Cat.Reasoning.html#2947" class="Function">cancel-inner</a> <a id="15801" class="Symbol">(</a><a data-type="(r : is-abelian C) (f : Hom (r .has-is-preab) A B₁) →
is-invertible r (decompose r f .fst)" id="15802" href="Cat.Abelian.Base.html#12035" class="Field">coker-ker≃ker-coker</a> <a id="15822" href="Cat.Abelian.Base.html#12452" class="Bound">f</a> <a id="15824" class="Symbol">.</a><a data-type="(r : (C ≅ a) b) → (C ∘ r .from) (r .to) ≡ id C" id="15825" href="Cat.Morphism.html#1889" class="Function">is-invertible.invr</a><a id="15843" class="Symbol">)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="15845" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a data-type="(r : Coequaliser C f g) →
(C ∘ e′) f ≡ (C ∘ e′) g → Hom C (r .coapex) F" id="15855" href="Cat.Diagram.Coequaliser.html#764" class="Function">Coker.coequalise</a> <a id="15872" class="Symbol">_</a> <a id="15874" class="Symbol">_</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="15876" href="Cat.Base.html#3006" class="Function Operator">∘</a> <a data-type="(r : Coequaliser C f g) → Hom C B₁ (r .coapex)" id="15878" href="Cat.Diagram.Coequaliser.html#1575" class="Function">Coker.coeq</a> <a id="15889" class="Symbol">_</a>                          <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="15916" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(r : Coequaliser C f g) →
(C ∘ has-is-coeq r .coequalise p) (r .coeq) ≡ e′" id="15919" href="Cat.Diagram.Coequaliser.html#834" class="Function">Coker.universal</a> <a id="15935" class="Symbol">_</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="15937" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a data-type="(r : Precategory o h) → r .Hom x x" id="15947" href="Cat.Base.html#2976" class="Function">id</a>                                                           <a data-type="(x : A) → x ≡ x" id="16008" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
</pre>
  </article>
</div>

</main>
</body>
</html>
