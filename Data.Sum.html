<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>

<head>
  <meta charset="utf-8"></meta>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"></meta>
  <meta name="keywords" content="Agda,categories,topos"></meta>

  <title>Data.Sum - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css"></link>
  <link rel="stylesheet" href="/css/katex.min.css"></link>
  <link rel="stylesheet" href="/css/agda-cats.css"></link>

  <meta name="twitter:card" content="summary"></meta>
  <meta name="twitter:title" content="Data.Sum - 1Lab"></meta>
  <meta name="twitter:image" content="https://cubical.1lab.dev/static/cube-128x.png"></meta>

  <meta name="og:title" content="Data.Sum - 1Lab"></meta>
  <meta name="og:image" content="https://cubical.1lab.dev/static/cube-128x.png"></meta>
  <meta name="og:site-name" content="The 1Lab"></meta>
  <meta name="og:type" content="website"></meta>
    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory."></meta>
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory."></meta>
  
  <script src="/equations.js" type="text/javascript"></script> 
  <script src="/highlight-hover.js" type="text/javascript"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>
</head>

<body>
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0;">
                <a class="Module">Data.Sum</a>
              </h3>

      <!-- Cube logo -->
      <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto; height: 32px;"></img>
      
      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr></hr>
      <ul>
      <li><a href="#sum-types"><a href="#sum-types" class="header-link">Sum Types<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#universal-properties"><a href="#universal-properties" class="header-link">Universal Properties<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#transformations"><a href="#transformations" class="header-link">Transformations<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#decidablity"><a href="#decidablity" class="header-link">Decidablity<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#closure-under-h-levels"><a href="#closure-under-h-levels" class="header-link">Closure under h-levels<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#closure-under-equivalences"><a href="#closure-under-equivalences" class="header-link">Closure under equivalences<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#algebraic-properties"><a href="#algebraic-properties" class="header-link">Algebraic properties<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      </ul>
      <hr></hr>

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>
      </div>

      <hr></hr>

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
              <a href="index.html">️back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/e9cc7e9178ca22c67ffb1c793c9531f2d4f4df9a/src/Data/Sum.lagda.md">link to source</a> <br />
      </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="index.html">️back to index</a>
      </div>
      
      <!-- Font toggle checkbox -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="1Lab.HLevel.Retracts.html" class="Module">1Lab.HLevel.Retracts</a>
<a id="42" class="Keyword">open</a> <a id="47" class="Keyword">import</a> <a id="54" href="1Lab.Type.Dec.html" class="Module">1Lab.Type.Dec</a>
<a id="68" class="Keyword">open</a> <a id="73" class="Keyword">import</a> <a id="80" href="1Lab.HLevel.html" class="Module">1Lab.HLevel</a>
<a id="92" class="Keyword">open</a> <a id="97" class="Keyword">import</a> <a id="104" href="1Lab.Equiv.html" class="Module">1Lab.Equiv</a>
<a id="115" class="Keyword">open</a> <a id="120" class="Keyword">import</a> <a id="127" href="1Lab.Path.html" class="Module">1Lab.Path</a>
<a id="137" class="Keyword">open</a> <a id="142" class="Keyword">import</a> <a id="149" href="1Lab.Type.html" class="Module">1Lab.Type</a>

<a id="160" class="Keyword">module</a> <a id="167" href="Data.Sum.html" class="Module">Data.Sum</a> <a id="176" class="Keyword">where</a>
</pre>
<h1 id="sum-types"><a href="#sum-types" class="header-link">Sum Types<span class="header-link-emoji">🔗</span></a></h1>
<p>Sum types are one of the fundamental ingredients of type theory. They play a dual role to the <a data-type="Type a → Type b → Type (a ⊔ b)" href="1Lab.Type.html#1836">product type</a>; if products allow us to state that we have elements of two types simultaneously, sum types allow us to state that we have an element of <em>one</em> of two types.</p>
<p>We use the notation <code>A ⊎ B</code> to hint at this type’s set-theoretic analog: the disjoint union.</p>
<pre class="Agda"><a id="592" class="Keyword">infixr</a> <a id="599" class="Number">1</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="601" href="Data.Sum.html#611" class="Datatype Operator">_⊎_</a>

<a id="606" class="Keyword">data</a> <a id="_⊎_"></a><a data-type="Type a → Type b → Type (a ⊔ b)" id="611" href="Data.Sum.html#611" class="Datatype Operator">_⊎_</a> <a id="615" class="Symbol">{</a><a id="616" href="Data.Sum.html#616" class="Bound">a</a> <a id="618" href="Data.Sum.html#618" class="Bound">b</a><a id="619" class="Symbol">}</a> <a id="621" class="Symbol">(</a><a id="622" href="Data.Sum.html#622" class="Bound">A</a> <a id="624" class="Symbol">:</a> <a id="626" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="631" href="Data.Sum.html#616" class="Bound">a</a><a id="632" class="Symbol">)</a> <a id="634" class="Symbol">(</a><a id="635" href="Data.Sum.html#635" class="Bound">B</a> <a id="637" class="Symbol">:</a> <a id="639" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="644" href="Data.Sum.html#618" class="Bound">b</a><a id="645" class="Symbol">)</a> <a id="647" class="Symbol">:</a> <a id="649" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="654" class="Symbol">(</a><a id="655" href="Data.Sum.html#616" class="Bound">a</a> <a data-type="Level → Level → Level" id="657" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="659" href="Data.Sum.html#618" class="Bound">b</a><a id="660" class="Symbol">)</a> <a id="662" class="Keyword">where</a>
  <a id="_⊎_.inl"></a><a data-type="A → A ⊎ B" id="670" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="674" class="Symbol">:</a> <a id="676" href="Data.Sum.html#622" class="Bound">A</a> <a id="678" class="Symbol">→</a> <a id="680" href="Data.Sum.html#622" class="Bound">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="682" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="684" href="Data.Sum.html#635" class="Bound">B</a>
  <a id="_⊎_.inr"></a><a data-type="B → A ⊎ B" id="688" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="692" class="Symbol">:</a> <a id="694" href="Data.Sum.html#635" class="Bound">B</a> <a id="696" class="Symbol">→</a> <a id="698" href="Data.Sum.html#622" class="Bound">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="700" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="702" href="Data.Sum.html#635" class="Bound">B</a>
</pre>
<!--
<pre class="Agda"><a id="721" class="Keyword">private</a> <a id="729" class="Keyword">variable</a>
  <a id="740" href="Data.Sum.html#740" class="Generalizable">a</a> <a id="742" href="Data.Sum.html#742" class="Generalizable">b</a> <a id="744" href="Data.Sum.html#744" class="Generalizable">c</a> <a id="746" href="Data.Sum.html#746" class="Generalizable">d</a> <a id="748" class="Symbol">:</a> <a id="750" href="Agda.Primitive.html#597" class="Postulate">Level</a>
  <a id="758" href="Data.Sum.html#758" class="Generalizable">A</a> <a id="760" href="Data.Sum.html#760" class="Generalizable">B</a> <a id="762" href="Data.Sum.html#762" class="Generalizable">C</a> <a id="764" href="Data.Sum.html#764" class="Generalizable">D</a> <a id="766" class="Symbol">:</a> <a id="768" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="773" href="Data.Sum.html#740" class="Generalizable">a</a>
</pre>-->
<p>As warmup, we have that both constructors are embeddings:</p>
<pre class="Agda"><a id="inl-inj"></a><a data-type="inl x ≡ inl y → x ≡ y" id="851" href="Data.Sum.html#851" class="Function">inl-inj</a> <a id="859" class="Symbol">:</a> <a id="861" class="Symbol">{</a><a id="862" href="Data.Sum.html#862" class="Bound">B</a> <a id="864" class="Symbol">:</a> <a id="866" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="871" href="Data.Sum.html#742" class="Generalizable">b</a><a id="872" class="Symbol">}</a> <a id="874" class="Symbol">{</a><a id="875" href="Data.Sum.html#875" class="Bound">x</a> <a id="877" href="Data.Sum.html#877" class="Bound">y</a> <a id="879" class="Symbol">:</a> <a id="881" href="Data.Sum.html#758" class="Generalizable">A</a><a id="882" class="Symbol">}</a> <a id="884" class="Symbol">→</a> <a data-type="A → A ⊎ B" id="886" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="890" class="Symbol">{</a><a id="891" class="Argument">B</a> <a id="893" class="Symbol">=</a> <a id="895" href="Data.Sum.html#862" class="Bound">B</a><a id="896" class="Symbol">}</a> <a id="898" href="Data.Sum.html#875" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="900" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="A → A ⊎ B" id="902" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="906" href="Data.Sum.html#877" class="Bound">y</a> <a id="908" class="Symbol">→</a> <a id="910" href="Data.Sum.html#875" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="912" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="914" href="Data.Sum.html#877" class="Bound">y</a>
<a data-type="inl x ≡ inl y → x ≡ y" id="916" href="Data.Sum.html#851" class="Function">inl-inj</a> <a id="924" class="Symbol">{</a><a id="925" class="Argument">A</a> <a id="927" class="Symbol">=</a> <a id="929" href="Data.Sum.html#929" class="Bound">A</a><a id="930" class="Symbol">}</a> <a id="932" class="Symbol">{</a><a id="933" class="Argument">x</a> <a id="935" class="Symbol">=</a> <a id="937" href="Data.Sum.html#937" class="Bound">x</a><a id="938" class="Symbol">}</a> <a id="940" href="Data.Sum.html#940" class="Bound">path</a> <a id="945" class="Symbol">=</a> <a data-type="(f : (x : A) → B x) (p : x ≡ y) → PathP (λ i → B (p i)) (f x) (f y)" id="947" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="950" href="Data.Sum.html#965" class="Function">f</a> <a id="952" href="Data.Sum.html#940" class="Bound">path</a> <a id="957" class="Keyword">where</a>
  <a id="965" href="Data.Sum.html#965" class="Function">f</a> <a id="967" class="Symbol">:</a> <a id="969" href="Data.Sum.html#929" class="Bound">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="971" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="973" href="Data.Sum.html#760" class="Generalizable">B</a> <a id="975" class="Symbol">→</a> <a id="977" href="Data.Sum.html#929" class="Bound">A</a>
  <a id="981" href="Data.Sum.html#965" class="Function">f</a> <a id="983" class="Symbol">(</a><a data-type="A → A ⊎ B" id="984" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="988" href="Data.Sum.html#988" class="Bound">x</a><a id="989" class="Symbol">)</a> <a id="991" class="Symbol">=</a> <a id="993" href="Data.Sum.html#988" class="Bound">x</a>
  <a id="997" href="Data.Sum.html#965" class="Function">f</a> <a id="999" class="Symbol">(</a><a data-type="B → A ⊎ B" id="1000" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="1004" class="Symbol">_)</a> <a id="1007" class="Symbol">=</a> <a id="1009" href="Data.Sum.html#937" class="Bound">x</a>

<a id="inr-inj"></a><a data-type="inr x ≡ inr y → x ≡ y" id="1012" href="Data.Sum.html#1012" class="Function">inr-inj</a> <a id="1020" class="Symbol">:</a> <a id="1022" class="Symbol">{</a><a id="1023" href="Data.Sum.html#1023" class="Bound">A</a> <a id="1025" class="Symbol">:</a> <a id="1027" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="1032" href="Data.Sum.html#742" class="Generalizable">b</a><a id="1033" class="Symbol">}</a> <a id="1035" class="Symbol">{</a><a id="1036" href="Data.Sum.html#1036" class="Bound">x</a> <a id="1038" href="Data.Sum.html#1038" class="Bound">y</a> <a id="1040" class="Symbol">:</a> <a id="1042" href="Data.Sum.html#760" class="Generalizable">B</a><a id="1043" class="Symbol">}</a> <a id="1045" class="Symbol">→</a> <a data-type="B → A ⊎ B" id="1047" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="1051" class="Symbol">{</a><a id="1052" class="Argument">A</a> <a id="1054" class="Symbol">=</a> <a id="1056" href="Data.Sum.html#1023" class="Bound">A</a><a id="1057" class="Symbol">}</a> <a id="1059" href="Data.Sum.html#1036" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="1061" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="B → A ⊎ B" id="1063" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="1067" href="Data.Sum.html#1038" class="Bound">y</a> <a id="1069" class="Symbol">→</a> <a id="1071" href="Data.Sum.html#1036" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="1073" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="1075" href="Data.Sum.html#1038" class="Bound">y</a>
<a data-type="inr x ≡ inr y → x ≡ y" id="1077" href="Data.Sum.html#1012" class="Function">inr-inj</a> <a id="1085" class="Symbol">{</a><a id="1086" class="Argument">B</a> <a id="1088" class="Symbol">=</a> <a id="1090" href="Data.Sum.html#1090" class="Bound">B</a><a id="1091" class="Symbol">}</a> <a id="1093" class="Symbol">{</a><a id="1094" class="Argument">x</a> <a id="1096" class="Symbol">=</a> <a id="1098" href="Data.Sum.html#1098" class="Bound">x</a><a id="1099" class="Symbol">}</a> <a id="1101" href="Data.Sum.html#1101" class="Bound">path</a> <a id="1106" class="Symbol">=</a> <a data-type="(f : (x : A) → B x) (p : x ≡ y) → PathP (λ i → B (p i)) (f x) (f y)" id="1108" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="1111" href="Data.Sum.html#1126" class="Function">f</a> <a id="1113" href="Data.Sum.html#1101" class="Bound">path</a> <a id="1118" class="Keyword">where</a>
  <a id="1126" href="Data.Sum.html#1126" class="Function">f</a> <a id="1128" class="Symbol">:</a> <a id="1130" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="1132" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="1134" href="Data.Sum.html#1090" class="Bound">B</a> <a id="1136" class="Symbol">→</a> <a id="1138" href="Data.Sum.html#1090" class="Bound">B</a>
  <a id="1142" href="Data.Sum.html#1126" class="Function">f</a> <a id="1144" class="Symbol">(</a><a data-type="A → A ⊎ B" id="1145" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="1149" class="Symbol">_)</a> <a id="1152" class="Symbol">=</a> <a id="1154" href="Data.Sum.html#1098" class="Bound">x</a>
  <a id="1158" href="Data.Sum.html#1126" class="Function">f</a> <a id="1160" class="Symbol">(</a><a data-type="B → A ⊎ B" id="1161" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="1165" href="Data.Sum.html#1165" class="Bound">x</a><a id="1166" class="Symbol">)</a> <a id="1168" class="Symbol">=</a> <a id="1170" href="Data.Sum.html#1165" class="Bound">x</a>

<a id="⊎-disjoint"></a><a data-type="inl x ≡ inr y → ⊥" id="1173" href="Data.Sum.html#1173" class="Function">⊎-disjoint</a> <a id="1184" class="Symbol">:</a> <a id="1186" class="Symbol">{</a><a id="1187" href="Data.Sum.html#1187" class="Bound">A</a> <a id="1189" class="Symbol">:</a> <a id="1191" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="1196" href="Data.Sum.html#740" class="Generalizable">a</a><a id="1197" class="Symbol">}</a> <a id="1199" class="Symbol">{</a><a id="1200" href="Data.Sum.html#1200" class="Bound">B</a> <a id="1202" class="Symbol">:</a> <a id="1204" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="1209" href="Data.Sum.html#742" class="Generalizable">b</a><a id="1210" class="Symbol">}</a> <a id="1212" class="Symbol">{</a><a id="1213" href="Data.Sum.html#1213" class="Bound">x</a> <a id="1215" class="Symbol">:</a> <a id="1217" href="Data.Sum.html#1187" class="Bound">A</a><a id="1218" class="Symbol">}</a> <a id="1220" class="Symbol">{</a><a id="1221" href="Data.Sum.html#1221" class="Bound">y</a> <a id="1223" class="Symbol">:</a> <a id="1225" href="Data.Sum.html#1200" class="Bound">B</a><a id="1226" class="Symbol">}</a> <a id="1228" class="Symbol">→</a> <a data-type="A → A ⊎ B" id="1230" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="1234" href="Data.Sum.html#1213" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="1236" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="B → A ⊎ B" id="1238" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="1242" href="Data.Sum.html#1221" class="Bound">y</a> <a id="1244" class="Symbol">→</a> <a data-type="Type" id="1246" href="1Lab.Type.html#1326" class="Datatype">⊥</a>
<a data-type="inl x ≡ inr y → ⊥" id="1248" href="Data.Sum.html#1173" class="Function">⊎-disjoint</a> <a id="1259" href="Data.Sum.html#1259" class="Bound">path</a> <a id="1264" class="Symbol">=</a> <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="1266" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="1272" class="Symbol">(λ</a> <a id="1275" class="Symbol">{</a> <a id="1277" class="Symbol">(</a><a data-type="A → A ⊎ B" id="1278" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="1282" href="Data.Sum.html#1282" class="Bound">x</a><a id="1283" class="Symbol">)</a> <a id="1285" class="Symbol">→</a> <a data-type="Type" id="1287" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a> <a id="1289" class="Symbol">;</a> <a id="1291" class="Symbol">(</a><a data-type="B → A ⊎ B" id="1292" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="1296" href="Data.Sum.html#1296" class="Bound">x</a><a id="1297" class="Symbol">)</a> <a id="1299" class="Symbol">→</a> <a data-type="Type" id="1301" href="1Lab.Type.html#1326" class="Datatype">⊥</a> <a id="1303" class="Symbol">})</a> <a id="1306" href="Data.Sum.html#1259" class="Bound">path</a> <a data-type="⊤" id="1311" href="Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>
</pre>
<h2 id="universal-properties"><a href="#universal-properties" class="header-link">Universal Properties<span class="header-link-emoji">🔗</span></a></h2>
<p>One of the most important things about sum types is the following property: given two functions <code>A → C</code> and <code>B → C</code>, we can construct a function <code>A ⊎ B → C</code>.</p>
<pre class="Agda"><a id="[_,_]"></a><a data-type="(A → C) → (B → C) → A ⊎ B → C" id="1511" href="Data.Sum.html#1511" class="Function Operator">[_,_]</a> <a id="1517" class="Symbol">:</a> <a id="1519" class="Symbol">(</a><a id="1520" href="Data.Sum.html#758" class="Generalizable">A</a> <a id="1522" class="Symbol">→</a> <a id="1524" href="Data.Sum.html#762" class="Generalizable">C</a><a id="1525" class="Symbol">)</a> <a id="1527" class="Symbol">→</a> <a id="1529" class="Symbol">(</a><a id="1530" href="Data.Sum.html#760" class="Generalizable">B</a> <a id="1532" class="Symbol">→</a> <a id="1534" href="Data.Sum.html#762" class="Generalizable">C</a><a id="1535" class="Symbol">)</a> <a id="1537" class="Symbol">→</a> <a id="1539" class="Symbol">(</a><a id="1540" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="1542" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="1544" href="Data.Sum.html#760" class="Generalizable">B</a><a id="1545" class="Symbol">)</a> <a id="1547" class="Symbol">→</a> <a id="1549" href="Data.Sum.html#762" class="Generalizable">C</a>
<a data-type="(A → C) → (B → C) → A ⊎ B → C" id="1551" href="Data.Sum.html#1511" class="Function Operator">[</a> <a id="1553" href="Data.Sum.html#1553" class="Bound">f</a> <a data-type="(A → C) → (B → C) → A ⊎ B → C" id="1555" href="Data.Sum.html#1511" class="Function Operator">,</a> <a id="1557" href="Data.Sum.html#1557" class="Bound">g</a> <a data-type="(A → C) → (B → C) → A ⊎ B → C" id="1559" href="Data.Sum.html#1511" class="Function Operator">]</a> <a id="1561" class="Symbol">(</a><a data-type="A → A ⊎ B" id="1562" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="1566" href="Data.Sum.html#1566" class="Bound">x</a><a id="1567" class="Symbol">)</a> <a id="1569" class="Symbol">=</a> <a id="1571" href="Data.Sum.html#1553" class="Bound">f</a> <a id="1573" href="Data.Sum.html#1566" class="Bound">x</a>
<a data-type="(A → C) → (B → C) → A ⊎ B → C" id="1575" href="Data.Sum.html#1511" class="Function Operator">[</a> <a id="1577" href="Data.Sum.html#1577" class="Bound">f</a> <a data-type="(A → C) → (B → C) → A ⊎ B → C" id="1579" href="Data.Sum.html#1511" class="Function Operator">,</a> <a id="1581" href="Data.Sum.html#1581" class="Bound">g</a> <a data-type="(A → C) → (B → C) → A ⊎ B → C" id="1583" href="Data.Sum.html#1511" class="Function Operator">]</a> <a id="1585" class="Symbol">(</a><a data-type="B → A ⊎ B" id="1586" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="1590" href="Data.Sum.html#1590" class="Bound">x</a><a id="1591" class="Symbol">)</a> <a id="1593" class="Symbol">=</a> <a id="1595" href="Data.Sum.html#1581" class="Bound">g</a> <a id="1597" href="Data.Sum.html#1590" class="Bound">x</a>
</pre>
<p>Furthermore, this function is “universal” in the following sense: if we have some function <code>h : A ⊎ B → C</code> that behaves like <code>f</code> when provided an <code>inl a</code>, and like <code>g</code> when provided <code>inr b</code>, then <code>h</code> <em>must</em> be equal to <code>[ f , g ]</code>.</p>
<pre class="Agda"><a id="[]-unique"></a><a data-type="f ≡ h ∘ inl → g ≡ h ∘ inr → [ f , g ] ≡ h" id="1845" href="Data.Sum.html#1845" class="Function">[]-unique</a> <a id="1855" class="Symbol">:</a> <a id="1857" class="Symbol">∀</a> <a id="1859" class="Symbol">{</a><a id="1860" href="Data.Sum.html#1860" class="Bound">f</a> <a id="1862" class="Symbol">:</a> <a id="1864" href="Data.Sum.html#758" class="Generalizable">A</a> <a id="1866" class="Symbol">→</a> <a id="1868" href="Data.Sum.html#762" class="Generalizable">C</a><a id="1869" class="Symbol">}</a> <a id="1871" class="Symbol">{</a><a id="1872" href="Data.Sum.html#1872" class="Bound">g</a> <a id="1874" class="Symbol">:</a> <a id="1876" href="Data.Sum.html#760" class="Generalizable">B</a> <a id="1878" class="Symbol">→</a> <a id="1880" href="Data.Sum.html#762" class="Generalizable">C</a><a id="1881" class="Symbol">}</a> <a id="1883" class="Symbol">{</a><a id="1884" href="Data.Sum.html#1884" class="Bound">h</a><a id="1885" class="Symbol">}</a> <a id="1887" class="Symbol">→</a> <a id="1889" href="Data.Sum.html#1860" class="Bound">f</a> <a data-type="A → A → Type ℓ" id="1891" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="1893" href="Data.Sum.html#1884" class="Bound">h</a> <a data-type="(B → C) → (A → B) → A → C" id="1895" href="1Lab.Type.html#2217" class="Function Operator">∘</a> <a data-type="A → A ⊎ B" id="1897" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="1901" class="Symbol">→</a> <a id="1903" href="Data.Sum.html#1872" class="Bound">g</a> <a data-type="A → A → Type ℓ" id="1905" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="1907" href="Data.Sum.html#1884" class="Bound">h</a> <a data-type="(B → C) → (A → B) → A → C" id="1909" href="1Lab.Type.html#2217" class="Function Operator">∘</a> <a data-type="B → A ⊎ B" id="1911" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="1915" class="Symbol">→</a> <a data-type="(A → C) → (B → C) → A ⊎ B → C" id="1917" href="Data.Sum.html#1511" class="Function Operator">[</a> <a id="1919" href="Data.Sum.html#1860" class="Bound">f</a> <a data-type="(A → C) → (B → C) → A ⊎ B → C" id="1921" href="Data.Sum.html#1511" class="Function Operator">,</a> <a id="1923" href="Data.Sum.html#1872" class="Bound">g</a> <a data-type="(A → C) → (B → C) → A ⊎ B → C" id="1925" href="Data.Sum.html#1511" class="Function Operator">]</a> <a data-type="A → A → Type ℓ" id="1927" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="1929" href="Data.Sum.html#1884" class="Bound">h</a>
<a data-type="f ≡ h ∘ inl → g ≡ h ∘ inr → [ f , g ] ≡ h" id="1931" href="Data.Sum.html#1845" class="Function">[]-unique</a> <a id="1941" href="Data.Sum.html#1941" class="Bound">p</a> <a id="1943" href="Data.Sum.html#1943" class="Bound">q</a> <a id="1945" class="Symbol">=</a> <a data-type="((x : A) → f x ≡ g x) → f ≡ g" id="1947" href="1Lab.Path.html#56413" class="Function">funext</a> <a id="1954" class="Symbol">λ</a> <a id="1956" class="Symbol">{</a> <a id="1958" class="Symbol">(</a><a data-type="A → A ⊎ B" id="1959" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="1963" href="Data.Sum.html#1963" class="Bound">x</a><a id="1964" class="Symbol">)</a> <a id="1966" href="Data.Sum.html#1966" class="Bound">i</a> <a id="1968" class="Symbol">→</a> <a id="1970" href="Data.Sum.html#1941" class="Bound">p</a> <a id="1972" href="Data.Sum.html#1966" class="Bound">i</a> <a id="1974" href="Data.Sum.html#1963" class="Bound">x</a> <a id="1976" class="Symbol">;</a> <a id="1978" class="Symbol">(</a><a data-type="B → A ⊎ B" id="1979" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="1983" href="Data.Sum.html#1983" class="Bound">x</a><a id="1984" class="Symbol">)</a> <a id="1986" href="Data.Sum.html#1986" class="Bound">i</a> <a id="1988" class="Symbol">→</a> <a id="1990" href="Data.Sum.html#1943" class="Bound">q</a> <a id="1992" href="Data.Sum.html#1986" class="Bound">i</a> <a id="1994" href="Data.Sum.html#1983" class="Bound">x</a> <a id="1996" class="Symbol">}</a>
</pre>
<p>We also have the following <strong>eta law</strong>. In general, eta laws relate the <em>introduction</em> forms with the <em>elimination</em> forms. The most familiar eta law is the one for functions: <code>λ x → (f x)</code> is the same as <code>f</code>. In agda, the eta law for functions requires no proof, it holds by definition. However, the same cannot be said for sum types, so we prove it here.</p>
<pre class="Agda"><a id="[]-η"></a><a data-type="(x : A ⊎ B) → [ inl , inr ] x ≡ x" id="2368" href="Data.Sum.html#2368" class="Function">[]-η</a> <a id="2373" class="Symbol">:</a> <a id="2375" class="Symbol">∀</a> <a id="2377" class="Symbol">(</a><a id="2378" href="Data.Sum.html#2378" class="Bound">x</a> <a id="2380" class="Symbol">:</a> <a id="2382" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="2384" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="2386" href="Data.Sum.html#760" class="Generalizable">B</a><a id="2387" class="Symbol">)</a> <a id="2389" class="Symbol">→</a> <a data-type="(A → C) → (B → C) → A ⊎ B → C" id="2391" href="Data.Sum.html#1511" class="Function Operator">[</a> <a data-type="A → A ⊎ B" id="2393" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a data-type="(A → C) → (B → C) → A ⊎ B → C" id="2397" href="Data.Sum.html#1511" class="Function Operator">,</a> <a data-type="B → A ⊎ B" id="2399" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a data-type="(A → C) → (B → C) → A ⊎ B → C" id="2403" href="Data.Sum.html#1511" class="Function Operator">]</a> <a id="2405" href="Data.Sum.html#2378" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="2407" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="2409" href="Data.Sum.html#2378" class="Bound">x</a>
<a data-type="(x : A ⊎ B) → [ inl , inr ] x ≡ x" id="2411" href="Data.Sum.html#2368" class="Function">[]-η</a> <a id="2416" class="Symbol">(</a><a data-type="A → A ⊎ B" id="2417" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="2421" href="Data.Sum.html#2421" class="Bound">x</a><a id="2422" class="Symbol">)</a> <a id="2424" class="Symbol">=</a> <a data-type="x ≡ x" id="2426" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x : A ⊎ B) → [ inl , inr ] x ≡ x" id="2431" href="Data.Sum.html#2368" class="Function">[]-η</a> <a id="2436" class="Symbol">(</a><a data-type="B → A ⊎ B" id="2437" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="2441" href="Data.Sum.html#2441" class="Bound">x</a><a id="2442" class="Symbol">)</a> <a id="2444" class="Symbol">=</a> <a data-type="x ≡ x" id="2446" href="1Lab.Path.html#2137" class="Function">refl</a>
</pre>
<p>This universal property can be strengthened to characterising the space of <em>dependent functions</em> out of the disjoint union: A dependent function <code>(x : A ⊎ B) → P x</code> is the product of functions covering the left and right cases.</p>
<pre class="Agda"><a id="⊎-universal"></a><a data-type="((x : A ⊎ B) → C x) ≃
(((x : A) → C (inl x)) × ((y : B) → C (inr y)))" id="2693" href="Data.Sum.html#2693" class="Function">⊎-universal</a> <a id="2705" class="Symbol">:</a> <a id="2707" class="Symbol">∀</a> <a id="2709" class="Symbol">{</a><a id="2710" href="Data.Sum.html#2710" class="Bound">A</a> <a id="2712" class="Symbol">:</a> <a id="2714" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2719" href="Data.Sum.html#740" class="Generalizable">a</a><a id="2720" class="Symbol">}</a> <a id="2722" class="Symbol">{</a><a id="2723" href="Data.Sum.html#2723" class="Bound">B</a> <a id="2725" class="Symbol">:</a> <a id="2727" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2732" href="Data.Sum.html#742" class="Generalizable">b</a><a id="2733" class="Symbol">}</a> <a id="2735" class="Symbol">{</a><a id="2736" href="Data.Sum.html#2736" class="Bound">C</a> <a id="2738" class="Symbol">:</a> <a id="2740" href="Data.Sum.html#2710" class="Bound">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="2742" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="2744" href="Data.Sum.html#2723" class="Bound">B</a> <a id="2746" class="Symbol">→</a> <a id="2748" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2753" href="Data.Sum.html#744" class="Generalizable">c</a><a id="2754" class="Symbol">}</a>
            <a id="2768" class="Symbol">→</a> <a id="2770" class="Symbol">((</a><a id="2772" href="Data.Sum.html#2772" class="Bound">x</a> <a id="2774" class="Symbol">:</a> <a id="2776" href="Data.Sum.html#2710" class="Bound">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="2778" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="2780" href="Data.Sum.html#2723" class="Bound">B</a><a id="2781" class="Symbol">)</a> <a id="2783" class="Symbol">→</a> <a id="2785" href="Data.Sum.html#2736" class="Bound">C</a> <a id="2787" href="Data.Sum.html#2772" class="Bound">x</a><a id="2788" class="Symbol">)</a>
            <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="2802" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="2804" class="Symbol">(</a> <a id="2806" class="Symbol">((</a><a id="2808" href="Data.Sum.html#2808" class="Bound">x</a> <a id="2810" class="Symbol">:</a> <a id="2812" href="Data.Sum.html#2710" class="Bound">A</a><a id="2813" class="Symbol">)</a> <a id="2815" class="Symbol">→</a> <a id="2817" href="Data.Sum.html#2736" class="Bound">C</a> <a id="2819" class="Symbol">(</a><a data-type="A → A ⊎ B" id="2820" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="2824" href="Data.Sum.html#2808" class="Bound">x</a><a id="2825" class="Symbol">))</a>
              <a data-type="Type a → Type b → Type (a ⊔ b)" id="2842" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="2844" class="Symbol">((</a><a id="2846" href="Data.Sum.html#2846" class="Bound">y</a> <a id="2848" class="Symbol">:</a> <a id="2850" href="Data.Sum.html#2723" class="Bound">B</a><a id="2851" class="Symbol">)</a> <a id="2853" class="Symbol">→</a> <a id="2855" href="Data.Sum.html#2736" class="Bound">C</a> <a id="2857" class="Symbol">(</a><a data-type="B → A ⊎ B" id="2858" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="2862" href="Data.Sum.html#2846" class="Bound">y</a><a id="2863" class="Symbol">)))</a>
<a data-type="((x : A ⊎ B) → C x) ≃
(((x : A) → C (inl x)) × ((y : B) → C (inr y)))" id="2867" href="Data.Sum.html#2693" class="Function">⊎-universal</a> <a id="2879" class="Symbol">{</a><a id="2880" class="Argument">A</a> <a id="2882" class="Symbol">=</a> <a id="2884" href="Data.Sum.html#2884" class="Bound">A</a><a id="2885" class="Symbol">}</a> <a id="2887" class="Symbol">{</a><a id="2888" href="Data.Sum.html#2888" class="Bound">B</a><a id="2889" class="Symbol">}</a> <a id="2891" class="Symbol">{</a><a id="2892" href="Data.Sum.html#2892" class="Bound">P</a><a id="2893" class="Symbol">}</a> <a id="2895" class="Symbol">=</a> <a data-type="Iso A B → A ≃ B" id="2897" href="1Lab.Equiv.html#20090" class="Function">Iso→Equiv</a> <a id="2907" href="Data.Sum.html#2923" class="Function">the-iso</a> <a id="2915" class="Keyword">where</a>
  <a id="2923" href="Data.Sum.html#2923" class="Function">the-iso</a> <a id="2931" class="Symbol">:</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="2933" href="1Lab.Equiv.html#6241" class="Function">Iso</a> <a id="2937" class="Symbol">_</a> <a id="2939" class="Symbol">_</a>
</pre>
<p>For “splitting” a dependent function from the coproduct, we can compose it with either of the constructors to restrict to a function on that factor:</p>
<pre class="Agda">  <a id="3106" href="Data.Sum.html#2923" class="Function">the-iso</a> <a id="3114" class="Symbol">.</a><a data-type="∑ A B → A" id="3115" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="3119" href="Data.Sum.html#3119" class="Bound">f</a> <a id="3121" class="Symbol">=</a> <a id="3123" class="Symbol">(λ</a> <a id="3126" href="Data.Sum.html#3126" class="Bound">x</a> <a id="3128" class="Symbol">→</a> <a id="3130" href="Data.Sum.html#3119" class="Bound">f</a> <a id="3132" class="Symbol">(</a><a data-type="A → A ⊎ B" id="3133" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="3137" href="Data.Sum.html#3126" class="Bound">x</a><a id="3138" class="Symbol">))</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="3141" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3143" class="Symbol">(λ</a> <a id="3146" href="Data.Sum.html#3146" class="Bound">x</a> <a id="3148" class="Symbol">→</a> <a id="3150" href="Data.Sum.html#3119" class="Bound">f</a> <a id="3152" class="Symbol">(</a><a data-type="B → A ⊎ B" id="3153" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="3157" href="Data.Sum.html#3146" class="Bound">x</a><a id="3158" class="Symbol">))</a>
</pre>
<p>Similarly, given a pair of functions, we can do a case split on the coproduct to decide which function to apply:</p>
<pre class="Agda">  <a id="3290" href="Data.Sum.html#2923" class="Function">the-iso</a> <a id="3298" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="3299" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="3303" class="Symbol">.</a><a data-type="isIso f → B → A" id="3304" href="1Lab.Equiv.html#6080" class="Field">isIso.inv</a> <a id="3314" class="Symbol">(</a><a id="3315" href="Data.Sum.html#3315" class="Bound">f</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="3317" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3319" href="Data.Sum.html#3319" class="Bound">g</a><a id="3320" class="Symbol">)</a> <a id="3322" class="Symbol">(</a><a data-type="A → A ⊎ B" id="3323" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="3327" href="Data.Sum.html#3327" class="Bound">x</a><a id="3328" class="Symbol">)</a> <a id="3330" class="Symbol">=</a> <a id="3332" href="Data.Sum.html#3315" class="Bound">f</a> <a id="3334" href="Data.Sum.html#3327" class="Bound">x</a>
  <a id="3338" href="Data.Sum.html#2923" class="Function">the-iso</a> <a id="3346" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="3347" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="3351" class="Symbol">.</a><a data-type="isIso f → B → A" id="3352" href="1Lab.Equiv.html#6080" class="Field">isIso.inv</a> <a id="3362" class="Symbol">(</a><a id="3363" href="Data.Sum.html#3363" class="Bound">f</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="3365" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3367" href="Data.Sum.html#3367" class="Bound">g</a><a id="3368" class="Symbol">)</a> <a id="3370" class="Symbol">(</a><a data-type="B → A ⊎ B" id="3371" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="3375" href="Data.Sum.html#3375" class="Bound">x</a><a id="3376" class="Symbol">)</a> <a id="3378" class="Symbol">=</a> <a id="3380" href="Data.Sum.html#3367" class="Bound">g</a> <a id="3382" href="Data.Sum.html#3375" class="Bound">x</a>

  <a id="3387" href="Data.Sum.html#2923" class="Function">the-iso</a> <a id="3395" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="3396" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="3400" class="Symbol">.</a><a data-type="(r : isIso f) → isRightInverse (r .inv) f" id="3401" href="1Lab.Equiv.html#6096" class="Field">isIso.rinv</a> <a id="3412" href="Data.Sum.html#3412" class="Bound">x</a> <a id="3414" class="Symbol">=</a> <a data-type="x ≡ x" id="3416" href="1Lab.Path.html#2137" class="Function">refl</a>
  <a id="3423" href="Data.Sum.html#2923" class="Function">the-iso</a> <a id="3431" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="3432" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="3436" class="Symbol">.</a><a data-type="(r : isIso f) → isLeftInverse (r .inv) f" id="3437" href="1Lab.Equiv.html#6128" class="Field">isIso.linv</a> <a id="3448" href="Data.Sum.html#3448" class="Bound">f</a> <a id="3450" href="Data.Sum.html#3450" class="Bound">i</a> <a id="3452" class="Symbol">(</a><a data-type="A → A ⊎ B" id="3453" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="3457" href="Data.Sum.html#3457" class="Bound">x</a><a id="3458" class="Symbol">)</a> <a id="3460" class="Symbol">=</a> <a id="3462" href="Data.Sum.html#3448" class="Bound">f</a> <a id="3464" class="Symbol">(</a><a data-type="A → A ⊎ B" id="3465" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="3469" href="Data.Sum.html#3457" class="Bound">x</a><a id="3470" class="Symbol">)</a>
  <a id="3474" href="Data.Sum.html#2923" class="Function">the-iso</a> <a id="3482" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="3483" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="3487" class="Symbol">.</a><a data-type="(r : isIso f) → isLeftInverse (r .inv) f" id="3488" href="1Lab.Equiv.html#6128" class="Field">isIso.linv</a> <a id="3499" href="Data.Sum.html#3499" class="Bound">f</a> <a id="3501" href="Data.Sum.html#3501" class="Bound">i</a> <a id="3503" class="Symbol">(</a><a data-type="B → A ⊎ B" id="3504" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="3508" href="Data.Sum.html#3508" class="Bound">x</a><a id="3509" class="Symbol">)</a> <a id="3511" class="Symbol">=</a> <a id="3513" href="Data.Sum.html#3499" class="Bound">f</a> <a id="3515" class="Symbol">(</a><a data-type="B → A ⊎ B" id="3516" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="3520" href="Data.Sum.html#3508" class="Bound">x</a><a id="3521" class="Symbol">)</a>
</pre>
<h2 id="transformations"><a href="#transformations" class="header-link">Transformations<span class="header-link-emoji">🔗</span></a></h2>
<p>Let’s move away from the abstract nonsense of universal properties for a bit, and cleanse our pallate with some small helper functions for mapping between sum types.</p>
<pre class="Agda"><a id="⊎-map"></a><a data-type="(A → C) → (B → D) → A ⊎ B → C ⊎ D" id="3723" href="Data.Sum.html#3723" class="Function">⊎-map</a> <a id="3729" class="Symbol">:</a> <a id="3731" class="Symbol">(</a><a id="3732" href="Data.Sum.html#758" class="Generalizable">A</a> <a id="3734" class="Symbol">→</a> <a id="3736" href="Data.Sum.html#762" class="Generalizable">C</a><a id="3737" class="Symbol">)</a> <a id="3739" class="Symbol">→</a> <a id="3741" class="Symbol">(</a><a id="3742" href="Data.Sum.html#760" class="Generalizable">B</a> <a id="3744" class="Symbol">→</a> <a id="3746" href="Data.Sum.html#764" class="Generalizable">D</a><a id="3747" class="Symbol">)</a> <a id="3749" class="Symbol">→</a> <a id="3751" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="3753" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="3755" href="Data.Sum.html#760" class="Generalizable">B</a> <a id="3757" class="Symbol">→</a> <a id="3759" href="Data.Sum.html#762" class="Generalizable">C</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="3761" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="3763" href="Data.Sum.html#764" class="Generalizable">D</a>
<a data-type="(A → C) → (B → D) → A ⊎ B → C ⊎ D" id="3765" href="Data.Sum.html#3723" class="Function">⊎-map</a> <a id="3771" href="Data.Sum.html#3771" class="Bound">f</a> <a id="3773" href="Data.Sum.html#3773" class="Bound">g</a> <a id="3775" class="Symbol">(</a><a data-type="A → A ⊎ B" id="3776" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="3780" href="Data.Sum.html#3780" class="Bound">a</a><a id="3781" class="Symbol">)</a> <a id="3783" class="Symbol">=</a> <a data-type="A → A ⊎ B" id="3785" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="3789" class="Symbol">(</a><a id="3790" href="Data.Sum.html#3771" class="Bound">f</a> <a id="3792" href="Data.Sum.html#3780" class="Bound">a</a><a id="3793" class="Symbol">)</a>
<a data-type="(A → C) → (B → D) → A ⊎ B → C ⊎ D" id="3795" href="Data.Sum.html#3723" class="Function">⊎-map</a> <a id="3801" href="Data.Sum.html#3801" class="Bound">f</a> <a id="3803" href="Data.Sum.html#3803" class="Bound">g</a> <a id="3805" class="Symbol">(</a><a data-type="B → A ⊎ B" id="3806" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="3810" href="Data.Sum.html#3810" class="Bound">b</a><a id="3811" class="Symbol">)</a> <a id="3813" class="Symbol">=</a> <a data-type="B → A ⊎ B" id="3815" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="3819" class="Symbol">(</a><a id="3820" href="Data.Sum.html#3803" class="Bound">g</a> <a id="3822" href="Data.Sum.html#3810" class="Bound">b</a><a id="3823" class="Symbol">)</a>

<a id="⊎-mapl"></a><a data-type="(A → C) → A ⊎ B → C ⊎ B" id="3826" href="Data.Sum.html#3826" class="Function">⊎-mapl</a> <a id="3833" class="Symbol">:</a> <a id="3835" class="Symbol">(</a><a id="3836" href="Data.Sum.html#758" class="Generalizable">A</a> <a id="3838" class="Symbol">→</a> <a id="3840" href="Data.Sum.html#762" class="Generalizable">C</a><a id="3841" class="Symbol">)</a> <a id="3843" class="Symbol">→</a> <a id="3845" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="3847" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="3849" href="Data.Sum.html#760" class="Generalizable">B</a> <a id="3851" class="Symbol">→</a> <a id="3853" href="Data.Sum.html#762" class="Generalizable">C</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="3855" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="3857" href="Data.Sum.html#760" class="Generalizable">B</a>
<a data-type="(A → C) → A ⊎ B → C ⊎ B" id="3859" href="Data.Sum.html#3826" class="Function">⊎-mapl</a> <a id="3866" href="Data.Sum.html#3866" class="Bound">f</a> <a id="3868" class="Symbol">=</a> <a data-type="(A → C) → (B → D) → A ⊎ B → C ⊎ D" id="3870" href="Data.Sum.html#3723" class="Function">⊎-map</a> <a id="3876" href="Data.Sum.html#3866" class="Bound">f</a> <a data-type="A → A" id="3878" href="1Lab.Type.html#2348" class="Function">id</a>

<a id="⊎-mapr"></a><a data-type="(B → C) → A ⊎ B → A ⊎ C" id="3882" href="Data.Sum.html#3882" class="Function">⊎-mapr</a> <a id="3889" class="Symbol">:</a> <a id="3891" class="Symbol">(</a><a id="3892" href="Data.Sum.html#760" class="Generalizable">B</a> <a id="3894" class="Symbol">→</a> <a id="3896" href="Data.Sum.html#762" class="Generalizable">C</a><a id="3897" class="Symbol">)</a> <a id="3899" class="Symbol">→</a> <a id="3901" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="3903" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="3905" href="Data.Sum.html#760" class="Generalizable">B</a> <a id="3907" class="Symbol">→</a> <a id="3909" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="3911" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="3913" href="Data.Sum.html#762" class="Generalizable">C</a>
<a data-type="(B → C) → A ⊎ B → A ⊎ C" id="3915" href="Data.Sum.html#3882" class="Function">⊎-mapr</a> <a id="3922" href="Data.Sum.html#3922" class="Bound">f</a> <a id="3924" class="Symbol">=</a> <a data-type="(A → C) → (B → D) → A ⊎ B → C ⊎ D" id="3926" href="Data.Sum.html#3723" class="Function">⊎-map</a> <a data-type="A → A" id="3932" href="1Lab.Type.html#2348" class="Function">id</a> <a id="3935" href="Data.Sum.html#3922" class="Bound">f</a>
</pre>
<h2 id="decidablity"><a href="#decidablity" class="header-link">Decidablity<span class="header-link-emoji">🔗</span></a></h2>
<p>This type has a very similar structure to <a data-type="Type ℓ → Type ℓ" href="1Lab.Type.Dec.html#197">Dec</a>, so we provide some helpers to convert between the two.</p>
<pre class="Agda"><a id="from-dec"></a><a data-type="Dec A → A ⊎ (A → ⊥)" id="4097" href="Data.Sum.html#4097" class="Function">from-dec</a> <a id="4106" class="Symbol">:</a> <a data-type="Type ℓ → Type ℓ" id="4108" href="1Lab.Type.Dec.html#197" class="Datatype">Dec</a> <a id="4112" href="Data.Sum.html#758" class="Generalizable">A</a> <a id="4114" class="Symbol">→</a> <a id="4116" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="4118" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="4120" class="Symbol">(</a><a id="4121" href="Data.Sum.html#758" class="Generalizable">A</a> <a id="4123" class="Symbol">→</a> <a data-type="Type" id="4125" href="1Lab.Type.html#1326" class="Datatype">⊥</a><a id="4126" class="Symbol">)</a>
<a data-type="Dec A → A ⊎ (A → ⊥)" id="4128" href="Data.Sum.html#4097" class="Function">from-dec</a> <a id="4137" class="Symbol">(</a><a data-type="A → Dec A" id="4138" href="1Lab.Type.Dec.html#235" class="InductiveConstructor">yes</a> <a id="4142" href="Data.Sum.html#4142" class="Bound">a</a><a id="4143" class="Symbol">)</a> <a id="4145" class="Symbol">=</a> <a data-type="A → A ⊎ B" id="4147" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="4151" href="Data.Sum.html#4142" class="Bound">a</a>
<a data-type="Dec A → A ⊎ (A → ⊥)" id="4153" href="Data.Sum.html#4097" class="Function">from-dec</a> <a id="4162" class="Symbol">(</a><a data-type="(A → ⊥) → Dec A" id="4163" href="1Lab.Type.Dec.html#253" class="InductiveConstructor">no</a> <a id="4166" href="Data.Sum.html#4166" class="Bound">¬a</a><a id="4168" class="Symbol">)</a> <a id="4170" class="Symbol">=</a> <a data-type="B → A ⊎ B" id="4172" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="4176" href="Data.Sum.html#4166" class="Bound">¬a</a>

<a id="to-dec"></a><a data-type="A ⊎ (A → ⊥) → Dec A" id="4180" href="Data.Sum.html#4180" class="Function">to-dec</a> <a id="4187" class="Symbol">:</a> <a id="4189" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="4191" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="4193" class="Symbol">(</a><a id="4194" href="Data.Sum.html#758" class="Generalizable">A</a> <a id="4196" class="Symbol">→</a> <a data-type="Type" id="4198" href="1Lab.Type.html#1326" class="Datatype">⊥</a><a id="4199" class="Symbol">)</a> <a id="4201" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="4203" href="1Lab.Type.Dec.html#197" class="Datatype">Dec</a> <a id="4207" href="Data.Sum.html#758" class="Generalizable">A</a>
<a data-type="A ⊎ (A → ⊥) → Dec A" id="4209" href="Data.Sum.html#4180" class="Function">to-dec</a> <a id="4216" class="Symbol">(</a><a data-type="A → A ⊎ B" id="4217" href="Data.Sum.html#670" class="InductiveConstructor">inl</a>  <a id="4222" href="Data.Sum.html#4222" class="Bound">a</a><a id="4223" class="Symbol">)</a> <a id="4225" class="Symbol">=</a> <a data-type="A → Dec A" id="4227" href="1Lab.Type.Dec.html#235" class="InductiveConstructor">yes</a> <a id="4231" href="Data.Sum.html#4222" class="Bound">a</a>
<a data-type="A ⊎ (A → ⊥) → Dec A" id="4233" href="Data.Sum.html#4180" class="Function">to-dec</a> <a id="4240" class="Symbol">(</a><a data-type="B → A ⊎ B" id="4241" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="4245" href="Data.Sum.html#4245" class="Bound">¬a</a><a id="4247" class="Symbol">)</a> <a id="4249" class="Symbol">=</a> <a data-type="(A → ⊥) → Dec A" id="4251" href="1Lab.Type.Dec.html#253" class="InductiveConstructor">no</a> <a id="4254" href="Data.Sum.html#4245" class="Bound">¬a</a>
</pre>
<p>The proof that these functions are inverses is automatic by computation, and thus it can be shown they are equivalences:</p>
<pre class="Agda"><a id="isEquiv-from-dec"></a><a data-type="isEquiv from-dec" id="4392" href="Data.Sum.html#4392" class="Function">isEquiv-from-dec</a> <a id="4409" class="Symbol">:</a> <a id="4411" class="Symbol">{</a><a id="4412" href="Data.Sum.html#4412" class="Bound">A</a> <a id="4414" class="Symbol">:</a> <a id="4416" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="4421" href="Data.Sum.html#740" class="Generalizable">a</a><a id="4422" class="Symbol">}</a> <a id="4424" class="Symbol">→</a> <a data-type="(f : A → B) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="4426" href="1Lab.Equiv.html#2293" class="Record">isEquiv</a> <a id="4434" class="Symbol">(</a><a data-type="Dec A → A ⊎ (A → ⊥)" id="4435" href="Data.Sum.html#4097" class="Function">from-dec</a> <a id="4444" class="Symbol">{</a><a id="4445" class="Argument">A</a> <a id="4447" class="Symbol">=</a> <a id="4449" href="Data.Sum.html#4412" class="Bound">A</a><a id="4450" class="Symbol">})</a>
<a data-type="isEquiv from-dec" id="4453" href="Data.Sum.html#4392" class="Function">isEquiv-from-dec</a> <a id="4470" class="Symbol">=</a> <a data-type="(i : isIso f) → isEquiv f" id="4472" href="1Lab.Equiv.html#19765" class="Function">isIso→isEquiv</a> <a id="4486" class="Symbol">(</a><a data-type="(inv : B → A) (rinv₁ : isRightInverse inv f)
(linv₁ : isLeftInverse inv f) →
isIso f" id="4487" href="1Lab.Equiv.html#6064" class="InductiveConstructor">iso</a> <a data-type="A ⊎ (A → ⊥) → Dec A" id="4491" href="Data.Sum.html#4180" class="Function">to-dec</a> <a id="4498" href="Data.Sum.html#4511" class="Function">p</a> <a id="4500" href="Data.Sum.html#4558" class="Function">q</a><a id="4501" class="Symbol">)</a> <a id="4503" class="Keyword">where</a>
  <a id="4511" href="Data.Sum.html#4511" class="Function">p</a> <a id="4513" class="Symbol">:</a> <a id="4515" class="Symbol">_</a>
  <a id="4519" href="Data.Sum.html#4511" class="Function">p</a> <a id="4521" class="Symbol">(</a><a data-type="A → A ⊎ B" id="4522" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="4526" href="Data.Sum.html#4526" class="Bound">x</a><a id="4527" class="Symbol">)</a> <a id="4529" class="Symbol">=</a> <a data-type="x ≡ x" id="4531" href="1Lab.Path.html#2137" class="Function">refl</a>
  <a id="4538" href="Data.Sum.html#4511" class="Function">p</a> <a id="4540" class="Symbol">(</a><a data-type="B → A ⊎ B" id="4541" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="4545" href="Data.Sum.html#4545" class="Bound">x</a><a id="4546" class="Symbol">)</a> <a id="4548" class="Symbol">=</a> <a data-type="x ≡ x" id="4550" href="1Lab.Path.html#2137" class="Function">refl</a>

  <a id="4558" href="Data.Sum.html#4558" class="Function">q</a> <a id="4560" class="Symbol">:</a> <a id="4562" class="Symbol">_</a>
  <a id="4566" href="Data.Sum.html#4558" class="Function">q</a> <a id="4568" class="Symbol">(</a><a data-type="A → Dec A" id="4569" href="1Lab.Type.Dec.html#235" class="InductiveConstructor">yes</a> <a id="4573" href="Data.Sum.html#4573" class="Bound">x</a><a id="4574" class="Symbol">)</a> <a id="4576" class="Symbol">=</a> <a data-type="x ≡ x" id="4578" href="1Lab.Path.html#2137" class="Function">refl</a>
  <a id="4585" href="Data.Sum.html#4558" class="Function">q</a> <a id="4587" class="Symbol">(</a><a data-type="(A → ⊥) → Dec A" id="4588" href="1Lab.Type.Dec.html#253" class="InductiveConstructor">no</a> <a id="4591" href="Data.Sum.html#4591" class="Bound">x</a><a id="4592" class="Symbol">)</a> <a id="4594" class="Symbol">=</a> <a data-type="x ≡ x" id="4596" href="1Lab.Path.html#2137" class="Function">refl</a>
</pre>
<h2 id="closure-under-h-levels"><a href="#closure-under-h-levels" class="header-link">Closure under h-levels<span class="header-link-emoji">🔗</span></a></h2>
<p>If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>

 and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>

 are <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>

-types,</span> for <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n \ge 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>

,</span> then so is their coproduct. The way we prove this is by characterising the entire path space of <code>A ⊎ B</code> in terms of the path spaces for <code>A</code> and <code>B</code>, using a recursive definition:</p>
<pre class="Agda"><a id="4866" class="Keyword">module</a> <a id="⊎Path"></a><a id="4873" href="Data.Sum.html#4873" class="Module">⊎Path</a> <a id="4879" class="Keyword">where</a>
  <a id="⊎Path.Code"></a><a data-type="A ⊎ B → A ⊎ B → Type (A.a ⊔ B.a)" id="4887" href="Data.Sum.html#4887" class="Function">Code</a> <a id="4892" class="Symbol">:</a> <a id="4894" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="4896" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="4898" href="Data.Sum.html#760" class="Generalizable">B</a> <a id="4900" class="Symbol">→</a> <a id="4902" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="4904" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="4906" href="Data.Sum.html#760" class="Generalizable">B</a> <a id="4908" class="Symbol">→</a> <a id="4910" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="4915" class="Symbol">(</a><a data-type="Type ℓ → Level" id="4916" href="1Lab.Type.html#924" class="Function">level-of</a> <a id="4925" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Level → Level → Level" id="4927" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a data-type="Type ℓ → Level" id="4929" href="1Lab.Type.html#924" class="Function">level-of</a> <a id="4938" href="Data.Sum.html#760" class="Generalizable">B</a><a id="4939" class="Symbol">)</a>
  <a data-type="A ⊎ B → A ⊎ B → Type (A.a ⊔ B.a)" id="4943" href="Data.Sum.html#4887" class="Function">Code</a> <a id="4948" class="Symbol">{</a><a id="4949" class="Argument">B</a> <a id="4951" class="Symbol">=</a> <a id="4953" href="Data.Sum.html#4953" class="Bound">B</a><a id="4954" class="Symbol">}</a> <a id="4956" class="Symbol">(</a><a data-type="A → A ⊎ B" id="4957" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="4961" href="Data.Sum.html#4961" class="Bound">x</a><a id="4962" class="Symbol">)</a> <a id="4964" class="Symbol">(</a><a data-type="A → A ⊎ B" id="4965" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="4969" href="Data.Sum.html#4969" class="Bound">y</a><a id="4970" class="Symbol">)</a> <a id="4972" class="Symbol">=</a> <a data-type="(ℓ : Level) (A : Type a) → Type (a ⊔ ℓ)" id="4974" href="1Lab.Type.html#2006" class="Record">Lift</a> <a id="4979" class="Symbol">(</a><a data-type="Type ℓ → Level" id="4980" href="1Lab.Type.html#924" class="Function">level-of</a> <a id="4989" href="Data.Sum.html#4953" class="Bound">B</a><a id="4990" class="Symbol">)</a> <a id="4992" class="Symbol">(</a><a id="4993" href="Data.Sum.html#4961" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="4995" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="4997" href="Data.Sum.html#4969" class="Bound">y</a><a id="4998" class="Symbol">)</a>
  <a data-type="A ⊎ B → A ⊎ B → Type (A.a ⊔ B.a)" id="5002" href="Data.Sum.html#4887" class="Function">Code</a> <a id="5007" class="Symbol">(</a><a data-type="A → A ⊎ B" id="5008" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="5012" href="Data.Sum.html#5012" class="Bound">x</a><a id="5013" class="Symbol">)</a> <a id="5015" class="Symbol">(</a><a data-type="B → A ⊎ B" id="5016" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="5020" href="Data.Sum.html#5020" class="Bound">y</a><a id="5021" class="Symbol">)</a> <a id="5023" class="Symbol">=</a> <a data-type="(ℓ : Level) (A : Type a) → Type (a ⊔ ℓ)" id="5025" href="1Lab.Type.html#2006" class="Record">Lift</a> <a id="5030" class="Symbol">_</a> <a data-type="Type" id="5032" href="1Lab.Type.html#1326" class="Datatype">⊥</a>
  <a data-type="A ⊎ B → A ⊎ B → Type (A.a ⊔ B.a)" id="5036" href="Data.Sum.html#4887" class="Function">Code</a> <a id="5041" class="Symbol">(</a><a data-type="B → A ⊎ B" id="5042" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="5046" href="Data.Sum.html#5046" class="Bound">x</a><a id="5047" class="Symbol">)</a> <a id="5049" class="Symbol">(</a><a data-type="A → A ⊎ B" id="5050" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="5054" href="Data.Sum.html#5054" class="Bound">y</a><a id="5055" class="Symbol">)</a> <a id="5057" class="Symbol">=</a> <a data-type="(ℓ : Level) (A : Type a) → Type (a ⊔ ℓ)" id="5059" href="1Lab.Type.html#2006" class="Record">Lift</a> <a id="5064" class="Symbol">_</a> <a data-type="Type" id="5066" href="1Lab.Type.html#1326" class="Datatype">⊥</a>
  <a data-type="A ⊎ B → A ⊎ B → Type (A.a ⊔ B.a)" id="5070" href="Data.Sum.html#4887" class="Function">Code</a> <a id="5075" class="Symbol">{</a><a id="5076" class="Argument">A</a> <a id="5078" class="Symbol">=</a> <a id="5080" href="Data.Sum.html#5080" class="Bound">A</a><a id="5081" class="Symbol">}</a> <a id="5083" class="Symbol">(</a><a data-type="B → A ⊎ B" id="5084" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="5088" href="Data.Sum.html#5088" class="Bound">x</a><a id="5089" class="Symbol">)</a> <a id="5091" class="Symbol">(</a><a data-type="B → A ⊎ B" id="5092" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="5096" href="Data.Sum.html#5096" class="Bound">y</a><a id="5097" class="Symbol">)</a> <a id="5099" class="Symbol">=</a> <a data-type="(ℓ : Level) (A : Type a) → Type (a ⊔ ℓ)" id="5101" href="1Lab.Type.html#2006" class="Record">Lift</a> <a id="5106" class="Symbol">(</a><a data-type="Type ℓ → Level" id="5107" href="1Lab.Type.html#924" class="Function">level-of</a> <a id="5116" href="Data.Sum.html#5080" class="Bound">A</a><a id="5117" class="Symbol">)</a> <a id="5119" class="Symbol">(</a><a id="5120" href="Data.Sum.html#5088" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="5122" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="5124" href="Data.Sum.html#5096" class="Bound">y</a><a id="5125" class="Symbol">)</a>
</pre>
<p>Given a <span class="Agda"><a data-type="A ⊎ B → A ⊎ B → Type (A.a ⊔ B.a)" href="Data.Sum.html#4887" class="Function">Code</a></span> for a path in <code>A ⊎ B</code>, we can turn it into a legitimate equality. Agda automatically lets us ignore the cases where the <span class="Agda"><a data-type="A ⊎ B → A ⊎ B → Type (A.a ⊔ B.a)" href="Data.Sum.html#4887" class="Function">Code</a></span> computes to <span class="Agda"><a data-type="Type" href="1Lab.Type.html#1326" class="Datatype">the empty type</a></span>.</p>
<pre class="Agda">  <a id="⊎Path.decode"></a><a data-type="Code x y → x ≡ y" id="5344" href="Data.Sum.html#5344" class="Function">decode</a> <a id="5351" class="Symbol">:</a> <a id="5353" class="Symbol">{</a><a id="5354" href="Data.Sum.html#5354" class="Bound">x</a> <a id="5356" href="Data.Sum.html#5356" class="Bound">y</a> <a id="5358" class="Symbol">:</a> <a id="5360" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="5362" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="5364" href="Data.Sum.html#760" class="Generalizable">B</a><a id="5365" class="Symbol">}</a> <a id="5367" class="Symbol">→</a> <a data-type="A ⊎ B → A ⊎ B → Type (A.a ⊔ B.a)" id="5369" href="Data.Sum.html#4887" class="Function">Code</a> <a id="5374" href="Data.Sum.html#5354" class="Bound">x</a> <a id="5376" href="Data.Sum.html#5356" class="Bound">y</a> <a id="5378" class="Symbol">→</a> <a id="5380" href="Data.Sum.html#5354" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="5382" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="5384" href="Data.Sum.html#5356" class="Bound">y</a>
  <a data-type="Code x y → x ≡ y" id="5388" href="Data.Sum.html#5344" class="Function">decode</a> <a id="5395" class="Symbol">{</a><a id="5396" class="Argument">x</a> <a id="5398" class="Symbol">=</a> <a data-type="A → A ⊎ B" id="5400" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="5404" href="Data.Sum.html#5404" class="Bound">x</a><a id="5405" class="Symbol">}</a> <a id="5407" class="Symbol">{</a><a id="5408" class="Argument">y</a> <a id="5410" class="Symbol">=</a> <a data-type="A → A ⊎ B" id="5412" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="5416" href="Data.Sum.html#5416" class="Bound">x₁</a><a id="5418" class="Symbol">}</a> <a id="5420" href="Data.Sum.html#5420" class="Bound">code</a> <a id="5425" class="Symbol">=</a> <a data-type="(f : (x : A) → B x) (p : x ≡ y) → PathP (λ i → B (p i)) (f x) (f y)" id="5427" href="1Lab.Path.html#19262" class="Function">ap</a> <a data-type="A → A ⊎ B" id="5430" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="5434" class="Symbol">(</a><a data-type="Lift ℓ A → A" id="5435" href="1Lab.Type.html#2082" class="Field">Lift.lower</a> <a id="5446" href="Data.Sum.html#5420" class="Bound">code</a><a id="5450" class="Symbol">)</a>
  <a data-type="Code x y → x ≡ y" id="5454" href="Data.Sum.html#5344" class="Function">decode</a> <a id="5461" class="Symbol">{</a><a id="5462" class="Argument">x</a> <a id="5464" class="Symbol">=</a> <a data-type="B → A ⊎ B" id="5466" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="5470" href="Data.Sum.html#5470" class="Bound">x</a><a id="5471" class="Symbol">}</a> <a id="5473" class="Symbol">{</a><a id="5474" class="Argument">y</a> <a id="5476" class="Symbol">=</a> <a data-type="B → A ⊎ B" id="5478" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="5482" href="Data.Sum.html#5482" class="Bound">x₁</a><a id="5484" class="Symbol">}</a> <a id="5486" href="Data.Sum.html#5486" class="Bound">code</a> <a id="5491" class="Symbol">=</a> <a data-type="(f : (x : A) → B x) (p : x ≡ y) → PathP (λ i → B (p i)) (f x) (f y)" id="5493" href="1Lab.Path.html#19262" class="Function">ap</a> <a data-type="B → A ⊎ B" id="5496" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="5500" class="Symbol">(</a><a data-type="Lift ℓ A → A" id="5501" href="1Lab.Type.html#2082" class="Field">Lift.lower</a> <a id="5512" href="Data.Sum.html#5486" class="Bound">code</a><a id="5516" class="Symbol">)</a>
</pre>
<p>In the inverse direction, we have a procedure for turning equalities into codes:</p>
<pre class="Agda">  <a id="⊎Path.encode"></a><a data-type="x ≡ y → Code x y" id="5615" href="Data.Sum.html#5615" class="Function">encode</a> <a id="5622" class="Symbol">:</a> <a id="5624" class="Symbol">{</a><a id="5625" href="Data.Sum.html#5625" class="Bound">x</a> <a id="5627" href="Data.Sum.html#5627" class="Bound">y</a> <a id="5629" class="Symbol">:</a> <a id="5631" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="5633" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="5635" href="Data.Sum.html#760" class="Generalizable">B</a><a id="5636" class="Symbol">}</a> <a id="5638" class="Symbol">→</a> <a id="5640" href="Data.Sum.html#5625" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="5642" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="5644" href="Data.Sum.html#5627" class="Bound">y</a> <a id="5646" class="Symbol">→</a> <a data-type="A ⊎ B → A ⊎ B → Type (A.a ⊔ B.a)" id="5648" href="Data.Sum.html#4887" class="Function">Code</a> <a id="5653" href="Data.Sum.html#5625" class="Bound">x</a> <a id="5655" href="Data.Sum.html#5627" class="Bound">y</a>
  <a data-type="x ≡ y → Code x y" id="5659" href="Data.Sum.html#5615" class="Function">encode</a> <a id="5666" class="Symbol">{</a><a id="5667" class="Argument">x</a> <a id="5669" class="Symbol">=</a> <a data-type="A → A ⊎ B" id="5671" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="5675" href="Data.Sum.html#5675" class="Bound">x</a><a id="5676" class="Symbol">}</a> <a id="5678" class="Symbol">{</a><a id="5679" class="Argument">y</a> <a id="5681" class="Symbol">=</a> <a data-type="A → A ⊎ B" id="5683" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="5687" href="Data.Sum.html#5687" class="Bound">y</a><a id="5688" class="Symbol">}</a> <a id="5690" href="Data.Sum.html#5690" class="Bound">path</a> <a id="5695" class="Symbol">=</a> <a data-type="(lower : A) → Lift ℓ A" id="5697" href="1Lab.Type.html#2065" class="InductiveConstructor">lift</a> <a id="5702" class="Symbol">(</a><a data-type="inl x ≡ inl y → x ≡ y" id="5703" href="Data.Sum.html#851" class="Function">inl-inj</a> <a id="5711" href="Data.Sum.html#5690" class="Bound">path</a><a id="5715" class="Symbol">)</a>
  <a data-type="x ≡ y → Code x y" id="5719" href="Data.Sum.html#5615" class="Function">encode</a> <a id="5726" class="Symbol">{</a><a id="5727" class="Argument">x</a> <a id="5729" class="Symbol">=</a> <a data-type="A → A ⊎ B" id="5731" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="5735" href="Data.Sum.html#5735" class="Bound">x</a><a id="5736" class="Symbol">}</a> <a id="5738" class="Symbol">{</a><a id="5739" class="Argument">y</a> <a id="5741" class="Symbol">=</a> <a data-type="B → A ⊎ B" id="5743" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="5747" href="Data.Sum.html#5747" class="Bound">y</a><a id="5748" class="Symbol">}</a> <a id="5750" href="Data.Sum.html#5750" class="Bound">path</a> <a id="5755" class="Symbol">=</a> <a data-type="⊥ → A" id="5757" href="1Lab.Type.html#1342" class="Function">absurd</a> <a id="5764" class="Symbol">(</a><a data-type="inl x ≡ inr y → ⊥" id="5765" href="Data.Sum.html#1173" class="Function">⊎-disjoint</a> <a id="5776" href="Data.Sum.html#5750" class="Bound">path</a><a id="5780" class="Symbol">)</a>
  <a data-type="x ≡ y → Code x y" id="5784" href="Data.Sum.html#5615" class="Function">encode</a> <a id="5791" class="Symbol">{</a><a id="5792" class="Argument">x</a> <a id="5794" class="Symbol">=</a> <a data-type="B → A ⊎ B" id="5796" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="5800" href="Data.Sum.html#5800" class="Bound">x</a><a id="5801" class="Symbol">}</a> <a id="5803" class="Symbol">{</a><a id="5804" class="Argument">y</a> <a id="5806" class="Symbol">=</a> <a data-type="A → A ⊎ B" id="5808" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="5812" href="Data.Sum.html#5812" class="Bound">y</a><a id="5813" class="Symbol">}</a> <a id="5815" href="Data.Sum.html#5815" class="Bound">path</a> <a id="5820" class="Symbol">=</a> <a data-type="⊥ → A" id="5822" href="1Lab.Type.html#1342" class="Function">absurd</a> <a id="5829" class="Symbol">(</a><a data-type="inl x ≡ inr y → ⊥" id="5830" href="Data.Sum.html#1173" class="Function">⊎-disjoint</a> <a id="5841" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="5842" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="5846" href="Data.Sum.html#5815" class="Bound">path</a><a id="5850" class="Symbol">))</a>
  <a data-type="x ≡ y → Code x y" id="5855" href="Data.Sum.html#5615" class="Function">encode</a> <a id="5862" class="Symbol">{</a><a id="5863" class="Argument">x</a> <a id="5865" class="Symbol">=</a> <a data-type="B → A ⊎ B" id="5867" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="5871" href="Data.Sum.html#5871" class="Bound">x</a><a id="5872" class="Symbol">}</a> <a id="5874" class="Symbol">{</a><a id="5875" class="Argument">y</a> <a id="5877" class="Symbol">=</a> <a data-type="B → A ⊎ B" id="5879" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="5883" href="Data.Sum.html#5883" class="Bound">y</a><a id="5884" class="Symbol">}</a> <a id="5886" href="Data.Sum.html#5886" class="Bound">path</a> <a id="5891" class="Symbol">=</a> <a data-type="(lower : A) → Lift ℓ A" id="5893" href="1Lab.Type.html#2065" class="InductiveConstructor">lift</a> <a id="5898" class="Symbol">(</a><a data-type="inr x ≡ inr y → x ≡ y" id="5899" href="Data.Sum.html#1012" class="Function">inr-inj</a> <a id="5907" href="Data.Sum.html#5886" class="Bound">path</a><a id="5911" class="Symbol">)</a>
</pre>
<p>Now we must establish that <span class="Agda"><a data-type="x ≡ y → Code x y" href="Data.Sum.html#5615" class="Function">encode</a></span> and <span class="Agda"><a data-type="Code x y → x ≡ y" href="Data.Sum.html#5344" class="Function">decode</a></span> are inverses. In the one direction, we can use path induction:</p>
<pre class="Agda">  <a id="⊎Path.decode-encode"></a><a data-type="(p : x ≡ y) → decode (encode p) ≡ p" id="6055" href="Data.Sum.html#6055" class="Function">decode-encode</a> <a id="6069" class="Symbol">:</a> <a id="6071" class="Symbol">{</a><a id="6072" href="Data.Sum.html#6072" class="Bound">x</a> <a id="6074" href="Data.Sum.html#6074" class="Bound">y</a> <a id="6076" class="Symbol">:</a> <a id="6078" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="6080" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="6082" href="Data.Sum.html#760" class="Generalizable">B</a><a id="6083" class="Symbol">}</a> <a id="6085" class="Symbol">(</a><a id="6086" href="Data.Sum.html#6086" class="Bound">p</a> <a id="6088" class="Symbol">:</a> <a id="6090" href="Data.Sum.html#6072" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="6092" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="6094" href="Data.Sum.html#6074" class="Bound">y</a><a id="6095" class="Symbol">)</a> <a id="6097" class="Symbol">→</a> <a data-type="Code x y → x ≡ y" id="6099" href="Data.Sum.html#5344" class="Function">decode</a> <a id="6106" class="Symbol">(</a><a data-type="x ≡ y → Code x y" id="6107" href="Data.Sum.html#5615" class="Function">encode</a> <a id="6114" href="Data.Sum.html#6086" class="Bound">p</a><a id="6115" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="6117" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="6119" href="Data.Sum.html#6086" class="Bound">p</a>
  <a data-type="(p : x ≡ y) → decode (encode p) ≡ p" id="6123" href="Data.Sum.html#6055" class="Function">decode-encode</a> <a id="6137" class="Symbol">=</a> <a data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" id="6139" href="1Lab.Path.html#18079" class="Function">J</a> <a id="6141" class="Symbol">(λ</a> <a id="6144" href="Data.Sum.html#6144" class="Bound">_</a> <a id="6146" href="Data.Sum.html#6146" class="Bound">p</a> <a id="6148" class="Symbol">→</a> <a data-type="Code x y → x ≡ y" id="6150" href="Data.Sum.html#5344" class="Function">decode</a> <a id="6157" class="Symbol">(</a><a data-type="x ≡ y → Code x y" id="6158" href="Data.Sum.html#5615" class="Function">encode</a> <a id="6165" href="Data.Sum.html#6146" class="Bound">p</a><a id="6166" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="6168" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="6170" href="Data.Sum.html#6146" class="Bound">p</a><a id="6171" class="Symbol">)</a> <a id="6173" href="Data.Sum.html#6192" class="Function">d-e-refl</a> <a id="6182" class="Keyword">where</a>
    <a id="6192" href="Data.Sum.html#6192" class="Function">d-e-refl</a> <a id="6201" class="Symbol">:</a> <a id="6203" class="Symbol">{</a><a id="6204" href="Data.Sum.html#6204" class="Bound">x</a> <a id="6206" class="Symbol">:</a> <a id="6208" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="6210" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="6212" href="Data.Sum.html#760" class="Generalizable">B</a><a id="6213" class="Symbol">}</a> <a id="6215" class="Symbol">→</a> <a data-type="Code x y → x ≡ y" id="6217" href="Data.Sum.html#5344" class="Function">decode</a> <a id="6224" class="Symbol">(</a><a data-type="x ≡ y → Code x y" id="6225" href="Data.Sum.html#5615" class="Function">encode</a> <a id="6232" class="Symbol">(λ</a> <a id="6235" href="Data.Sum.html#6235" class="Bound">i</a> <a id="6237" class="Symbol">→</a> <a id="6239" href="Data.Sum.html#6204" class="Bound">x</a><a id="6240" class="Symbol">))</a> <a data-type="A → A → Type ℓ" id="6243" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="6245" class="Symbol">(λ</a> <a id="6248" href="Data.Sum.html#6248" class="Bound">i</a> <a id="6250" class="Symbol">→</a> <a id="6252" href="Data.Sum.html#6204" class="Bound">x</a><a id="6253" class="Symbol">)</a>
    <a id="6259" href="Data.Sum.html#6192" class="Function">d-e-refl</a> <a id="6268" class="Symbol">{</a><a id="6269" class="Argument">x</a> <a id="6271" class="Symbol">=</a> <a data-type="A → A ⊎ B" id="6273" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="6277" href="Data.Sum.html#6277" class="Bound">x</a><a id="6278" class="Symbol">}</a> <a id="6280" class="Symbol">=</a> <a data-type="x ≡ x" id="6282" href="1Lab.Path.html#2137" class="Function">refl</a>
    <a id="6291" href="Data.Sum.html#6192" class="Function">d-e-refl</a> <a id="6300" class="Symbol">{</a><a id="6301" class="Argument">x</a> <a id="6303" class="Symbol">=</a> <a data-type="B → A ⊎ B" id="6305" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="6309" href="Data.Sum.html#6309" class="Bound">x</a><a id="6310" class="Symbol">}</a> <a id="6312" class="Symbol">=</a> <a data-type="x ≡ x" id="6314" href="1Lab.Path.html#2137" class="Function">refl</a>
</pre>
<p>In the other direction, the proof is by case analysis, and everything computes wonderfully to make the right-hand sides fillable by <span class="Agda"><a data-type="x ≡ x" href="1Lab.Path.html#2137" class="Function">refl</a></span>:</p>
<pre class="Agda">  <a id="⊎Path.encode-decode"></a><a data-type="(p : Code x y) → encode (decode p) ≡ p" id="6482" href="Data.Sum.html#6482" class="Function">encode-decode</a> <a id="6496" class="Symbol">:</a> <a id="6498" class="Symbol">{</a><a id="6499" href="Data.Sum.html#6499" class="Bound">x</a> <a id="6501" href="Data.Sum.html#6501" class="Bound">y</a> <a id="6503" class="Symbol">:</a> <a id="6505" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="6507" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="6509" href="Data.Sum.html#760" class="Generalizable">B</a><a id="6510" class="Symbol">}</a> <a id="6512" class="Symbol">(</a><a id="6513" href="Data.Sum.html#6513" class="Bound">p</a> <a id="6515" class="Symbol">:</a> <a data-type="A ⊎ B → A ⊎ B → Type (A.a ⊔ B.a)" id="6517" href="Data.Sum.html#4887" class="Function">Code</a> <a id="6522" href="Data.Sum.html#6499" class="Bound">x</a> <a id="6524" href="Data.Sum.html#6501" class="Bound">y</a><a id="6525" class="Symbol">)</a> <a id="6527" class="Symbol">→</a> <a data-type="x ≡ y → Code x y" id="6529" href="Data.Sum.html#5615" class="Function">encode</a> <a id="6536" class="Symbol">(</a><a data-type="Code x y → x ≡ y" id="6537" href="Data.Sum.html#5344" class="Function">decode</a> <a id="6544" href="Data.Sum.html#6513" class="Bound">p</a><a id="6545" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="6547" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="6549" href="Data.Sum.html#6513" class="Bound">p</a>
  <a data-type="(p : Code x y) → encode (decode p) ≡ p" id="6553" href="Data.Sum.html#6482" class="Function">encode-decode</a> <a id="6567" class="Symbol">{</a><a id="6568" class="Argument">x</a> <a id="6570" class="Symbol">=</a> <a data-type="A → A ⊎ B" id="6572" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="6576" href="Data.Sum.html#6576" class="Bound">x</a><a id="6577" class="Symbol">}</a> <a id="6579" class="Symbol">{</a><a id="6580" class="Argument">y</a> <a id="6582" class="Symbol">=</a> <a data-type="A → A ⊎ B" id="6584" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="6588" href="Data.Sum.html#6588" class="Bound">y</a><a id="6589" class="Symbol">}</a> <a id="6591" href="Data.Sum.html#6591" class="Bound">p</a> <a id="6593" class="Symbol">=</a> <a data-type="x ≡ x" id="6595" href="1Lab.Path.html#2137" class="Function">refl</a>
  <a data-type="(p : Code x y) → encode (decode p) ≡ p" id="6602" href="Data.Sum.html#6482" class="Function">encode-decode</a> <a id="6616" class="Symbol">{</a><a id="6617" class="Argument">x</a> <a id="6619" class="Symbol">=</a> <a data-type="B → A ⊎ B" id="6621" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="6625" href="Data.Sum.html#6625" class="Bound">x</a><a id="6626" class="Symbol">}</a> <a id="6628" class="Symbol">{</a><a id="6629" class="Argument">y</a> <a id="6631" class="Symbol">=</a> <a data-type="B → A ⊎ B" id="6633" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="6637" href="Data.Sum.html#6637" class="Bound">y</a><a id="6638" class="Symbol">}</a> <a id="6640" href="Data.Sum.html#6640" class="Bound">p</a> <a id="6642" class="Symbol">=</a> <a data-type="x ≡ x" id="6644" href="1Lab.Path.html#2137" class="Function">refl</a>
</pre>
<p>Thus, we have an equivalence between codes for equalities in <code>A ⊎ B</code> and <em>actual</em> equalities <code>A ⊎ B</code>. Since <span class="Agda"><a data-type="A ⊎ B → A ⊎ B → Type (A.a ⊔ B.a)" href="Data.Sum.html#4887" class="Function">Code</a></span> has a nice computational structure, we can establish its h-level by induction:</p>
<pre class="Agda">  <a id="⊎Path.Code≃Path"></a><a data-type="Code x y ≃ (x ≡ y)" id="6866" href="Data.Sum.html#6866" class="Function">Code≃Path</a> <a id="6876" class="Symbol">:</a> <a id="6878" class="Symbol">{</a><a id="6879" href="Data.Sum.html#6879" class="Bound">x</a> <a id="6881" href="Data.Sum.html#6881" class="Bound">y</a> <a id="6883" class="Symbol">:</a> <a id="6885" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="6887" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="6889" href="Data.Sum.html#760" class="Generalizable">B</a><a id="6890" class="Symbol">}</a> <a id="6892" class="Symbol">→</a> <a data-type="A ⊎ B → A ⊎ B → Type (A.a ⊔ B.a)" id="6894" href="Data.Sum.html#4887" class="Function">Code</a> <a id="6899" href="Data.Sum.html#6879" class="Bound">x</a> <a id="6901" href="Data.Sum.html#6881" class="Bound">y</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="6903" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="6905" class="Symbol">(</a><a id="6906" href="Data.Sum.html#6879" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="6908" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="6910" href="Data.Sum.html#6881" class="Bound">y</a><a id="6911" class="Symbol">)</a>
  <a data-type="Code x y ≃ (x ≡ y)" id="6915" href="Data.Sum.html#6866" class="Function">Code≃Path</a> <a id="6925" class="Symbol">=</a> <a data-type="Iso A B → A ≃ B" id="6927" href="1Lab.Equiv.html#20090" class="Function">Iso→Equiv</a> <a id="6937" class="Symbol">(</a><a data-type="Code x y → x ≡ y" id="6938" href="Data.Sum.html#5344" class="Function">decode</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="6945" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="(inv : B → A) (rinv₁ : isRightInverse inv f)
(linv₁ : isLeftInverse inv f) →
isIso f" id="6947" href="1Lab.Equiv.html#6064" class="InductiveConstructor">iso</a> <a data-type="x ≡ y → Code x y" id="6951" href="Data.Sum.html#5615" class="Function">encode</a> <a data-type="(p : x ≡ y) → decode (encode p) ≡ p" id="6958" href="Data.Sum.html#6055" class="Function">decode-encode</a> <a data-type="(p : Code x y) → encode (decode p) ≡ p" id="6972" href="Data.Sum.html#6482" class="Function">encode-decode</a><a id="6985" class="Symbol">)</a>
</pre>
<pre class="Agda"><a id="7000" class="Keyword">open</a> <a id="7005" href="Data.Sum.html#4873" class="Module">⊎Path</a>

<a id="isHLevel-Code"></a><a data-type="isHLevel A (suc (suc n)) →
isHLevel B (suc (suc n)) → isHLevel (Code x y) (suc n)" id="7012" href="Data.Sum.html#7012" class="Function">isHLevel-Code</a> <a id="7026" class="Symbol">:</a> <a id="7028" class="Symbol">{</a><a id="7029" href="Data.Sum.html#7029" class="Bound">x</a> <a id="7031" href="Data.Sum.html#7031" class="Bound">y</a> <a id="7033" class="Symbol">:</a> <a id="7035" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="7037" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="7039" href="Data.Sum.html#760" class="Generalizable">B</a><a id="7040" class="Symbol">}</a> <a id="7042" class="Symbol">{</a><a id="7043" href="Data.Sum.html#7043" class="Bound">n</a> <a id="7045" class="Symbol">:</a> <a data-type="Type" id="7047" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a><a id="7050" class="Symbol">}</a>
            <a id="7064" class="Symbol">→</a> <a data-type="Type ℓ → Nat → Type ℓ" id="7066" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a> <a id="7075" href="Data.Sum.html#758" class="Generalizable">A</a> <a id="7077" class="Symbol">(</a><a data-type="Nat → Nat" id="7078" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="7082" class="Symbol">(</a><a data-type="Nat → Nat" id="7083" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="7087" href="Data.Sum.html#7043" class="Bound">n</a><a id="7088" class="Symbol">))</a>
            <a id="7103" class="Symbol">→</a> <a data-type="Type ℓ → Nat → Type ℓ" id="7105" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a> <a id="7114" href="Data.Sum.html#760" class="Generalizable">B</a> <a id="7116" class="Symbol">(</a><a data-type="Nat → Nat" id="7117" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="7121" class="Symbol">(</a><a data-type="Nat → Nat" id="7122" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="7126" href="Data.Sum.html#7043" class="Bound">n</a><a id="7127" class="Symbol">))</a>
            <a id="7142" class="Symbol">→</a> <a data-type="Type ℓ → Nat → Type ℓ" id="7144" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a> <a id="7153" class="Symbol">(</a><a data-type="A ⊎ B → A ⊎ B → Type (A.a ⊔ B.a)" id="7154" href="Data.Sum.html#4887" class="Function">Code</a> <a id="7159" href="Data.Sum.html#7029" class="Bound">x</a> <a id="7161" href="Data.Sum.html#7031" class="Bound">y</a><a id="7162" class="Symbol">)</a> <a id="7164" class="Symbol">(</a><a data-type="Nat → Nat" id="7165" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="7169" href="Data.Sum.html#7043" class="Bound">n</a><a id="7170" class="Symbol">)</a>
<a data-type="isHLevel A (suc (suc n)) →
isHLevel B (suc (suc n)) → isHLevel (Code x y) (suc n)" id="7172" href="Data.Sum.html#7012" class="Function">isHLevel-Code</a> <a id="7186" class="Symbol">{</a><a id="7187" class="Argument">x</a> <a id="7189" class="Symbol">=</a> <a data-type="A → A ⊎ B" id="7191" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="7195" href="Data.Sum.html#7195" class="Bound">x</a><a id="7196" class="Symbol">}</a> <a id="7198" class="Symbol">{</a><a data-type="A → A ⊎ B" id="7199" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="7203" href="Data.Sum.html#7203" class="Bound">y</a><a id="7204" class="Symbol">}</a> <a id="7206" class="Symbol">{</a><a id="7207" href="Data.Sum.html#7207" class="Bound">n</a><a id="7208" class="Symbol">}</a> <a id="7210" href="Data.Sum.html#7210" class="Bound">ahl</a> <a id="7214" href="Data.Sum.html#7214" class="Bound">bhl</a> <a id="7218" class="Symbol">=</a>
  <a data-type="(n : Nat) → isHLevel A n → isHLevel (Lift b A) n" id="7222" href="1Lab.HLevel.Retracts.html#6281" class="Function">isHLevel-Lift</a> <a id="7236" class="Symbol">(</a><a data-type="Nat → Nat" id="7237" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="7241" href="Data.Sum.html#7207" class="Bound">n</a><a id="7242" class="Symbol">)</a> <a id="7244" class="Symbol">(</a><a id="7245" href="Data.Sum.html#7210" class="Bound">ahl</a> <a id="7249" href="Data.Sum.html#7195" class="Bound">x</a> <a id="7251" href="Data.Sum.html#7203" class="Bound">y</a><a id="7252" class="Symbol">)</a>
<a data-type="isHLevel A (suc (suc n)) →
isHLevel B (suc (suc n)) → isHLevel (Code x y) (suc n)" id="7254" href="Data.Sum.html#7012" class="Function">isHLevel-Code</a> <a id="7268" class="Symbol">{</a><a id="7269" class="Argument">x</a> <a id="7271" class="Symbol">=</a> <a data-type="B → A ⊎ B" id="7273" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="7277" href="Data.Sum.html#7277" class="Bound">x</a><a id="7278" class="Symbol">}</a> <a id="7280" class="Symbol">{</a><a data-type="B → A ⊎ B" id="7281" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="7285" href="Data.Sum.html#7285" class="Bound">y</a><a id="7286" class="Symbol">}</a> <a id="7288" class="Symbol">{</a><a id="7289" href="Data.Sum.html#7289" class="Bound">n</a><a id="7290" class="Symbol">}</a> <a id="7292" href="Data.Sum.html#7292" class="Bound">ahl</a> <a id="7296" href="Data.Sum.html#7296" class="Bound">bhl</a> <a id="7300" class="Symbol">=</a>
  <a data-type="(n : Nat) → isHLevel A n → isHLevel (Lift b A) n" id="7304" href="1Lab.HLevel.Retracts.html#6281" class="Function">isHLevel-Lift</a> <a id="7318" class="Symbol">(</a><a data-type="Nat → Nat" id="7319" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="7323" href="Data.Sum.html#7289" class="Bound">n</a><a id="7324" class="Symbol">)</a> <a id="7326" class="Symbol">(</a><a id="7327" href="Data.Sum.html#7296" class="Bound">bhl</a> <a id="7331" href="Data.Sum.html#7277" class="Bound">x</a> <a id="7333" href="Data.Sum.html#7285" class="Bound">y</a><a id="7334" class="Symbol">)</a>
</pre>
<p>In the two cases where <code>x</code> and <code>y</code> match, we can use the fact that <span class="Agda"><a data-type="(n : Nat) → isHLevel A n → isHLevel (Lift b A) n" href="1Lab.HLevel.Retracts.html#6281" class="Function">Lift preserves h-levels</a></span> and the assumption that <code>A</code> (or <code>B</code>) have the given h-level.</p>
<pre class="Agda"><a data-type="isHLevel A (suc (suc n)) →
isHLevel B (suc (suc n)) → isHLevel (Code x y) (suc n)" id="7531" href="Data.Sum.html#7012" class="Function">isHLevel-Code</a> <a id="7545" class="Symbol">{</a><a id="7546" class="Argument">x</a> <a id="7548" class="Symbol">=</a> <a data-type="A → A ⊎ B" id="7550" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="7554" href="Data.Sum.html#7554" class="Bound">x</a><a id="7555" class="Symbol">}</a> <a id="7557" class="Symbol">{</a><a data-type="B → A ⊎ B" id="7558" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="7562" href="Data.Sum.html#7562" class="Bound">y</a><a id="7563" class="Symbol">}</a> <a id="7565" class="Symbol">{</a><a id="7566" href="Data.Sum.html#7566" class="Bound">n</a><a id="7567" class="Symbol">}</a> <a id="7569" href="Data.Sum.html#7569" class="Bound">ahl</a> <a id="7573" href="Data.Sum.html#7573" class="Bound">bhl</a> <a id="7577" class="Symbol">=</a>
  <a data-type="(n : Nat) → isHLevel A n → isHLevel (Lift b A) n" id="7581" href="1Lab.HLevel.Retracts.html#6281" class="Function">isHLevel-Lift</a> <a id="7595" class="Symbol">(</a><a data-type="Nat → Nat" id="7596" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="7600" href="Data.Sum.html#7566" class="Bound">n</a><a id="7601" class="Symbol">)</a> <a id="7603" class="Symbol">(</a><a data-type="isProp A → isHLevel A (suc n)" id="7604" href="1Lab.HLevel.html#9249" class="Function">isProp→isHLevel-suc</a> <a id="7624" class="Symbol">λ</a> <a id="7626" href="Data.Sum.html#7626" class="Bound">x</a> <a id="7628" class="Symbol">→</a> <a data-type="⊥ → A" id="7630" href="1Lab.Type.html#1342" class="Function">absurd</a> <a id="7637" href="Data.Sum.html#7626" class="Bound">x</a><a id="7638" class="Symbol">)</a>
<a data-type="isHLevel A (suc (suc n)) →
isHLevel B (suc (suc n)) → isHLevel (Code x y) (suc n)" id="7640" href="Data.Sum.html#7012" class="Function">isHLevel-Code</a> <a id="7654" class="Symbol">{</a><a id="7655" class="Argument">x</a> <a id="7657" class="Symbol">=</a> <a data-type="B → A ⊎ B" id="7659" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="7663" href="Data.Sum.html#7663" class="Bound">x</a><a id="7664" class="Symbol">}</a> <a id="7666" class="Symbol">{</a><a data-type="A → A ⊎ B" id="7667" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="7671" href="Data.Sum.html#7671" class="Bound">y</a><a id="7672" class="Symbol">}</a> <a id="7674" class="Symbol">{</a><a id="7675" href="Data.Sum.html#7675" class="Bound">n</a><a id="7676" class="Symbol">}</a> <a id="7678" href="Data.Sum.html#7678" class="Bound">ahl</a> <a id="7682" href="Data.Sum.html#7682" class="Bound">bhl</a> <a id="7686" class="Symbol">=</a> 
  <a data-type="(n : Nat) → isHLevel A n → isHLevel (Lift b A) n" id="7691" href="1Lab.HLevel.Retracts.html#6281" class="Function">isHLevel-Lift</a> <a id="7705" class="Symbol">(</a><a data-type="Nat → Nat" id="7706" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="7710" href="Data.Sum.html#7675" class="Bound">n</a><a id="7711" class="Symbol">)</a> <a id="7713" class="Symbol">(</a><a data-type="isProp A → isHLevel A (suc n)" id="7714" href="1Lab.HLevel.html#9249" class="Function">isProp→isHLevel-suc</a> <a id="7734" class="Symbol">λ</a> <a id="7736" href="Data.Sum.html#7736" class="Bound">x</a> <a id="7738" class="Symbol">→</a> <a data-type="⊥ → A" id="7740" href="1Lab.Type.html#1342" class="Function">absurd</a> <a id="7747" href="Data.Sum.html#7736" class="Bound">x</a><a id="7748" class="Symbol">)</a>
</pre>
<p>In the mismatched cases, we use the fact that <span class="Agda"><a data-type="isProp A → isHLevel A (suc n)" href="1Lab.HLevel.html#9249" class="Function">propositions have any successor h-level</a></span> to prove that <code>⊥</code> is also at the same h-level as <code>A</code> and <code>B</code>. Thus, we have:</p>
<pre class="Agda"><a id="isHLevel-⊎"></a><a data-type="(n : Nat) →
isHLevel A (2 + n) → isHLevel B (2 + n) → isHLevel (A ⊎ B) (2 + n)" id="7962" href="Data.Sum.html#7962" class="Function">isHLevel-⊎</a> <a id="7973" class="Symbol">:</a> <a id="7975" class="Symbol">(</a><a id="7976" href="Data.Sum.html#7976" class="Bound">n</a> <a id="7978" class="Symbol">:</a> <a data-type="Type" id="7980" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a><a id="7983" class="Symbol">)</a>
           <a id="7996" class="Symbol">→</a> <a data-type="Type ℓ → Nat → Type ℓ" id="7998" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a> <a id="8007" href="Data.Sum.html#758" class="Generalizable">A</a> <a id="8009" class="Symbol">(</a><a id="8010" class="Number">2</a> <a data-type="Nat → Nat → Nat" id="8012" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="8014" href="Data.Sum.html#7976" class="Bound">n</a><a id="8015" class="Symbol">)</a>
           <a id="8028" class="Symbol">→</a> <a data-type="Type ℓ → Nat → Type ℓ" id="8030" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a> <a id="8039" href="Data.Sum.html#760" class="Generalizable">B</a> <a id="8041" class="Symbol">(</a><a id="8042" class="Number">2</a> <a data-type="Nat → Nat → Nat" id="8044" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="8046" href="Data.Sum.html#7976" class="Bound">n</a><a id="8047" class="Symbol">)</a>
           <a id="8060" class="Symbol">→</a> <a data-type="Type ℓ → Nat → Type ℓ" id="8062" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a> <a id="8071" class="Symbol">(</a><a id="8072" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="8074" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="8076" href="Data.Sum.html#760" class="Generalizable">B</a><a id="8077" class="Symbol">)</a> <a id="8079" class="Symbol">(</a><a id="8080" class="Number">2</a> <a data-type="Nat → Nat → Nat" id="8082" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="8084" href="Data.Sum.html#7976" class="Bound">n</a><a id="8085" class="Symbol">)</a>
<a data-type="(n : Nat) →
isHLevel A (2 + n) → isHLevel B (2 + n) → isHLevel (A ⊎ B) (2 + n)" id="8087" href="Data.Sum.html#7962" class="Function">isHLevel-⊎</a> <a id="8098" href="Data.Sum.html#8098" class="Bound">n</a> <a id="8100" href="Data.Sum.html#8100" class="Bound">ahl</a> <a id="8104" href="Data.Sum.html#8104" class="Bound">bhl</a> <a id="8108" href="Data.Sum.html#8108" class="Bound">x</a> <a id="8110" href="Data.Sum.html#8110" class="Bound">y</a> <a id="8112" class="Symbol">=</a> <a data-type="(n : Nat) → A ≃ B → isHLevel A n → isHLevel B n" id="8114" href="1Lab.HLevel.Retracts.html#3899" class="Function">isHLevel≃</a> <a id="8124" class="Symbol">(</a><a id="8125" class="Number">1</a> <a data-type="Nat → Nat → Nat" id="8127" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="8129" href="Data.Sum.html#8098" class="Bound">n</a><a id="8130" class="Symbol">)</a> <a data-type="Code x y ≃ (x ≡ y)" id="8132" href="Data.Sum.html#6866" class="Function">Code≃Path</a> <a id="8142" class="Symbol">(</a><a data-type="isHLevel A (suc (suc n)) →
isHLevel B (suc (suc n)) → isHLevel (Code x y) (suc n)" id="8143" href="Data.Sum.html#7012" class="Function">isHLevel-Code</a> <a id="8157" href="Data.Sum.html#8100" class="Bound">ahl</a> <a id="8161" href="Data.Sum.html#8104" class="Bound">bhl</a><a id="8164" class="Symbol">)</a>
</pre>
<p>Note that, in general, <a data-type="Type ℓ → Type ℓ" href="1Lab.HLevel.html#2594">being a proposition</a> and <a data-type="(A : Type ℓ) → Type ℓ" href="1Lab.HLevel.html#1328">being contractible</a> are not preserved under coproducts. Consider the case where <code>(A, a)</code> and <code>(B, b)</code> are both contractible (this generalises to propositions): Then their coproduct has two distinct points, <code>in­l a</code> and <code>inr b</code>. However, the coproduct of <em>disjoint</em> propositions is a proposition:</p>
<pre class="Agda"><a id="isProp-disjoint-⊎"></a><a data-type="isProp A → isProp B → (A × B → ⊥) → isProp (A ⊎ B)" id="8625" href="Data.Sum.html#8625" class="Function">isProp-disjoint-⊎</a> <a id="8643" class="Symbol">:</a> <a data-type="Type ℓ → Type ℓ" id="8645" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="8652" href="Data.Sum.html#758" class="Generalizable">A</a> <a id="8654" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="8656" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="8663" href="Data.Sum.html#760" class="Generalizable">B</a> <a id="8665" class="Symbol">→</a> <a id="8667" class="Symbol">(</a><a id="8668" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="8670" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="8672" href="Data.Sum.html#760" class="Generalizable">B</a> <a id="8674" class="Symbol">→</a> <a data-type="Type" id="8676" href="1Lab.Type.html#1326" class="Datatype">⊥</a><a id="8677" class="Symbol">)</a>
                  <a id="8697" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="8699" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="8706" class="Symbol">(</a><a id="8707" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="8709" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="8711" href="Data.Sum.html#760" class="Generalizable">B</a><a id="8712" class="Symbol">)</a>
<a data-type="isProp A → isProp B → (A × B → ⊥) → isProp (A ⊎ B)" id="8714" href="Data.Sum.html#8625" class="Function">isProp-disjoint-⊎</a> <a id="8732" href="Data.Sum.html#8732" class="Bound">Ap</a> <a id="8735" href="Data.Sum.html#8735" class="Bound">Bp</a> <a id="8738" href="Data.Sum.html#8738" class="Bound">notab</a> <a id="8744" class="Symbol">(</a><a data-type="A → A ⊎ B" id="8745" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="8749" href="Data.Sum.html#8749" class="Bound">x</a><a id="8750" class="Symbol">)</a> <a id="8752" class="Symbol">(</a><a data-type="A → A ⊎ B" id="8753" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="8757" href="Data.Sum.html#8757" class="Bound">y</a><a id="8758" class="Symbol">)</a> <a id="8760" class="Symbol">=</a> <a data-type="(f : (x : A) → B x) (p : x ≡ y) → PathP (λ i → B (p i)) (f x) (f y)" id="8762" href="1Lab.Path.html#19262" class="Function">ap</a> <a data-type="A → A ⊎ B" id="8765" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="8769" class="Symbol">(</a><a id="8770" href="Data.Sum.html#8732" class="Bound">Ap</a> <a id="8773" href="Data.Sum.html#8749" class="Bound">x</a> <a id="8775" href="Data.Sum.html#8757" class="Bound">y</a><a id="8776" class="Symbol">)</a>
<a data-type="isProp A → isProp B → (A × B → ⊥) → isProp (A ⊎ B)" id="8778" href="Data.Sum.html#8625" class="Function">isProp-disjoint-⊎</a> <a id="8796" href="Data.Sum.html#8796" class="Bound">Ap</a> <a id="8799" href="Data.Sum.html#8799" class="Bound">Bp</a> <a id="8802" href="Data.Sum.html#8802" class="Bound">notab</a> <a id="8808" class="Symbol">(</a><a data-type="A → A ⊎ B" id="8809" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="8813" href="Data.Sum.html#8813" class="Bound">x</a><a id="8814" class="Symbol">)</a> <a id="8816" class="Symbol">(</a><a data-type="B → A ⊎ B" id="8817" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="8821" href="Data.Sum.html#8821" class="Bound">y</a><a id="8822" class="Symbol">)</a> <a id="8824" class="Symbol">=</a> <a data-type="⊥ → A" id="8826" href="1Lab.Type.html#1342" class="Function">absurd</a> <a id="8833" class="Symbol">(</a><a id="8834" href="Data.Sum.html#8802" class="Bound">notab</a> <a id="8840" class="Symbol">(</a><a id="8841" href="Data.Sum.html#8813" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="8843" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8845" href="Data.Sum.html#8821" class="Bound">y</a><a id="8846" class="Symbol">))</a>
<a data-type="isProp A → isProp B → (A × B → ⊥) → isProp (A ⊎ B)" id="8849" href="Data.Sum.html#8625" class="Function">isProp-disjoint-⊎</a> <a id="8867" href="Data.Sum.html#8867" class="Bound">Ap</a> <a id="8870" href="Data.Sum.html#8870" class="Bound">Bp</a> <a id="8873" href="Data.Sum.html#8873" class="Bound">notab</a> <a id="8879" class="Symbol">(</a><a data-type="B → A ⊎ B" id="8880" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="8884" href="Data.Sum.html#8884" class="Bound">x</a><a id="8885" class="Symbol">)</a> <a id="8887" class="Symbol">(</a><a data-type="A → A ⊎ B" id="8888" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="8892" href="Data.Sum.html#8892" class="Bound">y</a><a id="8893" class="Symbol">)</a> <a id="8895" class="Symbol">=</a> <a data-type="⊥ → A" id="8897" href="1Lab.Type.html#1342" class="Function">absurd</a> <a id="8904" class="Symbol">(</a><a id="8905" href="Data.Sum.html#8873" class="Bound">notab</a> <a id="8911" class="Symbol">(</a><a id="8912" href="Data.Sum.html#8892" class="Bound">y</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="8914" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8916" href="Data.Sum.html#8884" class="Bound">x</a><a id="8917" class="Symbol">))</a>
<a data-type="isProp A → isProp B → (A × B → ⊥) → isProp (A ⊎ B)" id="8920" href="Data.Sum.html#8625" class="Function">isProp-disjoint-⊎</a> <a id="8938" href="Data.Sum.html#8938" class="Bound">Ap</a> <a id="8941" href="Data.Sum.html#8941" class="Bound">Bp</a> <a id="8944" href="Data.Sum.html#8944" class="Bound">notab</a> <a id="8950" class="Symbol">(</a><a data-type="B → A ⊎ B" id="8951" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="8955" href="Data.Sum.html#8955" class="Bound">x</a><a id="8956" class="Symbol">)</a> <a id="8958" class="Symbol">(</a><a data-type="B → A ⊎ B" id="8959" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="8963" href="Data.Sum.html#8963" class="Bound">y</a><a id="8964" class="Symbol">)</a> <a id="8966" class="Symbol">=</a> <a data-type="(f : (x : A) → B x) (p : x ≡ y) → PathP (λ i → B (p i)) (f x) (f y)" id="8968" href="1Lab.Path.html#19262" class="Function">ap</a> <a data-type="B → A ⊎ B" id="8971" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="8975" class="Symbol">(</a><a id="8976" href="Data.Sum.html#8941" class="Bound">Bp</a> <a id="8979" href="Data.Sum.html#8955" class="Bound">x</a> <a id="8981" href="Data.Sum.html#8963" class="Bound">y</a><a id="8982" class="Symbol">)</a>
</pre>
<h2 id="closure-under-equivalences"><a href="#closure-under-equivalences" class="header-link">Closure under equivalences<span class="header-link-emoji">🔗</span></a></h2>
<p><a href="1Lab.Univalence.html#the-axiom">Univalence</a> automatically implies that all type formers respect equivalences. However, the proof using univalence is restricted to types of the same universe level. Thus, <span class="Agda"><a data-type="A ≃ B → C ≃ D → (A ⊎ C) ≃ (B ⊎ D)" href="Data.Sum.html#9328" class="Function">⊎-ap</a></span>: Coproducts respect equivalences in both arguments, across levels.</p>
<pre class="Agda"><a id="⊎-ap"></a><a data-type="A ≃ B → C ≃ D → (A ⊎ C) ≃ (B ⊎ D)" id="9328" href="Data.Sum.html#9328" class="Function">⊎-ap</a> <a id="9333" class="Symbol">:</a> <a id="9335" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="9337" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="9339" href="Data.Sum.html#760" class="Generalizable">B</a> <a id="9341" class="Symbol">→</a> <a id="9343" href="Data.Sum.html#762" class="Generalizable">C</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="9345" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="9347" href="Data.Sum.html#764" class="Generalizable">D</a> <a id="9349" class="Symbol">→</a> <a id="9351" class="Symbol">(</a><a id="9352" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="9354" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="9356" href="Data.Sum.html#762" class="Generalizable">C</a><a id="9357" class="Symbol">)</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="9359" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="9361" class="Symbol">(</a><a id="9362" href="Data.Sum.html#760" class="Generalizable">B</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="9364" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="9366" href="Data.Sum.html#764" class="Generalizable">D</a><a id="9367" class="Symbol">)</a>
<a data-type="A ≃ B → C ≃ D → (A ⊎ C) ≃ (B ⊎ D)" id="9369" href="Data.Sum.html#9328" class="Function">⊎-ap</a> <a id="9374" class="Symbol">(</a><a id="9375" href="Data.Sum.html#9375" class="Bound">f</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="9377" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="9379" href="Data.Sum.html#9379" class="Bound">f-eqv</a><a id="9384" class="Symbol">)</a> <a id="9386" class="Symbol">(</a><a id="9387" href="Data.Sum.html#9387" class="Bound">g</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="9389" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="9391" href="Data.Sum.html#9391" class="Bound">g-eqv</a><a id="9396" class="Symbol">)</a> <a id="9398" class="Symbol">=</a> <a data-type="Iso A B → A ≃ B" id="9400" href="1Lab.Equiv.html#20090" class="Function">Iso→Equiv</a> <a id="9410" href="Data.Sum.html#9484" class="Function">cong</a> <a id="9415" class="Keyword">where</a>
  <a id="9423" href="Data.Sum.html#9423" class="Function">f-iso</a> <a id="9429" class="Symbol">=</a> <a data-type="isEquiv f → isIso f" id="9431" href="1Lab.Equiv.html#6787" class="Function">isEquiv→isIso</a> <a id="9445" href="Data.Sum.html#9379" class="Bound">f-eqv</a>
  <a id="9453" href="Data.Sum.html#9453" class="Function">g-iso</a> <a id="9459" class="Symbol">=</a> <a data-type="isEquiv f → isIso f" id="9461" href="1Lab.Equiv.html#6787" class="Function">isEquiv→isIso</a> <a id="9475" href="Data.Sum.html#9391" class="Bound">g-eqv</a>

  <a id="9484" href="Data.Sum.html#9484" class="Function">cong</a> <a id="9489" class="Symbol">:</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="9491" href="1Lab.Equiv.html#6241" class="Function">Iso</a> <a id="9495" class="Symbol">_</a> <a id="9497" class="Symbol">_</a>
  <a id="9501" href="Data.Sum.html#9484" class="Function">cong</a> <a id="9506" class="Symbol">.</a><a data-type="∑ A B → A" id="9507" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="9511" class="Symbol">(</a><a data-type="A → A ⊎ B" id="9512" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="9516" href="Data.Sum.html#9516" class="Bound">x</a><a id="9517" class="Symbol">)</a> <a id="9519" class="Symbol">=</a> <a data-type="A → A ⊎ B" id="9521" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="9525" class="Symbol">(</a><a id="9526" href="Data.Sum.html#9375" class="Bound">f</a> <a id="9528" href="Data.Sum.html#9516" class="Bound">x</a><a id="9529" class="Symbol">)</a>
  <a id="9533" href="Data.Sum.html#9484" class="Function">cong</a> <a id="9538" class="Symbol">.</a><a data-type="∑ A B → A" id="9539" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="9543" class="Symbol">(</a><a data-type="B → A ⊎ B" id="9544" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="9548" href="Data.Sum.html#9548" class="Bound">x</a><a id="9549" class="Symbol">)</a> <a id="9551" class="Symbol">=</a> <a data-type="B → A ⊎ B" id="9553" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="9557" class="Symbol">(</a><a id="9558" href="Data.Sum.html#9387" class="Bound">g</a> <a id="9560" href="Data.Sum.html#9548" class="Bound">x</a><a id="9561" class="Symbol">)</a>

  <a id="9566" href="Data.Sum.html#9484" class="Function">cong</a> <a id="9571" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="9572" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="9576" class="Symbol">.</a><a data-type="isIso f → B → A" id="9577" href="1Lab.Equiv.html#6080" class="Field">isIso.inv</a> <a id="9587" class="Symbol">(</a><a data-type="A → A ⊎ B" id="9588" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="9592" href="Data.Sum.html#9592" class="Bound">x</a><a id="9593" class="Symbol">)</a> <a id="9595" class="Symbol">=</a> <a data-type="A → A ⊎ B" id="9597" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="9601" class="Symbol">(</a><a id="9602" href="Data.Sum.html#9423" class="Function">f-iso</a> <a id="9608" class="Symbol">.</a><a data-type="isIso f → B → A" id="9609" href="1Lab.Equiv.html#6080" class="Field">isIso.inv</a> <a id="9619" href="Data.Sum.html#9592" class="Bound">x</a><a id="9620" class="Symbol">)</a>
  <a id="9624" href="Data.Sum.html#9484" class="Function">cong</a> <a id="9629" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="9630" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="9634" class="Symbol">.</a><a data-type="isIso f → B → A" id="9635" href="1Lab.Equiv.html#6080" class="Field">isIso.inv</a> <a id="9645" class="Symbol">(</a><a data-type="B → A ⊎ B" id="9646" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="9650" href="Data.Sum.html#9650" class="Bound">x</a><a id="9651" class="Symbol">)</a> <a id="9653" class="Symbol">=</a> <a data-type="B → A ⊎ B" id="9655" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="9659" class="Symbol">(</a><a id="9660" href="Data.Sum.html#9453" class="Function">g-iso</a> <a id="9666" class="Symbol">.</a><a data-type="isIso f → B → A" id="9667" href="1Lab.Equiv.html#6080" class="Field">isIso.inv</a> <a id="9677" href="Data.Sum.html#9650" class="Bound">x</a><a id="9678" class="Symbol">)</a>

  <a id="9683" href="Data.Sum.html#9484" class="Function">cong</a> <a id="9688" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="9689" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="9693" class="Symbol">.</a><a data-type="(r : isIso f) → isRightInverse (r .inv) f" id="9694" href="1Lab.Equiv.html#6096" class="Field">isIso.rinv</a> <a id="9705" class="Symbol">(</a><a data-type="A → A ⊎ B" id="9706" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="9710" href="Data.Sum.html#9710" class="Bound">x</a><a id="9711" class="Symbol">)</a> <a id="9713" class="Symbol">=</a> <a data-type="(f : (x : A) → B x) (p : x ≡ y) → PathP (λ i → B (p i)) (f x) (f y)" id="9715" href="1Lab.Path.html#19262" class="Function">ap</a> <a data-type="A → A ⊎ B" id="9718" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="9722" class="Symbol">(</a><a id="9723" href="Data.Sum.html#9423" class="Function">f-iso</a> <a id="9729" class="Symbol">.</a><a data-type="(r : isIso f) → isRightInverse (r .inv) f" id="9730" href="1Lab.Equiv.html#6096" class="Field">isIso.rinv</a> <a id="9741" href="Data.Sum.html#9710" class="Bound">x</a><a id="9742" class="Symbol">)</a>
  <a id="9746" href="Data.Sum.html#9484" class="Function">cong</a> <a id="9751" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="9752" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="9756" class="Symbol">.</a><a data-type="(r : isIso f) → isRightInverse (r .inv) f" id="9757" href="1Lab.Equiv.html#6096" class="Field">isIso.rinv</a> <a id="9768" class="Symbol">(</a><a data-type="B → A ⊎ B" id="9769" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="9773" href="Data.Sum.html#9773" class="Bound">x</a><a id="9774" class="Symbol">)</a> <a id="9776" class="Symbol">=</a> <a data-type="(f : (x : A) → B x) (p : x ≡ y) → PathP (λ i → B (p i)) (f x) (f y)" id="9778" href="1Lab.Path.html#19262" class="Function">ap</a> <a data-type="B → A ⊎ B" id="9781" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="9785" class="Symbol">(</a><a id="9786" href="Data.Sum.html#9453" class="Function">g-iso</a> <a id="9792" class="Symbol">.</a><a data-type="(r : isIso f) → isRightInverse (r .inv) f" id="9793" href="1Lab.Equiv.html#6096" class="Field">isIso.rinv</a> <a id="9804" href="Data.Sum.html#9773" class="Bound">x</a><a id="9805" class="Symbol">)</a>

  <a id="9810" href="Data.Sum.html#9484" class="Function">cong</a> <a id="9815" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="9816" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="9820" class="Symbol">.</a><a data-type="(r : isIso f) → isLeftInverse (r .inv) f" id="9821" href="1Lab.Equiv.html#6128" class="Field">isIso.linv</a> <a id="9832" class="Symbol">(</a><a data-type="A → A ⊎ B" id="9833" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="9837" href="Data.Sum.html#9837" class="Bound">x</a><a id="9838" class="Symbol">)</a> <a id="9840" class="Symbol">=</a> <a data-type="(f : (x : A) → B x) (p : x ≡ y) → PathP (λ i → B (p i)) (f x) (f y)" id="9842" href="1Lab.Path.html#19262" class="Function">ap</a> <a data-type="A → A ⊎ B" id="9845" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="9849" class="Symbol">(</a><a id="9850" href="Data.Sum.html#9423" class="Function">f-iso</a> <a id="9856" class="Symbol">.</a><a data-type="(r : isIso f) → isLeftInverse (r .inv) f" id="9857" href="1Lab.Equiv.html#6128" class="Field">isIso.linv</a> <a id="9868" href="Data.Sum.html#9837" class="Bound">x</a><a id="9869" class="Symbol">)</a>
  <a id="9873" href="Data.Sum.html#9484" class="Function">cong</a> <a id="9878" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="9879" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="9883" class="Symbol">.</a><a data-type="(r : isIso f) → isLeftInverse (r .inv) f" id="9884" href="1Lab.Equiv.html#6128" class="Field">isIso.linv</a> <a id="9895" class="Symbol">(</a><a data-type="B → A ⊎ B" id="9896" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="9900" href="Data.Sum.html#9900" class="Bound">x</a><a id="9901" class="Symbol">)</a> <a id="9903" class="Symbol">=</a> <a data-type="(f : (x : A) → B x) (p : x ≡ y) → PathP (λ i → B (p i)) (f x) (f y)" id="9905" href="1Lab.Path.html#19262" class="Function">ap</a> <a data-type="B → A ⊎ B" id="9908" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="9912" class="Symbol">(</a><a id="9913" href="Data.Sum.html#9453" class="Function">g-iso</a> <a id="9919" class="Symbol">.</a><a data-type="(r : isIso f) → isLeftInverse (r .inv) f" id="9920" href="1Lab.Equiv.html#6128" class="Field">isIso.linv</a> <a id="9931" href="Data.Sum.html#9900" class="Bound">x</a><a id="9932" class="Symbol">)</a>

<a id="⊎-apˡ"></a><a data-type="A ≃ B → (A ⊎ C) ≃ (B ⊎ C)" id="9935" href="Data.Sum.html#9935" class="Function">⊎-apˡ</a> <a id="9941" class="Symbol">:</a> <a id="9943" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="9945" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="9947" href="Data.Sum.html#760" class="Generalizable">B</a> <a id="9949" class="Symbol">→</a> <a id="9951" class="Symbol">(</a><a id="9952" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="9954" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="9956" href="Data.Sum.html#762" class="Generalizable">C</a><a id="9957" class="Symbol">)</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="9959" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="9961" class="Symbol">(</a><a id="9962" href="Data.Sum.html#760" class="Generalizable">B</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="9964" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="9966" href="Data.Sum.html#762" class="Generalizable">C</a><a id="9967" class="Symbol">)</a>
<a data-type="A ≃ B → (A ⊎ C) ≃ (B ⊎ C)" id="9969" href="Data.Sum.html#9935" class="Function">⊎-apˡ</a> <a id="9975" href="Data.Sum.html#9975" class="Bound">f</a> <a id="9977" class="Symbol">=</a> <a data-type="A ≃ B → C ≃ D → (A ⊎ C) ≃ (B ⊎ D)" id="9979" href="Data.Sum.html#9328" class="Function">⊎-ap</a> <a id="9984" href="Data.Sum.html#9975" class="Bound">f</a> <a id="9986" class="Symbol">(</a><a data-type="A → A" id="9987" href="1Lab.Type.html#2348" class="Function">id</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="9990" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="9992" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="9999" class="Symbol">)</a>

<a id="⊎-apʳ"></a><a data-type="B ≃ C → (A ⊎ B) ≃ (A ⊎ C)" id="10002" href="Data.Sum.html#10002" class="Function">⊎-apʳ</a> <a id="10008" class="Symbol">:</a> <a id="10010" href="Data.Sum.html#760" class="Generalizable">B</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="10012" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="10014" href="Data.Sum.html#762" class="Generalizable">C</a> <a id="10016" class="Symbol">→</a> <a id="10018" class="Symbol">(</a><a id="10019" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="10021" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="10023" href="Data.Sum.html#760" class="Generalizable">B</a><a id="10024" class="Symbol">)</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="10026" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="10028" class="Symbol">(</a><a id="10029" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="10031" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="10033" href="Data.Sum.html#762" class="Generalizable">C</a><a id="10034" class="Symbol">)</a>
<a data-type="B ≃ C → (A ⊎ B) ≃ (A ⊎ C)" id="10036" href="Data.Sum.html#10002" class="Function">⊎-apʳ</a> <a id="10042" href="Data.Sum.html#10042" class="Bound">f</a> <a id="10044" class="Symbol">=</a> <a data-type="A ≃ B → C ≃ D → (A ⊎ C) ≃ (B ⊎ D)" id="10046" href="Data.Sum.html#9328" class="Function">⊎-ap</a> <a id="10051" class="Symbol">(</a><a data-type="A → A" id="10052" href="1Lab.Type.html#2348" class="Function">id</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="10055" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="10057" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="10064" class="Symbol">)</a> <a id="10066" href="Data.Sum.html#10042" class="Bound">f</a>
</pre>
<h2 id="algebraic-properties"><a href="#algebraic-properties" class="header-link">Algebraic properties<span class="header-link-emoji">🔗</span></a></h2>
<p>Considered as an algebraic operator on <em>types</em>, the coproduct satisfies many of the same properties of addition. Specifically, when restricted to finite types, the coproduct is exactly the same as addition.</p>
<pre class="Agda"><a id="⊎-comm"></a><a data-type="(A ⊎ B) ≃ (B ⊎ A)" id="10314" href="Data.Sum.html#10314" class="Function">⊎-comm</a> <a id="10321" class="Symbol">:</a> <a id="10323" class="Symbol">(</a><a id="10324" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="10326" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="10328" href="Data.Sum.html#760" class="Generalizable">B</a><a id="10329" class="Symbol">)</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="10331" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="10333" class="Symbol">(</a><a id="10334" href="Data.Sum.html#760" class="Generalizable">B</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="10336" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="10338" href="Data.Sum.html#758" class="Generalizable">A</a><a id="10339" class="Symbol">)</a>
<a data-type="(A ⊎ B) ≃ (B ⊎ A)" id="10341" href="Data.Sum.html#10314" class="Function">⊎-comm</a> <a id="10348" class="Symbol">=</a> <a data-type="Iso A B → A ≃ B" id="10350" href="1Lab.Equiv.html#20090" class="Function">Iso→Equiv</a> <a id="10360" href="Data.Sum.html#10370" class="Function">i</a> <a id="10362" class="Keyword">where</a>
  <a id="10370" href="Data.Sum.html#10370" class="Function">i</a> <a id="10372" class="Symbol">:</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="10374" href="1Lab.Equiv.html#6241" class="Function">Iso</a> <a id="10378" class="Symbol">_</a> <a id="10380" class="Symbol">_</a>
  <a id="10384" href="Data.Sum.html#10370" class="Function">i</a> <a id="10386" class="Symbol">.</a><a data-type="∑ A B → A" id="10387" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10391" class="Symbol">(</a><a data-type="A → A ⊎ B" id="10392" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="10396" href="Data.Sum.html#10396" class="Bound">x</a><a id="10397" class="Symbol">)</a> <a id="10399" class="Symbol">=</a> <a data-type="B → A ⊎ B" id="10401" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="10405" href="Data.Sum.html#10396" class="Bound">x</a>
  <a id="10409" href="Data.Sum.html#10370" class="Function">i</a> <a id="10411" class="Symbol">.</a><a data-type="∑ A B → A" id="10412" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10416" class="Symbol">(</a><a data-type="B → A ⊎ B" id="10417" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="10421" href="Data.Sum.html#10421" class="Bound">x</a><a id="10422" class="Symbol">)</a> <a id="10424" class="Symbol">=</a> <a data-type="A → A ⊎ B" id="10426" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="10430" href="Data.Sum.html#10421" class="Bound">x</a>

  <a id="10435" href="Data.Sum.html#10370" class="Function">i</a> <a id="10437" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="10438" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10442" class="Symbol">.</a><a data-type="isIso f → B → A" id="10443" href="1Lab.Equiv.html#6080" class="Field">isIso.inv</a> <a id="10453" class="Symbol">(</a><a data-type="A → A ⊎ B" id="10454" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="10458" href="Data.Sum.html#10458" class="Bound">x</a><a id="10459" class="Symbol">)</a> <a id="10461" class="Symbol">=</a> <a data-type="B → A ⊎ B" id="10463" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="10467" href="Data.Sum.html#10458" class="Bound">x</a>
  <a id="10471" href="Data.Sum.html#10370" class="Function">i</a> <a id="10473" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="10474" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10478" class="Symbol">.</a><a data-type="isIso f → B → A" id="10479" href="1Lab.Equiv.html#6080" class="Field">isIso.inv</a> <a id="10489" class="Symbol">(</a><a data-type="B → A ⊎ B" id="10490" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="10494" href="Data.Sum.html#10494" class="Bound">x</a><a id="10495" class="Symbol">)</a> <a id="10497" class="Symbol">=</a> <a data-type="A → A ⊎ B" id="10499" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="10503" href="Data.Sum.html#10494" class="Bound">x</a>

  <a id="10508" href="Data.Sum.html#10370" class="Function">i</a> <a id="10510" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="10511" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10515" class="Symbol">.</a><a data-type="(r : isIso f) → isRightInverse (r .inv) f" id="10516" href="1Lab.Equiv.html#6096" class="Field">isIso.rinv</a> <a id="10527" class="Symbol">(</a><a data-type="A → A ⊎ B" id="10528" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="10532" href="Data.Sum.html#10532" class="Bound">x</a><a id="10533" class="Symbol">)</a> <a id="10535" class="Symbol">=</a> <a data-type="x ≡ x" id="10537" href="1Lab.Path.html#2137" class="Function">refl</a>
  <a id="10544" href="Data.Sum.html#10370" class="Function">i</a> <a id="10546" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="10547" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10551" class="Symbol">.</a><a data-type="(r : isIso f) → isRightInverse (r .inv) f" id="10552" href="1Lab.Equiv.html#6096" class="Field">isIso.rinv</a> <a id="10563" class="Symbol">(</a><a data-type="B → A ⊎ B" id="10564" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="10568" href="Data.Sum.html#10568" class="Bound">x</a><a id="10569" class="Symbol">)</a> <a id="10571" class="Symbol">=</a> <a data-type="x ≡ x" id="10573" href="1Lab.Path.html#2137" class="Function">refl</a>
  <a id="10580" href="Data.Sum.html#10370" class="Function">i</a> <a id="10582" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="10583" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10587" class="Symbol">.</a><a data-type="(r : isIso f) → isLeftInverse (r .inv) f" id="10588" href="1Lab.Equiv.html#6128" class="Field">isIso.linv</a> <a id="10599" class="Symbol">(</a><a data-type="A → A ⊎ B" id="10600" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="10604" href="Data.Sum.html#10604" class="Bound">x</a><a id="10605" class="Symbol">)</a> <a id="10607" class="Symbol">=</a> <a data-type="x ≡ x" id="10609" href="1Lab.Path.html#2137" class="Function">refl</a>
  <a id="10616" href="Data.Sum.html#10370" class="Function">i</a> <a id="10618" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="10619" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10623" class="Symbol">.</a><a data-type="(r : isIso f) → isLeftInverse (r .inv) f" id="10624" href="1Lab.Equiv.html#6128" class="Field">isIso.linv</a> <a id="10635" class="Symbol">(</a><a data-type="B → A ⊎ B" id="10636" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="10640" href="Data.Sum.html#10640" class="Bound">x</a><a id="10641" class="Symbol">)</a> <a id="10643" class="Symbol">=</a> <a data-type="x ≡ x" id="10645" href="1Lab.Path.html#2137" class="Function">refl</a>

<a id="⊎-assoc"></a><a data-type="((A ⊎ B) ⊎ C) ≃ (A ⊎ B ⊎ C)" id="10651" href="Data.Sum.html#10651" class="Function">⊎-assoc</a> <a id="10659" class="Symbol">:</a> <a id="10661" class="Symbol">((</a><a id="10663" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="10665" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="10667" href="Data.Sum.html#760" class="Generalizable">B</a><a id="10668" class="Symbol">)</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="10670" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="10672" href="Data.Sum.html#762" class="Generalizable">C</a><a id="10673" class="Symbol">)</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="10675" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="10677" class="Symbol">(</a><a id="10678" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="10680" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="10682" class="Symbol">(</a><a id="10683" href="Data.Sum.html#760" class="Generalizable">B</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="10685" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="10687" href="Data.Sum.html#762" class="Generalizable">C</a><a id="10688" class="Symbol">))</a>
<a data-type="((A ⊎ B) ⊎ C) ≃ (A ⊎ B ⊎ C)" id="10691" href="Data.Sum.html#10651" class="Function">⊎-assoc</a> <a id="10699" class="Symbol">=</a> <a data-type="Iso A B → A ≃ B" id="10701" href="1Lab.Equiv.html#20090" class="Function">Iso→Equiv</a> <a id="10711" href="Data.Sum.html#10721" class="Function">i</a> <a id="10713" class="Keyword">where</a>
  <a id="10721" href="Data.Sum.html#10721" class="Function">i</a> <a id="10723" class="Symbol">:</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="10725" href="1Lab.Equiv.html#6241" class="Function">Iso</a> <a id="10729" class="Symbol">_</a> <a id="10731" class="Symbol">_</a>
  <a id="10735" href="Data.Sum.html#10721" class="Function">i</a> <a id="10737" class="Symbol">.</a><a data-type="∑ A B → A" id="10738" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10742" class="Symbol">(</a><a data-type="A → A ⊎ B" id="10743" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="10747" class="Symbol">(</a><a data-type="A → A ⊎ B" id="10748" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="10752" href="Data.Sum.html#10752" class="Bound">x</a><a id="10753" class="Symbol">))</a> <a id="10756" class="Symbol">=</a> <a data-type="A → A ⊎ B" id="10758" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="10762" href="Data.Sum.html#10752" class="Bound">x</a>
  <a id="10766" href="Data.Sum.html#10721" class="Function">i</a> <a id="10768" class="Symbol">.</a><a data-type="∑ A B → A" id="10769" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10773" class="Symbol">(</a><a data-type="A → A ⊎ B" id="10774" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="10778" class="Symbol">(</a><a data-type="B → A ⊎ B" id="10779" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="10783" href="Data.Sum.html#10783" class="Bound">x</a><a id="10784" class="Symbol">))</a> <a id="10787" class="Symbol">=</a> <a data-type="B → A ⊎ B" id="10789" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="10793" class="Symbol">(</a><a data-type="A → A ⊎ B" id="10794" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="10798" href="Data.Sum.html#10783" class="Bound">x</a><a id="10799" class="Symbol">)</a>
  <a id="10803" href="Data.Sum.html#10721" class="Function">i</a> <a id="10805" class="Symbol">.</a><a data-type="∑ A B → A" id="10806" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10810" class="Symbol">(</a><a data-type="B → A ⊎ B" id="10811" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="10815" href="Data.Sum.html#10815" class="Bound">x</a><a id="10816" class="Symbol">)</a>       <a id="10824" class="Symbol">=</a> <a data-type="B → A ⊎ B" id="10826" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="10830" class="Symbol">(</a><a data-type="B → A ⊎ B" id="10831" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="10835" href="Data.Sum.html#10815" class="Bound">x</a><a id="10836" class="Symbol">)</a>

  <a id="10841" href="Data.Sum.html#10721" class="Function">i</a> <a id="10843" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="10844" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10848" class="Symbol">.</a><a data-type="isIso f → B → A" id="10849" href="1Lab.Equiv.html#6080" class="Field">isIso.inv</a> <a id="10859" class="Symbol">(</a><a data-type="A → A ⊎ B" id="10860" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="10864" href="Data.Sum.html#10864" class="Bound">x</a><a id="10865" class="Symbol">)</a>       <a id="10873" class="Symbol">=</a> <a data-type="A → A ⊎ B" id="10875" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="10879" class="Symbol">(</a><a data-type="A → A ⊎ B" id="10880" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="10884" href="Data.Sum.html#10864" class="Bound">x</a><a id="10885" class="Symbol">)</a>
  <a id="10889" href="Data.Sum.html#10721" class="Function">i</a> <a id="10891" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="10892" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10896" class="Symbol">.</a><a data-type="isIso f → B → A" id="10897" href="1Lab.Equiv.html#6080" class="Field">isIso.inv</a> <a id="10907" class="Symbol">(</a><a data-type="B → A ⊎ B" id="10908" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="10912" class="Symbol">(</a><a data-type="A → A ⊎ B" id="10913" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="10917" href="Data.Sum.html#10917" class="Bound">x</a><a id="10918" class="Symbol">))</a> <a id="10921" class="Symbol">=</a> <a data-type="A → A ⊎ B" id="10923" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="10927" class="Symbol">(</a><a data-type="B → A ⊎ B" id="10928" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="10932" href="Data.Sum.html#10917" class="Bound">x</a><a id="10933" class="Symbol">)</a>
  <a id="10937" href="Data.Sum.html#10721" class="Function">i</a> <a id="10939" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="10940" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10944" class="Symbol">.</a><a data-type="isIso f → B → A" id="10945" href="1Lab.Equiv.html#6080" class="Field">isIso.inv</a> <a id="10955" class="Symbol">(</a><a data-type="B → A ⊎ B" id="10956" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="10960" class="Symbol">(</a><a data-type="B → A ⊎ B" id="10961" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="10965" href="Data.Sum.html#10965" class="Bound">x</a><a id="10966" class="Symbol">))</a> <a id="10969" class="Symbol">=</a> <a data-type="B → A ⊎ B" id="10971" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="10975" href="Data.Sum.html#10965" class="Bound">x</a>

  <a id="10980" href="Data.Sum.html#10721" class="Function">i</a> <a id="10982" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="10983" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10987" class="Symbol">.</a><a data-type="(r : isIso f) → isRightInverse (r .inv) f" id="10988" href="1Lab.Equiv.html#6096" class="Field">isIso.rinv</a> <a id="10999" class="Symbol">(</a><a data-type="A → A ⊎ B" id="11000" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="11004" href="Data.Sum.html#11004" class="Bound">x</a><a id="11005" class="Symbol">)</a> <a id="11007" class="Symbol">=</a> <a data-type="x ≡ x" id="11009" href="1Lab.Path.html#2137" class="Function">refl</a>
  <a id="11016" href="Data.Sum.html#10721" class="Function">i</a> <a id="11018" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11019" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11023" class="Symbol">.</a><a data-type="(r : isIso f) → isRightInverse (r .inv) f" id="11024" href="1Lab.Equiv.html#6096" class="Field">isIso.rinv</a> <a id="11035" class="Symbol">(</a><a data-type="B → A ⊎ B" id="11036" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="11040" class="Symbol">(</a><a data-type="A → A ⊎ B" id="11041" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="11045" href="Data.Sum.html#11045" class="Bound">x</a><a id="11046" class="Symbol">))</a> <a id="11049" class="Symbol">=</a> <a data-type="x ≡ x" id="11051" href="1Lab.Path.html#2137" class="Function">refl</a>
  <a id="11058" href="Data.Sum.html#10721" class="Function">i</a> <a id="11060" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11061" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11065" class="Symbol">.</a><a data-type="(r : isIso f) → isRightInverse (r .inv) f" id="11066" href="1Lab.Equiv.html#6096" class="Field">isIso.rinv</a> <a id="11077" class="Symbol">(</a><a data-type="B → A ⊎ B" id="11078" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="11082" class="Symbol">(</a><a data-type="B → A ⊎ B" id="11083" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="11087" href="Data.Sum.html#11087" class="Bound">x</a><a id="11088" class="Symbol">))</a> <a id="11091" class="Symbol">=</a> <a data-type="x ≡ x" id="11093" href="1Lab.Path.html#2137" class="Function">refl</a>

  <a id="11101" href="Data.Sum.html#10721" class="Function">i</a> <a id="11103" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11104" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11108" class="Symbol">.</a><a data-type="(r : isIso f) → isLeftInverse (r .inv) f" id="11109" href="1Lab.Equiv.html#6128" class="Field">isIso.linv</a> <a id="11120" class="Symbol">(</a><a data-type="A → A ⊎ B" id="11121" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="11125" class="Symbol">(</a><a data-type="A → A ⊎ B" id="11126" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="11130" href="Data.Sum.html#11130" class="Bound">x</a><a id="11131" class="Symbol">))</a> <a id="11134" class="Symbol">=</a> <a data-type="x ≡ x" id="11136" href="1Lab.Path.html#2137" class="Function">refl</a>
  <a id="11143" href="Data.Sum.html#10721" class="Function">i</a> <a id="11145" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11146" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11150" class="Symbol">.</a><a data-type="(r : isIso f) → isLeftInverse (r .inv) f" id="11151" href="1Lab.Equiv.html#6128" class="Field">isIso.linv</a> <a id="11162" class="Symbol">(</a><a data-type="A → A ⊎ B" id="11163" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="11167" class="Symbol">(</a><a data-type="B → A ⊎ B" id="11168" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="11172" href="Data.Sum.html#11172" class="Bound">x</a><a id="11173" class="Symbol">))</a> <a id="11176" class="Symbol">=</a> <a data-type="x ≡ x" id="11178" href="1Lab.Path.html#2137" class="Function">refl</a>
  <a id="11185" href="Data.Sum.html#10721" class="Function">i</a> <a id="11187" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11188" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11192" class="Symbol">.</a><a data-type="(r : isIso f) → isLeftInverse (r .inv) f" id="11193" href="1Lab.Equiv.html#6128" class="Field">isIso.linv</a> <a id="11204" class="Symbol">(</a><a data-type="B → A ⊎ B" id="11205" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="11209" href="Data.Sum.html#11209" class="Bound">x</a><a id="11210" class="Symbol">)</a> <a id="11212" class="Symbol">=</a> <a data-type="x ≡ x" id="11214" href="1Lab.Path.html#2137" class="Function">refl</a>

<a id="⊎-zeroʳ"></a><a data-type="(A ⊎ ⊥) ≃ A" id="11220" href="Data.Sum.html#11220" class="Function">⊎-zeroʳ</a> <a id="11228" class="Symbol">:</a> <a id="11230" class="Symbol">(</a><a id="11231" href="Data.Sum.html#758" class="Generalizable">A</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="11233" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a data-type="Type" id="11235" href="1Lab.Type.html#1326" class="Datatype">⊥</a><a id="11236" class="Symbol">)</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="11238" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="11240" href="Data.Sum.html#758" class="Generalizable">A</a>
<a data-type="(A ⊎ ⊥) ≃ A" id="11242" href="Data.Sum.html#11220" class="Function">⊎-zeroʳ</a> <a id="11250" class="Symbol">.</a><a data-type="∑ A B → A" id="11251" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="11255" class="Symbol">(</a><a data-type="A → A ⊎ B" id="11256" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="11260" href="Data.Sum.html#11260" class="Bound">x</a><a id="11261" class="Symbol">)</a> <a id="11263" class="Symbol">=</a> <a id="11265" href="Data.Sum.html#11260" class="Bound">x</a>
<a data-type="(A ⊎ ⊥) ≃ A" id="11267" href="Data.Sum.html#11220" class="Function">⊎-zeroʳ</a> <a id="11275" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11276" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11280" class="Symbol">.</a><a data-type="isEquiv f → (y : B) → isContr (fibre f y)" id="11281" href="1Lab.Equiv.html#2382" class="Field">isEqv</a> <a id="11287" href="Data.Sum.html#11287" class="Bound">y</a> <a id="11289" class="Symbol">.</a><a data-type="isContr A → A" id="11290" href="1Lab.HLevel.html#1400" class="Field">centre</a> <a id="11297" class="Symbol">=</a> <a data-type="A → A ⊎ B" id="11299" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="11303" href="Data.Sum.html#11287" class="Bound">y</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="11305" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="x ≡ x" id="11307" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(A ⊎ ⊥) ≃ A" id="11312" href="Data.Sum.html#11220" class="Function">⊎-zeroʳ</a> <a id="11320" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11321" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11325" class="Symbol">.</a><a data-type="isEquiv f → (y : B) → isContr (fibre f y)" id="11326" href="1Lab.Equiv.html#2382" class="Field">isEqv</a> <a id="11332" href="Data.Sum.html#11332" class="Bound">y</a> <a id="11334" class="Symbol">.</a><a data-type="(r : isContr A) (x : A) → r .centre ≡ x" id="11335" href="1Lab.HLevel.html#1415" class="Field">paths</a> <a id="11341" class="Symbol">(</a><a data-type="A → A ⊎ B" id="11342" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="11346" href="Data.Sum.html#11346" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="11348" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="11350" href="Data.Sum.html#11350" class="Bound">p</a><a id="11351" class="Symbol">)</a> <a id="11353" href="Data.Sum.html#11353" class="Bound">i</a> <a id="11355" class="Symbol">=</a> <a data-type="A → A ⊎ B" id="11357" href="Data.Sum.html#670" class="InductiveConstructor">inl</a> <a id="11361" class="Symbol">(</a><a id="11362" href="Data.Sum.html#11350" class="Bound">p</a> <a id="11364" class="Symbol">(</a><a id="11365" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="11367" href="Data.Sum.html#11353" class="Bound">i</a><a id="11368" class="Symbol">))</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="11371" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="11373" class="Symbol">λ</a> <a id="11375" href="Data.Sum.html#11375" class="Bound">j</a> <a id="11377" class="Symbol">→</a> <a id="11379" href="Data.Sum.html#11350" class="Bound">p</a> <a id="11381" class="Symbol">(</a><a id="11382" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="11384" href="Data.Sum.html#11353" class="Bound">i</a> <a id="11386" href="1Lab.Path.html#765" class="Primitive Operator">∨</a> <a id="11388" href="Data.Sum.html#11375" class="Bound">j</a><a id="11389" class="Symbol">)</a>

<a id="⊎-zeroˡ"></a><a data-type="(⊥ ⊎ A) ≃ A" id="11392" href="Data.Sum.html#11392" class="Function">⊎-zeroˡ</a> <a id="11400" class="Symbol">:</a> <a id="11402" class="Symbol">(</a><a data-type="Type" id="11403" href="1Lab.Type.html#1326" class="Datatype">⊥</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="11405" href="Data.Sum.html#611" class="Datatype Operator">⊎</a> <a id="11407" href="Data.Sum.html#758" class="Generalizable">A</a><a id="11408" class="Symbol">)</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="11410" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="11412" href="Data.Sum.html#758" class="Generalizable">A</a>
<a data-type="(⊥ ⊎ A) ≃ A" id="11414" href="Data.Sum.html#11392" class="Function">⊎-zeroˡ</a> <a id="11422" class="Symbol">.</a><a data-type="∑ A B → A" id="11423" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="11427" class="Symbol">(</a><a data-type="B → A ⊎ B" id="11428" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="11432" href="Data.Sum.html#11432" class="Bound">x</a><a id="11433" class="Symbol">)</a> <a id="11435" class="Symbol">=</a> <a id="11437" href="Data.Sum.html#11432" class="Bound">x</a>
<a data-type="(⊥ ⊎ A) ≃ A" id="11439" href="Data.Sum.html#11392" class="Function">⊎-zeroˡ</a> <a id="11447" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11448" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11452" class="Symbol">.</a><a data-type="isEquiv f → (y : B) → isContr (fibre f y)" id="11453" href="1Lab.Equiv.html#2382" class="Field">isEqv</a> <a id="11459" href="Data.Sum.html#11459" class="Bound">y</a> <a id="11461" class="Symbol">.</a><a data-type="isContr A → A" id="11462" href="1Lab.HLevel.html#1400" class="Field">centre</a> <a id="11469" class="Symbol">=</a> <a data-type="B → A ⊎ B" id="11471" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="11475" href="Data.Sum.html#11459" class="Bound">y</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="11477" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="x ≡ x" id="11479" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(⊥ ⊎ A) ≃ A" id="11484" href="Data.Sum.html#11392" class="Function">⊎-zeroˡ</a> <a id="11492" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11493" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11497" class="Symbol">.</a><a data-type="isEquiv f → (y : B) → isContr (fibre f y)" id="11498" href="1Lab.Equiv.html#2382" class="Field">isEqv</a> <a id="11504" href="Data.Sum.html#11504" class="Bound">y</a> <a id="11506" class="Symbol">.</a><a data-type="(r : isContr A) (x : A) → r .centre ≡ x" id="11507" href="1Lab.HLevel.html#1415" class="Field">paths</a> <a id="11513" class="Symbol">(</a><a data-type="B → A ⊎ B" id="11514" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="11518" href="Data.Sum.html#11518" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="11520" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="11522" href="Data.Sum.html#11522" class="Bound">p</a><a id="11523" class="Symbol">)</a> <a id="11525" href="Data.Sum.html#11525" class="Bound">i</a> <a id="11527" class="Symbol">=</a> <a data-type="B → A ⊎ B" id="11529" href="Data.Sum.html#688" class="InductiveConstructor">inr</a> <a id="11533" class="Symbol">(</a><a id="11534" href="Data.Sum.html#11522" class="Bound">p</a> <a id="11536" class="Symbol">(</a><a id="11537" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="11539" href="Data.Sum.html#11525" class="Bound">i</a><a id="11540" class="Symbol">))</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="11543" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="11545" class="Symbol">λ</a> <a id="11547" href="Data.Sum.html#11547" class="Bound">j</a> <a id="11549" class="Symbol">→</a> <a id="11551" href="Data.Sum.html#11522" class="Bound">p</a> <a id="11553" class="Symbol">(</a><a id="11554" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="11556" href="Data.Sum.html#11525" class="Bound">i</a> <a id="11558" href="1Lab.Path.html#765" class="Primitive Operator">∨</a> <a id="11560" href="Data.Sum.html#11547" class="Bound">j</a><a id="11561" class="Symbol">)</a>
</pre>
  </article>
</div>

</main>
</body>
<style>.equations { display: none !important; }</style></html>