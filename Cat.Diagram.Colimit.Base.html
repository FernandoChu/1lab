<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>Cat.Diagram.Colimit.Base - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />
  <link rel="stylesheet" href="/css/agda-cats.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Cat.Diagram.Colimit.Base - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="Cat.Diagram.Colimit.Base - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script src="/equations.js"></script>
  <script src="/highlight-hover.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

  <!-- Google font embeds -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&amp;family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&amp;display=swap" rel="stylesheet">
</head>

<body>
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">Cat.Diagram.Colimit.Base</a>
              </h3>

      <!-- Cube logo -->
      <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#idea"><a href="#idea" class="header-link">Idea<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#construction"><a href="#construction" class="header-link">Construction<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#cocone-maps"><a href="#cocone-maps" class="header-link">Cocone Maps<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#colimits"><a href="#colimits" class="header-link">Colimits<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#preservation-of-colimits"><a href="#preservation-of-colimits" class="header-link">Preservation of Colimits<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#cocompleteness"><a href="#cocompleteness" class="header-link">Cocompleteness<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
              <a href="index.html">️back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/998be50f8f59a0b1934fd8206f579b8622fde202/src/Cat/Diagram/Colimit/Base.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao and Reed Mullanix</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="index.html">️back to index</a>
      </div>
      
      <!-- Font toggle checkbox -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="Cat.Diagram.Initial.html" class="Module">Cat.Diagram.Initial</a>
<a id="41" class="Keyword">open</a> <a id="46" class="Keyword">import</a> <a id="53" href="Cat.Prelude.html" class="Module">Cat.Prelude</a>

<a id="66" class="Keyword">import</a> <a id="73" href="Cat.Morphism.html" class="Module">Cat.Morphism</a>

<a id="87" class="Keyword">module</a> <a id="94" href="Cat.Diagram.Colimit.Base.html" class="Module">Cat.Diagram.Colimit.Base</a> <a id="119" class="Keyword">where</a>
</pre>
<!--
<pre class="Agda"><a id="143" class="Keyword">private</a> <a id="151" class="Keyword">variable</a>
  <a id="162" href="Cat.Diagram.Colimit.Base.html#162" class="Generalizable">o</a> <a id="164" href="Cat.Diagram.Colimit.Base.html#164" class="Generalizable">ℓ</a> <a id="166" href="Cat.Diagram.Colimit.Base.html#166" class="Generalizable">o′</a> <a id="169" href="Cat.Diagram.Colimit.Base.html#169" class="Generalizable">ℓ′</a> <a id="172" class="Symbol">:</a> <a id="174" href="Agda.Primitive.html#597" class="Postulate">Level</a>
</pre>-->
<h1 id="idea"><a href="#idea" class="header-link">Idea<span class="header-link-emoji">🔗</span></a></h1>
<p>Colimits are dual to limits <a href="Cat.Diagram.Limit.Base.html">limit</a>; much like their cousins, they generalize constructions in several settings to arbitrary categories. A colimit (if it exists), is the “best solution” to an “identification problem”. This is in contrast to the limit, which acts as a solution to an “equational problem”.</p>
<h1 id="construction"><a href="#construction" class="header-link">Construction<span class="header-link-emoji">🔗</span></a></h1>
<p>Every concrete colimit (<a href="Cat.Diagra.Coproduct">coproducts</a>, <a href="Cat.Diagra.Coequaliser">coequalisers</a>, <a href="Cat.Diagra.Initial">initial objects</a>) we have seen so far consists of roughly the same data. We begin with some collection of objects and morphisms, and then state that the colimit of that collection is some object with a universal property relating all of those objects and morphisms.</p>
<p>It would be convienent to be able to talk about <em>all</em> of these situations at once, as opposed to on a case-by-case basis. To do this, we need to introduce a bit of categorical machinery: the Cocone.</p>
<p>The first step is to generalize the “collection of objects and morphisms” involved. Luckily, this step involves no new ideas, just a change in perspective. We already have a way of describing a collection of objects and morphisms: it’s a category! As an example, the starting data of a coproduct is a pair of objects, which can be thought of as a very simple category, with only identity morphisms.</p>
<div class="diagram-container">
<img src="456f1760f1961d4382237acb757e2adbcf467813.svg" title="commutative diagram" class="diagram quiver short-2" />
</div>
<p>The next step also involves nothing more than a change in perspective. Let’s denote our “diagram” category from earlier as <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi></mrow><annotation encoding="application/x-tex">J</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span></span></span></span>.</span> Then, a means of picking out a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi></mrow><annotation encoding="application/x-tex">J</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span></span></span></span> shaped figure in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> is… a functor <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi>J</mi><mo>→</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">F : J \to C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>!</span> Going back to the coproduct example, a functor from our 2 object category into <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> selects 2 (not necessarily distinct!) objects in <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>.</span> We this pair of category and functor a <em>diagram</em> in <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>.</span></p>
<pre class="Agda"><a id="2075" class="Keyword">module</a> <a id="2082" href="Cat.Diagram.Colimit.Base.html#2082" class="Module">_</a> <a id="2084" class="Symbol">{</a><a id="2085" href="Cat.Diagram.Colimit.Base.html#2085" class="Bound">J</a> <a id="2087" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="2089" href="Cat.Base.html#704" class="Record">Precategory</a> <a id="2101" href="Cat.Diagram.Colimit.Base.html#162" class="Generalizable">o</a> <a id="2103" href="Cat.Diagram.Colimit.Base.html#164" class="Generalizable">ℓ</a><a id="2104" class="Symbol">}</a> <a id="2106" class="Symbol">{</a><a id="2107" href="Cat.Diagram.Colimit.Base.html#2107" class="Bound">C</a> <a id="2109" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="2111" href="Cat.Base.html#704" class="Record">Precategory</a> <a id="2123" href="Cat.Diagram.Colimit.Base.html#166" class="Generalizable">o′</a> <a id="2126" href="Cat.Diagram.Colimit.Base.html#169" class="Generalizable">ℓ′</a><a id="2128" class="Symbol">}</a> <a id="2130" class="Symbol">(</a><a id="2131" href="Cat.Diagram.Colimit.Base.html#2131" class="Bound">F</a> <a id="2133" class="Symbol">:</a> <a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="2135" href="Cat.Base.html#7206" class="Record">Functor</a> <a id="2143" href="Cat.Diagram.Colimit.Base.html#2085" class="Bound">J</a> <a id="2145" href="Cat.Diagram.Colimit.Base.html#2107" class="Bound">C</a><a id="2146" class="Symbol">)</a> <a id="2148" class="Keyword">where</a>
  <a id="2156" class="Keyword">private</a>
    <a id="2168" class="Keyword">import</a> <a id="2175" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="2189" href="Cat.Diagram.Colimit.Base.html#2085" class="Bound">J</a> as <a id="2194" href="Cat.Diagram.Colimit.Base.html#2194" class="Module">J</a>
    <a id="2200" class="Keyword">import</a> <a id="2207" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="2221" href="Cat.Diagram.Colimit.Base.html#2107" class="Bound">C</a> as <a id="2226" href="Cat.Diagram.Colimit.Base.html#2226" class="Module">C</a>
    <a id="2232" class="Keyword">module</a> <a id="2239" href="Cat.Diagram.Colimit.Base.html#2239" class="Module">F</a> <a id="2241" class="Symbol">=</a> <a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="2243" href="Cat.Base.html#7206" class="Module">Functor</a> <a id="2251" href="Cat.Diagram.Colimit.Base.html#2131" class="Bound">F</a>

  <a id="2256" class="Keyword">record</a> <a data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" id="2263" href="Cat.Diagram.Colimit.Base.html#2263" class="Record">Cocone</a> <a id="2270" class="Symbol">:</a> <a id="2272" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2277" class="Symbol">(</a><a id="2278" href="Cat.Diagram.Colimit.Base.html#2101" class="Bound">o</a> <a data-type="Level → Level → Level" id="2280" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="2282" href="Cat.Diagram.Colimit.Base.html#2103" class="Bound">ℓ</a> <a data-type="Level → Level → Level" id="2284" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="2286" href="Cat.Diagram.Colimit.Base.html#2123" class="Bound">o′</a> <a data-type="Level → Level → Level" id="2289" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="2291" href="Cat.Diagram.Colimit.Base.html#2126" class="Bound">ℓ′</a><a id="2293" class="Symbol">)</a> <a id="2295" class="Keyword">where</a>
    <a id="2305" class="Keyword">no-eta-equality</a>
    <a id="2325" class="Keyword">constructor</a> <a data-type="(coapex : C .Ob) (ψ : (x : J₁ .Ob) → C .Hom (₀ F x) coapex)
(commutes : (f : J₁ .Hom x y) → C ._∘_ (ψ y) (₁ F f) ≡ ψ x) →
Cocone F" id="2337" href="Cat.Diagram.Colimit.Base.html#2337" class="InductiveConstructor">cocone</a>
</pre>
<p>Now, for the actual machinery! If we want to capture the essence of all of our concrete examples of colimits, we a notion of an object equipped with maps <em>from</em> every object in our diagram. We call this designated object the “coapex” of the cocone.</p>
<pre class="Agda">    <a id="2612" class="Keyword">field</a>
      <a data-type="Cocone F → C .Ob" id="2624" href="Cat.Diagram.Colimit.Base.html#2624" class="Field">coapex</a> <a id="2631" class="Symbol">:</a> <a data-type="Precategory o h → Type o" id="2633" href="Cat.Base.html#1419" class="Function">C.Ob</a>
      <a data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" id="2644" href="Cat.Diagram.Colimit.Base.html#2644" class="Field">ψ</a>      <a id="2651" class="Symbol">:</a> <a id="2653" class="Symbol">(</a><a id="2654" href="Cat.Diagram.Colimit.Base.html#2654" class="Bound">x</a> <a id="2656" class="Symbol">:</a> <a data-type="Precategory o h → Type o" id="2658" href="Cat.Base.html#1419" class="Function">J.Ob</a><a id="2662" class="Symbol">)</a> <a id="2664" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="2666" href="Cat.Base.html#1436" class="Function">C.Hom</a> <a id="2672" class="Symbol">(</a><a data-type="(r : Functor C D) → C .Ob → D .Ob" id="2673" href="Cat.Base.html#8727" class="Function">F.₀</a> <a id="2677" href="Cat.Diagram.Colimit.Base.html#2654" class="Bound">x</a><a id="2678" class="Symbol">)</a> <a data-type="Cocone F → C .Ob" id="2680" href="Cat.Diagram.Colimit.Base.html#2624" class="Field">coapex</a>
</pre>
<p>If our diagram consisted of only objects, we would be done! However, some diagrams contan non-identity morphisms, so we need to take those into account as well. This bit is best understood through the lens of the coequaliser: in order to describe the commuting condition there, we want every injection map from the codomain of a morphism to factor through that morphism.</p>
<pre class="Agda">      <a data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" id="3078" href="Cat.Diagram.Colimit.Base.html#3078" class="Field">commutes</a> <a id="3087" class="Symbol">:</a> <a id="3089" class="Symbol">∀</a> <a id="3091" class="Symbol">{</a><a id="3092" href="Cat.Diagram.Colimit.Base.html#3092" class="Bound">x</a> <a id="3094" href="Cat.Diagram.Colimit.Base.html#3094" class="Bound">y</a><a id="3095" class="Symbol">}</a> <a id="3097" class="Symbol">(</a><a id="3098" href="Cat.Diagram.Colimit.Base.html#3098" class="Bound">f</a> <a id="3100" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="3102" href="Cat.Base.html#1436" class="Function">J.Hom</a> <a id="3108" href="Cat.Diagram.Colimit.Base.html#3092" class="Bound">x</a> <a id="3110" href="Cat.Diagram.Colimit.Base.html#3094" class="Bound">y</a><a id="3111" class="Symbol">)</a> <a id="3113" class="Symbol">→</a> <a data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" id="3115" href="Cat.Diagram.Colimit.Base.html#2644" class="Field">ψ</a> <a id="3117" href="Cat.Diagram.Colimit.Base.html#3094" class="Bound">y</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3119" href="Cat.Base.html#3006" class="Function Operator">C.∘</a> <a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="3123" href="Cat.Base.html#8808" class="Function">F.₁</a> <a id="3127" href="Cat.Diagram.Colimit.Base.html#3098" class="Bound">f</a> <a data-type="A → A → Type ℓ" id="3129" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" id="3131" href="Cat.Diagram.Colimit.Base.html#2644" class="Field">ψ</a> <a id="3133" href="Cat.Diagram.Colimit.Base.html#3092" class="Bound">x</a>
</pre>
<p>As per usual, we define a helper lemma charaterizing the path space of cones:</p>
<pre class="Agda">  <a id="3229" class="Keyword">open</a> <a data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" id="3234" href="Cat.Diagram.Colimit.Base.html#2263" class="Module">Cocone</a>

  <a data-type="(F : Functor J₁ C) (p : coapex x ≡ coapex y) →
((o : J₁ .Ob) →
 PathP (λ i → C .Hom (₀ F o) (p i)) (ψ x o) (ψ y o)) →
x ≡ y" id="3244" href="Cat.Diagram.Colimit.Base.html#3244" class="Function">Cocone-path</a> <a id="3256" class="Symbol">:</a> <a id="3258" class="Symbol">{</a><a id="3259" href="Cat.Diagram.Colimit.Base.html#3259" class="Bound">x</a> <a id="3261" href="Cat.Diagram.Colimit.Base.html#3261" class="Bound">y</a> <a id="3263" class="Symbol">:</a> <a data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" id="3265" href="Cat.Diagram.Colimit.Base.html#2263" class="Record">Cocone</a><a id="3271" class="Symbol">}</a>
              <a id="3287" class="Symbol">→</a> <a id="3289" class="Symbol">(</a><a id="3290" href="Cat.Diagram.Colimit.Base.html#3290" class="Bound">p</a> <a id="3292" class="Symbol">:</a> <a data-type="Cocone F → C .Ob" id="3294" href="Cat.Diagram.Colimit.Base.html#2624" class="Field">coapex</a> <a id="3301" href="Cat.Diagram.Colimit.Base.html#3259" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="3303" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Cocone F → C .Ob" id="3305" href="Cat.Diagram.Colimit.Base.html#2624" class="Field">coapex</a> <a id="3312" href="Cat.Diagram.Colimit.Base.html#3261" class="Bound">y</a><a id="3313" class="Symbol">)</a>
              <a id="3329" class="Symbol">→</a> <a id="3331" class="Symbol">(∀</a> <a id="3334" href="Cat.Diagram.Colimit.Base.html#3334" class="Bound">o</a> <a id="3336" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="3338" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="3344" class="Symbol">(λ</a> <a id="3347" href="Cat.Diagram.Colimit.Base.html#3347" class="Bound">i</a> <a id="3349" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="3351" href="Cat.Base.html#1436" class="Function">C.Hom</a> <a id="3357" class="Symbol">(</a><a data-type="(r : Functor C D) → C .Ob → D .Ob" id="3358" href="Cat.Base.html#8727" class="Function">F.₀</a> <a id="3362" href="Cat.Diagram.Colimit.Base.html#3334" class="Bound">o</a><a id="3363" class="Symbol">)</a> <a id="3365" class="Symbol">(</a><a id="3366" href="Cat.Diagram.Colimit.Base.html#3290" class="Bound">p</a> <a id="3368" href="Cat.Diagram.Colimit.Base.html#3347" class="Bound">i</a><a id="3369" class="Symbol">))</a> <a id="3372" class="Symbol">(</a><a data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" id="3373" href="Cat.Diagram.Colimit.Base.html#2644" class="Field">ψ</a> <a id="3375" href="Cat.Diagram.Colimit.Base.html#3259" class="Bound">x</a> <a id="3377" href="Cat.Diagram.Colimit.Base.html#3334" class="Bound">o</a><a id="3378" class="Symbol">)</a> <a id="3380" class="Symbol">(</a><a data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" id="3381" href="Cat.Diagram.Colimit.Base.html#2644" class="Field">ψ</a> <a id="3383" href="Cat.Diagram.Colimit.Base.html#3261" class="Bound">y</a> <a id="3385" href="Cat.Diagram.Colimit.Base.html#3334" class="Bound">o</a><a id="3386" class="Symbol">))</a>
              <a id="3403" class="Symbol">→</a> <a id="3405" href="Cat.Diagram.Colimit.Base.html#3259" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="3407" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="3409" href="Cat.Diagram.Colimit.Base.html#3261" class="Bound">y</a>
  <a data-type="(F : Functor J₁ C) (p : coapex x ≡ coapex y) →
((o : J₁ .Ob) →
 PathP (λ i → C .Hom (₀ F o) (p i)) (ψ x o) (ψ y o)) →
x ≡ y" id="3413" href="Cat.Diagram.Colimit.Base.html#3244" class="Function">Cocone-path</a> <a id="3425" href="Cat.Diagram.Colimit.Base.html#3425" class="Bound">p</a> <a id="3427" href="Cat.Diagram.Colimit.Base.html#3427" class="Bound">q</a> <a id="3429" href="Cat.Diagram.Colimit.Base.html#3429" class="Bound">i</a> <a id="3431" class="Symbol">.</a><a data-type="Cocone F → C .Ob" id="3432" href="Cat.Diagram.Colimit.Base.html#2624" class="Field">coapex</a> <a id="3439" class="Symbol">=</a> <a id="3441" href="Cat.Diagram.Colimit.Base.html#3425" class="Bound">p</a> <a id="3443" href="Cat.Diagram.Colimit.Base.html#3429" class="Bound">i</a>
  <a data-type="(F : Functor J₁ C) (p : coapex x ≡ coapex y) →
((o : J₁ .Ob) →
 PathP (λ i → C .Hom (₀ F o) (p i)) (ψ x o) (ψ y o)) →
x ≡ y" id="3447" href="Cat.Diagram.Colimit.Base.html#3244" class="Function">Cocone-path</a> <a id="3459" href="Cat.Diagram.Colimit.Base.html#3459" class="Bound">p</a> <a id="3461" href="Cat.Diagram.Colimit.Base.html#3461" class="Bound">q</a> <a id="3463" href="Cat.Diagram.Colimit.Base.html#3463" class="Bound">i</a> <a id="3465" class="Symbol">.</a><a data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" id="3466" href="Cat.Diagram.Colimit.Base.html#2644" class="Field">ψ</a> <a id="3468" href="Cat.Diagram.Colimit.Base.html#3468" class="Bound">o</a> <a id="3470" class="Symbol">=</a> <a id="3472" href="Cat.Diagram.Colimit.Base.html#3461" class="Bound">q</a> <a id="3474" href="Cat.Diagram.Colimit.Base.html#3468" class="Bound">o</a> <a id="3476" href="Cat.Diagram.Colimit.Base.html#3463" class="Bound">i</a>
  <a data-type="(F : Functor J₁ C) (p : coapex x ≡ coapex y) →
((o : J₁ .Ob) →
 PathP (λ i → C .Hom (₀ F o) (p i)) (ψ x o) (ψ y o)) →
x ≡ y" id="3480" href="Cat.Diagram.Colimit.Base.html#3244" class="Function">Cocone-path</a> <a id="3492" class="Symbol">{</a><a id="3493" class="Argument">x</a> <a id="3495" class="Symbol">=</a> <a id="3497" href="Cat.Diagram.Colimit.Base.html#3497" class="Bound">x</a><a id="3498" class="Symbol">}</a> <a id="3500" class="Symbol">{</a><a id="3501" class="Argument">y</a> <a id="3503" class="Symbol">=</a> <a id="3505" href="Cat.Diagram.Colimit.Base.html#3505" class="Bound">y</a><a id="3506" class="Symbol">}</a> <a id="3508" href="Cat.Diagram.Colimit.Base.html#3508" class="Bound">p</a> <a id="3510" href="Cat.Diagram.Colimit.Base.html#3510" class="Bound">q</a> <a id="3512" href="Cat.Diagram.Colimit.Base.html#3512" class="Bound">i</a> <a id="3514" class="Symbol">.</a><a data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" id="3515" href="Cat.Diagram.Colimit.Base.html#3078" class="Field">commutes</a> <a id="3524" class="Symbol">{</a><a id="3525" class="Argument">x</a> <a id="3527" class="Symbol">=</a> <a id="3529" href="Cat.Diagram.Colimit.Base.html#3529" class="Bound">a</a><a id="3530" class="Symbol">}</a> <a id="3532" class="Symbol">{</a><a id="3533" class="Argument">y</a> <a id="3535" class="Symbol">=</a> <a id="3537" href="Cat.Diagram.Colimit.Base.html#3537" class="Bound">b</a><a id="3538" class="Symbol">}</a> <a id="3540" href="Cat.Diagram.Colimit.Base.html#3540" class="Bound">f</a> <a id="3542" class="Symbol">=</a>
    <a data-type="((i : I) → is-prop (B₁ i)) →
(b0 : B₁ i0) (b1 : B₁ i1) → PathP B₁ b0 b1" id="3548" href="1Lab.HLevel.html#13498" class="Function">is-prop→pathp</a> <a id="3562" class="Symbol">(λ</a> <a id="3565" href="Cat.Diagram.Colimit.Base.html#3565" class="Bound">i</a> <a id="3567" class="Symbol">→</a> <a data-type="(r : Precategory o h) (x y : r .Ob) → is-set (r .Hom x y)" id="3569" href="Cat.Base.html#1784" class="Function">C.Hom-set</a> <a id="3579" class="Symbol">_</a> <a id="3581" class="Symbol">_</a> <a id="3583" class="Symbol">(</a><a id="3584" href="Cat.Diagram.Colimit.Base.html#3510" class="Bound">q</a> <a id="3586" href="Cat.Diagram.Colimit.Base.html#3537" class="Bound">b</a> <a id="3588" href="Cat.Diagram.Colimit.Base.html#3565" class="Bound">i</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3590" href="Cat.Base.html#3006" class="Function Operator">C.∘</a> <a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="3594" href="Cat.Base.html#8808" class="Function">F.₁</a> <a id="3598" href="Cat.Diagram.Colimit.Base.html#3540" class="Bound">f</a><a id="3599" class="Symbol">)</a> <a id="3601" class="Symbol">(</a><a id="3602" href="Cat.Diagram.Colimit.Base.html#3510" class="Bound">q</a> <a id="3604" href="Cat.Diagram.Colimit.Base.html#3529" class="Bound">a</a> <a id="3606" href="Cat.Diagram.Colimit.Base.html#3565" class="Bound">i</a><a id="3607" class="Symbol">))</a>
      <a id="3616" class="Symbol">(</a><a id="3617" href="Cat.Diagram.Colimit.Base.html#3497" class="Bound">x</a> <a id="3619" class="Symbol">.</a><a data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" id="3620" href="Cat.Diagram.Colimit.Base.html#3078" class="Field">commutes</a> <a id="3629" href="Cat.Diagram.Colimit.Base.html#3540" class="Bound">f</a><a id="3630" class="Symbol">)</a> <a id="3632" class="Symbol">(</a><a id="3633" href="Cat.Diagram.Colimit.Base.html#3505" class="Bound">y</a> <a id="3635" class="Symbol">.</a><a data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" id="3636" href="Cat.Diagram.Colimit.Base.html#3078" class="Field">commutes</a> <a id="3645" href="Cat.Diagram.Colimit.Base.html#3540" class="Bound">f</a><a id="3646" class="Symbol">)</a> <a id="3648" href="Cat.Diagram.Colimit.Base.html#3512" class="Bound">i</a>
</pre>
<h2 id="cocone-maps"><a href="#cocone-maps" class="header-link">Cocone Maps<span class="header-link-emoji">🔗</span></a></h2>
<p>Now that we’ve defined cocones, we need a way to figure out how to express universal properties. Like most things categorical, we begin by considering a “cocone morphism”, which will give us a category that we can work within. The idea here is that a morphism of cocones is a morphism in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> between the coapicies, such that all of the injection maps commute.</p>
<pre class="Agda">  <a id="4042" class="Keyword">record</a> <a data-type="(F : Functor J₁ C) (x y : Cocone F) → Type (o ⊔ ℓ′)" id="4049" href="Cat.Diagram.Colimit.Base.html#4049" class="Record">Cocone-hom</a> <a id="4060" class="Symbol">(</a><a id="4061" href="Cat.Diagram.Colimit.Base.html#4061" class="Bound">x</a> <a id="4063" href="Cat.Diagram.Colimit.Base.html#4063" class="Bound">y</a> <a id="4065" class="Symbol">:</a> <a data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" id="4067" href="Cat.Diagram.Colimit.Base.html#2263" class="Record">Cocone</a><a id="4073" class="Symbol">)</a> <a id="4075" class="Symbol">:</a> <a id="4077" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="4082" class="Symbol">(</a><a id="4083" href="Cat.Diagram.Colimit.Base.html#2101" class="Bound">o</a> <a data-type="Level → Level → Level" id="4085" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="4087" href="Cat.Diagram.Colimit.Base.html#2126" class="Bound">ℓ′</a><a id="4089" class="Symbol">)</a> <a id="4091" class="Keyword">where</a>
    <a id="4101" class="Keyword">no-eta-equality</a>
    <a id="4121" class="Keyword">constructor</a> <a data-type="(hom : C .Hom (x .coapex) (y .coapex))
(commutes : (o : J₁ .Ob) → C ._∘_ hom (x .ψ o) ≡ y .ψ o) →
Cocone-hom F x y" id="4133" href="Cat.Diagram.Colimit.Base.html#4133" class="InductiveConstructor">cocone-hom</a>
    <a id="4148" class="Keyword">field</a>
      <a data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" id="4160" href="Cat.Diagram.Colimit.Base.html#4160" class="Field">hom</a> <a id="4164" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="4166" href="Cat.Base.html#1436" class="Function">C.Hom</a> <a id="4172" class="Symbol">(</a><a id="4173" href="Cat.Diagram.Colimit.Base.html#4061" class="Bound">x</a> <a id="4175" class="Symbol">.</a><a data-type="Cocone F → C .Ob" id="4176" href="Cat.Diagram.Colimit.Base.html#2624" class="Field">coapex</a><a id="4182" class="Symbol">)</a> <a id="4184" class="Symbol">(</a><a id="4185" href="Cat.Diagram.Colimit.Base.html#4063" class="Bound">y</a> <a id="4187" class="Symbol">.</a><a data-type="Cocone F → C .Ob" id="4188" href="Cat.Diagram.Colimit.Base.html#2624" class="Field">coapex</a><a id="4194" class="Symbol">)</a>
      <a data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" id="4202" href="Cat.Diagram.Colimit.Base.html#4202" class="Field">commutes</a> <a id="4211" class="Symbol">:</a> <a id="4213" class="Symbol">∀</a> <a id="4215" href="Cat.Diagram.Colimit.Base.html#4215" class="Bound">o</a> <a id="4217" class="Symbol">→</a> <a data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" id="4219" href="Cat.Diagram.Colimit.Base.html#4160" class="Field">hom</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="4223" href="Cat.Base.html#3006" class="Function Operator">C.∘</a> <a id="4227" href="Cat.Diagram.Colimit.Base.html#4061" class="Bound">x</a> <a id="4229" class="Symbol">.</a><a data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" id="4230" href="Cat.Diagram.Colimit.Base.html#2644" class="Field">ψ</a> <a id="4232" href="Cat.Diagram.Colimit.Base.html#4215" class="Bound">o</a> <a data-type="A → A → Type ℓ" id="4234" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="4236" href="Cat.Diagram.Colimit.Base.html#4063" class="Bound">y</a> <a id="4238" class="Symbol">.</a><a data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" id="4239" href="Cat.Diagram.Colimit.Base.html#2644" class="Field">ψ</a> <a id="4241" href="Cat.Diagram.Colimit.Base.html#4215" class="Bound">o</a>
</pre>
<!--
<pre class="Agda">  <a id="4263" class="Keyword">private</a> <a id="4271" class="Keyword">unquoteDecl</a> <a id="4283" href="Cat.Diagram.Colimit.Base.html#4283" class="Function">eqv</a> <a id="4287" class="Symbol">=</a> <a id="4289" href="1Lab.Reflection.Record.html#5133" class="Function">declare-record-iso</a> <a id="4308" href="Cat.Diagram.Colimit.Base.html#4283" class="Function">eqv</a> <a id="4312" class="Symbol">(</a><a id="4313" class="Keyword">quote</a> <a id="4319" href="Cat.Diagram.Colimit.Base.html#4049" class="Record">Cocone-hom</a><a id="4329" class="Symbol">)</a>
</pre>-->
<p>We define yet another helper lemma that describes the path space of cocone morphisms.</p>
<pre class="Agda">  <a id="4437" class="Keyword">open</a> <a data-type="(F : Functor J₁ C) (x y : Cocone F) → Type (o ⊔ ℓ′)" id="4442" href="Cat.Diagram.Colimit.Base.html#4049" class="Module">Cocone-hom</a>

  <a data-type="(F : Functor J₁ C) → f .hom ≡ g .hom → f ≡ g" id="4456" href="Cat.Diagram.Colimit.Base.html#4456" class="Function">Cocone-hom-path</a> <a id="4472" class="Symbol">:</a> <a id="4474" class="Symbol">∀</a> <a id="4476" class="Symbol">{</a><a id="4477" href="Cat.Diagram.Colimit.Base.html#4477" class="Bound">x</a> <a id="4479" href="Cat.Diagram.Colimit.Base.html#4479" class="Bound">y</a><a id="4480" class="Symbol">}</a> <a id="4482" class="Symbol">{</a><a id="4483" href="Cat.Diagram.Colimit.Base.html#4483" class="Bound">f</a> <a id="4485" href="Cat.Diagram.Colimit.Base.html#4485" class="Bound">g</a> <a id="4487" class="Symbol">:</a> <a data-type="(F : Functor J₁ C) (x y : Cocone F) → Type (o ⊔ ℓ′)" id="4489" href="Cat.Diagram.Colimit.Base.html#4049" class="Record">Cocone-hom</a> <a id="4500" href="Cat.Diagram.Colimit.Base.html#4477" class="Bound">x</a> <a id="4502" href="Cat.Diagram.Colimit.Base.html#4479" class="Bound">y</a><a id="4503" class="Symbol">}</a> <a id="4505" class="Symbol">→</a> <a id="4507" href="Cat.Diagram.Colimit.Base.html#4483" class="Bound">f</a> <a id="4509" class="Symbol">.</a><a data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" id="4510" href="Cat.Diagram.Colimit.Base.html#4160" class="Field">hom</a> <a data-type="A → A → Type ℓ" id="4514" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="4516" href="Cat.Diagram.Colimit.Base.html#4485" class="Bound">g</a> <a id="4518" class="Symbol">.</a><a data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" id="4519" href="Cat.Diagram.Colimit.Base.html#4160" class="Field">hom</a> <a id="4523" class="Symbol">→</a> <a id="4525" href="Cat.Diagram.Colimit.Base.html#4483" class="Bound">f</a> <a data-type="A → A → Type ℓ" id="4527" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="4529" href="Cat.Diagram.Colimit.Base.html#4485" class="Bound">g</a>
  <a data-type="(F : Functor J₁ C) → f .hom ≡ g .hom → f ≡ g" id="4533" href="Cat.Diagram.Colimit.Base.html#4456" class="Function">Cocone-hom-path</a> <a id="4549" href="Cat.Diagram.Colimit.Base.html#4549" class="Bound">p</a> <a id="4551" href="Cat.Diagram.Colimit.Base.html#4551" class="Bound">i</a> <a id="4553" class="Symbol">.</a><a data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" id="4554" href="Cat.Diagram.Colimit.Base.html#4160" class="Field">hom</a> <a id="4558" class="Symbol">=</a> <a id="4560" href="Cat.Diagram.Colimit.Base.html#4549" class="Bound">p</a> <a id="4562" href="Cat.Diagram.Colimit.Base.html#4551" class="Bound">i</a>
  <a data-type="(F : Functor J₁ C) → f .hom ≡ g .hom → f ≡ g" id="4566" href="Cat.Diagram.Colimit.Base.html#4456" class="Function">Cocone-hom-path</a> <a id="4582" class="Symbol">{</a><a id="4583" class="Argument">x</a> <a id="4585" class="Symbol">=</a> <a id="4587" href="Cat.Diagram.Colimit.Base.html#4587" class="Bound">x</a><a id="4588" class="Symbol">}</a> <a id="4590" class="Symbol">{</a><a id="4591" class="Argument">y</a> <a id="4593" class="Symbol">=</a> <a id="4595" href="Cat.Diagram.Colimit.Base.html#4595" class="Bound">y</a><a id="4596" class="Symbol">}</a> <a id="4598" class="Symbol">{</a><a id="4599" class="Argument">f</a> <a id="4601" class="Symbol">=</a> <a id="4603" href="Cat.Diagram.Colimit.Base.html#4603" class="Bound">f</a><a id="4604" class="Symbol">}</a> <a id="4606" class="Symbol">{</a><a id="4607" class="Argument">g</a> <a id="4609" class="Symbol">=</a> <a id="4611" href="Cat.Diagram.Colimit.Base.html#4611" class="Bound">g</a><a id="4612" class="Symbol">}</a> <a id="4614" href="Cat.Diagram.Colimit.Base.html#4614" class="Bound">p</a> <a id="4616" href="Cat.Diagram.Colimit.Base.html#4616" class="Bound">i</a> <a id="4618" class="Symbol">.</a><a data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" id="4619" href="Cat.Diagram.Colimit.Base.html#4202" class="Field">commutes</a> <a id="4628" href="Cat.Diagram.Colimit.Base.html#4628" class="Bound">o</a> <a id="4630" href="Cat.Diagram.Colimit.Base.html#4630" class="Bound">j</a> <a id="4632" class="Symbol">=</a>
    <a data-type="((i j : I) → is-set (A i j)) →
(p : PathP (λ j → A j i0) a c) (q : PathP (A i0) a b)
(s : PathP (A i1) c d) (r : PathP (λ j → A j i1) b d) →
SquareP A p q s r" id="4638" href="1Lab.HLevel.html#15401" class="Function">is-set→squarep</a> <a id="4653" class="Symbol">(λ</a> <a id="4656" href="Cat.Diagram.Colimit.Base.html#4656" class="Bound">i</a> <a id="4658" href="Cat.Diagram.Colimit.Base.html#4658" class="Bound">j</a> <a id="4660" class="Symbol">→</a> <a data-type="(r : Precategory o h) (x y : r .Ob) → is-set (r .Hom x y)" id="4662" href="Cat.Base.html#1784" class="Function">C.Hom-set</a> <a id="4672" class="Symbol">_</a> <a id="4674" class="Symbol">_)</a>
      <a id="4683" class="Symbol">(λ</a> <a id="4686" href="Cat.Diagram.Colimit.Base.html#4686" class="Bound">j</a> <a id="4688" class="Symbol">→</a> <a id="4690" href="Cat.Diagram.Colimit.Base.html#4614" class="Bound">p</a> <a id="4692" href="Cat.Diagram.Colimit.Base.html#4686" class="Bound">j</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="4694" href="Cat.Base.html#3006" class="Function Operator">C.∘</a> <a id="4698" href="Cat.Diagram.Colimit.Base.html#4587" class="Bound">x</a> <a id="4700" class="Symbol">.</a><a data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" id="4701" href="Cat.Diagram.Colimit.Base.html#2644" class="Field">ψ</a> <a id="4703" href="Cat.Diagram.Colimit.Base.html#4628" class="Bound">o</a><a id="4704" class="Symbol">)</a> <a id="4706" class="Symbol">(</a><a id="4707" href="Cat.Diagram.Colimit.Base.html#4603" class="Bound">f</a> <a id="4709" class="Symbol">.</a><a data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" id="4710" href="Cat.Diagram.Colimit.Base.html#4202" class="Field">commutes</a> <a id="4719" href="Cat.Diagram.Colimit.Base.html#4628" class="Bound">o</a><a id="4720" class="Symbol">)</a> <a id="4722" class="Symbol">(</a><a id="4723" href="Cat.Diagram.Colimit.Base.html#4611" class="Bound">g</a> <a id="4725" class="Symbol">.</a><a data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" id="4726" href="Cat.Diagram.Colimit.Base.html#4202" class="Field">commutes</a> <a id="4735" href="Cat.Diagram.Colimit.Base.html#4628" class="Bound">o</a><a id="4736" class="Symbol">)</a> <a data-type="x ≡ x" id="4738" href="1Lab.Path.html#3593" class="Function">refl</a> <a id="4743" href="Cat.Diagram.Colimit.Base.html#4616" class="Bound">i</a> <a id="4745" href="Cat.Diagram.Colimit.Base.html#4630" class="Bound">j</a>
</pre>
<p>Now, we can define the category of cocones over a given diagram:</p>
<pre class="Agda">  <a data-type="(F : Functor J₁ C) → Precategory (o ⊔ ℓ ⊔ o′ ⊔ ℓ′) (o ⊔ ℓ′)" id="4828" href="Cat.Diagram.Colimit.Base.html#4828" class="Function">Cocones</a> <a id="4836" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="4838" href="Cat.Base.html#704" class="Record">Precategory</a> <a id="4850" class="Symbol">_</a> <a id="4852" class="Symbol">_</a>
  <a data-type="(F : Functor J₁ C) → Precategory (o ⊔ ℓ ⊔ o′ ⊔ ℓ′) (o ⊔ ℓ′)" id="4856" href="Cat.Diagram.Colimit.Base.html#4828" class="Function">Cocones</a> <a id="4864" class="Symbol">=</a> <a id="4866" href="Cat.Diagram.Colimit.Base.html#5234" class="Function">cat</a> <a id="4870" class="Keyword">where</a>
    <a id="4880" class="Keyword">open</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="4885" href="Cat.Base.html#704" class="Module">Precategory</a>

    <a id="4902" href="Cat.Diagram.Colimit.Base.html#4902" class="Function">compose</a> <a id="4910" class="Symbol">:</a> <a id="4912" class="Symbol">∀</a> <a id="4914" class="Symbol">{</a><a id="4915" href="Cat.Diagram.Colimit.Base.html#4915" class="Bound">x</a> <a id="4917" href="Cat.Diagram.Colimit.Base.html#4917" class="Bound">y</a> <a id="4919" href="Cat.Diagram.Colimit.Base.html#4919" class="Bound">z</a><a id="4920" class="Symbol">}</a> <a id="4922" class="Symbol">→</a> <a data-type="(F : Functor J₁ C) (x y : Cocone F) → Type (o ⊔ ℓ′)" id="4924" href="Cat.Diagram.Colimit.Base.html#4049" class="Record">Cocone-hom</a> <a id="4935" href="Cat.Diagram.Colimit.Base.html#4917" class="Bound">y</a> <a id="4937" href="Cat.Diagram.Colimit.Base.html#4919" class="Bound">z</a> <a id="4939" class="Symbol">→</a> <a data-type="(F : Functor J₁ C) (x y : Cocone F) → Type (o ⊔ ℓ′)" id="4941" href="Cat.Diagram.Colimit.Base.html#4049" class="Record">Cocone-hom</a> <a id="4952" href="Cat.Diagram.Colimit.Base.html#4915" class="Bound">x</a> <a id="4954" href="Cat.Diagram.Colimit.Base.html#4917" class="Bound">y</a> <a id="4956" class="Symbol">→</a> <a data-type="(F : Functor J₁ C) (x y : Cocone F) → Type (o ⊔ ℓ′)" id="4958" href="Cat.Diagram.Colimit.Base.html#4049" class="Record">Cocone-hom</a> <a id="4969" href="Cat.Diagram.Colimit.Base.html#4915" class="Bound">x</a> <a id="4971" href="Cat.Diagram.Colimit.Base.html#4919" class="Bound">z</a>
    <a id="4977" href="Cat.Diagram.Colimit.Base.html#4902" class="Function">compose</a> <a id="4985" href="Cat.Diagram.Colimit.Base.html#4985" class="Bound">K</a> <a id="4987" href="Cat.Diagram.Colimit.Base.html#4987" class="Bound">L</a> <a id="4989" class="Symbol">.</a><a data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" id="4990" href="Cat.Diagram.Colimit.Base.html#4160" class="Field">hom</a> <a id="4994" class="Symbol">=</a> <a id="4996" href="Cat.Diagram.Colimit.Base.html#4985" class="Bound">K</a> <a id="4998" class="Symbol">.</a><a data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" id="4999" href="Cat.Diagram.Colimit.Base.html#4160" class="Field">hom</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="5003" href="Cat.Base.html#3006" class="Function Operator">C.∘</a> <a id="5007" href="Cat.Diagram.Colimit.Base.html#4987" class="Bound">L</a> <a id="5009" class="Symbol">.</a><a data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" id="5010" href="Cat.Diagram.Colimit.Base.html#4160" class="Field">hom</a>
    <a id="5018" href="Cat.Diagram.Colimit.Base.html#4902" class="Function">compose</a> <a id="5026" class="Symbol">{</a><a id="5027" class="Argument">x</a> <a id="5029" class="Symbol">=</a> <a id="5031" href="Cat.Diagram.Colimit.Base.html#5031" class="Bound">x</a><a id="5032" class="Symbol">}</a> <a id="5034" class="Symbol">{</a><a id="5035" class="Argument">y</a> <a id="5037" class="Symbol">=</a> <a id="5039" href="Cat.Diagram.Colimit.Base.html#5039" class="Bound">y</a><a id="5040" class="Symbol">}</a> <a id="5042" class="Symbol">{</a><a id="5043" class="Argument">z</a> <a id="5045" class="Symbol">=</a> <a id="5047" href="Cat.Diagram.Colimit.Base.html#5047" class="Bound">z</a><a id="5048" class="Symbol">}</a> <a id="5050" href="Cat.Diagram.Colimit.Base.html#5050" class="Bound">K</a> <a id="5052" href="Cat.Diagram.Colimit.Base.html#5052" class="Bound">L</a> <a id="5054" class="Symbol">.</a><a data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" id="5055" href="Cat.Diagram.Colimit.Base.html#4202" class="Field">commutes</a> <a id="5064" href="Cat.Diagram.Colimit.Base.html#5064" class="Bound">o</a> <a id="5066" class="Symbol">=</a>
      <a id="5074" class="Symbol">(</a><a id="5075" href="Cat.Diagram.Colimit.Base.html#5050" class="Bound">K</a> <a id="5077" class="Symbol">.</a><a data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" id="5078" href="Cat.Diagram.Colimit.Base.html#4160" class="Field">hom</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="5082" href="Cat.Base.html#3006" class="Function Operator">C.∘</a> <a id="5086" href="Cat.Diagram.Colimit.Base.html#5052" class="Bound">L</a> <a id="5088" class="Symbol">.</a><a data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" id="5089" href="Cat.Diagram.Colimit.Base.html#4160" class="Field">hom</a><a id="5092" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="5094" href="Cat.Base.html#3006" class="Function Operator">C.∘</a> <a id="5098" href="Cat.Diagram.Colimit.Base.html#5031" class="Bound">x</a> <a id="5100" class="Symbol">.</a><a data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" id="5101" href="Cat.Diagram.Colimit.Base.html#2644" class="Field">ψ</a> <a id="5103" href="Cat.Diagram.Colimit.Base.html#5064" class="Bound">o</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="5105" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" id="5108" href="Cat.Reasoning.html#1678" class="Function">C.pullr</a> <a id="5116" class="Symbol">(</a><a id="5117" href="Cat.Diagram.Colimit.Base.html#5052" class="Bound">L</a> <a id="5119" class="Symbol">.</a><a data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" id="5120" href="Cat.Diagram.Colimit.Base.html#4202" class="Field">commutes</a> <a id="5129" href="Cat.Diagram.Colimit.Base.html#5064" class="Bound">o</a><a id="5130" class="Symbol">)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="5132" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="5140" href="Cat.Diagram.Colimit.Base.html#5050" class="Bound">K</a> <a id="5142" class="Symbol">.</a><a data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" id="5143" href="Cat.Diagram.Colimit.Base.html#4160" class="Field">hom</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="5147" href="Cat.Base.html#3006" class="Function Operator">C.∘</a> <a id="5151" href="Cat.Diagram.Colimit.Base.html#5039" class="Bound">y</a> <a id="5153" class="Symbol">.</a><a data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" id="5154" href="Cat.Diagram.Colimit.Base.html#2644" class="Field">ψ</a> <a id="5156" href="Cat.Diagram.Colimit.Base.html#5064" class="Bound">o</a>              <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="5171" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a id="5174" href="Cat.Diagram.Colimit.Base.html#5050" class="Bound">K</a> <a id="5176" class="Symbol">.</a><a data-type="(r : Cocone-hom F x y) (o : J₁ .Ob) →
C ._∘_ (r .hom) (x .ψ o) ≡ y .ψ o" id="5177" href="Cat.Diagram.Colimit.Base.html#4202" class="Field">commutes</a> <a id="5186" href="Cat.Diagram.Colimit.Base.html#5064" class="Bound">o</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="5188" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="5196" href="Cat.Diagram.Colimit.Base.html#5047" class="Bound">z</a> <a id="5198" class="Symbol">.</a><a data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" id="5199" href="Cat.Diagram.Colimit.Base.html#2644" class="Field">ψ</a> <a id="5201" href="Cat.Diagram.Colimit.Base.html#5064" class="Bound">o</a>                         <a data-type="(x : A) → x ≡ x" id="5227" href="1Lab.Path.html#46957" class="Function Operator">∎</a>

    <a id="5234" href="Cat.Diagram.Colimit.Base.html#5234" class="Function">cat</a> <a id="5238" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="5240" href="Cat.Base.html#704" class="Record">Precategory</a> <a id="5252" class="Symbol">_</a> <a id="5254" class="Symbol">_</a>
    <a id="5260" href="Cat.Diagram.Colimit.Base.html#5234" class="Function">cat</a> <a id="5264" class="Symbol">.</a><a data-type="Precategory o h → Type o" id="5265" href="Cat.Base.html#1419" class="Field">Ob</a> <a id="5268" class="Symbol">=</a> <a data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" id="5270" href="Cat.Diagram.Colimit.Base.html#2263" class="Record">Cocone</a>
    <a id="5281" href="Cat.Diagram.Colimit.Base.html#5234" class="Function">cat</a> <a id="5285" class="Symbol">.</a><a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="5286" href="Cat.Base.html#1436" class="Field">Hom</a> <a id="5290" class="Symbol">=</a> <a data-type="(F : Functor J₁ C) (x y : Cocone F) → Type (o ⊔ ℓ′)" id="5292" href="Cat.Diagram.Colimit.Base.html#4049" class="Record">Cocone-hom</a>
    <a id="5307" href="Cat.Diagram.Colimit.Base.html#5234" class="Function">cat</a> <a id="5311" class="Symbol">.</a><a data-type="(r : Precategory o h) → r .Hom x x" id="5312" href="Cat.Base.html#2976" class="Field">id</a> <a id="5315" class="Symbol">=</a> <a data-type="(hom : C .Hom (x .coapex) (y .coapex))
(commutes : (o : J₁ .Ob) → C ._∘_ hom (x .ψ o) ≡ y .ψ o) →
Cocone-hom F x y" id="5317" href="Cat.Diagram.Colimit.Base.html#4133" class="InductiveConstructor">cocone-hom</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="5328" href="Cat.Base.html#2976" class="Function">C.id</a> <a id="5333" class="Symbol">(λ</a> <a id="5336" href="Cat.Diagram.Colimit.Base.html#5336" class="Bound">_</a> <a id="5338" class="Symbol">→</a> <a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" id="5340" href="Cat.Base.html#3482" class="Function">C.idl</a> <a id="5346" class="Symbol">_)</a>
    <a id="5353" href="Cat.Diagram.Colimit.Base.html#5234" class="Function">cat</a> <a id="5357" class="Symbol">.</a><a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="5358" href="Cat.Base.html#3006" class="Field Operator">_∘_</a> <a id="5362" class="Symbol">=</a> <a id="5364" href="Cat.Diagram.Colimit.Base.html#4902" class="Function">compose</a>
    <a id="5376" href="Cat.Diagram.Colimit.Base.html#5234" class="Function">cat</a> <a id="5380" class="Symbol">.</a><a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" id="5381" href="Cat.Base.html#3437" class="Field">idr</a> <a id="5385" href="Cat.Diagram.Colimit.Base.html#5385" class="Bound">f</a> <a id="5387" class="Symbol">=</a> <a data-type="(F : Functor J₁ C) → f .hom ≡ g .hom → f ≡ g" id="5389" href="Cat.Diagram.Colimit.Base.html#4456" class="Function">Cocone-hom-path</a> <a id="5405" class="Symbol">(</a><a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" id="5406" href="Cat.Base.html#3437" class="Function">C.idr</a> <a id="5412" class="Symbol">(</a><a id="5413" href="Cat.Diagram.Colimit.Base.html#5385" class="Bound">f</a> <a id="5415" class="Symbol">.</a><a data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" id="5416" href="Cat.Diagram.Colimit.Base.html#4160" class="Field">hom</a><a id="5419" class="Symbol">))</a>
    <a id="5426" href="Cat.Diagram.Colimit.Base.html#5234" class="Function">cat</a> <a id="5430" class="Symbol">.</a><a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" id="5431" href="Cat.Base.html#3482" class="Field">idl</a> <a id="5435" href="Cat.Diagram.Colimit.Base.html#5435" class="Bound">f</a> <a id="5437" class="Symbol">=</a> <a data-type="(F : Functor J₁ C) → f .hom ≡ g .hom → f ≡ g" id="5439" href="Cat.Diagram.Colimit.Base.html#4456" class="Function">Cocone-hom-path</a> <a id="5455" class="Symbol">(</a><a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" id="5456" href="Cat.Base.html#3482" class="Function">C.idl</a> <a id="5462" class="Symbol">(</a><a id="5463" href="Cat.Diagram.Colimit.Base.html#5435" class="Bound">f</a> <a id="5465" class="Symbol">.</a><a data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" id="5466" href="Cat.Diagram.Colimit.Base.html#4160" class="Field">hom</a><a id="5469" class="Symbol">))</a>
    <a id="5476" href="Cat.Diagram.Colimit.Base.html#5234" class="Function">cat</a> <a id="5480" class="Symbol">.</a><a data-type="(r : Precategory o h) (f : r .Hom y z) (g : r .Hom x y)
(h : r .Hom w x) →
r ._∘_ f (r ._∘_ g h) ≡ r ._∘_ (r ._∘_ f g) h" id="5481" href="Cat.Base.html#3857" class="Field">assoc</a> <a id="5487" href="Cat.Diagram.Colimit.Base.html#5487" class="Bound">f</a> <a id="5489" href="Cat.Diagram.Colimit.Base.html#5489" class="Bound">g</a> <a id="5491" href="Cat.Diagram.Colimit.Base.html#5491" class="Bound">h</a> <a id="5493" class="Symbol">=</a> <a data-type="(F : Functor J₁ C) → f .hom ≡ g .hom → f ≡ g" id="5495" href="Cat.Diagram.Colimit.Base.html#4456" class="Function">Cocone-hom-path</a> <a id="5511" class="Symbol">(</a><a data-type="(r : Precategory o h) (f : r .Hom y z) (g : r .Hom x y)
(h : r .Hom w x) →
r ._∘_ f (r ._∘_ g h) ≡ r ._∘_ (r ._∘_ f g) h" id="5512" href="Cat.Base.html#3857" class="Function">C.assoc</a> <a id="5520" class="Symbol">(</a><a id="5521" href="Cat.Diagram.Colimit.Base.html#5487" class="Bound">f</a> <a id="5523" class="Symbol">.</a><a data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" id="5524" href="Cat.Diagram.Colimit.Base.html#4160" class="Field">hom</a><a id="5527" class="Symbol">)</a> <a id="5529" class="Symbol">(</a><a id="5530" href="Cat.Diagram.Colimit.Base.html#5489" class="Bound">g</a> <a id="5532" class="Symbol">.</a><a data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" id="5533" href="Cat.Diagram.Colimit.Base.html#4160" class="Field">hom</a><a id="5536" class="Symbol">)</a> <a id="5538" class="Symbol">(</a><a id="5539" href="Cat.Diagram.Colimit.Base.html#5491" class="Bound">h</a> <a id="5541" class="Symbol">.</a><a data-type="Cocone-hom F x y → C .Hom (x .coapex) (y .coapex)" id="5542" href="Cat.Diagram.Colimit.Base.html#4160" class="Field">hom</a><a id="5545" class="Symbol">))</a>

</pre>
<!--
<pre class="Agda">    <a id="5571" href="Cat.Diagram.Colimit.Base.html#5234" class="Function">cat</a> <a id="5575" class="Symbol">.</a><a id="5576" href="Cat.Base.html#1784" class="Field">Hom-set</a> <a id="5584" href="Cat.Diagram.Colimit.Base.html#5584" class="Bound">x</a> <a id="5586" href="Cat.Diagram.Colimit.Base.html#5586" class="Bound">y</a> <a id="5588" class="Symbol">=</a> <a id="5590" href="1Lab.HLevel.Retracts.html#3945" class="Function">is-hlevel≃</a> <a id="5601" class="Number">2</a> <a id="5603" class="Symbol">(</a><a id="5604" href="1Lab.Equiv.html#20161" class="Function">Iso→Equiv</a> <a id="5614" href="Cat.Diagram.Colimit.Base.html#4283" class="Function">eqv</a> <a id="5618" href="1Lab.Equiv.html#21355" class="Function Operator">e⁻¹</a><a id="5621" class="Symbol">)</a> <a id="5623" class="Symbol">(</a><a id="5624" href="1Lab.HLevel.Retracts.html#7786" class="Function">hlevel</a> <a id="5631" class="Number">2</a><a id="5632" class="Symbol">)</a>
      <a id="5640" class="Keyword">where</a> <a id="5646" class="Keyword">open</a> <a id="5651" href="Cat.Base.html#3984" class="Module">C.HLevel-instance</a>
</pre>-->
<h2 id="colimits"><a href="#colimits" class="header-link">Colimits<span class="header-link-emoji">🔗</span></a></h2>
We now have all of the machinery in place! What remains is the universal property, which expresses that a <em>particular</em> cocone is universal, in the sense that it has a <em>unique</em> map to any other cocone. However, we already have something that captures this idea, it’s the initial object! This leads to the following terse definition: A colimit over a diagram is an initial object in the category of cocones over that diagram.
<pre class="Agda">  <a data-type="(F : Functor J₁ C) → Cocone F → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" id="6121" href="Cat.Diagram.Colimit.Base.html#6121" class="Function">is-colimit</a> <a id="6132" class="Symbol">:</a> <a data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" id="6134" href="Cat.Diagram.Colimit.Base.html#2263" class="Record">Cocone</a> <a id="6141" class="Symbol">→</a> <a id="6143" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="6148" class="Symbol">_</a>
  <a data-type="(F : Functor J₁ C) → Cocone F → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" id="6152" href="Cat.Diagram.Colimit.Base.html#6121" class="Function">is-colimit</a> <a id="6163" href="Cat.Diagram.Colimit.Base.html#6163" class="Bound">K</a> <a id="6165" class="Symbol">=</a> <a data-type="(C : Precategory o h) → Ob C → Type (o ⊔ h)" id="6167" href="Cat.Diagram.Initial.html#326" class="Function">is-initial</a> <a data-type="(F : Functor J₁ C) → Precategory (o ⊔ ℓ ⊔ o′ ⊔ ℓ′) (o ⊔ ℓ′)" id="6178" href="Cat.Diagram.Colimit.Base.html#4828" class="Function">Cocones</a> <a id="6186" href="Cat.Diagram.Colimit.Base.html#6163" class="Bound">K</a>

  <a data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" id="6191" href="Cat.Diagram.Colimit.Base.html#6191" class="Function">Colimit</a> <a id="6199" class="Symbol">:</a> <a id="6201" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="6206" class="Symbol">_</a>
  <a data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" id="6210" href="Cat.Diagram.Colimit.Base.html#6191" class="Function">Colimit</a> <a id="6218" class="Symbol">=</a> <a data-type="(C : Precategory o h) → Type (o ⊔ h)" id="6220" href="Cat.Diagram.Initial.html#401" class="Record">Initial</a> <a data-type="(F : Functor J₁ C) → Precategory (o ⊔ ℓ ⊔ o′ ⊔ ℓ′) (o ⊔ ℓ′)" id="6228" href="Cat.Diagram.Colimit.Base.html#4828" class="Function">Cocones</a>

  <a data-type="(F : Functor J₁ C) → Colimit F → C .Ob" id="6239" href="Cat.Diagram.Colimit.Base.html#6239" class="Function">Colimit-apex</a> <a id="6252" class="Symbol">:</a> <a data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" id="6254" href="Cat.Diagram.Colimit.Base.html#6191" class="Function">Colimit</a> <a id="6262" class="Symbol">→</a> <a data-type="Precategory o h → Type o" id="6264" href="Cat.Base.html#1419" class="Function">C.Ob</a>
  <a data-type="(F : Functor J₁ C) → Colimit F → C .Ob" id="6271" href="Cat.Diagram.Colimit.Base.html#6239" class="Function">Colimit-apex</a> <a id="6284" href="Cat.Diagram.Colimit.Base.html#6284" class="Bound">x</a> <a id="6286" class="Symbol">=</a> <a data-type="Cocone F → C .Ob" id="6288" href="Cat.Diagram.Colimit.Base.html#2624" class="Field">coapex</a> <a id="6295" class="Symbol">(</a><a data-type="Initial C → Ob C" id="6296" href="Cat.Diagram.Initial.html#442" class="Field">Initial.bot</a> <a id="6308" href="Cat.Diagram.Colimit.Base.html#6284" class="Bound">x</a><a id="6309" class="Symbol">)</a>
</pre>
<!--
<pre class="Agda"><a id="6330" class="Keyword">module</a> <a id="6337" href="Cat.Diagram.Colimit.Base.html#6337" class="Module">_</a> <a id="6339" class="Symbol">{</a><a id="6340" href="Cat.Diagram.Colimit.Base.html#6340" class="Bound">o₁</a> <a id="6343" href="Cat.Diagram.Colimit.Base.html#6343" class="Bound">h₁</a> <a id="6346" href="Cat.Diagram.Colimit.Base.html#6346" class="Bound">o₂</a> <a id="6349" href="Cat.Diagram.Colimit.Base.html#6349" class="Bound">h₂</a> <a id="6352" href="Cat.Diagram.Colimit.Base.html#6352" class="Bound">o₃</a> <a id="6355" href="Cat.Diagram.Colimit.Base.html#6355" class="Bound">h₃</a> <a id="6358" class="Symbol">:</a> <a id="6360" class="Symbol">_}</a>
         <a id="6372" class="Symbol">{</a><a id="6373" href="Cat.Diagram.Colimit.Base.html#6373" class="Bound">J</a> <a id="6375" class="Symbol">:</a> <a id="6377" href="Cat.Base.html#704" class="Record">Precategory</a> <a id="6389" href="Cat.Diagram.Colimit.Base.html#6340" class="Bound">o₁</a> <a id="6392" href="Cat.Diagram.Colimit.Base.html#6343" class="Bound">h₁</a><a id="6394" class="Symbol">}</a>
         <a id="6405" class="Symbol">{</a><a id="6406" href="Cat.Diagram.Colimit.Base.html#6406" class="Bound">C</a> <a id="6408" class="Symbol">:</a> <a id="6410" href="Cat.Base.html#704" class="Record">Precategory</a> <a id="6422" href="Cat.Diagram.Colimit.Base.html#6346" class="Bound">o₂</a> <a id="6425" href="Cat.Diagram.Colimit.Base.html#6349" class="Bound">h₂</a><a id="6427" class="Symbol">}</a>
         <a id="6438" class="Symbol">{</a><a id="6439" href="Cat.Diagram.Colimit.Base.html#6439" class="Bound">D</a> <a id="6441" class="Symbol">:</a> <a id="6443" href="Cat.Base.html#704" class="Record">Precategory</a> <a id="6455" href="Cat.Diagram.Colimit.Base.html#6352" class="Bound">o₃</a> <a id="6458" href="Cat.Diagram.Colimit.Base.html#6355" class="Bound">h₃</a><a id="6460" class="Symbol">}</a>
         <a id="6471" class="Symbol">{</a><a id="6472" href="Cat.Diagram.Colimit.Base.html#6472" class="Bound">Dia</a> <a id="6476" class="Symbol">:</a> <a id="6478" href="Cat.Base.html#7206" class="Record">Functor</a> <a id="6486" href="Cat.Diagram.Colimit.Base.html#6373" class="Bound">J</a> <a id="6488" href="Cat.Diagram.Colimit.Base.html#6406" class="Bound">C</a><a id="6489" class="Symbol">}</a>
         <a id="6500" class="Symbol">(</a><a id="6501" href="Cat.Diagram.Colimit.Base.html#6501" class="Bound">F</a> <a id="6503" class="Symbol">:</a> <a id="6505" href="Cat.Base.html#7206" class="Record">Functor</a> <a id="6513" href="Cat.Diagram.Colimit.Base.html#6406" class="Bound">C</a> <a id="6515" href="Cat.Diagram.Colimit.Base.html#6439" class="Bound">D</a><a id="6516" class="Symbol">)</a>
  <a id="6520" class="Keyword">where</a>

  <a id="6529" class="Keyword">private</a>
    <a id="6541" class="Keyword">module</a> <a id="6548" href="Cat.Diagram.Colimit.Base.html#6548" class="Module">D</a> <a id="6550" class="Symbol">=</a> <a id="6552" href="Cat.Base.html#704" class="Module">Precategory</a> <a id="6564" href="Cat.Diagram.Colimit.Base.html#6439" class="Bound">D</a>
    <a id="6570" class="Keyword">module</a> <a id="6577" href="Cat.Diagram.Colimit.Base.html#6577" class="Module">C</a> <a id="6579" class="Symbol">=</a> <a id="6581" href="Cat.Base.html#704" class="Module">Precategory</a> <a id="6593" href="Cat.Diagram.Colimit.Base.html#6406" class="Bound">C</a>
    <a id="6599" class="Keyword">module</a> <a id="6606" href="Cat.Diagram.Colimit.Base.html#6606" class="Module">J</a> <a id="6608" class="Symbol">=</a> <a id="6610" href="Cat.Base.html#704" class="Module">Precategory</a> <a id="6622" href="Cat.Diagram.Colimit.Base.html#6373" class="Bound">J</a>

  <a id="6627" class="Keyword">open</a> <a id="6632" href="Cat.Base.html#7206" class="Module">Functor</a>
</pre>-->
<h1 id="preservation-of-colimits"><a href="#preservation-of-colimits" class="header-link">Preservation of Colimits<span class="header-link-emoji">🔗</span></a></h1>
<p>Because a cocone is a commutative diagram, any given functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi mathvariant="script">C</mi><mo>→</mo><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">F : \ca{C} \to \ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span> takes cocones in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span> to cocones in <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">D</mi></mrow><annotation encoding="application/x-tex">\ca{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">D</span></span></span></span>,</span> as functors preserve commutative diagrams.</p>
<pre class="Agda">  <a data-type="(F : Functor C D) → Cocone Dia → Cocone (F F∘ Dia)" id="6866" href="Cat.Diagram.Colimit.Base.html#6866" class="Function">F-map-cocone</a> <a id="6879" class="Symbol">:</a> <a data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" id="6881" href="Cat.Diagram.Colimit.Base.html#2263" class="Record">Cocone</a> <a id="6888" href="Cat.Diagram.Colimit.Base.html#6472" class="Bound">Dia</a> <a id="6892" class="Symbol">→</a> <a data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" id="6894" href="Cat.Diagram.Colimit.Base.html#2263" class="Record">Cocone</a> <a id="6901" class="Symbol">(</a><a id="6902" href="Cat.Diagram.Colimit.Base.html#6501" class="Bound">F</a> <a data-type="Functor D E → Functor C D → Functor C E" id="6904" href="Cat.Base.html#9697" class="Function Operator">F∘</a> <a id="6907" href="Cat.Diagram.Colimit.Base.html#6472" class="Bound">Dia</a><a id="6910" class="Symbol">)</a>
  <a data-type="(F : Functor C D) → Cocone Dia → Cocone (F F∘ Dia)" id="6914" href="Cat.Diagram.Colimit.Base.html#6866" class="Function">F-map-cocone</a> <a id="6927" href="Cat.Diagram.Colimit.Base.html#6927" class="Bound">x</a> <a id="6929" class="Symbol">.</a><a data-type="Cocone F → C .Ob" id="6930" href="Cat.Diagram.Colimit.Base.html#2624" class="Field">Cocone.coapex</a> <a id="6944" class="Symbol">=</a> <a id="6946" href="Cat.Diagram.Colimit.Base.html#6501" class="Bound">F</a> <a id="6948" class="Symbol">.</a><a data-type="Functor C D → C .Ob → Ob D" id="6949" href="Cat.Base.html#7996" class="Field">F₀</a> <a id="6952" class="Symbol">(</a><a data-type="Cocone F → C .Ob" id="6953" href="Cat.Diagram.Colimit.Base.html#2624" class="Field">Cocone.coapex</a> <a id="6967" href="Cat.Diagram.Colimit.Base.html#6927" class="Bound">x</a><a id="6968" class="Symbol">)</a>
  <a data-type="(F : Functor C D) → Cocone Dia → Cocone (F F∘ Dia)" id="6972" href="Cat.Diagram.Colimit.Base.html#6866" class="Function">F-map-cocone</a> <a id="6985" href="Cat.Diagram.Colimit.Base.html#6985" class="Bound">x</a> <a id="6987" class="Symbol">.</a><a data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" id="6988" href="Cat.Diagram.Colimit.Base.html#2644" class="Field">Cocone.ψ</a> <a id="6997" href="Cat.Diagram.Colimit.Base.html#6997" class="Bound">f</a> <a id="6999" class="Symbol">=</a> <a id="7001" href="Cat.Diagram.Colimit.Base.html#6501" class="Bound">F</a> <a id="7003" class="Symbol">.</a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="7004" href="Cat.Base.html#8017" class="Field">F₁</a> <a id="7007" class="Symbol">(</a><a data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" id="7008" href="Cat.Diagram.Colimit.Base.html#2644" class="Field">Cocone.ψ</a> <a id="7017" href="Cat.Diagram.Colimit.Base.html#6985" class="Bound">x</a> <a id="7019" href="Cat.Diagram.Colimit.Base.html#6997" class="Bound">f</a><a id="7020" class="Symbol">)</a>
  <a data-type="(F : Functor C D) → Cocone Dia → Cocone (F F∘ Dia)" id="7024" href="Cat.Diagram.Colimit.Base.html#6866" class="Function">F-map-cocone</a> <a id="7037" href="Cat.Diagram.Colimit.Base.html#7037" class="Bound">x</a> <a id="7039" class="Symbol">.</a><a data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" id="7040" href="Cat.Diagram.Colimit.Base.html#3078" class="Field">Cocone.commutes</a> <a id="7056" class="Symbol">{</a><a id="7057" class="Argument">y</a> <a id="7059" class="Symbol">=</a> <a id="7061" href="Cat.Diagram.Colimit.Base.html#7061" class="Bound">y</a><a id="7062" class="Symbol">}</a> <a id="7064" href="Cat.Diagram.Colimit.Base.html#7064" class="Bound">f</a> <a id="7066" class="Symbol">=</a>
    <a id="7072" href="Cat.Diagram.Colimit.Base.html#6501" class="Bound">F</a> <a id="7074" class="Symbol">.</a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="7075" href="Cat.Base.html#8017" class="Field">F₁</a> <a id="7078" class="Symbol">(</a><a data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" id="7079" href="Cat.Diagram.Colimit.Base.html#2644" class="Field">Cocone.ψ</a> <a id="7088" href="Cat.Diagram.Colimit.Base.html#7037" class="Bound">x</a> <a id="7090" href="Cat.Diagram.Colimit.Base.html#7061" class="Bound">y</a><a id="7091" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7093" href="Cat.Base.html#3006" class="Function Operator">D.∘</a> <a id="7097" href="Cat.Diagram.Colimit.Base.html#6501" class="Bound">F</a> <a id="7099" class="Symbol">.</a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="7100" href="Cat.Base.html#8017" class="Field">F₁</a> <a id="7103" class="Symbol">(</a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="7104" href="Cat.Base.html#8017" class="Field">F₁</a> <a id="7107" href="Cat.Diagram.Colimit.Base.html#6472" class="Bound">Dia</a> <a id="7111" href="Cat.Diagram.Colimit.Base.html#7064" class="Bound">f</a><a id="7112" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" id="7114" href="1Lab.Path.html#46783" class="Function Operator">≡˘⟨</a> <a data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" id="7118" href="Cat.Base.html#8383" class="Field">F-∘</a> <a id="7122" href="Cat.Diagram.Colimit.Base.html#6501" class="Bound">F</a> <a id="7124" class="Symbol">_</a> <a id="7126" class="Symbol">_</a> <a data-type="(x : A) → y ≡ x → y ≡ z → x ≡ z" id="7128" href="1Lab.Path.html#46783" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡˘</span></span>
    <a id="7134" href="Cat.Diagram.Colimit.Base.html#6501" class="Bound">F</a> <a id="7136" class="Symbol">.</a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="7137" href="Cat.Base.html#8017" class="Field">F₁</a> <a id="7140" class="Symbol">((</a><a data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" id="7142" href="Cat.Diagram.Colimit.Base.html#2644" class="Field">Cocone.ψ</a> <a id="7151" href="Cat.Diagram.Colimit.Base.html#7037" class="Bound">x</a> <a id="7153" href="Cat.Diagram.Colimit.Base.html#7061" class="Bound">y</a><a id="7154" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="7156" href="Cat.Base.html#3006" class="Function Operator">C.∘</a> <a id="7160" class="Symbol">(</a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="7161" href="Cat.Base.html#8017" class="Field">F₁</a> <a id="7164" href="Cat.Diagram.Colimit.Base.html#6472" class="Bound">Dia</a> <a id="7168" href="Cat.Diagram.Colimit.Base.html#7064" class="Bound">f</a><a id="7169" class="Symbol">))</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="7172" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="7175" href="1Lab.Path.html#20756" class="Function">ap</a> <a id="7178" class="Symbol">(</a><a id="7179" href="Cat.Diagram.Colimit.Base.html#6501" class="Bound">F</a> <a id="7181" class="Symbol">.</a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="7182" href="Cat.Base.html#8017" class="Field">F₁</a><a id="7184" class="Symbol">)</a> <a id="7186" class="Symbol">(</a><a data-type="(r : Cocone F) (f : J₁ .Hom x y) → C ._∘_ (r .ψ y) (₁ F f) ≡ r .ψ x" id="7187" href="Cat.Diagram.Colimit.Base.html#3078" class="Field">Cocone.commutes</a> <a id="7203" href="Cat.Diagram.Colimit.Base.html#7037" class="Bound">x</a> <a id="7205" class="Symbol">_)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="7208" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="7214" href="Cat.Diagram.Colimit.Base.html#6501" class="Bound">F</a> <a id="7216" class="Symbol">.</a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="7217" href="Cat.Base.html#8017" class="Field">F₁</a> <a id="7220" class="Symbol">(</a><a data-type="(r : Cocone F) (x : J₁ .Ob) → C .Hom (₀ F x) (r .coapex)" id="7221" href="Cat.Diagram.Colimit.Base.html#2644" class="Field">Cocone.ψ</a> <a id="7230" href="Cat.Diagram.Colimit.Base.html#7037" class="Bound">x</a> <a id="7232" class="Symbol">_)</a> <a data-type="(x : A) → x ≡ x" id="7235" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
</pre>
<p>Though functors must take cocones to cocones, they may not necessarily take colimiting cocones to colimiting cocones! When a functor does, we say that it <em>preserves</em> colimits.</p>
<pre class="Agda">  <a data-type="(F : Functor C D) → Colimit Dia → Type (o₁ ⊔ h₁ ⊔ o₃ ⊔ h₃)" id="7429" href="Cat.Diagram.Colimit.Base.html#7429" class="Function">Preserves-colimit</a> <a id="7447" class="Symbol">:</a> <a data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" id="7449" href="Cat.Diagram.Colimit.Base.html#6191" class="Function">Colimit</a> <a id="7457" href="Cat.Diagram.Colimit.Base.html#6472" class="Bound">Dia</a> <a id="7461" class="Symbol">→</a> <a id="7463" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="7468" class="Symbol">_</a>
  <a data-type="(F : Functor C D) → Colimit Dia → Type (o₁ ⊔ h₁ ⊔ o₃ ⊔ h₃)" id="7472" href="Cat.Diagram.Colimit.Base.html#7429" class="Function">Preserves-colimit</a> <a id="7490" href="Cat.Diagram.Colimit.Base.html#7490" class="Bound">o</a> <a id="7492" class="Symbol">=</a> <a data-type="(C : Precategory o h) → Ob C → Type (o ⊔ h)" id="7494" href="Cat.Diagram.Initial.html#326" class="Function">is-initial</a> <a id="7505" class="Symbol">(</a><a data-type="(F : Functor J₁ C) → Precategory (o ⊔ ℓ ⊔ o′ ⊔ ℓ′) (o ⊔ ℓ′)" id="7506" href="Cat.Diagram.Colimit.Base.html#4828" class="Function">Cocones</a> <a id="7514" class="Symbol">(</a><a id="7515" href="Cat.Diagram.Colimit.Base.html#6501" class="Bound">F</a> <a data-type="Functor D E → Functor C D → Functor C E" id="7517" href="Cat.Base.html#9697" class="Function Operator">F∘</a> <a id="7520" href="Cat.Diagram.Colimit.Base.html#6472" class="Bound">Dia</a><a id="7523" class="Symbol">))</a> <a id="7526" class="Symbol">(</a><a data-type="(F : Functor C D) → Cocone Dia → Cocone (F F∘ Dia)" id="7527" href="Cat.Diagram.Colimit.Base.html#6866" class="Function">F-map-cocone</a> <a id="7540" class="Symbol">(</a><a data-type="Initial C → Ob C" id="7541" href="Cat.Diagram.Initial.html#442" class="Field">Initial.bot</a> <a id="7553" href="Cat.Diagram.Colimit.Base.html#7490" class="Bound">o</a><a id="7554" class="Symbol">))</a>
</pre>
<h2 id="cocompleteness"><a href="#cocompleteness" class="header-link">Cocompleteness<span class="header-link-emoji">🔗</span></a></h2>
<p>A category is <strong>cocomplete</strong> if admits for limits of arbitrary shape. However, in the presence of excluded middle, if a category admits coproducts indexed by its class of morphisms, then it is automatically [thin]. Since excluded middle is independent of type theory, we can not prove that any non-thin categories have arbitrary colimits.</p>
<p>Instead, categories are cocomplete <em>with respect to</em> a pair of universes: A category is <strong><span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>o</mi><mo separator="true">,</mo><mi mathvariant="normal">ℓ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(o, \ell)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">ℓ</span><span class="mclose">)</span></span></span></span>-cocomplete</span></strong> if it has colimits for any diagram indexed by a precategory with objects in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">T</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi></mrow><mtext> </mtext><mi>o</mi></mrow><annotation encoding="application/x-tex">\ty\ o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">Type</span></span><span class="mspace"> </span><span class="mord mathnormal">o</span></span></span></span> and morphisms in <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">T</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi></mrow><mtext> </mtext><mi mathvariant="normal">ℓ</mi></mrow><annotation encoding="application/x-tex">\ty\ \ell</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">Type</span></span><span class="mspace"> </span><span class="mord">ℓ</span></span></span></span>.</span></p>
<pre class="Agda"><a id="is-cocomplete"></a><a data-type="(o ℓ : Level) →
Precategory oc ℓc → Type (oc ⊔ ℓc ⊔ lsuc o ⊔ lsuc ℓ)" id="8160" href="Cat.Diagram.Colimit.Base.html#8160" class="Function">is-cocomplete</a> <a id="8174" class="Symbol">:</a> <a id="8176" class="Symbol">∀</a> <a id="8178" class="Symbol">{</a><a id="8179" href="Cat.Diagram.Colimit.Base.html#8179" class="Bound">oc</a> <a id="8182" href="Cat.Diagram.Colimit.Base.html#8182" class="Bound">ℓc</a><a id="8184" class="Symbol">}</a> <a id="8186" href="Cat.Diagram.Colimit.Base.html#8186" class="Bound">o</a> <a id="8188" href="Cat.Diagram.Colimit.Base.html#8188" class="Bound">ℓ</a> <a id="8190" class="Symbol">→</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="8192" href="Cat.Base.html#704" class="Record">Precategory</a> <a id="8204" href="Cat.Diagram.Colimit.Base.html#8179" class="Bound">oc</a> <a id="8207" href="Cat.Diagram.Colimit.Base.html#8182" class="Bound">ℓc</a> <a id="8210" class="Symbol">→</a> <a id="8212" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="8217" class="Symbol">_</a>
<a data-type="(o ℓ : Level) →
Precategory oc ℓc → Type (oc ⊔ ℓc ⊔ lsuc o ⊔ lsuc ℓ)" id="8219" href="Cat.Diagram.Colimit.Base.html#8160" class="Function">is-cocomplete</a> <a id="8233" href="Cat.Diagram.Colimit.Base.html#8233" class="Bound">o</a> <a id="8235" href="Cat.Diagram.Colimit.Base.html#8235" class="Bound">ℓ</a> <a id="8237" href="Cat.Diagram.Colimit.Base.html#8237" class="Bound">C</a> <a id="8239" class="Symbol">=</a> <a id="8241" class="Symbol">∀</a> <a id="8243" class="Symbol">{</a><a id="8244" href="Cat.Diagram.Colimit.Base.html#8244" class="Bound">D</a> <a id="8246" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="8248" href="Cat.Base.html#704" class="Record">Precategory</a> <a id="8260" href="Cat.Diagram.Colimit.Base.html#8233" class="Bound">o</a> <a id="8262" href="Cat.Diagram.Colimit.Base.html#8235" class="Bound">ℓ</a><a id="8263" class="Symbol">}</a> <a id="8265" class="Symbol">(</a><a id="8266" href="Cat.Diagram.Colimit.Base.html#8266" class="Bound">F</a> <a id="8268" class="Symbol">:</a> <a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="8270" href="Cat.Base.html#7206" class="Record">Functor</a> <a id="8278" href="Cat.Diagram.Colimit.Base.html#8244" class="Bound">D</a> <a id="8280" href="Cat.Diagram.Colimit.Base.html#8237" class="Bound">C</a><a id="8281" class="Symbol">)</a> <a id="8283" class="Symbol">→</a> <a data-type="(F : Functor J₁ C) → Type (o ⊔ ℓ ⊔ o′ ⊔ ℓ′)" id="8285" href="Cat.Diagram.Colimit.Base.html#6191" class="Function">Colimit</a> <a id="8293" href="Cat.Diagram.Colimit.Base.html#8266" class="Bound">F</a>
</pre>
  </article>
</div>

</main>
</body>
</html>
