<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>

<head>
  <meta charset="utf-8"></meta>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"></meta>
  <meta name="keywords" content="Agda,categories,topos"></meta>

  <title>1Lab.Univalence.SIP - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css"></link>
  <link rel="stylesheet" href="/css/katex.min.css"></link>
  <link rel="stylesheet" href="/css/agda-cats.css"></link>

  <meta name="twitter:card" content="summary"></meta>
  <meta name="twitter:title" content="1Lab.Univalence.SIP - 1Lab"></meta>
  <meta name="twitter:image" content="https://cubical.1lab.dev/static/cube-128x.png"></meta>

  <meta name="og:title" content="1Lab.Univalence.SIP - 1Lab"></meta>
  <meta name="og:image" content="https://cubical.1lab.dev/static/cube-128x.png"></meta>
  <meta name="og:site-name" content="The 1Lab"></meta>
  <meta name="og:type" content="website"></meta>
    <meta name="og:description" content="&lt;p&gt;The structure identity principle characterises equality in “types-with-structure” as being exactly the equivalences that preserve that structure. In a sense, it augments univalence with the notion of preservation of structure.&lt;/p&gt;"></meta>
  <meta name="twitter:description" content="&lt;p&gt;The structure identity principle characterises equality in “types-with-structure” as being exactly the equivalences that preserve that structure. In a sense, it augments univalence with the notion of preservation of structure.&lt;/p&gt;"></meta>
  
  <script src="/equations.js" type="text/javascript"></script> 
  <script src="/highlight-hover.js" type="text/javascript"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>
</head>

<body>
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0;">
                <a class="Module">1Lab.Univalence.SIP</a>
              </h3>

      <!-- Cube logo -->
      <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto; height: 32px;"></img>
      
      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr></hr>
      <ul>
      <li><a href="#structure-identity-principle"><a href="#structure-identity-principle" class="header-link">Structure Identity Principle<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#the-principle"><a href="#the-principle" class="header-link">The principle<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#structure-combinators"><a href="#structure-combinators" class="header-link">Structure Combinators<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#example-infty-magmas"><a href="#example-infty-magmas" class="header-link">Example: <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>

      -magmas</span><span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#transport-structures"><a href="#transport-structures" class="header-link">Transport Structures<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#adding-axioms"><a href="#adding-axioms" class="header-link">Adding Axioms<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#a-language-for-structures"><a href="#a-language-for-structures" class="header-link">A Language for Structures<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#descriptions-of-structures"><a href="#descriptions-of-structures" class="header-link">Descriptions of Structures<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      </ul>
      <hr></hr>

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>
      </div>

      <hr></hr>

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
              <a href="index.html">️back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/6e4ffb26deaffc3f09a61871e975cb615ec5df05/src/1Lab/Univalence/SIP.lagda.md">link to source</a> <br />
      </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="index.html">️back to index</a>
      </div>
      
      <!-- Font toggle checkbox -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>
    </div>

<pre class="Agda"><a id="268" class="Keyword">open</a> <a id="273" class="Keyword">import</a> <a id="280" href="1Lab.Path.Groupoid.html" class="Module">1Lab.Path.Groupoid</a>
<a id="299" class="Keyword">open</a> <a id="304" class="Keyword">import</a> <a id="311" href="1Lab.Type.Sigma.html" class="Module">1Lab.Type.Sigma</a>
<a id="327" class="Keyword">open</a> <a id="332" class="Keyword">import</a> <a id="339" href="1Lab.Univalence.html" class="Module">1Lab.Univalence</a>
<a id="355" class="Keyword">open</a> <a id="360" class="Keyword">import</a> <a id="367" href="1Lab.Type.Pi.html" class="Module">1Lab.Type.Pi</a>
<a id="380" class="Keyword">open</a> <a id="385" class="Keyword">import</a> <a id="392" href="1Lab.HLevel.html" class="Module">1Lab.HLevel</a>
<a id="404" class="Keyword">open</a> <a id="409" class="Keyword">import</a> <a id="416" href="1Lab.Equiv.html" class="Module">1Lab.Equiv</a>
<a id="427" class="Keyword">open</a> <a id="432" class="Keyword">import</a> <a id="439" href="1Lab.Path.html" class="Module">1Lab.Path</a>
<a id="449" class="Keyword">open</a> <a id="454" class="Keyword">import</a> <a id="461" href="1Lab.Type.html" class="Module">1Lab.Type</a>

<a id="472" class="Keyword">module</a> <a id="479" href="1Lab.Univalence.SIP.html" class="Module">1Lab.Univalence.SIP</a> <a id="499" class="Keyword">where</a>
</pre>
<h1 id="structure-identity-principle"><a href="#structure-identity-principle" class="header-link">Structure Identity Principle<span class="header-link-emoji">🔗</span></a></h1>
<p>In mathematics in general, it’s often <em>notationally</em> helpful to identify isomorphic <em>structures</em> (e.g.: groups) in a proof. However, when this mathematics is done using material set theory as a foundations, this identification is merely a shorthand — nothing <em>prevents</em> you from distinguishing isomorphic groups in ZFC by, for instance, asking about membership of a particular set in the underlying set of each group.</p>
<p>In univalent mathematics, it’s a theorem that no family of types can distinguish between isomorphic structures. <a href="1Lab.Univalence.html">Univalence</a> is this statement, but for <em>types</em>. For structures built out of types, it seems like we would need a bit more power, but in reality, we don’t!</p>
<p>“Structure Identity Principle” is the name for several related theorems in Homotopy Type Theory, which generically say that “paths on a structure are isomorphisms of that structure”.</p>
<p>For instance, the version in the HoTT Book says that if a structure <code>S</code> on the objects of a univalent category <code>S</code> can be described in a certain way, then the category of <code>S</code>-structured objects of <code>C</code> is univalent. As a benefit, the Book version of the SIP characterises the <em>homomorphisms</em> of <code>S</code>-structures, not just the <em>isomorphisms</em>. As a downside, it only applies to <a data-type="Type ℓ → Type ℓ" href="1Lab.HLevel.html#3342">set-level</a> structures.</p>
<pre class="Agda"><a id="1935" class="Keyword">record</a>
  <a id="Structure"></a><a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="1944" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="1954" class="Symbol">{</a><a id="1955" href="1Lab.Univalence.SIP.html#1955" class="Bound">ℓ₁</a> <a id="1958" href="1Lab.Univalence.SIP.html#1958" class="Bound">ℓ₂</a><a id="1960" class="Symbol">}</a> <a id="1962" class="Symbol">(</a><a id="1963" href="1Lab.Univalence.SIP.html#1963" class="Bound">ℓ₃</a> <a id="1966" class="Symbol">:</a> <a id="1968" class="Symbol">_)</a> <a id="1971" class="Symbol">(</a><a id="1972" href="1Lab.Univalence.SIP.html#1972" class="Bound">S</a> <a id="1974" class="Symbol">:</a> <a id="1976" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="1981" href="1Lab.Univalence.SIP.html#1955" class="Bound">ℓ₁</a> <a id="1984" class="Symbol">→</a> <a id="1986" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="1991" href="1Lab.Univalence.SIP.html#1958" class="Bound">ℓ₂</a><a id="1993" class="Symbol">)</a> <a id="1995" class="Symbol">:</a> <a id="1997" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2002" class="Symbol">(</a><a data-type="Level → Level" id="2003" href="Agda.Primitive.html#780" class="Primitive">lsuc</a> <a id="2008" class="Symbol">(</a><a id="2009" href="1Lab.Univalence.SIP.html#1955" class="Bound">ℓ₁</a> <a data-type="Level → Level → Level" id="2012" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="2014" href="1Lab.Univalence.SIP.html#1963" class="Bound">ℓ₃</a><a id="2016" class="Symbol">)</a> <a data-type="Level → Level → Level" id="2018" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="2020" href="1Lab.Univalence.SIP.html#1958" class="Bound">ℓ₂</a><a id="2022" class="Symbol">)</a>
  <a id="2026" class="Keyword">where</a>

  <a id="2035" class="Keyword">constructor</a> <a id="HomT→Str"></a><a data-type="(is-hom₁ : (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃) →
Structure ℓ₃ S₁" id="2047" href="1Lab.Univalence.SIP.html#2047" class="InductiveConstructor">HomT→Str</a>
  <a id="2058" class="Keyword">field</a>
</pre>
<p>The material on this page, especially the definition of <span class="Agda"><a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a></span> and <span class="Agda"><a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a></span>, is adapted from <cite><a href="https://arxiv.org/abs/2009.05547">Internalizing Representation Independence with Univalence</a></cite>. The SIP formalised here says, very generically, that a <span class="Agda"><a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a></span> is a family of types <code>S : Type → Type</code>, and a <span class="Agda"><a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" href="1Lab.Univalence.SIP.html#3316" class="Function">type with</a></span> structure is an inhabitant of the <a href="1Lab.Type.html#1649">total space</a> <code>Σ S</code>.</p>
<p>What sets a <span class="Agda"><a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a></span> apart from a type family is a notion of <em>homomorphic equivalence</em>: Given an equivalence of the underlying types, the predicate <code>is-hom (A , x) (B , y) eqv</code> should represent what it means for <code>eqv</code> to take the <code>x</code>-structure on <code>A</code> to the <code>y</code>-structure on <code>B</code>.</p>
<pre class="Agda">   <a id="Structure.is-hom"></a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="2872" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="2879" class="Symbol">:</a> <a id="2881" class="Symbol">(</a><a id="2882" href="1Lab.Univalence.SIP.html#2882" class="Bound">A</a> <a id="2884" href="1Lab.Univalence.SIP.html#2884" class="Bound">B</a> <a id="2886" class="Symbol">:</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="2888" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="2890" href="1Lab.Univalence.SIP.html#1972" class="Bound">S</a><a id="2891" class="Symbol">)</a> <a id="2893" class="Symbol">→</a> <a id="2895" class="Symbol">(</a><a id="2896" href="1Lab.Univalence.SIP.html#2882" class="Bound">A</a> <a id="2898" class="Symbol">.</a><a data-type="∑ A B → A" id="2899" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="2903" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="2905" href="1Lab.Univalence.SIP.html#2884" class="Bound">B</a> <a id="2907" class="Symbol">.</a><a data-type="∑ A B → A" id="2908" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="2911" class="Symbol">)</a> <a id="2913" class="Symbol">→</a> <a id="2915" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2920" href="1Lab.Univalence.SIP.html#1963" class="Bound">ℓ₃</a>
</pre>
<p>As a grounding example, consider equipping types with group structure: If <code>(A , _⋆_)</code> and <code>(B , _*_)</code> are types with group structure (with many fields omitted!), and <code>f : A → B</code> is the underlying map of an equivalence <code>A ≃ B</code>, then <span class="Agda"><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a></span> would be <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mo stretchy="false">(</mo><mi>x</mi><mi>y</mi><mspace></mspace><mspace width="0.1111em"></mspace><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333em"></mspace><mi>A</mi><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo>⋆</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall (x y\colon A) f(x \star y) = f(x) * f(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∀</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋆</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>

 - the “usual” definition of group homomorphism.</p>
<pre class="Agda"><a id="3293" class="Keyword">open</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="3298" href="1Lab.Univalence.SIP.html#1944" class="Module">Structure</a> <a id="3308" class="Keyword">public</a>

<a id="TypeWith"></a><a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="3316" href="1Lab.Univalence.SIP.html#3316" class="Function">TypeWith</a> <a id="3325" class="Symbol">:</a> <a id="3327" class="Symbol">∀</a> <a id="3329" class="Symbol">{</a><a id="3330" href="1Lab.Univalence.SIP.html#3330" class="Bound">ℓ</a> <a id="3332" href="1Lab.Univalence.SIP.html#3332" class="Bound">ℓ₁</a> <a id="3335" href="1Lab.Univalence.SIP.html#3335" class="Bound">ℓ₂</a><a id="3337" class="Symbol">}</a> <a id="3339" class="Symbol">{</a><a id="3340" href="1Lab.Univalence.SIP.html#3340" class="Bound">S</a> <a id="3342" class="Symbol">:</a> <a id="3344" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3349" href="1Lab.Univalence.SIP.html#3330" class="Bound">ℓ</a> <a id="3351" class="Symbol">→</a> <a id="3353" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3358" href="1Lab.Univalence.SIP.html#3332" class="Bound">ℓ₁</a><a id="3360" class="Symbol">}</a> <a id="3362" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="3364" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="3374" href="1Lab.Univalence.SIP.html#3335" class="Bound">ℓ₂</a> <a id="3377" href="1Lab.Univalence.SIP.html#3340" class="Bound">S</a> <a id="3379" class="Symbol">→</a> <a id="3381" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3386" class="Symbol">_</a>
<a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="3388" href="1Lab.Univalence.SIP.html#3316" class="Function">TypeWith</a> <a id="3397" class="Symbol">{</a><a id="3398" class="Argument">S</a> <a id="3400" class="Symbol">=</a> <a id="3402" href="1Lab.Univalence.SIP.html#3402" class="Bound">S</a><a id="3403" class="Symbol">}</a> <a id="3405" class="Symbol">_</a> <a id="3407" class="Symbol">=</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="3409" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="3411" href="1Lab.Univalence.SIP.html#3402" class="Bound">S</a>
</pre>
<!--
<pre class="Agda"><a id="3431" class="Keyword">private</a> <a id="3439" class="Keyword">variable</a>
  <a id="3450" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="3452" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a> <a id="3455" href="1Lab.Univalence.SIP.html#3455" class="Generalizable">ℓ₂</a> <a id="3458" href="1Lab.Univalence.SIP.html#3458" class="Generalizable">ℓ₃</a> <a id="3461" class="Symbol">:</a> <a id="3463" href="Agda.Primitive.html#597" class="Postulate">Level</a>
  <a id="3471" href="1Lab.Univalence.SIP.html#3471" class="Generalizable">A</a> <a id="3473" class="Symbol">:</a> <a id="3475" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3480" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a>
  <a id="3484" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="3486" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a> <a id="3488" class="Symbol">:</a> <a id="3490" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3495" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="3497" class="Symbol">→</a> <a id="3499" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3504" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a>
</pre>-->
<p>A structure is said to be <strong>univalent</strong> if a homomorphic equivalence of structures <code>A</code>, <code>B</code> induces a path of the structures, over the univalence axiom — that is, if <span class="Agda"><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a></span> agrees with what it means for “S X” and “S Y” to be equal, where this equality is dependent on one induced by univalence.</p>
<pre class="Agda"><a id="isUnivalent"></a><a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="3831" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="3843" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="3845" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="3855" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="3857" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="3859" class="Symbol">→</a> <a id="3861" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3866" class="Symbol">_</a>
<a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="3868" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="3880" class="Symbol">{</a><a id="3881" class="Argument">S</a> <a id="3883" class="Symbol">=</a> <a id="3885" href="1Lab.Univalence.SIP.html#3885" class="Bound">S</a><a id="3886" class="Symbol">}</a> <a id="3888" href="1Lab.Univalence.SIP.html#3888" class="Bound">ι</a> <a id="3890" class="Symbol">=</a>
  <a id="3894" class="Symbol">∀</a> <a id="3896" class="Symbol">{</a><a id="3897" href="1Lab.Univalence.SIP.html#3897" class="Bound">X</a> <a id="3899" href="1Lab.Univalence.SIP.html#3899" class="Bound">Y</a><a id="3900" class="Symbol">}</a>
  <a id="3904" class="Symbol">→</a> <a id="3906" class="Symbol">(</a><a id="3907" href="1Lab.Univalence.SIP.html#3907" class="Bound">f</a> <a id="3909" class="Symbol">:</a> <a id="3911" href="1Lab.Univalence.SIP.html#3897" class="Bound">X</a> <a id="3913" class="Symbol">.</a><a data-type="∑ A B → A" id="3914" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="3918" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="3920" href="1Lab.Univalence.SIP.html#3899" class="Bound">Y</a> <a id="3922" class="Symbol">.</a><a data-type="∑ A B → A" id="3923" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="3926" class="Symbol">)</a>
  <a id="3930" class="Symbol">→</a> <a id="3932" href="1Lab.Univalence.SIP.html#3888" class="Bound">ι</a> <a id="3934" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="3935" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="3942" href="1Lab.Univalence.SIP.html#3897" class="Bound">X</a> <a id="3944" href="1Lab.Univalence.SIP.html#3899" class="Bound">Y</a> <a id="3946" href="1Lab.Univalence.SIP.html#3907" class="Bound">f</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="3948" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="3950" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="3956" class="Symbol">(λ</a> <a id="3959" href="1Lab.Univalence.SIP.html#3959" class="Bound">i</a> <a id="3961" class="Symbol">→</a> <a id="3963" href="1Lab.Univalence.SIP.html#3885" class="Bound">S</a> <a id="3965" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="3966" href="1Lab.Univalence.html#8827" class="Function">ua</a> <a id="3969" href="1Lab.Univalence.SIP.html#3907" class="Bound">f</a> <a id="3971" href="1Lab.Univalence.SIP.html#3959" class="Bound">i</a><a id="3972" class="Symbol">))</a> <a id="3975" class="Symbol">(</a><a id="3976" href="1Lab.Univalence.SIP.html#3897" class="Bound">X</a> <a id="3978" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="3979" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="3982" class="Symbol">)</a> <a id="3984" class="Symbol">(</a><a id="3985" href="1Lab.Univalence.SIP.html#3899" class="Bound">Y</a> <a id="3987" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="3988" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="3991" class="Symbol">)</a>
</pre>
<p>The notation <span class="Agda"><a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">A ≃[ σ ] B</a></span> stands for the type of σ-homomorphic equivalences, i.e. those equivalences of the types underlying <code>A</code> and <code>B</code> that σ identifies as being homomorphic.</p>
<pre class="Agda"><a id="_≃[_]_"></a><a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="4204" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">_≃[_]_</a> <a id="4211" class="Symbol">:</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="4213" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="4215" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="4217" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="4219" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="4229" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="4231" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="4233" class="Symbol">→</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="4235" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="4237" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="4239" class="Symbol">→</a> <a id="4241" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="4246" class="Symbol">_</a>
<a id="4248" href="1Lab.Univalence.SIP.html#4248" class="Bound">A</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="4250" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">≃[</a> <a id="4253" href="1Lab.Univalence.SIP.html#4253" class="Bound">σ</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="4255" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">]</a> <a id="4257" href="1Lab.Univalence.SIP.html#4257" class="Bound">B</a> <a id="4259" class="Symbol">=</a>
  <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="4263" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="4266" href="1Lab.Univalence.SIP.html#4266" class="Bound">f</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="4268" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="4270" href="1Lab.Univalence.SIP.html#4248" class="Bound">A</a> <a id="4272" class="Symbol">.</a><a data-type="∑ A B → A" id="4273" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="4277" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="4279" href="1Lab.Univalence.SIP.html#4257" class="Bound">B</a> <a id="4281" class="Symbol">.</a><a data-type="∑ A B → A" id="4282" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="4286" href="1Lab.Type.html#1563" class="Function">]</a>
   <a id="4291" class="Symbol">(</a><a id="4292" href="1Lab.Univalence.SIP.html#4253" class="Bound">σ</a> <a id="4294" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="4295" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="4302" href="1Lab.Univalence.SIP.html#4248" class="Bound">A</a> <a id="4304" href="1Lab.Univalence.SIP.html#4257" class="Bound">B</a> <a id="4306" href="1Lab.Univalence.SIP.html#4266" class="Bound">f</a><a id="4307" class="Symbol">)</a>
</pre>
<h2 id="the-principle"><a href="#the-principle" class="header-link">The principle<span class="header-link-emoji">🔗</span></a></h2>
<p>The <strong>structure identity principle</strong> says that, if <code>S</code> is a <span class="Agda"><a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" href="1Lab.Univalence.SIP.html#3831" class="Function">univalent structure</a></span>, then the path space of <code>Σ S</code> is equivalent to the space of S-homomorphic equivalences of types. Again using groups as a grounding example: equality of groups is group isomorphism.</p>
<pre class="Agda"><a id="SIP"></a><a data-type="isUnivalent σ → (X ≃[ σ ] Y) ≃ (X ≡ Y)" id="4629" href="1Lab.Univalence.SIP.html#4629" class="Function">SIP</a> <a id="4633" class="Symbol">:</a> <a id="4635" class="Symbol">{</a><a id="4636" href="1Lab.Univalence.SIP.html#4636" class="Bound">σ</a> <a id="4638" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="4640" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="4650" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="4652" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="4653" class="Symbol">}</a> <a id="4655" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="4657" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="4669" href="1Lab.Univalence.SIP.html#4636" class="Bound">σ</a> <a id="4671" class="Symbol">→</a> <a id="4673" class="Symbol">{</a><a id="4674" href="1Lab.Univalence.SIP.html#4674" class="Bound">X</a> <a id="4676" href="1Lab.Univalence.SIP.html#4676" class="Bound">Y</a> <a id="4678" class="Symbol">:</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="4680" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="4682" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="4683" class="Symbol">}</a> <a id="4685" class="Symbol">→</a> <a id="4687" class="Symbol">(</a><a id="4688" href="1Lab.Univalence.SIP.html#4674" class="Bound">X</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="4690" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">≃[</a> <a id="4693" href="1Lab.Univalence.SIP.html#4636" class="Bound">σ</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="4695" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">]</a> <a id="4697" href="1Lab.Univalence.SIP.html#4676" class="Bound">Y</a><a id="4698" class="Symbol">)</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="4700" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="4702" class="Symbol">(</a><a id="4703" href="1Lab.Univalence.SIP.html#4674" class="Bound">X</a> <a data-type="A → A → Type ℓ" id="4705" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="4707" href="1Lab.Univalence.SIP.html#4676" class="Bound">Y</a><a id="4708" class="Symbol">)</a>
<a data-type="isUnivalent σ → (X ≃[ σ ] Y) ≃ (X ≡ Y)" id="4710" href="1Lab.Univalence.SIP.html#4629" class="Function">SIP</a> <a id="4714" class="Symbol">{</a><a id="4715" class="Argument">S</a> <a id="4717" class="Symbol">=</a> <a id="4719" href="1Lab.Univalence.SIP.html#4719" class="Bound">S</a><a id="4720" class="Symbol">}</a> <a id="4722" class="Symbol">{</a><a id="4723" class="Argument">σ</a> <a id="4725" class="Symbol">=</a> <a id="4727" href="1Lab.Univalence.SIP.html#4727" class="Bound">σ</a><a id="4728" class="Symbol">}</a> <a id="4730" href="1Lab.Univalence.SIP.html#4730" class="Bound">is-univ</a> <a id="4738" class="Symbol">{</a><a id="4739" href="1Lab.Univalence.SIP.html#4739" class="Bound">X</a><a id="4740" class="Symbol">}</a> <a id="4742" class="Symbol">{</a><a id="4743" href="1Lab.Univalence.SIP.html#4743" class="Bound">Y</a><a id="4744" class="Symbol">}</a> <a id="4746" class="Symbol">=</a>
  <a id="4750" href="1Lab.Univalence.SIP.html#4739" class="Bound">X</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="4752" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">≃[</a> <a id="4755" href="1Lab.Univalence.SIP.html#4727" class="Bound">σ</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="4757" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">]</a> <a id="4759" href="1Lab.Univalence.SIP.html#4743" class="Bound">Y</a>                                                       <a data-type="(A : Type ℓ) → A ≃ B → A ≃ B" id="4815" href="1Lab.Equiv.html#22946" class="Function Operator">≃⟨⟩</a>
  <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="4821" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="4824" href="1Lab.Univalence.SIP.html#4824" class="Bound">e</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="4826" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="4828" href="1Lab.Univalence.SIP.html#4739" class="Bound">X</a> <a id="4830" class="Symbol">.</a><a data-type="∑ A B → A" id="4831" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="4835" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="4837" href="1Lab.Univalence.SIP.html#4743" class="Bound">Y</a> <a id="4839" class="Symbol">.</a><a data-type="∑ A B → A" id="4840" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="4844" href="1Lab.Type.html#1563" class="Function">]</a> <a id="4846" class="Symbol">(</a><a id="4847" href="1Lab.Univalence.SIP.html#4727" class="Bound">σ</a> <a id="4849" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="4850" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="4857" href="1Lab.Univalence.SIP.html#4739" class="Bound">X</a> <a id="4859" href="1Lab.Univalence.SIP.html#4743" class="Bound">Y</a> <a id="4861" href="1Lab.Univalence.SIP.html#4824" class="Bound">e</a><a id="4862" class="Symbol">)</a>                       <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="4886" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a data-type="(e : A ≃ A&#39;) → ((x : A) → P x ≃ Q (e .fst x)) → Σ P ≃ Σ Q" id="4889" href="1Lab.Type.Sigma.html#2110" class="Function">Σ-ap</a> <a id="4894" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="4895" href="1Lab.Univalence.html#8827" class="Function">ua</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="4898" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv ua" id="4900" href="1Lab.Univalence.html#16851" class="Function">univalence⁻¹</a><a id="4912" class="Symbol">)</a> <a id="4914" href="1Lab.Univalence.SIP.html#4730" class="Bound">is-univ</a> <a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="4922" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="4926" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="4929" href="1Lab.Univalence.SIP.html#4929" class="Bound">p</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="4931" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="4933" href="1Lab.Univalence.SIP.html#4739" class="Bound">X</a> <a id="4935" class="Symbol">.</a><a data-type="∑ A B → A" id="4936" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="A → A → Type ℓ" id="4940" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="4942" href="1Lab.Univalence.SIP.html#4743" class="Bound">Y</a> <a id="4944" class="Symbol">.</a><a data-type="∑ A B → A" id="4945" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="4949" href="1Lab.Type.html#1563" class="Function">]</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="4951" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="4957" class="Symbol">(λ</a> <a id="4960" href="1Lab.Univalence.SIP.html#4960" class="Bound">i</a> <a id="4962" class="Symbol">→</a> <a id="4964" href="1Lab.Univalence.SIP.html#4719" class="Bound">S</a> <a id="4966" class="Symbol">(</a><a id="4967" href="1Lab.Univalence.SIP.html#4929" class="Bound">p</a> <a id="4969" href="1Lab.Univalence.SIP.html#4960" class="Bound">i</a><a id="4970" class="Symbol">))</a> <a id="4973" class="Symbol">(</a><a id="4974" href="1Lab.Univalence.SIP.html#4739" class="Bound">X</a> <a id="4976" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="4977" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="4980" class="Symbol">)</a> <a id="4982" class="Symbol">(</a><a id="4983" href="1Lab.Univalence.SIP.html#4743" class="Bound">Y</a> <a id="4985" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="4986" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="4989" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="4991" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a data-type="Iso A B → A ≃ B" id="4994" href="1Lab.Equiv.html#20090" class="Function">Iso→Equiv</a> <a data-type="Iso (Σ (λ p → PathP (λ i → B i (p i)) (x .snd) (y .snd)))
(PathP (λ i → Σ (B i)) x y)" id="5004" href="1Lab.Type.Sigma.html#553" class="Function">Σ-PathP-iso</a> <a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="5016" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a id="5020" class="Symbol">(</a><a id="5021" href="1Lab.Univalence.SIP.html#4739" class="Bound">X</a> <a data-type="A → A → Type ℓ" id="5023" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="5025" href="1Lab.Univalence.SIP.html#4743" class="Bound">Y</a><a id="5026" class="Symbol">)</a>                                                          <a data-type="(A : Type ℓ) → A ≃ A" id="5085" href="1Lab.Equiv.html#23023" class="Function Operator">≃∎</a>
</pre>
<p>The proof of the <span class="Agda"><a data-type="isUnivalent σ → (X ≃[ σ ] Y) ≃ (X ≡ Y)" href="1Lab.Univalence.SIP.html#4629" class="Function">SIP</a></span> follows essentially from <span class="Agda"><a data-type="isEquiv ua" href="1Lab.Univalence.html#16851" class="Function">univalence</a></span>, and the fact that <span class="Agda"><a data-type="(e : A ≃ A&#39;) → ((x : A) → P x ≃ Q (e .fst x)) → Σ P ≃ Σ Q" href="1Lab.Type.Sigma.html#2110" class="Function">Σ types respect equivalences</a></span>. In one fell swoop, we convert from the type of homomorphic equivalences to a dependent pair of paths. By the characterisation of <span class="Agda"><a data-type="Iso (Σ (λ p → PathP (λ i → B i (p i)) (x .snd) (y .snd)))
(PathP (λ i → Σ (B i)) x y)" href="1Lab.Type.Sigma.html#553" class="Function">path spaces of Σ types</a></span>, this latter pair is equivalent to <code>X ≡ Y</code>.</p>
<pre class="Agda"><a id="sip"></a><a data-type="isUnivalent σ → X ≃[ σ ] Y → X ≡ Y" id="5488" href="1Lab.Univalence.SIP.html#5488" class="Function">sip</a> <a id="5492" class="Symbol">:</a> <a id="5494" class="Symbol">{</a><a id="5495" href="1Lab.Univalence.SIP.html#5495" class="Bound">σ</a> <a id="5497" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="5499" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="5509" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="5511" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="5512" class="Symbol">}</a> <a id="5514" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="5516" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="5528" href="1Lab.Univalence.SIP.html#5495" class="Bound">σ</a> <a id="5530" class="Symbol">→</a> <a id="5532" class="Symbol">{</a><a id="5533" href="1Lab.Univalence.SIP.html#5533" class="Bound">X</a> <a id="5535" href="1Lab.Univalence.SIP.html#5535" class="Bound">Y</a> <a id="5537" class="Symbol">:</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="5539" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="5541" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="5542" class="Symbol">}</a> <a id="5544" class="Symbol">→</a> <a id="5546" class="Symbol">(</a><a id="5547" href="1Lab.Univalence.SIP.html#5533" class="Bound">X</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="5549" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">≃[</a> <a id="5552" href="1Lab.Univalence.SIP.html#5495" class="Bound">σ</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="5554" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">]</a> <a id="5556" href="1Lab.Univalence.SIP.html#5535" class="Bound">Y</a><a id="5557" class="Symbol">)</a> <a id="5559" class="Symbol">→</a> <a id="5561" class="Symbol">(</a><a id="5562" href="1Lab.Univalence.SIP.html#5533" class="Bound">X</a> <a data-type="A → A → Type ℓ" id="5564" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="5566" href="1Lab.Univalence.SIP.html#5535" class="Bound">Y</a><a id="5567" class="Symbol">)</a>
<a data-type="isUnivalent σ → X ≃[ σ ] Y → X ≡ Y" id="5569" href="1Lab.Univalence.SIP.html#5488" class="Function">sip</a> <a id="5573" href="1Lab.Univalence.SIP.html#5573" class="Bound">σ</a> <a id="5575" class="Symbol">=</a> <a data-type="isUnivalent σ → (X ≃[ σ ] Y) ≃ (X ≡ Y)" id="5577" href="1Lab.Univalence.SIP.html#4629" class="Function">SIP</a> <a id="5581" href="1Lab.Univalence.SIP.html#5573" class="Bound">σ</a> <a id="5583" class="Symbol">.</a><a data-type="∑ A B → A" id="5584" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a>
</pre>
<h1 id="structure-combinators"><a href="#structure-combinators" class="header-link">Structure Combinators<span class="header-link-emoji">🔗</span></a></h1>
<p>Univalent structures can be built up in an algebraic manner through the use of <em>structure combinators</em>. These express closure of structures under a number of type formers. For instance, if <code>S</code> and <code>T</code> are univalent structures, then so is <code>λ X → S X → T X</code>.</p>
<p>The simplest case of univalent structure is the <em>constant structure</em>, which is what you get when you equip a type <code>X</code> with a choice of inhabitant of some other type <code>Y</code>, unrelated to <code>X</code>. Since the given function is <code>f : A → B</code>, it can’t act on <code>T</code>, so the notion of homomorphism is independent of <code>f</code>.</p>
<pre class="Agda"><a id="constantStr"></a><a data-type="(A : Type ℓ) → Structure ℓ (λ X → A)" id="6188" href="1Lab.Univalence.SIP.html#6188" class="Function">constantStr</a> <a id="6200" class="Symbol">:</a> <a id="6202" class="Symbol">(</a><a id="6203" href="1Lab.Univalence.SIP.html#6203" class="Bound">A</a> <a id="6205" class="Symbol">:</a> <a id="6207" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="6212" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a><a id="6213" class="Symbol">)</a> <a id="6215" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="6217" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="6227" class="Symbol">{</a><a id="6228" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a><a id="6230" class="Symbol">}</a> <a id="6232" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="6234" class="Symbol">(λ</a> <a id="6237" href="1Lab.Univalence.SIP.html#6237" class="Bound">X</a> <a id="6239" class="Symbol">→</a> <a id="6241" href="1Lab.Univalence.SIP.html#6203" class="Bound">A</a><a id="6242" class="Symbol">)</a>
<a data-type="(A : Type ℓ) → Structure ℓ (λ X → A)" id="6244" href="1Lab.Univalence.SIP.html#6188" class="Function">constantStr</a> <a id="6256" href="1Lab.Univalence.SIP.html#6256" class="Bound">T</a> <a id="6258" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="6259" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="6266" class="Symbol">(</a><a id="6267" href="1Lab.Univalence.SIP.html#6267" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="6269" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="6271" href="1Lab.Univalence.SIP.html#6271" class="Bound">x</a><a id="6272" class="Symbol">)</a> <a id="6274" class="Symbol">(</a><a id="6275" href="1Lab.Univalence.SIP.html#6275" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="6277" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="6279" href="1Lab.Univalence.SIP.html#6279" class="Bound">y</a><a id="6280" class="Symbol">)</a> <a id="6282" href="1Lab.Univalence.SIP.html#6282" class="Bound">f</a> <a id="6284" class="Symbol">=</a> <a id="6286" href="1Lab.Univalence.SIP.html#6271" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="6288" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="6290" href="1Lab.Univalence.SIP.html#6279" class="Bound">y</a>

<a id="constantStr-univalent"></a><a data-type="isUnivalent (constantStr A)" id="6293" href="1Lab.Univalence.SIP.html#6293" class="Function">constantStr-univalent</a> <a id="6315" class="Symbol">:</a> <a id="6317" class="Symbol">{</a><a id="6318" href="1Lab.Univalence.SIP.html#6318" class="Bound">A</a> <a id="6320" class="Symbol">:</a> <a id="6322" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="6327" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a><a id="6328" class="Symbol">}</a> <a id="6330" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="6332" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="6344" class="Symbol">(</a><a data-type="(A : Type ℓ) → Structure ℓ (λ X → A)" id="6345" href="1Lab.Univalence.SIP.html#6188" class="Function">constantStr</a> <a id="6357" class="Symbol">{</a><a id="6358" class="Argument">ℓ₁</a> <a id="6361" class="Symbol">=</a> <a id="6363" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a><a id="6365" class="Symbol">}</a> <a id="6367" href="1Lab.Univalence.SIP.html#6318" class="Bound">A</a><a id="6368" class="Symbol">)</a>
<a data-type="isUnivalent (constantStr A)" id="6370" href="1Lab.Univalence.SIP.html#6293" class="Function">constantStr-univalent</a> <a id="6392" href="1Lab.Univalence.SIP.html#6392" class="Bound">f</a> <a id="6394" class="Symbol">=</a> <a id="6396" class="Symbol">_</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="6398" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="6400" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a>
</pre>
<p>The next simplest case is considering the identity function as a structure. In that case, the resulting structured type is that of a <em>pointed type</em>, whence the name <span class="Agda"><a data-type="Structure ℓ (λ X → X)" href="1Lab.Univalence.SIP.html#7039" class="Function">pointedStr</a></span>.</p>
<p>The name <span class="Agda"><a data-type="Structure ℓ (λ X → X)" href="1Lab.Univalence.SIP.html#7039" class="Function">pointedStr</a></span> breaks down when it is used with some of the other combinators: A type equipped with the <span class="Agda"><a data-type="Structure ℓ S₁ →
Structure ℓ₂ T → Structure (ℓ ⊔ ℓ₂) (λ X → S₁ X × T X)" href="1Lab.Univalence.SIP.html#7539" class="Function">product</a></span> of two <span class="Agda"><a data-type="Structure ℓ (λ X → X)" href="1Lab.Univalence.SIP.html#7039" class="Function">pointed structures</a></span> is indeed a “bipointed structure”, but a type equipped with <span class="Agda"><a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" href="1Lab.Univalence.SIP.html#16922" class="Function">maps between</a></span> two <span class="Agda"><a data-type="Structure ℓ (λ X → X)" href="1Lab.Univalence.SIP.html#7039" class="Function">pointed structures</a></span> is a type equipped with an endomorphism, which does not necessitate a point.</p>
<pre class="Agda"><a id="pointedStr"></a><a data-type="Structure ℓ (λ X → X)" id="7039" href="1Lab.Univalence.SIP.html#7039" class="Function">pointedStr</a> <a id="7050" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="7052" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="7062" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="7064" class="Symbol">(λ</a> <a id="7067" href="1Lab.Univalence.SIP.html#7067" class="Bound">X</a> <a id="7069" class="Symbol">→</a> <a id="7071" href="1Lab.Univalence.SIP.html#7067" class="Bound">X</a><a id="7072" class="Symbol">)</a>
<a data-type="Structure ℓ (λ X → X)" id="7074" href="1Lab.Univalence.SIP.html#7039" class="Function">pointedStr</a> <a id="7085" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="7086" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="7093" class="Symbol">(</a><a id="7094" href="1Lab.Univalence.SIP.html#7094" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="7096" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7098" href="1Lab.Univalence.SIP.html#7098" class="Bound">x</a><a id="7099" class="Symbol">)</a> <a id="7101" class="Symbol">(</a><a id="7102" href="1Lab.Univalence.SIP.html#7102" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="7104" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7106" href="1Lab.Univalence.SIP.html#7106" class="Bound">y</a><a id="7107" class="Symbol">)</a> <a id="7109" href="1Lab.Univalence.SIP.html#7109" class="Bound">f</a> <a id="7111" class="Symbol">=</a> <a id="7113" href="1Lab.Univalence.SIP.html#7109" class="Bound">f</a> <a id="7115" class="Symbol">.</a><a data-type="∑ A B → A" id="7116" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="7120" href="1Lab.Univalence.SIP.html#7098" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="7122" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="7124" href="1Lab.Univalence.SIP.html#7106" class="Bound">y</a>
</pre>
<p>This is univalent by <span class="Agda"><a data-type="(e : A ≃ B) → (e .fst x ≡ y) ≃ PathP (λ i → ua e i) x y" href="1Lab.Univalence.html#14306" class="Function">uaPathP≃Path</a></span>, which says <code>PathP (ua f) x y</code> is equivalent to <code>f .fst x ≡ y</code>.</p>
<pre class="Agda"><a id="pointedStr-univalent"></a><a data-type="isUnivalent pointedStr" id="7247" href="1Lab.Univalence.SIP.html#7247" class="Function">pointedStr-univalent</a> <a id="7268" class="Symbol">:</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="7270" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="7282" class="Symbol">(</a><a data-type="Structure ℓ (λ X → X)" id="7283" href="1Lab.Univalence.SIP.html#7039" class="Function">pointedStr</a> <a id="7294" class="Symbol">{</a><a id="7295" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a><a id="7296" class="Symbol">})</a>
<a data-type="isUnivalent pointedStr" id="7299" href="1Lab.Univalence.SIP.html#7247" class="Function">pointedStr-univalent</a> <a id="7320" href="1Lab.Univalence.SIP.html#7320" class="Bound">f</a> <a id="7322" class="Symbol">=</a> <a data-type="(e : A ≃ B) → (e .fst x ≡ y) ≃ PathP (λ i → ua e i) x y" id="7324" href="1Lab.Univalence.html#14306" class="Function">uaPathP≃Path</a> <a id="7337" class="Symbol">_</a>
</pre>
<p>If <code>S</code> and <code>T</code> are univalent structures, then so is their pointwise product. The notion of a <code>S × T</code>-homomorphism is that of a function homomorphic for both <code>S</code> and <code>T</code>, simultaneously:</p>
<pre class="Agda"><a id="productStr"></a><a data-type="Structure ℓ S₁ →
Structure ℓ₂ T → Structure (ℓ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="7539" href="1Lab.Univalence.SIP.html#7539" class="Function">productStr</a> <a id="7550" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="7552" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="7562" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="7564" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="7566" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="7568" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="7578" href="1Lab.Univalence.SIP.html#3455" class="Generalizable">ℓ₂</a> <a id="7581" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a> <a id="7583" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="7585" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="7595" class="Symbol">_</a> <a id="7597" class="Symbol">(λ</a> <a id="7600" href="1Lab.Univalence.SIP.html#7600" class="Bound">X</a> <a id="7602" class="Symbol">→</a> <a id="7604" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="7606" href="1Lab.Univalence.SIP.html#7600" class="Bound">X</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="7608" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="7610" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a> <a id="7612" href="1Lab.Univalence.SIP.html#7600" class="Bound">X</a><a id="7613" class="Symbol">)</a>
<a data-type="Structure ℓ S₁ →
Structure ℓ₂ T → Structure (ℓ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="7615" href="1Lab.Univalence.SIP.html#7539" class="Function">productStr</a> <a id="7626" href="1Lab.Univalence.SIP.html#7626" class="Bound">S</a> <a id="7628" href="1Lab.Univalence.SIP.html#7628" class="Bound">T</a> <a id="7630" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="7631" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="7638" class="Symbol">(</a><a id="7639" href="1Lab.Univalence.SIP.html#7639" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="7641" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7643" href="1Lab.Univalence.SIP.html#7643" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="7645" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7647" href="1Lab.Univalence.SIP.html#7647" class="Bound">y</a><a id="7648" class="Symbol">)</a> <a id="7650" class="Symbol">(</a><a id="7651" href="1Lab.Univalence.SIP.html#7651" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="7653" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7655" href="1Lab.Univalence.SIP.html#7655" class="Bound">x&#39;</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="7658" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7660" href="1Lab.Univalence.SIP.html#7660" class="Bound">y&#39;</a><a id="7662" class="Symbol">)</a> <a id="7664" href="1Lab.Univalence.SIP.html#7664" class="Bound">f</a> <a id="7666" class="Symbol">=</a>
  <a id="7670" href="1Lab.Univalence.SIP.html#7626" class="Bound">S</a> <a id="7672" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="7673" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="7680" class="Symbol">(</a><a id="7681" href="1Lab.Univalence.SIP.html#7639" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="7683" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7685" href="1Lab.Univalence.SIP.html#7643" class="Bound">x</a><a id="7686" class="Symbol">)</a> <a id="7688" class="Symbol">(</a><a id="7689" href="1Lab.Univalence.SIP.html#7651" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="7691" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7693" href="1Lab.Univalence.SIP.html#7655" class="Bound">x&#39;</a><a id="7695" class="Symbol">)</a> <a id="7697" href="1Lab.Univalence.SIP.html#7664" class="Bound">f</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="7699" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="7701" href="1Lab.Univalence.SIP.html#7628" class="Bound">T</a> <a id="7703" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="7704" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="7711" class="Symbol">(</a><a id="7712" href="1Lab.Univalence.SIP.html#7639" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="7714" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7716" href="1Lab.Univalence.SIP.html#7647" class="Bound">y</a><a id="7717" class="Symbol">)</a> <a id="7719" class="Symbol">(</a><a id="7720" href="1Lab.Univalence.SIP.html#7651" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="7722" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7724" href="1Lab.Univalence.SIP.html#7660" class="Bound">y&#39;</a><a id="7726" class="Symbol">)</a> <a id="7728" href="1Lab.Univalence.SIP.html#7664" class="Bound">f</a>

<a id="productStr-univalent"></a><a data-type="isUnivalent σ → isUnivalent τ → isUnivalent (productStr σ τ)" id="7731" href="1Lab.Univalence.SIP.html#7731" class="Function">productStr-univalent</a> <a id="7752" class="Symbol">:</a> <a id="7754" class="Symbol">{</a><a id="7755" href="1Lab.Univalence.SIP.html#7755" class="Bound">σ</a> <a id="7757" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="7759" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="7769" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a> <a id="7772" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="7773" class="Symbol">}</a> <a id="7775" class="Symbol">{</a><a id="7776" href="1Lab.Univalence.SIP.html#7776" class="Bound">τ</a> <a id="7778" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="7780" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="7790" href="1Lab.Univalence.SIP.html#3455" class="Generalizable">ℓ₂</a> <a id="7793" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a><a id="7794" class="Symbol">}</a>
                     <a id="7817" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="7819" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="7831" href="1Lab.Univalence.SIP.html#7755" class="Bound">σ</a> <a id="7833" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="7835" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="7847" href="1Lab.Univalence.SIP.html#7776" class="Bound">τ</a>
                     <a id="7870" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="7872" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="7884" class="Symbol">(</a><a data-type="Structure ℓ S₁ →
Structure ℓ₂ T → Structure (ℓ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="7885" href="1Lab.Univalence.SIP.html#7539" class="Function">productStr</a> <a id="7896" href="1Lab.Univalence.SIP.html#7755" class="Bound">σ</a> <a id="7898" href="1Lab.Univalence.SIP.html#7776" class="Bound">τ</a><a id="7899" class="Symbol">)</a>
<a data-type="isUnivalent σ → isUnivalent τ → isUnivalent (productStr σ τ)" id="7901" href="1Lab.Univalence.SIP.html#7731" class="Function">productStr-univalent</a> <a id="7922" class="Symbol">{</a><a id="7923" class="Argument">S</a> <a id="7925" class="Symbol">=</a> <a id="7927" href="1Lab.Univalence.SIP.html#7927" class="Bound">S</a><a id="7928" class="Symbol">}</a> <a id="7930" class="Symbol">{</a><a id="7931" class="Argument">T</a> <a id="7933" class="Symbol">=</a> <a id="7935" href="1Lab.Univalence.SIP.html#7935" class="Bound">T</a><a id="7936" class="Symbol">}</a> <a id="7938" class="Symbol">{</a><a id="7939" class="Argument">σ</a> <a id="7941" class="Symbol">=</a> <a id="7943" href="1Lab.Univalence.SIP.html#7943" class="Bound">σ</a><a id="7944" class="Symbol">}</a> <a id="7946" class="Symbol">{</a><a id="7947" href="1Lab.Univalence.SIP.html#7947" class="Bound">τ</a><a id="7948" class="Symbol">}</a> <a id="7950" href="1Lab.Univalence.SIP.html#7950" class="Bound">θ₁</a> <a id="7953" href="1Lab.Univalence.SIP.html#7953" class="Bound">θ₂</a> <a id="7956" class="Symbol">{</a><a id="7957" href="1Lab.Univalence.SIP.html#7957" class="Bound">X</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="7959" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7961" href="1Lab.Univalence.SIP.html#7961" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="7963" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7965" href="1Lab.Univalence.SIP.html#7965" class="Bound">y</a><a id="7966" class="Symbol">}</a> <a id="7968" class="Symbol">{</a><a id="7969" href="1Lab.Univalence.SIP.html#7969" class="Bound">Y</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="7971" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7973" href="1Lab.Univalence.SIP.html#7973" class="Bound">x&#39;</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="7976" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7978" href="1Lab.Univalence.SIP.html#7978" class="Bound">y&#39;</a><a id="7980" class="Symbol">}</a> <a id="7982" href="1Lab.Univalence.SIP.html#7982" class="Bound">f</a> <a id="7984" class="Symbol">=</a>
  <a id="7988" class="Symbol">(</a><a id="7989" href="1Lab.Univalence.SIP.html#7943" class="Bound">σ</a> <a id="7991" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="7992" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="7999" class="Symbol">(</a><a id="8000" href="1Lab.Univalence.SIP.html#7957" class="Bound">X</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="8002" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8004" href="1Lab.Univalence.SIP.html#7961" class="Bound">x</a><a id="8005" class="Symbol">)</a> <a id="8007" class="Symbol">(</a><a id="8008" href="1Lab.Univalence.SIP.html#7969" class="Bound">Y</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="8010" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8012" href="1Lab.Univalence.SIP.html#7973" class="Bound">x&#39;</a><a id="8014" class="Symbol">)</a> <a id="8016" class="Symbol">_</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="8018" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="8020" href="1Lab.Univalence.SIP.html#7947" class="Bound">τ</a> <a id="8022" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="8023" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="8030" class="Symbol">(</a><a id="8031" href="1Lab.Univalence.SIP.html#7957" class="Bound">X</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="8033" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8035" href="1Lab.Univalence.SIP.html#7965" class="Bound">y</a><a id="8036" class="Symbol">)</a> <a id="8038" class="Symbol">(</a><a id="8039" href="1Lab.Univalence.SIP.html#7969" class="Bound">Y</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="8041" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8043" href="1Lab.Univalence.SIP.html#7978" class="Bound">y&#39;</a><a id="8045" class="Symbol">)</a> <a id="8047" class="Symbol">_)</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="8050" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a data-type="(e : A ≃ A&#39;) → ((x : A) → P x ≃ Q (e .fst x)) → Σ P ≃ Σ Q" id="8053" href="1Lab.Type.Sigma.html#2110" class="Function">Σ-ap</a> <a id="8058" class="Symbol">(</a><a id="8059" href="1Lab.Univalence.SIP.html#7950" class="Bound">θ₁</a> <a id="8062" href="1Lab.Univalence.SIP.html#7982" class="Bound">f</a><a id="8063" class="Symbol">)</a> <a id="8065" class="Symbol">(λ</a> <a id="8068" href="1Lab.Univalence.SIP.html#8068" class="Bound">_</a> <a id="8070" class="Symbol">→</a> <a id="8072" href="1Lab.Univalence.SIP.html#7953" class="Bound">θ₂</a> <a id="8075" href="1Lab.Univalence.SIP.html#7982" class="Bound">f</a><a id="8076" class="Symbol">)</a> <a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="8078" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a id="8082" class="Symbol">(</a><a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="8083" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="8089" class="Symbol">_</a> <a id="8091" class="Symbol">_</a> <a id="8093" class="Symbol">_</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="8095" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="8097" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="8103" class="Symbol">_</a> <a id="8105" class="Symbol">_</a> <a id="8107" class="Symbol">_)</a>                                   <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="8144" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a data-type="Iso A B → A ≃ B" id="8147" href="1Lab.Equiv.html#20090" class="Function">Iso→Equiv</a> <a data-type="Iso (Σ (λ p → PathP (λ i → B i (p i)) (x .snd) (y .snd)))
(PathP (λ i → Σ (B i)) x y)" id="8157" href="1Lab.Type.Sigma.html#553" class="Function">Σ-PathP-iso</a> <a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="8169" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="8173" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="8179" class="Symbol">(λ</a> <a id="8182" href="1Lab.Univalence.SIP.html#8182" class="Bound">i</a> <a id="8184" class="Symbol">→</a> <a id="8186" href="1Lab.Univalence.SIP.html#7927" class="Bound">S</a> <a id="8188" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="8189" href="1Lab.Univalence.html#8827" class="Function">ua</a> <a id="8192" href="1Lab.Univalence.SIP.html#7982" class="Bound">f</a> <a id="8194" href="1Lab.Univalence.SIP.html#8182" class="Bound">i</a><a id="8195" class="Symbol">)</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="8197" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="8199" href="1Lab.Univalence.SIP.html#7935" class="Bound">T</a> <a id="8201" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="8202" href="1Lab.Univalence.html#8827" class="Function">ua</a> <a id="8205" href="1Lab.Univalence.SIP.html#7982" class="Bound">f</a> <a id="8207" href="1Lab.Univalence.SIP.html#8182" class="Bound">i</a><a id="8208" class="Symbol">))</a> <a id="8211" class="Symbol">(</a><a id="8212" href="1Lab.Univalence.SIP.html#7961" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="8214" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8216" href="1Lab.Univalence.SIP.html#7965" class="Bound">y</a><a id="8217" class="Symbol">)</a> <a id="8219" class="Symbol">(</a><a id="8220" href="1Lab.Univalence.SIP.html#7973" class="Bound">x&#39;</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="8223" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8225" href="1Lab.Univalence.SIP.html#7978" class="Bound">y&#39;</a><a id="8227" class="Symbol">)</a>       <a data-type="(A : Type ℓ) → A ≃ A" id="8235" href="1Lab.Equiv.html#23023" class="Function Operator">≃∎</a>
</pre>
<p>If <code>S</code> and <code>T</code> are univalent structures, then so are the families of functions between them. For reasons we’ll see below, this is called <span class="Agda"><a data-type="Structure ℓ₁ S₁ →
Structure ℓ₂ T → Structure (ℓ₁ ⊔ S.ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" href="1Lab.Univalence.SIP.html#8474" class="Function">Str-functionStr</a></span> (a rather redundant name!) instead of <span class="Agda"><a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" href="1Lab.Univalence.SIP.html#16922" class="Function">functionStr</a></span>.</p>
<pre class="Agda"><a id="Str-functionStr"></a><a data-type="Structure ℓ₁ S₁ →
Structure ℓ₂ T → Structure (ℓ₁ ⊔ S.ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="8474" href="1Lab.Univalence.SIP.html#8474" class="Function">Str-functionStr</a> <a id="8490" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="8492" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="8502" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a> <a id="8505" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="8507" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="8509" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="8519" href="1Lab.Univalence.SIP.html#3455" class="Generalizable">ℓ₂</a> <a id="8522" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a> <a id="8524" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="8526" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="8536" class="Symbol">_</a> <a id="8538" class="Symbol">(λ</a> <a id="8541" href="1Lab.Univalence.SIP.html#8541" class="Bound">X</a> <a id="8543" class="Symbol">→</a> <a id="8545" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="8547" href="1Lab.Univalence.SIP.html#8541" class="Bound">X</a> <a id="8549" class="Symbol">→</a> <a id="8551" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a> <a id="8553" href="1Lab.Univalence.SIP.html#8541" class="Bound">X</a><a id="8554" class="Symbol">)</a>
<a data-type="Structure ℓ₁ S₁ →
Structure ℓ₂ T → Structure (ℓ₁ ⊔ S.ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="8556" href="1Lab.Univalence.SIP.html#8474" class="Function">Str-functionStr</a> <a id="8572" class="Symbol">{</a><a id="8573" class="Argument">S</a> <a id="8575" class="Symbol">=</a> <a id="8577" href="1Lab.Univalence.SIP.html#8577" class="Bound">S</a><a id="8578" class="Symbol">}</a> <a id="8580" href="1Lab.Univalence.SIP.html#8580" class="Bound">σ</a> <a id="8582" href="1Lab.Univalence.SIP.html#8582" class="Bound">τ</a> <a id="8584" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="8585" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="8592" class="Symbol">(</a><a id="8593" href="1Lab.Univalence.SIP.html#8593" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="8595" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8597" href="1Lab.Univalence.SIP.html#8597" class="Bound">f</a><a id="8598" class="Symbol">)</a> <a id="8600" class="Symbol">(</a><a id="8601" href="1Lab.Univalence.SIP.html#8601" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="8603" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8605" href="1Lab.Univalence.SIP.html#8605" class="Bound">g</a><a id="8606" class="Symbol">)</a> <a id="8608" href="1Lab.Univalence.SIP.html#8608" class="Bound">h</a> <a id="8610" class="Symbol">=</a>
  <a id="8614" class="Symbol">{</a><a id="8615" href="1Lab.Univalence.SIP.html#8615" class="Bound">s</a> <a id="8617" class="Symbol">:</a> <a id="8619" href="1Lab.Univalence.SIP.html#8577" class="Bound">S</a> <a id="8621" href="1Lab.Univalence.SIP.html#8593" class="Bound">A</a><a id="8622" class="Symbol">}</a> <a id="8624" class="Symbol">{</a><a id="8625" href="1Lab.Univalence.SIP.html#8625" class="Bound">t</a> <a id="8627" class="Symbol">:</a> <a id="8629" href="1Lab.Univalence.SIP.html#8577" class="Bound">S</a> <a id="8631" href="1Lab.Univalence.SIP.html#8601" class="Bound">B</a><a id="8632" class="Symbol">}</a> <a id="8634" class="Symbol">→</a> <a id="8636" href="1Lab.Univalence.SIP.html#8580" class="Bound">σ</a> <a id="8638" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="8639" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="8646" class="Symbol">(</a><a id="8647" href="1Lab.Univalence.SIP.html#8593" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="8649" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8651" href="1Lab.Univalence.SIP.html#8615" class="Bound">s</a><a id="8652" class="Symbol">)</a> <a id="8654" class="Symbol">(</a><a id="8655" href="1Lab.Univalence.SIP.html#8601" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="8657" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8659" href="1Lab.Univalence.SIP.html#8625" class="Bound">t</a><a id="8660" class="Symbol">)</a> <a id="8662" href="1Lab.Univalence.SIP.html#8608" class="Bound">h</a>
                      <a id="8686" class="Symbol">→</a> <a id="8688" href="1Lab.Univalence.SIP.html#8582" class="Bound">τ</a> <a id="8690" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="8691" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="8698" class="Symbol">(</a><a id="8699" href="1Lab.Univalence.SIP.html#8593" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="8701" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8703" href="1Lab.Univalence.SIP.html#8597" class="Bound">f</a> <a id="8705" href="1Lab.Univalence.SIP.html#8615" class="Bound">s</a><a id="8706" class="Symbol">)</a> <a id="8708" class="Symbol">(</a><a id="8709" href="1Lab.Univalence.SIP.html#8601" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="8711" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8713" href="1Lab.Univalence.SIP.html#8605" class="Bound">g</a> <a id="8715" href="1Lab.Univalence.SIP.html#8625" class="Bound">t</a><a id="8716" class="Symbol">)</a> <a id="8718" href="1Lab.Univalence.SIP.html#8608" class="Bound">h</a>

<a id="Str-functionStr-univalent"></a><a data-type="isUnivalent σ → isUnivalent τ → isUnivalent (Str-functionStr σ τ)" id="8721" href="1Lab.Univalence.SIP.html#8721" class="Function">Str-functionStr-univalent</a> <a id="8747" class="Symbol">:</a> <a id="8749" class="Symbol">{</a><a id="8750" href="1Lab.Univalence.SIP.html#8750" class="Bound">σ</a> <a id="8752" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="8754" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="8764" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a> <a id="8767" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="8768" class="Symbol">}</a> <a id="8770" class="Symbol">{</a><a id="8771" href="1Lab.Univalence.SIP.html#8771" class="Bound">τ</a> <a id="8773" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="8775" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="8785" href="1Lab.Univalence.SIP.html#3455" class="Generalizable">ℓ₂</a> <a id="8788" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a><a id="8789" class="Symbol">}</a>
                          <a id="8817" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="8819" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="8831" href="1Lab.Univalence.SIP.html#8750" class="Bound">σ</a> <a id="8833" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="8835" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="8847" href="1Lab.Univalence.SIP.html#8771" class="Bound">τ</a>
                          <a id="8875" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="8877" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="8889" class="Symbol">(</a><a data-type="Structure ℓ₁ S₁ →
Structure ℓ₂ T → Structure (ℓ₁ ⊔ S.ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="8890" href="1Lab.Univalence.SIP.html#8474" class="Function">Str-functionStr</a> <a id="8906" href="1Lab.Univalence.SIP.html#8750" class="Bound">σ</a> <a id="8908" href="1Lab.Univalence.SIP.html#8771" class="Bound">τ</a><a id="8909" class="Symbol">)</a>
<a data-type="isUnivalent σ → isUnivalent τ → isUnivalent (Str-functionStr σ τ)" id="8911" href="1Lab.Univalence.SIP.html#8721" class="Function">Str-functionStr-univalent</a> <a id="8937" class="Symbol">{</a><a id="8938" class="Argument">S</a> <a id="8940" class="Symbol">=</a> <a id="8942" href="1Lab.Univalence.SIP.html#8942" class="Bound">S</a><a id="8943" class="Symbol">}</a> <a id="8945" class="Symbol">{</a><a id="8946" class="Argument">T</a> <a id="8948" class="Symbol">=</a> <a id="8950" href="1Lab.Univalence.SIP.html#8950" class="Bound">T</a><a id="8951" class="Symbol">}</a> <a id="8953" class="Symbol">{</a><a id="8954" class="Argument">σ</a> <a id="8956" class="Symbol">=</a> <a id="8958" href="1Lab.Univalence.SIP.html#8958" class="Bound">σ</a><a id="8959" class="Symbol">}</a> <a id="8961" class="Symbol">{</a><a id="8962" href="1Lab.Univalence.SIP.html#8962" class="Bound">τ</a><a id="8963" class="Symbol">}</a> <a id="8965" href="1Lab.Univalence.SIP.html#8965" class="Bound">θ₁</a> <a id="8968" href="1Lab.Univalence.SIP.html#8968" class="Bound">θ₂</a> <a id="8971" href="1Lab.Univalence.SIP.html#8971" class="Bound">eqv</a> <a id="8975" class="Symbol">=</a>
  <a data-type="((x : A) → P x ≃ Q x) → ({x : A} → P x) ≃ ({x : A} → Q x)" id="8979" href="1Lab.Type.Pi.html#1118" class="Function">Π-impl-cod≃</a> <a id="8991" class="Symbol">(λ</a> <a id="8994" href="1Lab.Univalence.SIP.html#8994" class="Bound">s</a> <a id="8996" class="Symbol">→</a> <a data-type="((x : A) → P x ≃ Q x) → ({x : A} → P x) ≃ ({x : A} → Q x)" id="8998" href="1Lab.Type.Pi.html#1118" class="Function">Π-impl-cod≃</a> <a id="9010" class="Symbol">λ</a> <a id="9012" href="1Lab.Univalence.SIP.html#9012" class="Bound">t</a> <a id="9014" class="Symbol">→</a> <a data-type="A ≃ B → C ≃ D → (A → C) ≃ (B → D)" id="9016" href="1Lab.Type.Pi.html#1721" class="Function">function≃</a> <a id="9026" class="Symbol">(</a><a id="9027" href="1Lab.Univalence.SIP.html#8965" class="Bound">θ₁</a> <a id="9030" href="1Lab.Univalence.SIP.html#8971" class="Bound">eqv</a><a id="9033" class="Symbol">)</a> <a id="9035" class="Symbol">(</a><a id="9036" href="1Lab.Univalence.SIP.html#8968" class="Bound">θ₂</a> <a id="9039" href="1Lab.Univalence.SIP.html#8971" class="Bound">eqv</a><a id="9042" class="Symbol">))</a> <a data-type="A ≃ B → B ≃ C → A ≃ C" id="9045" href="1Lab.Equiv.html#21156" class="Function Operator">∙e</a> <a data-type="({x₀ : A i0} {x₁ : A i1} (p : PathP A x₀ x₁) →
 PathP (λ i → B i (p i)) (f x₀) (g x₁))
≃ PathP (λ i → (x : A i) → B i x) f g" id="9048" href="1Lab.Type.Pi.html#3070" class="Function">funextDep≃</a>
</pre>
<h2 id="example-infty-magmas"><a href="#example-infty-magmas" class="header-link">Example: <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>

-magmas</span><span class="header-link-emoji">🔗</span></a></h2>
<p>We provide an example of applying the SIP, and the structure combinators: <strong><span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>

-magmas</span></strong>. Recall that a <a href="https://ncatlab.org/nlab/show/magma">magma</a> is a <a data-type="(ℓ : Level) → Type (lsuc ℓ)" href="1Lab.HLevel.html#3398">Set</a> equipped with a binary operation, with no further conditions imposed. In HoTT, we can relax this even further: An <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>

-magma</span> is a <span class="Agda"><a href="1Lab.Type.html#394" class="Primitive">Type</a></span> - that is, an <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>

-groupoid</span> - equipped with a binary operation.</p>
<pre class="Agda"><a id="9522" class="Keyword">private</a>
  <a id="binop"></a><a id="9532" href="1Lab.Univalence.SIP.html#9532" class="Function">binop</a> <a id="9538" class="Symbol">:</a> <a id="9540" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="9545" class="Symbol">→</a> <a id="9547" href="1Lab.Type.html#394" class="Primitive">Type</a>
  <a id="9554" href="1Lab.Univalence.SIP.html#9532" class="Function">binop</a> <a id="9560" href="1Lab.Univalence.SIP.html#9560" class="Bound">X</a> <a id="9562" class="Symbol">=</a> <a id="9564" href="1Lab.Univalence.SIP.html#9560" class="Bound">X</a> <a id="9566" class="Symbol">→</a> <a id="9568" href="1Lab.Univalence.SIP.html#9560" class="Bound">X</a> <a id="9570" class="Symbol">→</a> <a id="9572" href="1Lab.Univalence.SIP.html#9560" class="Bound">X</a>
</pre>
<p>We can impose a <span class="Agda"><a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a></span> on <span class="Agda"><a href="1Lab.Univalence.SIP.html#9532" class="Function">binop</a></span> by applying nested <span class="Agda"><a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" href="1Lab.Univalence.SIP.html#16922" class="Function">functionStr</a></span> and <span class="Agda"><a data-type="Structure ℓ (λ X → X)" href="1Lab.Univalence.SIP.html#7039" class="Function">pointedStr</a></span>. Since this structure is built out of structure combinators, it’s automatically univalent:</p>
<pre class="Agda">  <a id="∞-Magma"></a><a id="9798" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a> <a id="9806" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="9808" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a data-type="Level" id="9818" href="Agda.Primitive.html#764" class="Primitive">lzero</a> <a id="9824" href="1Lab.Univalence.SIP.html#9532" class="Function">binop</a>
  <a id="9832" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a> <a id="9840" class="Symbol">=</a> <a data-type="Structure ℓ₁ S₁ →
Structure ℓ₂ T → Structure (ℓ₁ ⊔ S.ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="9842" href="1Lab.Univalence.SIP.html#8474" class="Function">Str-functionStr</a> <a data-type="Structure ℓ (λ X → X)" id="9858" href="1Lab.Univalence.SIP.html#7039" class="Function">pointedStr</a> <a id="9869" class="Symbol">(</a><a data-type="Structure ℓ₁ S₁ →
Structure ℓ₂ T → Structure (ℓ₁ ⊔ S.ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="9870" href="1Lab.Univalence.SIP.html#8474" class="Function">Str-functionStr</a> <a data-type="Structure ℓ (λ X → X)" id="9886" href="1Lab.Univalence.SIP.html#7039" class="Function">pointedStr</a> <a data-type="Structure ℓ (λ X → X)" id="9897" href="1Lab.Univalence.SIP.html#7039" class="Function">pointedStr</a><a id="9907" class="Symbol">)</a>

  <a id="∞-Magma-univ"></a><a id="9912" href="1Lab.Univalence.SIP.html#9912" class="Function">∞-Magma-univ</a> <a id="9925" class="Symbol">:</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="9927" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="9939" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a>
  <a id="9949" href="1Lab.Univalence.SIP.html#9912" class="Function">∞-Magma-univ</a> <a id="9962" class="Symbol">=</a>
    <a data-type="isUnivalent σ → isUnivalent τ → isUnivalent (Str-functionStr σ τ)" id="9968" href="1Lab.Univalence.SIP.html#8721" class="Function">Str-functionStr-univalent</a> <a id="9994" class="Symbol">{</a><a id="9995" class="Argument">τ</a> <a id="9997" class="Symbol">=</a> <a data-type="Structure ℓ₁ S₁ →
Structure ℓ₂ T → Structure (ℓ₁ ⊔ S.ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="9999" href="1Lab.Univalence.SIP.html#8474" class="Function">Str-functionStr</a> <a data-type="Structure ℓ (λ X → X)" id="10015" href="1Lab.Univalence.SIP.html#7039" class="Function">pointedStr</a> <a data-type="Structure ℓ (λ X → X)" id="10026" href="1Lab.Univalence.SIP.html#7039" class="Function">pointedStr</a><a id="10036" class="Symbol">}</a>
      <a data-type="isUnivalent pointedStr" id="10044" href="1Lab.Univalence.SIP.html#7247" class="Function">pointedStr-univalent</a>
      <a id="10071" class="Symbol">(</a><a data-type="isUnivalent σ → isUnivalent τ → isUnivalent (Str-functionStr σ τ)" id="10072" href="1Lab.Univalence.SIP.html#8721" class="Function">Str-functionStr-univalent</a> <a id="10098" class="Symbol">{</a><a id="10099" class="Argument">τ</a> <a id="10101" class="Symbol">=</a> <a data-type="Structure ℓ (λ X → X)" id="10103" href="1Lab.Univalence.SIP.html#7039" class="Function">pointedStr</a><a id="10113" class="Symbol">}</a>
        <a data-type="isUnivalent pointedStr" id="10123" href="1Lab.Univalence.SIP.html#7247" class="Function">pointedStr-univalent</a>
        <a data-type="isUnivalent pointedStr" id="10152" href="1Lab.Univalence.SIP.html#7247" class="Function">pointedStr-univalent</a><a id="10172" class="Symbol">)</a>
</pre>
<p>The type of <span class="Agda"><a href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a></span> homomorphisms generated by this equivalence is slightly inconvenient: Instead of getting <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo>⋆</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mi>x</mi><mo>∗</mo><mi>f</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">f (x \star y) = f x * f y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋆</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>

,</span> we get something that is parameterised over two paths:</p>
<pre class="Agda">  <a id="10392" href="1Lab.Univalence.SIP.html#10392" class="Function">_</a> <a id="10394" class="Symbol">:</a> <a id="10396" class="Symbol">{</a><a id="10397" href="1Lab.Univalence.SIP.html#10397" class="Bound">A</a> <a id="10399" href="1Lab.Univalence.SIP.html#10399" class="Bound">B</a> <a id="10401" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="10403" href="1Lab.Univalence.SIP.html#3316" class="Function">TypeWith</a> <a id="10412" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a><a id="10419" class="Symbol">}</a> <a id="10421" class="Symbol">{</a><a id="10422" href="1Lab.Univalence.SIP.html#10422" class="Bound">f</a> <a id="10424" class="Symbol">:</a> <a id="10426" href="1Lab.Univalence.SIP.html#10397" class="Bound">A</a> <a id="10428" class="Symbol">.</a><a data-type="∑ A B → A" id="10429" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="10433" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="10435" href="1Lab.Univalence.SIP.html#10399" class="Bound">B</a> <a id="10437" class="Symbol">.</a><a data-type="∑ A B → A" id="10438" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="10441" class="Symbol">}</a>
    <a id="10447" class="Symbol">→</a> <a id="10449" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a> <a id="10457" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="10458" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="10465" href="1Lab.Univalence.SIP.html#10397" class="Bound">A</a> <a id="10467" href="1Lab.Univalence.SIP.html#10399" class="Bound">B</a> <a id="10469" href="1Lab.Univalence.SIP.html#10422" class="Bound">f</a>
    <a data-type="A → A → Type ℓ" id="10475" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10477" class="Symbol">(</a> <a id="10479" class="Symbol">{</a><a id="10480" href="1Lab.Univalence.SIP.html#10480" class="Bound">s</a> <a id="10482" class="Symbol">:</a> <a id="10484" href="1Lab.Univalence.SIP.html#10397" class="Bound">A</a> <a id="10486" class="Symbol">.</a><a data-type="∑ A B → A" id="10487" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="10490" class="Symbol">}</a> <a id="10492" class="Symbol">{</a><a id="10493" href="1Lab.Univalence.SIP.html#10493" class="Bound">t</a> <a id="10495" class="Symbol">:</a> <a id="10497" href="1Lab.Univalence.SIP.html#10399" class="Bound">B</a> <a id="10499" class="Symbol">.</a><a data-type="∑ A B → A" id="10500" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="10503" class="Symbol">}</a> <a id="10505" class="Symbol">→</a> <a id="10507" href="1Lab.Univalence.SIP.html#10422" class="Bound">f</a> <a id="10509" class="Symbol">.</a><a data-type="∑ A B → A" id="10510" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10514" href="1Lab.Univalence.SIP.html#10480" class="Bound">s</a> <a data-type="A → A → Type ℓ" id="10516" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10518" href="1Lab.Univalence.SIP.html#10493" class="Bound">t</a>
      <a id="10526" class="Symbol">→</a> <a id="10528" class="Symbol">{</a><a id="10529" href="1Lab.Univalence.SIP.html#10529" class="Bound">x</a> <a id="10531" class="Symbol">:</a> <a id="10533" href="1Lab.Univalence.SIP.html#10397" class="Bound">A</a> <a id="10535" class="Symbol">.</a><a data-type="∑ A B → A" id="10536" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="10539" class="Symbol">}</a> <a id="10541" class="Symbol">{</a><a id="10542" href="1Lab.Univalence.SIP.html#10542" class="Bound">y</a> <a id="10544" class="Symbol">:</a> <a id="10546" href="1Lab.Univalence.SIP.html#10399" class="Bound">B</a> <a id="10548" class="Symbol">.</a><a data-type="∑ A B → A" id="10549" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="10552" class="Symbol">}</a> <a id="10554" class="Symbol">→</a> <a id="10556" href="1Lab.Univalence.SIP.html#10422" class="Bound">f</a> <a id="10558" class="Symbol">.</a><a data-type="∑ A B → A" id="10559" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10563" href="1Lab.Univalence.SIP.html#10529" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="10565" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10567" href="1Lab.Univalence.SIP.html#10542" class="Bound">y</a>
      <a id="10575" class="Symbol">→</a> <a id="10577" href="1Lab.Univalence.SIP.html#10422" class="Bound">f</a> <a id="10579" class="Symbol">.</a><a data-type="∑ A B → A" id="10580" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10584" class="Symbol">(</a><a id="10585" href="1Lab.Univalence.SIP.html#10397" class="Bound">A</a> <a id="10587" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="10588" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10592" href="1Lab.Univalence.SIP.html#10480" class="Bound">s</a> <a id="10594" href="1Lab.Univalence.SIP.html#10529" class="Bound">x</a><a id="10595" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="10597" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10599" href="1Lab.Univalence.SIP.html#10399" class="Bound">B</a> <a id="10601" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="10602" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10606" href="1Lab.Univalence.SIP.html#10493" class="Bound">t</a> <a id="10608" href="1Lab.Univalence.SIP.html#10542" class="Bound">y</a><a id="10609" class="Symbol">)</a>
  <a id="10613" class="Symbol">_</a> <a id="10615" class="Symbol">=</a> <a data-type="x ≡ x" id="10617" href="1Lab.Path.html#2137" class="Function">refl</a>
</pre>
<p>This condition, although it looks a lot more complicated, is essentially the same as the standard notion:</p>
<pre class="Agda">  <a id="fixup"></a><a id="10744" href="1Lab.Univalence.SIP.html#10744" class="Function">fixup</a> <a id="10750" class="Symbol">:</a> <a id="10752" class="Symbol">{</a><a id="10753" href="1Lab.Univalence.SIP.html#10753" class="Bound">A</a> <a id="10755" href="1Lab.Univalence.SIP.html#10755" class="Bound">B</a> <a id="10757" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="10759" href="1Lab.Univalence.SIP.html#3316" class="Function">TypeWith</a> <a id="10768" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a><a id="10775" class="Symbol">}</a> <a id="10777" class="Symbol">{</a><a id="10778" href="1Lab.Univalence.SIP.html#10778" class="Bound">f</a> <a id="10780" class="Symbol">:</a> <a id="10782" href="1Lab.Univalence.SIP.html#10753" class="Bound">A</a> <a id="10784" class="Symbol">.</a><a data-type="∑ A B → A" id="10785" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="10789" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="10791" href="1Lab.Univalence.SIP.html#10755" class="Bound">B</a> <a id="10793" class="Symbol">.</a><a data-type="∑ A B → A" id="10794" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="10797" class="Symbol">}</a>
        <a id="10807" class="Symbol">→</a> <a id="10809" class="Symbol">((</a><a id="10811" href="1Lab.Univalence.SIP.html#10811" class="Bound">x</a> <a id="10813" href="1Lab.Univalence.SIP.html#10813" class="Bound">y</a> <a id="10815" class="Symbol">:</a> <a id="10817" href="1Lab.Univalence.SIP.html#10753" class="Bound">A</a> <a id="10819" class="Symbol">.</a><a data-type="∑ A B → A" id="10820" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="10823" class="Symbol">)</a> <a id="10825" class="Symbol">→</a> <a id="10827" href="1Lab.Univalence.SIP.html#10778" class="Bound">f</a> <a id="10829" class="Symbol">.</a><a data-type="∑ A B → A" id="10830" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10834" class="Symbol">(</a><a id="10835" href="1Lab.Univalence.SIP.html#10753" class="Bound">A</a> <a id="10837" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="10838" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10842" href="1Lab.Univalence.SIP.html#10811" class="Bound">x</a> <a id="10844" href="1Lab.Univalence.SIP.html#10813" class="Bound">y</a><a id="10845" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="10847" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10849" href="1Lab.Univalence.SIP.html#10755" class="Bound">B</a> <a id="10851" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="10852" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10856" class="Symbol">(</a><a id="10857" href="1Lab.Univalence.SIP.html#10778" class="Bound">f</a> <a id="10859" class="Symbol">.</a><a data-type="∑ A B → A" id="10860" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10864" href="1Lab.Univalence.SIP.html#10811" class="Bound">x</a><a id="10865" class="Symbol">)</a> <a id="10867" class="Symbol">(</a><a id="10868" href="1Lab.Univalence.SIP.html#10778" class="Bound">f</a> <a id="10870" class="Symbol">.</a><a data-type="∑ A B → A" id="10871" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10875" href="1Lab.Univalence.SIP.html#10813" class="Bound">y</a><a id="10876" class="Symbol">))</a>
        <a id="10887" class="Symbol">→</a> <a id="10889" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a> <a id="10897" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="10898" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="10905" href="1Lab.Univalence.SIP.html#10753" class="Bound">A</a> <a id="10907" href="1Lab.Univalence.SIP.html#10755" class="Bound">B</a> <a id="10909" href="1Lab.Univalence.SIP.html#10778" class="Bound">f</a>
  <a id="10913" href="1Lab.Univalence.SIP.html#10744" class="Function">fixup</a> <a id="10919" class="Symbol">{</a><a id="10920" class="Argument">A</a> <a id="10922" class="Symbol">=</a> <a id="10924" href="1Lab.Univalence.SIP.html#10924" class="Bound">A</a><a id="10925" class="Symbol">}</a> <a id="10927" class="Symbol">{</a><a id="10928" href="1Lab.Univalence.SIP.html#10928" class="Bound">B</a><a id="10929" class="Symbol">}</a> <a id="10931" class="Symbol">{</a><a id="10932" href="1Lab.Univalence.SIP.html#10932" class="Bound">f</a><a id="10933" class="Symbol">}</a> <a id="10935" href="1Lab.Univalence.SIP.html#10935" class="Bound">path</a> <a id="10940" class="Symbol">{</a><a id="10941" href="1Lab.Univalence.SIP.html#10941" class="Bound">s</a><a id="10942" class="Symbol">}</a> <a id="10944" class="Symbol">{</a><a id="10945" href="1Lab.Univalence.SIP.html#10945" class="Bound">t</a><a id="10946" class="Symbol">}</a> <a id="10948" href="1Lab.Univalence.SIP.html#10948" class="Bound">p</a> <a id="10950" class="Symbol">{</a><a id="10951" href="1Lab.Univalence.SIP.html#10951" class="Bound">s₁</a><a id="10953" class="Symbol">}</a> <a id="10955" class="Symbol">{</a><a id="10956" href="1Lab.Univalence.SIP.html#10956" class="Bound">t₁</a><a id="10958" class="Symbol">}</a> <a id="10960" href="1Lab.Univalence.SIP.html#10960" class="Bound">q</a> <a id="10962" class="Symbol">=</a>
    <a id="10968" href="1Lab.Univalence.SIP.html#10932" class="Bound">f</a> <a id="10970" class="Symbol">.</a><a data-type="∑ A B → A" id="10971" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10975" class="Symbol">(</a><a id="10976" href="1Lab.Univalence.SIP.html#10924" class="Bound">A</a> <a id="10978" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="10979" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10983" href="1Lab.Univalence.SIP.html#10941" class="Bound">s</a> <a id="10985" href="1Lab.Univalence.SIP.html#10951" class="Bound">s₁</a><a id="10987" class="Symbol">)</a>     <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="10993" href="1Lab.Path.html#45199" class="Function Operator">≡⟨</a> <a id="10996" href="1Lab.Univalence.SIP.html#10935" class="Bound">path</a> <a id="11001" class="Symbol">_</a> <a id="11003" class="Symbol">_</a> <a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="11005" href="1Lab.Path.html#45199" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡</span></span>
    <a id="11011" href="1Lab.Univalence.SIP.html#10928" class="Bound">B</a> <a id="11013" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11014" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11018" class="Symbol">(</a><a id="11019" href="1Lab.Univalence.SIP.html#10932" class="Bound">f</a> <a id="11021" class="Symbol">.</a><a data-type="∑ A B → A" id="11022" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="11026" href="1Lab.Univalence.SIP.html#10941" class="Bound">s</a><a id="11027" class="Symbol">)</a> <a id="11029" class="Symbol">(</a><a id="11030" href="1Lab.Univalence.SIP.html#10932" class="Bound">f</a> <a id="11032" class="Symbol">.</a><a data-type="∑ A B → A" id="11033" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="11037" href="1Lab.Univalence.SIP.html#10951" class="Bound">s₁</a><a id="11039" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="11041" href="1Lab.Path.html#45199" class="Function Operator">≡⟨</a> <a data-type="(f : (x : A) (y : B x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" id="11044" href="1Lab.Path.html#19695" class="Function">ap₂</a> <a id="11048" class="Symbol">(</a><a id="11049" href="1Lab.Univalence.SIP.html#10928" class="Bound">B</a> <a id="11051" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11052" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="11055" class="Symbol">)</a> <a id="11057" href="1Lab.Univalence.SIP.html#10948" class="Bound">p</a> <a id="11059" href="1Lab.Univalence.SIP.html#10960" class="Bound">q</a> <a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="11061" href="1Lab.Path.html#45199" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡</span></span>
    <a id="11067" href="1Lab.Univalence.SIP.html#10928" class="Bound">B</a> <a id="11069" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11070" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11074" href="1Lab.Univalence.SIP.html#10945" class="Bound">t</a>     <a id="11080" href="1Lab.Univalence.SIP.html#10956" class="Bound">t₁</a>     <a data-type="(x : A) → x ≡ x" id="11087" href="1Lab.Path.html#45365" class="Function Operator">∎</a>
</pre>
<p>As an example, we equip the type of booleans with two ∞-magma structures, one given by conjunction, one by disjunction, and prove that <span class="Agda"><a data-type="Bool → Bool" href="Data.Bool.html#1190" class="Function">not</a></span> makes them equal as ∞-magmas:</p>
<div class="mathpar">
<pre class="Agda">  <a id="11303" class="Keyword">open</a> <a id="11308" class="Keyword">import</a> <a id="11315" href="Data.Bool.html" class="Module">Data.Bool</a>
</pre>
</pre>
</div>
<div class="mathpar">
<pre class="Agda">  <a id="Conj"></a><a id="11373" href="1Lab.Univalence.SIP.html#11373" class="Function">Conj</a> <a id="11378" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="11380" href="1Lab.Univalence.SIP.html#3316" class="Function">TypeWith</a> <a id="11389" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a>
  <a id="11399" href="1Lab.Univalence.SIP.html#11373" class="Function">Conj</a> <a id="11404" class="Symbol">.</a><a data-type="∑ A B → A" id="11405" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="11409" class="Symbol">=</a> <a data-type="Type" id="11411" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="11418" href="1Lab.Univalence.SIP.html#11373" class="Function">Conj</a> <a id="11423" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11424" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="11428" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="11434" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="11440" class="Symbol">=</a> <a data-type="Bool" id="11442" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="11450" href="1Lab.Univalence.SIP.html#11373" class="Function">Conj</a> <a id="11455" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11456" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="11460" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="11466" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="11472" class="Symbol">=</a> <a data-type="Bool" id="11474" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="11482" href="1Lab.Univalence.SIP.html#11373" class="Function">Conj</a> <a id="11487" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11488" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="11492" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a data-type="Bool" id="11498" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="11504" class="Symbol">=</a> <a data-type="Bool" id="11506" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="11514" href="1Lab.Univalence.SIP.html#11373" class="Function">Conj</a> <a id="11519" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11520" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="11524" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a data-type="Bool" id="11530" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="11536" class="Symbol">=</a> <a data-type="Bool" id="11538" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
</pre>
<pre class="Agda">  <a id="Disj"></a><a id="11558" href="1Lab.Univalence.SIP.html#11558" class="Function">Disj</a> <a id="11563" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="11565" href="1Lab.Univalence.SIP.html#3316" class="Function">TypeWith</a> <a id="11574" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a>
  <a id="11584" href="1Lab.Univalence.SIP.html#11558" class="Function">Disj</a> <a id="11589" class="Symbol">.</a><a data-type="∑ A B → A" id="11590" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="11594" class="Symbol">=</a> <a data-type="Type" id="11596" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="11603" href="1Lab.Univalence.SIP.html#11558" class="Function">Disj</a> <a id="11608" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11609" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="11613" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="11619" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="11625" class="Symbol">=</a> <a data-type="Bool" id="11627" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="11635" href="1Lab.Univalence.SIP.html#11558" class="Function">Disj</a> <a id="11640" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11641" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="11645" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="11651" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="11657" class="Symbol">=</a> <a data-type="Bool" id="11659" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
  <a id="11666" href="1Lab.Univalence.SIP.html#11558" class="Function">Disj</a> <a id="11671" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11672" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="11676" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a data-type="Bool" id="11682" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="11688" class="Symbol">=</a> <a data-type="Bool" id="11690" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
  <a id="11697" href="1Lab.Univalence.SIP.html#11558" class="Function">Disj</a> <a id="11702" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11703" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="11707" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a data-type="Bool" id="11713" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="11719" class="Symbol">=</a> <a data-type="Bool" id="11721" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
</pre>
</div>
<p>I claim that <span class="Agda"><a data-type="Bool → Bool" href="Data.Bool.html#1190" class="Function">not</a></span> is a <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>

-magma</span> isomorphism between <span class="Agda"><a href="1Lab.Univalence.SIP.html#11373" class="Function">Conj</a></span> and <span class="Agda"><a href="1Lab.Univalence.SIP.html#11558" class="Function">Disj</a></span>:</p>
<pre class="Agda">  <a id="not-iso"></a><a id="11848" href="1Lab.Univalence.SIP.html#11848" class="Function">not-iso</a> <a id="11856" class="Symbol">:</a> <a id="11858" href="1Lab.Univalence.SIP.html#11373" class="Function">Conj</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="11863" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">≃[</a> <a id="11866" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="11874" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">]</a> <a id="11876" href="1Lab.Univalence.SIP.html#11558" class="Function">Disj</a>
  <a id="11883" href="1Lab.Univalence.SIP.html#11848" class="Function">not-iso</a> <a id="11891" class="Symbol">.</a><a data-type="∑ A B → A" id="11892" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="11896" class="Symbol">=</a> <a data-type="Bool → Bool" id="11898" href="Data.Bool.html#1190" class="Function">not</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="11902" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv not" id="11904" href="Data.Bool.html#7030" class="Function">isEquiv-not</a>
  <a id="11918" href="1Lab.Univalence.SIP.html#11848" class="Function">not-iso</a> <a id="11926" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11927" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11931" class="Symbol">=</a> <a id="11933" href="1Lab.Univalence.SIP.html#10744" class="Function">fixup</a> <a id="11939" class="Symbol">{</a><a id="11940" class="Argument">A</a> <a id="11942" class="Symbol">=</a> <a id="11944" href="1Lab.Univalence.SIP.html#11373" class="Function">Conj</a><a id="11948" class="Symbol">}</a> <a id="11950" class="Symbol">{</a><a id="11951" class="Argument">B</a> <a id="11953" class="Symbol">=</a> <a id="11955" href="1Lab.Univalence.SIP.html#11558" class="Function">Disj</a><a id="11959" class="Symbol">}</a> <a id="11961" class="Symbol">{</a><a id="11962" class="Argument">f</a> <a id="11964" class="Symbol">=</a> <a id="11966" class="Symbol">_</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="11968" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv not" id="11970" href="Data.Bool.html#7030" class="Function">isEquiv-not</a><a id="11981" class="Symbol">}</a> <a id="11983" class="Symbol">λ</a> <a id="11985" class="Keyword">where</a>
    <a data-type="Bool" id="11995" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="12001" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="12007" class="Symbol">→</a> <a data-type="x ≡ x" id="12009" href="1Lab.Path.html#2137" class="Function">refl</a>
    <a data-type="Bool" id="12018" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="12024" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="12029" class="Symbol">→</a> <a data-type="x ≡ x" id="12031" href="1Lab.Path.html#2137" class="Function">refl</a>
    <a data-type="Bool" id="12040" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="Bool" id="12045" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="12051" class="Symbol">→</a> <a data-type="x ≡ x" id="12053" href="1Lab.Path.html#2137" class="Function">refl</a>
    <a data-type="Bool" id="12062" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="Bool" id="12067" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="12072" class="Symbol">→</a> <a data-type="x ≡ x" id="12074" href="1Lab.Path.html#2137" class="Function">refl</a>
</pre>
<p>It’s not clear that this should be the case, especially since the case analysis obfuscates the result further. However, writing <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∧</mo></mrow><annotation encoding="application/x-tex">\land</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∧</span></span></span></span>

 and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∨</mo></mrow><annotation encoding="application/x-tex">\lor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∨</span></span></span></span>

 for the actions of <span class="Agda"><a href="1Lab.Univalence.SIP.html#11373" class="Function">Conj</a></span> and <span class="Agda"><a href="1Lab.Univalence.SIP.html#11558" class="Function">Disj</a></span> (as one should!), then we see that <span class="Agda"><a href="1Lab.Univalence.SIP.html#11848" class="Function">not-iso</a></span> says exactly that</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">¬</mi><mo stretchy="false">(</mo><mi>x</mi><mo>∧</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">¬</mi><mi>x</mi><mo>∨</mo><mi mathvariant="normal">¬</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">
\neg (x \land y) = \neg x \lor \neg y
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">¬</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord">¬</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></span>

</p>
<p>From this and the SIP we get that <span class="Agda"><a href="1Lab.Univalence.SIP.html#11373" class="Function">Conj</a></span> and <span class="Agda"><a href="1Lab.Univalence.SIP.html#11558" class="Function">Disj</a></span> are the same <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>

-magma:</span></p>
<pre class="Agda">  <a id="Conj≡Disj"></a><a id="12504" href="1Lab.Univalence.SIP.html#12504" class="Function">Conj≡Disj</a> <a id="12514" class="Symbol">:</a> <a id="12516" href="1Lab.Univalence.SIP.html#11373" class="Function">Conj</a> <a data-type="A → A → Type ℓ" id="12521" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="12523" href="1Lab.Univalence.SIP.html#11558" class="Function">Disj</a>
  <a id="12530" href="1Lab.Univalence.SIP.html#12504" class="Function">Conj≡Disj</a> <a id="12540" class="Symbol">=</a> <a data-type="isUnivalent σ → X ≃[ σ ] Y → X ≡ Y" id="12542" href="1Lab.Univalence.SIP.html#5488" class="Function">sip</a> <a id="12546" href="1Lab.Univalence.SIP.html#9912" class="Function">∞-Magma-univ</a> <a id="12559" href="1Lab.Univalence.SIP.html#11848" class="Function">not-iso</a>
</pre>
<p>We have a similar phenomenon that happens with NAND and NOR:</p>
<div class="mathpar">
<pre class="Agda">  <a id="Nand"></a><a id="12664" href="1Lab.Univalence.SIP.html#12664" class="Function">Nand</a> <a id="12669" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="12671" href="1Lab.Univalence.SIP.html#3316" class="Function">TypeWith</a> <a id="12680" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a>
  <a id="12690" href="1Lab.Univalence.SIP.html#12664" class="Function">Nand</a> <a id="12695" class="Symbol">.</a><a data-type="∑ A B → A" id="12696" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="12700" class="Symbol">=</a> <a data-type="Type" id="12702" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="12709" href="1Lab.Univalence.SIP.html#12664" class="Function">Nand</a> <a id="12714" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="12715" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="12719" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="12725" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="12731" class="Symbol">=</a> <a data-type="Bool" id="12733" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
  <a id="12740" href="1Lab.Univalence.SIP.html#12664" class="Function">Nand</a> <a id="12745" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="12746" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="12750" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="12756" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="12762" class="Symbol">=</a> <a data-type="Bool" id="12764" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
  <a id="12771" href="1Lab.Univalence.SIP.html#12664" class="Function">Nand</a> <a id="12776" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="12777" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="12781" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a data-type="Bool" id="12787" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="12793" class="Symbol">=</a> <a data-type="Bool" id="12795" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
  <a id="12802" href="1Lab.Univalence.SIP.html#12664" class="Function">Nand</a> <a id="12807" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="12808" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="12812" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a data-type="Bool" id="12818" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="12824" class="Symbol">=</a> <a data-type="Bool" id="12826" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
</pre>
<pre class="Agda">  <a id="Nor"></a><a id="12847" href="1Lab.Univalence.SIP.html#12847" class="Function">Nor</a> <a id="12851" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="12853" href="1Lab.Univalence.SIP.html#3316" class="Function">TypeWith</a> <a id="12862" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a>
  <a id="12872" href="1Lab.Univalence.SIP.html#12847" class="Function">Nor</a> <a id="12876" class="Symbol">.</a><a data-type="∑ A B → A" id="12877" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="12881" class="Symbol">=</a> <a data-type="Type" id="12883" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="12890" href="1Lab.Univalence.SIP.html#12847" class="Function">Nor</a> <a id="12894" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="12895" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="12899" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="12905" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="12911" class="Symbol">=</a> <a data-type="Bool" id="12913" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
  <a id="12920" href="1Lab.Univalence.SIP.html#12847" class="Function">Nor</a> <a id="12924" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="12925" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="12929" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="12935" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="12941" class="Symbol">=</a> <a data-type="Bool" id="12943" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="12951" href="1Lab.Univalence.SIP.html#12847" class="Function">Nor</a> <a id="12955" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="12956" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="12960" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a data-type="Bool" id="12966" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="12972" class="Symbol">=</a> <a data-type="Bool" id="12974" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="12982" href="1Lab.Univalence.SIP.html#12847" class="Function">Nor</a> <a id="12986" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="12987" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="12991" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a data-type="Bool" id="12997" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="13003" class="Symbol">=</a> <a data-type="Bool" id="13005" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
</pre>
</div>
<pre class="Agda">  <a id="not-iso&#39;"></a><a id="13033" href="1Lab.Univalence.SIP.html#13033" class="Function">not-iso&#39;</a> <a id="13042" class="Symbol">:</a> <a id="13044" href="1Lab.Univalence.SIP.html#12664" class="Function">Nand</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="13049" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">≃[</a> <a id="13052" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="13060" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">]</a> <a id="13062" href="1Lab.Univalence.SIP.html#12847" class="Function">Nor</a>
  <a id="13068" href="1Lab.Univalence.SIP.html#13033" class="Function">not-iso&#39;</a> <a id="13077" class="Symbol">.</a><a data-type="∑ A B → A" id="13078" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="13082" class="Symbol">=</a> <a data-type="Bool → Bool" id="13084" href="Data.Bool.html#1190" class="Function">not</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="13088" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv not" id="13090" href="Data.Bool.html#7030" class="Function">isEquiv-not</a>
  <a id="13104" href="1Lab.Univalence.SIP.html#13033" class="Function">not-iso&#39;</a> <a id="13113" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="13114" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="13118" class="Symbol">=</a> <a id="13120" href="1Lab.Univalence.SIP.html#10744" class="Function">fixup</a> <a id="13126" class="Symbol">{</a><a id="13127" class="Argument">A</a> <a id="13129" class="Symbol">=</a> <a id="13131" href="1Lab.Univalence.SIP.html#12664" class="Function">Nand</a><a id="13135" class="Symbol">}</a> <a id="13137" class="Symbol">{</a><a id="13138" class="Argument">B</a> <a id="13140" class="Symbol">=</a> <a id="13142" href="1Lab.Univalence.SIP.html#12847" class="Function">Nor</a><a id="13145" class="Symbol">}</a> <a id="13147" class="Symbol">{</a><a id="13148" class="Argument">f</a> <a id="13150" class="Symbol">=</a> <a id="13152" class="Symbol">_</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="13154" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv not" id="13156" href="Data.Bool.html#7030" class="Function">isEquiv-not</a><a id="13167" class="Symbol">}</a> <a id="13169" class="Symbol">λ</a> <a id="13171" class="Keyword">where</a>
    <a data-type="Bool" id="13181" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="13187" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="13193" class="Symbol">→</a> <a data-type="x ≡ x" id="13195" href="1Lab.Path.html#2137" class="Function">refl</a>
    <a data-type="Bool" id="13204" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="13210" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="13215" class="Symbol">→</a> <a data-type="x ≡ x" id="13217" href="1Lab.Path.html#2137" class="Function">refl</a>
    <a data-type="Bool" id="13226" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="Bool" id="13231" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="13237" class="Symbol">→</a> <a data-type="x ≡ x" id="13239" href="1Lab.Path.html#2137" class="Function">refl</a>
    <a data-type="Bool" id="13248" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="Bool" id="13253" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="13258" class="Symbol">→</a> <a data-type="x ≡ x" id="13260" href="1Lab.Path.html#2137" class="Function">refl</a>
</pre>
<h1 id="transport-structures"><a href="#transport-structures" class="header-link">Transport Structures<span class="header-link-emoji">🔗</span></a></h1>
<p>As an alternative to equipping a type family <code>S : Type → Type</code> with a notion of S-homomorphism, we can equip it with a notion of <em>action</em>. Equipping a structure with a notion of action canonically equips it with a notion of homomorphism:</p>
<pre class="Agda"><a id="EqvAction"></a><a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="13541" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="13551" class="Symbol">:</a> <a id="13553" class="Symbol">(</a><a id="13554" href="1Lab.Univalence.SIP.html#13554" class="Bound">S</a> <a id="13556" class="Symbol">:</a> <a id="13558" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13563" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="13565" class="Symbol">→</a> <a id="13567" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13572" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a><a id="13574" class="Symbol">)</a> <a id="13576" class="Symbol">→</a> <a id="13578" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13583" class="Symbol">_</a>
<a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="13585" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="13595" class="Symbol">{</a><a id="13596" class="Argument">ℓ</a> <a id="13598" class="Symbol">=</a> <a id="13600" href="1Lab.Univalence.SIP.html#13600" class="Bound">ℓ</a><a id="13601" class="Symbol">}</a> <a id="13603" href="1Lab.Univalence.SIP.html#13603" class="Bound">S</a> <a id="13605" class="Symbol">=</a> <a id="13607" class="Symbol">{</a><a id="13608" href="1Lab.Univalence.SIP.html#13608" class="Bound">X</a> <a id="13610" href="1Lab.Univalence.SIP.html#13610" class="Bound">Y</a> <a id="13612" class="Symbol">:</a> <a id="13614" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13619" href="1Lab.Univalence.SIP.html#13600" class="Bound">ℓ</a><a id="13620" class="Symbol">}</a> <a id="13622" class="Symbol">→</a> <a id="13624" class="Symbol">(</a><a id="13625" href="1Lab.Univalence.SIP.html#13608" class="Bound">X</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="13627" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="13629" href="1Lab.Univalence.SIP.html#13610" class="Bound">Y</a><a id="13630" class="Symbol">)</a> <a id="13632" class="Symbol">→</a> <a id="13634" class="Symbol">(</a><a id="13635" href="1Lab.Univalence.SIP.html#13603" class="Bound">S</a> <a id="13637" href="1Lab.Univalence.SIP.html#13608" class="Bound">X</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="13639" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="13641" href="1Lab.Univalence.SIP.html#13603" class="Bound">S</a> <a id="13643" href="1Lab.Univalence.SIP.html#13610" class="Bound">Y</a><a id="13644" class="Symbol">)</a>

<a id="Action→Structure"></a><a data-type="EqvAction S₁ → Structure ℓ₁ S₁" id="13647" href="1Lab.Univalence.SIP.html#13647" class="Function">Action→Structure</a> <a id="13664" class="Symbol">:</a> <a id="13666" class="Symbol">{</a><a id="13667" href="1Lab.Univalence.SIP.html#13667" class="Bound">S</a> <a id="13669" class="Symbol">:</a> <a id="13671" href="1Lab.Type.html#394" class="Primitive">Type</a>  <a id="13677" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="13679" class="Symbol">→</a> <a id="13681" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13686" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a><a id="13688" class="Symbol">}</a> <a id="13690" class="Symbol">→</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="13692" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="13702" href="1Lab.Univalence.SIP.html#13667" class="Bound">S</a> <a id="13704" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="13706" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="13716" class="Symbol">_</a> <a id="13718" href="1Lab.Univalence.SIP.html#13667" class="Bound">S</a>
<a data-type="EqvAction S₁ → Structure ℓ₁ S₁" id="13720" href="1Lab.Univalence.SIP.html#13647" class="Function">Action→Structure</a> <a id="13737" href="1Lab.Univalence.SIP.html#13737" class="Bound">act</a> <a id="13741" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="13742" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="13749" class="Symbol">(</a><a id="13750" href="1Lab.Univalence.SIP.html#13750" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="13752" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="13754" href="1Lab.Univalence.SIP.html#13754" class="Bound">x</a><a id="13755" class="Symbol">)</a> <a id="13757" class="Symbol">(</a><a id="13758" href="1Lab.Univalence.SIP.html#13758" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="13760" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="13762" href="1Lab.Univalence.SIP.html#13762" class="Bound">y</a><a id="13763" class="Symbol">)</a> <a id="13765" href="1Lab.Univalence.SIP.html#13765" class="Bound">f</a> <a id="13767" class="Symbol">=</a> <a id="13769" href="1Lab.Univalence.SIP.html#13737" class="Bound">act</a> <a id="13773" href="1Lab.Univalence.SIP.html#13765" class="Bound">f</a> <a id="13775" class="Symbol">.</a><a data-type="∑ A B → A" id="13776" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="13780" href="1Lab.Univalence.SIP.html#13754" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="13782" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="13784" href="1Lab.Univalence.SIP.html#13762" class="Bound">y</a>
</pre>
<p>A <strong>transport structure</strong> is a structure <code>S : Type → Type</code> with a choice of equivalence action <code>α : EqvAction S</code> which agrees with the “intrinsic” notion of equivalence action that is induced by <a href="1Lab.Path.html#computation">the computation rules for transport</a>.</p>
<pre class="Agda"><a id="isTransportStr"></a><a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="14101" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a> <a id="14116" class="Symbol">:</a> <a id="14118" class="Symbol">{</a><a id="14119" href="1Lab.Univalence.SIP.html#14119" class="Bound">S</a> <a id="14121" class="Symbol">:</a> <a id="14123" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14128" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="14130" class="Symbol">→</a> <a id="14132" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14137" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a><a id="14139" class="Symbol">}</a> <a id="14141" class="Symbol">→</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="14143" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="14153" href="1Lab.Univalence.SIP.html#14119" class="Bound">S</a> <a id="14155" class="Symbol">→</a> <a id="14157" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14162" class="Symbol">_</a>
<a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="14164" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a> <a id="14179" class="Symbol">{</a><a id="14180" class="Argument">ℓ</a> <a id="14182" class="Symbol">=</a> <a id="14184" href="1Lab.Univalence.SIP.html#14184" class="Bound">ℓ</a><a id="14185" class="Symbol">}</a> <a id="14187" class="Symbol">{</a><a id="14188" class="Argument">S</a> <a id="14190" class="Symbol">=</a> <a id="14192" href="1Lab.Univalence.SIP.html#14192" class="Bound">S</a><a id="14193" class="Symbol">}</a> <a id="14195" href="1Lab.Univalence.SIP.html#14195" class="Bound">act</a> <a id="14199" class="Symbol">=</a>
  <a id="14203" class="Symbol">{</a><a id="14204" href="1Lab.Univalence.SIP.html#14204" class="Bound">X</a> <a id="14206" href="1Lab.Univalence.SIP.html#14206" class="Bound">Y</a> <a id="14208" class="Symbol">:</a> <a id="14210" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14215" href="1Lab.Univalence.SIP.html#14184" class="Bound">ℓ</a><a id="14216" class="Symbol">}</a> <a id="14218" class="Symbol">(</a><a id="14219" href="1Lab.Univalence.SIP.html#14219" class="Bound">e</a> <a id="14221" class="Symbol">:</a> <a id="14223" href="1Lab.Univalence.SIP.html#14204" class="Bound">X</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="14225" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="14227" href="1Lab.Univalence.SIP.html#14206" class="Bound">Y</a><a id="14228" class="Symbol">)</a> <a id="14230" class="Symbol">(</a><a id="14231" href="1Lab.Univalence.SIP.html#14231" class="Bound">s</a> <a id="14233" class="Symbol">:</a> <a id="14235" href="1Lab.Univalence.SIP.html#14192" class="Bound">S</a> <a id="14237" href="1Lab.Univalence.SIP.html#14204" class="Bound">X</a><a id="14238" class="Symbol">)</a> <a id="14240" class="Symbol">→</a> <a id="14242" href="1Lab.Univalence.SIP.html#14195" class="Bound">act</a> <a id="14246" href="1Lab.Univalence.SIP.html#14219" class="Bound">e</a> <a id="14248" class="Symbol">.</a><a data-type="∑ A B → A" id="14249" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="14253" href="1Lab.Univalence.SIP.html#14231" class="Bound">s</a> <a data-type="A → A → Type ℓ" id="14255" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="14257" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="14263" href="1Lab.Univalence.SIP.html#14192" class="Bound">S</a> <a id="14265" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="14266" href="1Lab.Univalence.html#8827" class="Function">ua</a> <a id="14269" href="1Lab.Univalence.SIP.html#14219" class="Bound">e</a><a id="14270" class="Symbol">)</a> <a id="14272" href="1Lab.Univalence.SIP.html#14231" class="Bound">s</a>
</pre>
<p>While the above definition of <code class="sourceCode agda">transport structure</code> is natural, it can sometimes be unwieldy to work with. Using <span class="Agda"><a data-type="(P : (B : Type ℓ) → A ≃ B → Type ℓ&#39;) →
P A ((λ x → x) , idEquiv) → (e : A ≃ B) → P B e" href="1Lab.Univalence.html#19813" class="Function">univalence</a></span>, the condition for being a transport structure can be weakened to “preserves the identity equivalence”, with no loss of generality:</p>
<pre class="Agda"><a id="preservesId"></a><a data-type="EqvAction S₁ → Type (lsuc ℓ)" id="14573" href="1Lab.Univalence.SIP.html#14573" class="Function">preservesId</a> <a id="14585" class="Symbol">:</a> <a id="14587" class="Symbol">{</a><a id="14588" href="1Lab.Univalence.SIP.html#14588" class="Bound">S</a> <a id="14590" class="Symbol">:</a> <a id="14592" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14597" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="14599" class="Symbol">→</a> <a id="14601" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14606" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a><a id="14607" class="Symbol">}</a> <a id="14609" class="Symbol">→</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="14611" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="14621" href="1Lab.Univalence.SIP.html#14588" class="Bound">S</a> <a id="14623" class="Symbol">→</a> <a id="14625" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14630" class="Symbol">_</a>
<a data-type="EqvAction S₁ → Type (lsuc ℓ)" id="14632" href="1Lab.Univalence.SIP.html#14573" class="Function">preservesId</a> <a id="14644" class="Symbol">{</a><a id="14645" class="Argument">ℓ</a> <a id="14647" class="Symbol">=</a> <a id="14649" href="1Lab.Univalence.SIP.html#14649" class="Bound">ℓ</a><a id="14650" class="Symbol">}</a> <a id="14652" class="Symbol">{</a><a id="14653" class="Argument">S</a> <a id="14655" class="Symbol">=</a> <a id="14657" href="1Lab.Univalence.SIP.html#14657" class="Bound">S</a><a id="14658" class="Symbol">}</a> <a id="14660" href="1Lab.Univalence.SIP.html#14660" class="Bound">act</a> <a id="14664" class="Symbol">=</a>
  <a id="14668" class="Symbol">{</a><a id="14669" href="1Lab.Univalence.SIP.html#14669" class="Bound">X</a> <a id="14671" class="Symbol">:</a> <a id="14673" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14678" href="1Lab.Univalence.SIP.html#14649" class="Bound">ℓ</a><a id="14679" class="Symbol">}</a> <a id="14681" class="Symbol">(</a><a id="14682" href="1Lab.Univalence.SIP.html#14682" class="Bound">s</a> <a id="14684" class="Symbol">:</a> <a id="14686" href="1Lab.Univalence.SIP.html#14657" class="Bound">S</a> <a id="14688" href="1Lab.Univalence.SIP.html#14669" class="Bound">X</a><a id="14689" class="Symbol">)</a> <a id="14691" class="Symbol">→</a> <a id="14693" href="1Lab.Univalence.SIP.html#14660" class="Bound">act</a> <a id="14697" class="Symbol">(</a><a data-type="A → A" id="14698" href="1Lab.Type.html#2348" class="Function">id</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="14701" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="14703" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="14710" class="Symbol">)</a> <a id="14712" class="Symbol">.</a><a data-type="∑ A B → A" id="14713" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="14717" href="1Lab.Univalence.SIP.html#14682" class="Bound">s</a> <a data-type="A → A → Type ℓ" id="14719" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="14721" href="1Lab.Univalence.SIP.html#14682" class="Bound">s</a>
</pre>
<p>The proof is by equivalence induction: To show something about all <code>Y : Type, x : X ≃ Y</code> (with X fixed), it suffices to cover the case where <code>Y</code> is <code>X</code> and <code>e</code> is the identity equivalence. This case is by the assumption that <span class="Agda"><a data-type="EqvAction S₁ → Type (lsuc ℓ)" href="1Lab.Univalence.SIP.html#14573" class="Function">σ preserves id</a></span>.</p>
<pre class="Agda"><a id="preservesId→isTransportStr"></a><a data-type="(σ : EqvAction S₁) → preservesId σ → isTransportStr σ" id="15005" href="1Lab.Univalence.SIP.html#15005" class="Function">preservesId→isTransportStr</a> <a id="15032" class="Symbol">:</a> <a id="15034" class="Symbol">(</a><a id="15035" href="1Lab.Univalence.SIP.html#15035" class="Bound">σ</a> <a id="15037" class="Symbol">:</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="15039" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="15049" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="15050" class="Symbol">)</a> <a id="15052" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ)" id="15054" href="1Lab.Univalence.SIP.html#14573" class="Function">preservesId</a> <a id="15066" href="1Lab.Univalence.SIP.html#15035" class="Bound">σ</a> <a id="15068" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="15070" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a> <a id="15085" href="1Lab.Univalence.SIP.html#15035" class="Bound">σ</a>
<a data-type="(σ : EqvAction S₁) → preservesId σ → isTransportStr σ" id="15087" href="1Lab.Univalence.SIP.html#15005" class="Function">preservesId→isTransportStr</a> <a id="15114" class="Symbol">{</a><a id="15115" class="Argument">S</a> <a id="15117" class="Symbol">=</a> <a id="15119" href="1Lab.Univalence.SIP.html#15119" class="Bound">S</a><a id="15120" class="Symbol">}</a> <a id="15122" href="1Lab.Univalence.SIP.html#15122" class="Bound">σ</a> <a id="15124" href="1Lab.Univalence.SIP.html#15124" class="Bound">pres-id</a> <a id="15132" href="1Lab.Univalence.SIP.html#15132" class="Bound">e</a> <a id="15134" href="1Lab.Univalence.SIP.html#15134" class="Bound">s</a> <a id="15136" class="Symbol">=</a>
  <a data-type="(P : (B : Type ℓ) → A ≃ B → Type ℓ&#39;) →
P A ((λ x → x) , idEquiv) → (e : A ≃ B) → P B e" id="15140" href="1Lab.Univalence.html#19813" class="Function">EquivJ</a> <a id="15147" class="Symbol">(λ</a> <a id="15150" href="1Lab.Univalence.SIP.html#15150" class="Bound">_</a> <a id="15152" href="1Lab.Univalence.SIP.html#15152" class="Bound">e</a> <a id="15154" class="Symbol">→</a> <a id="15156" href="1Lab.Univalence.SIP.html#15122" class="Bound">σ</a> <a id="15158" href="1Lab.Univalence.SIP.html#15152" class="Bound">e</a> <a id="15160" class="Symbol">.</a><a data-type="∑ A B → A" id="15161" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="15165" href="1Lab.Univalence.SIP.html#15134" class="Bound">s</a> <a data-type="A → A → Type ℓ" id="15167" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="15169" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="15175" href="1Lab.Univalence.SIP.html#15119" class="Bound">S</a> <a id="15177" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="15178" href="1Lab.Univalence.html#8827" class="Function">ua</a> <a id="15181" href="1Lab.Univalence.SIP.html#15152" class="Bound">e</a><a id="15182" class="Symbol">)</a> <a id="15184" href="1Lab.Univalence.SIP.html#15134" class="Bound">s</a><a id="15185" class="Symbol">)</a> <a id="15187" href="1Lab.Univalence.SIP.html#15381" class="Function">lemma&#39;</a> <a id="15194" href="1Lab.Univalence.SIP.html#15132" class="Bound">e</a>
  <a id="15198" class="Keyword">where</a>
</pre>
<p>Unfortunately we can not directly use the assumption that <code>σ</code> preserves <span class="Agda"><a data-type="A → A" href="1Lab.Type.html#2348" class="Function">id</a></span> in the proof, but it can be used as the final step in an equational proof:</p>
<pre class="Agda">    <a id="15381" href="1Lab.Univalence.SIP.html#15381" class="Function">lemma&#39;</a> <a id="15388" class="Symbol">:</a> <a id="15390" href="1Lab.Univalence.SIP.html#15122" class="Bound">σ</a> <a id="15392" class="Symbol">(</a><a data-type="A → A" id="15393" href="1Lab.Type.html#2348" class="Function">id</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="15396" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="15398" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="15405" class="Symbol">)</a> <a id="15407" class="Symbol">.</a><a data-type="∑ A B → A" id="15408" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="15412" href="1Lab.Univalence.SIP.html#15134" class="Bound">s</a> <a data-type="A → A → Type ℓ" id="15414" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="15416" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="15422" href="1Lab.Univalence.SIP.html#15119" class="Bound">S</a> <a id="15424" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="15425" href="1Lab.Univalence.html#8827" class="Function">ua</a> <a id="15428" class="Symbol">(</a><a data-type="A → A" id="15429" href="1Lab.Type.html#2348" class="Function">id</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="15432" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="15434" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="15441" class="Symbol">))</a> <a id="15444" href="1Lab.Univalence.SIP.html#15134" class="Bound">s</a>
    <a id="15450" href="1Lab.Univalence.SIP.html#15381" class="Function">lemma&#39;</a> <a id="15457" class="Symbol">=</a>
      <a data-type="x ≡ y → y ≡ x" id="15465" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="15469" class="Symbol">(</a>
        <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="15479" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="15485" href="1Lab.Univalence.SIP.html#15119" class="Bound">S</a> <a id="15487" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="15488" href="1Lab.Univalence.html#8827" class="Function">ua</a> <a id="15491" class="Symbol">(</a><a data-type="A → A" id="15492" href="1Lab.Type.html#2348" class="Function">id</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="15495" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="15497" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="15504" class="Symbol">))</a> <a id="15507" href="1Lab.Univalence.SIP.html#15134" class="Bound">s</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="15509" href="1Lab.Path.html#45199" class="Function Operator">≡⟨</a> <a data-type="(f : (x : A) → B x) (p : x ≡ y) → PathP (λ i → B (p i)) (f x) (f y)" id="15512" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="15515" class="Symbol">(λ</a> <a id="15518" href="1Lab.Univalence.SIP.html#15518" class="Bound">p</a> <a id="15520" class="Symbol">→</a> <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="15522" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="15528" href="1Lab.Univalence.SIP.html#15119" class="Bound">S</a> <a id="15530" href="1Lab.Univalence.SIP.html#15518" class="Bound">p</a> <a id="15532" href="1Lab.Univalence.SIP.html#15134" class="Bound">s</a><a id="15533" class="Symbol">)</a> <a data-type="ua ((λ x → x) , idEquiv) ≡ refl" id="15535" href="1Lab.Univalence.html#16276" class="Function">uaIdEquiv</a> <a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="15545" href="1Lab.Path.html#45199" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡</span></span>
        <a data-type="A ≡ B → A → B" id="15555" href="1Lab.Path.html#10335" class="Function">transport</a> <a data-type="x ≡ x" id="15565" href="1Lab.Path.html#2137" class="Function">refl</a> <a id="15570" href="1Lab.Univalence.SIP.html#15134" class="Bound">s</a>              <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="15585" href="1Lab.Path.html#45199" class="Function Operator">≡⟨</a> <a data-type="(x : A) → transport (λ i → A) x ≡ x" id="15588" href="1Lab.Path.html#12012" class="Function">transport-refl</a> <a id="15603" class="Symbol">_</a> <a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="15605" href="1Lab.Path.html#45199" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡</span></span>
        <a id="15615" href="1Lab.Univalence.SIP.html#15134" class="Bound">s</a>                             <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="15645" href="1Lab.Path.html#45199" class="Function Operator">≡⟨</a> <a data-type="x ≡ y → y ≡ x" id="15648" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="15652" class="Symbol">(</a><a id="15653" href="1Lab.Univalence.SIP.html#15124" class="Bound">pres-id</a> <a id="15661" href="1Lab.Univalence.SIP.html#15134" class="Bound">s</a><a id="15662" class="Symbol">)</a> <a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="15664" href="1Lab.Path.html#45199" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡</span></span> 
        <a id="15675" href="1Lab.Univalence.SIP.html#15122" class="Bound">σ</a> <a id="15677" class="Symbol">(</a><a data-type="A → A" id="15678" href="1Lab.Type.html#2348" class="Function">id</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="15681" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="15683" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="15690" class="Symbol">)</a> <a id="15692" class="Symbol">.</a><a data-type="∑ A B → A" id="15693" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="15697" href="1Lab.Univalence.SIP.html#15134" class="Bound">s</a>       <a data-type="(x : A) → x ≡ x" id="15705" href="1Lab.Path.html#45365" class="Function Operator">∎</a>
      <a id="15713" class="Symbol">)</a>
</pre>
<!--
<pre class="Agda"><a id="transportStr⁻¹"></a><a id="15733" href="1Lab.Univalence.SIP.html#15733" class="Function">transportStr⁻¹</a> <a id="15748" class="Symbol">:</a>
  <a id="15752" class="Symbol">{</a><a id="15753" href="1Lab.Univalence.SIP.html#15753" class="Bound">S</a> <a id="15755" class="Symbol">:</a> <a id="15757" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="15762" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="15764" class="Symbol">→</a> <a id="15766" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="15771" href="1Lab.Univalence.SIP.html#3455" class="Generalizable">ℓ₂</a><a id="15773" class="Symbol">}</a> <a id="15775" class="Symbol">(</a><a id="15776" href="1Lab.Univalence.SIP.html#15776" class="Bound">α</a> <a id="15778" class="Symbol">:</a> <a id="15780" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="15790" href="1Lab.Univalence.SIP.html#15753" class="Bound">S</a><a id="15791" class="Symbol">)</a> <a id="15793" class="Symbol">(</a><a id="15794" href="1Lab.Univalence.SIP.html#15794" class="Bound">τ</a> <a id="15796" class="Symbol">:</a> <a id="15798" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a> <a id="15813" href="1Lab.Univalence.SIP.html#15776" class="Bound">α</a><a id="15814" class="Symbol">)</a>
  <a id="15818" class="Symbol">{</a><a id="15819" href="1Lab.Univalence.SIP.html#15819" class="Bound">X</a> <a id="15821" href="1Lab.Univalence.SIP.html#15821" class="Bound">Y</a> <a id="15823" class="Symbol">:</a> <a id="15825" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="15830" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a><a id="15831" class="Symbol">}</a> <a id="15833" class="Symbol">(</a><a id="15834" href="1Lab.Univalence.SIP.html#15834" class="Bound">e</a> <a id="15836" class="Symbol">:</a> <a id="15838" href="1Lab.Univalence.SIP.html#15819" class="Bound">X</a> <a id="15840" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="15842" href="1Lab.Univalence.SIP.html#15821" class="Bound">Y</a><a id="15843" class="Symbol">)</a> <a id="15845" class="Symbol">(</a><a id="15846" href="1Lab.Univalence.SIP.html#15846" class="Bound">t</a> <a id="15848" class="Symbol">:</a> <a id="15850" href="1Lab.Univalence.SIP.html#15753" class="Bound">S</a> <a id="15852" href="1Lab.Univalence.SIP.html#15821" class="Bound">Y</a><a id="15853" class="Symbol">)</a>
  <a id="15857" class="Symbol">→</a> <a id="15859" href="1Lab.Equiv.html#6391" class="Function">equiv→inverse</a> <a id="15873" class="Symbol">(</a><a id="15874" href="1Lab.Univalence.SIP.html#15776" class="Bound">α</a> <a id="15876" href="1Lab.Univalence.SIP.html#15834" class="Bound">e</a> <a id="15878" class="Symbol">.</a><a id="15879" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="15882" class="Symbol">)</a> <a id="15884" href="1Lab.Univalence.SIP.html#15846" class="Bound">t</a> <a id="15886" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="15888" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="15894" href="1Lab.Univalence.SIP.html#15753" class="Bound">S</a> <a id="15896" class="Symbol">(</a><a id="15897" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="15901" class="Symbol">(</a><a id="15902" href="1Lab.Univalence.html#8827" class="Function">ua</a> <a id="15905" href="1Lab.Univalence.SIP.html#15834" class="Bound">e</a><a id="15906" class="Symbol">))</a> <a id="15909" href="1Lab.Univalence.SIP.html#15846" class="Bound">t</a>
<a id="15911" href="1Lab.Univalence.SIP.html#15733" class="Function">transportStr⁻¹</a> <a id="15926" class="Symbol">{</a><a id="15927" class="Argument">S</a> <a id="15929" class="Symbol">=</a> <a id="15931" href="1Lab.Univalence.SIP.html#15931" class="Bound">S</a><a id="15932" class="Symbol">}</a> <a id="15934" href="1Lab.Univalence.SIP.html#15934" class="Bound">α</a> <a id="15936" href="1Lab.Univalence.SIP.html#15936" class="Bound">τ</a> <a id="15938" href="1Lab.Univalence.SIP.html#15938" class="Bound">e</a> <a id="15940" href="1Lab.Univalence.SIP.html#15940" class="Bound">t</a> <a id="15942" class="Symbol">=</a>
     <a id="15949" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="15953" class="Symbol">(</a><a id="15954" href="1Lab.Path.html#13290" class="Function">transport⁻Transport</a> <a id="15974" class="Symbol">(</a><a id="15975" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="15978" href="1Lab.Univalence.SIP.html#15931" class="Bound">S</a> <a id="15980" class="Symbol">(</a><a id="15981" href="1Lab.Univalence.html#8827" class="Function">ua</a> <a id="15984" href="1Lab.Univalence.SIP.html#15938" class="Bound">e</a><a id="15985" class="Symbol">))</a> <a id="15988" class="Symbol">(</a><a id="15989" href="1Lab.Equiv.html#6391" class="Function">equiv→inverse</a> <a id="16003" class="Symbol">(</a><a id="16004" href="1Lab.Univalence.SIP.html#15934" class="Bound">α</a> <a id="16006" href="1Lab.Univalence.SIP.html#15938" class="Bound">e</a> <a id="16008" class="Symbol">.</a><a id="16009" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="16012" class="Symbol">)</a> <a id="16014" href="1Lab.Univalence.SIP.html#15940" class="Bound">t</a><a id="16015" class="Symbol">))</a>
  <a id="16020" href="1Lab.Path.html#36860" class="Function Operator">··</a> <a id="16023" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="16027" class="Symbol">(</a><a id="16028" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="16031" class="Symbol">(</a><a id="16032" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="16038" href="1Lab.Univalence.SIP.html#15931" class="Bound">S</a> <a id="16040" class="Symbol">(</a><a id="16041" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="16045" class="Symbol">(</a><a id="16046" href="1Lab.Univalence.html#8827" class="Function">ua</a> <a id="16049" href="1Lab.Univalence.SIP.html#15938" class="Bound">e</a><a id="16050" class="Symbol">)))</a> <a id="16054" class="Symbol">(</a><a id="16055" href="1Lab.Univalence.SIP.html#15936" class="Bound">τ</a> <a id="16057" href="1Lab.Univalence.SIP.html#15938" class="Bound">e</a> <a id="16059" class="Symbol">(</a><a id="16060" href="1Lab.Equiv.html#6391" class="Function">equiv→inverse</a> <a id="16074" class="Symbol">(</a><a id="16075" href="1Lab.Univalence.SIP.html#15934" class="Bound">α</a> <a id="16077" href="1Lab.Univalence.SIP.html#15938" class="Bound">e</a> <a id="16079" class="Symbol">.</a><a id="16080" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="16083" class="Symbol">)</a> <a id="16085" href="1Lab.Univalence.SIP.html#15940" class="Bound">t</a><a id="16086" class="Symbol">)))</a>
  <a id="16092" href="1Lab.Path.html#36860" class="Function Operator">··</a> <a id="16095" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="16098" class="Symbol">(</a><a id="16099" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="16105" href="1Lab.Univalence.SIP.html#15931" class="Bound">S</a> <a id="16107" class="Symbol">(</a><a id="16108" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="16112" class="Symbol">(</a><a id="16113" href="1Lab.Univalence.html#8827" class="Function">ua</a> <a id="16116" href="1Lab.Univalence.SIP.html#15938" class="Bound">e</a><a id="16117" class="Symbol">)))</a> <a id="16121" class="Symbol">(</a><a id="16122" href="1Lab.Equiv.html#6488" class="Function">equiv→section</a> <a id="16136" class="Symbol">(</a><a id="16137" href="1Lab.Univalence.SIP.html#15934" class="Bound">α</a> <a id="16139" href="1Lab.Univalence.SIP.html#15938" class="Bound">e</a> <a id="16141" class="Symbol">.</a><a id="16142" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="16145" class="Symbol">)</a> <a id="16147" href="1Lab.Univalence.SIP.html#15940" class="Bound">t</a><a id="16148" class="Symbol">)</a>
</pre>-->
<p>If <code>S</code> is a <code class="sourceCode agda" id="isTransportStr">transport structure</code>, then its canonical equipment as a <span class="Agda"><a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a></span> is univalent:</p>
<pre class="Agda"><a id="isTransp→isUnivalent"></a><a data-type="(a : EqvAction S₁) →
isTransportStr a → isUnivalent (Action→Structure a)" id="16295" href="1Lab.Univalence.SIP.html#16295" class="Function">isTransp→isUnivalent</a> <a id="16316" class="Symbol">:</a> <a id="16318" class="Symbol">{</a><a id="16319" href="1Lab.Univalence.SIP.html#16319" class="Bound">S</a> <a id="16321" class="Symbol">:</a> <a id="16323" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="16328" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="16330" class="Symbol">→</a> <a id="16332" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="16337" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a><a id="16339" class="Symbol">}</a> <a id="16341" class="Symbol">(</a><a id="16342" href="1Lab.Univalence.SIP.html#16342" class="Bound">a</a> <a id="16344" class="Symbol">:</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="16346" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="16356" href="1Lab.Univalence.SIP.html#16319" class="Bound">S</a><a id="16357" class="Symbol">)</a>
                     <a id="16380" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="16382" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a> <a id="16397" href="1Lab.Univalence.SIP.html#16342" class="Bound">a</a>
                     <a id="16420" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="16422" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="16434" class="Symbol">(</a><a data-type="EqvAction S₁ → Structure ℓ₁ S₁" id="16435" href="1Lab.Univalence.SIP.html#13647" class="Function">Action→Structure</a> <a id="16452" href="1Lab.Univalence.SIP.html#16342" class="Bound">a</a><a id="16453" class="Symbol">)</a>
<a data-type="(a : EqvAction S₁) →
isTransportStr a → isUnivalent (Action→Structure a)" id="16455" href="1Lab.Univalence.SIP.html#16295" class="Function">isTransp→isUnivalent</a> <a id="16476" class="Symbol">{</a><a id="16477" class="Argument">S</a> <a id="16479" class="Symbol">=</a> <a id="16481" href="1Lab.Univalence.SIP.html#16481" class="Bound">S</a><a id="16482" class="Symbol">}</a> <a id="16484" href="1Lab.Univalence.SIP.html#16484" class="Bound">act</a> <a id="16488" href="1Lab.Univalence.SIP.html#16488" class="Bound">is-tr</a> <a id="16494" class="Symbol">{</a><a id="16495" href="1Lab.Univalence.SIP.html#16495" class="Bound">X</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="16497" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="16499" href="1Lab.Univalence.SIP.html#16499" class="Bound">s</a><a id="16500" class="Symbol">}</a> <a id="16502" class="Symbol">{</a><a id="16503" href="1Lab.Univalence.SIP.html#16503" class="Bound">Y</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="16505" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="16507" href="1Lab.Univalence.SIP.html#16507" class="Bound">t</a><a id="16508" class="Symbol">}</a> <a id="16510" href="1Lab.Univalence.SIP.html#16510" class="Bound">eqv</a> <a id="16514" class="Symbol">=</a>
  <a id="16518" href="1Lab.Univalence.SIP.html#16484" class="Bound">act</a> <a id="16522" href="1Lab.Univalence.SIP.html#16510" class="Bound">eqv</a> <a id="16526" class="Symbol">.</a><a data-type="∑ A B → A" id="16527" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="16531" href="1Lab.Univalence.SIP.html#16499" class="Bound">s</a> <a data-type="A → A → Type ℓ" id="16533" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="16535" href="1Lab.Univalence.SIP.html#16507" class="Bound">t</a>              <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="16550" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a data-type="A ≡ B → A ≃ B" id="16553" href="1Lab.Univalence.html#15494" class="Function">pathToEquiv</a> <a id="16565" class="Symbol">(</a><a data-type="(f : (x : A) → B x) (p : x ≡ y) → PathP (λ i → B (p i)) (f x) (f y)" id="16566" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="16569" class="Symbol">(</a><a data-type="A → A → Type ℓ" id="16570" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">_≡</a> <a id="16573" href="1Lab.Univalence.SIP.html#16507" class="Bound">t</a><a id="16574" class="Symbol">)</a> <a id="16576" class="Symbol">(</a><a id="16577" href="1Lab.Univalence.SIP.html#16488" class="Bound">is-tr</a> <a id="16583" href="1Lab.Univalence.SIP.html#16510" class="Bound">eqv</a> <a id="16587" href="1Lab.Univalence.SIP.html#16499" class="Bound">s</a><a id="16588" class="Symbol">))</a> <a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="16591" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="16595" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="16601" href="1Lab.Univalence.SIP.html#16481" class="Bound">S</a> <a id="16603" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="16604" href="1Lab.Univalence.html#8827" class="Function">ua</a> <a id="16607" href="1Lab.Univalence.SIP.html#16510" class="Bound">eqv</a><a id="16610" class="Symbol">)</a> <a id="16612" href="1Lab.Univalence.SIP.html#16499" class="Bound">s</a> <a data-type="A → A → Type ℓ" id="16614" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="16616" href="1Lab.Univalence.SIP.html#16507" class="Bound">t</a>          <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="16627" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a data-type="A ≡ B → A ≃ B" id="16630" href="1Lab.Univalence.html#15494" class="Function">pathToEquiv</a> <a id="16642" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="16643" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="16647" class="Symbol">(</a><a data-type="(P : I → Type ℓ) (p : P i0) (q : P i1) →
PathP P p q ≡ Path (P i1) (transport P p) q" id="16648" href="1Lab.Path.html#47534" class="Function">PathP≡Path</a> <a id="16659" class="Symbol">(λ</a> <a id="16662" href="1Lab.Univalence.SIP.html#16662" class="Bound">i</a> <a id="16664" class="Symbol">→</a> <a id="16666" href="1Lab.Univalence.SIP.html#16481" class="Bound">S</a> <a id="16668" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="16669" href="1Lab.Univalence.html#8827" class="Function">ua</a> <a id="16672" href="1Lab.Univalence.SIP.html#16510" class="Bound">eqv</a> <a id="16676" href="1Lab.Univalence.SIP.html#16662" class="Bound">i</a><a id="16677" class="Symbol">))</a> <a id="16680" href="1Lab.Univalence.SIP.html#16499" class="Bound">s</a> <a id="16682" href="1Lab.Univalence.SIP.html#16507" class="Bound">t</a><a id="16683" class="Symbol">))</a> <a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="16686" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="16690" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="16696" class="Symbol">(λ</a> <a id="16699" href="1Lab.Univalence.SIP.html#16699" class="Bound">i</a> <a id="16701" class="Symbol">→</a> <a id="16703" href="1Lab.Univalence.SIP.html#16481" class="Bound">S</a> <a id="16705" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="16706" href="1Lab.Univalence.html#8827" class="Function">ua</a> <a id="16709" href="1Lab.Univalence.SIP.html#16510" class="Bound">eqv</a> <a id="16713" href="1Lab.Univalence.SIP.html#16699" class="Bound">i</a><a id="16714" class="Symbol">))</a> <a id="16717" href="1Lab.Univalence.SIP.html#16499" class="Bound">s</a> <a id="16719" href="1Lab.Univalence.SIP.html#16507" class="Bound">t</a>  <a data-type="(A : Type ℓ) → A ≃ A" id="16722" href="1Lab.Equiv.html#23023" class="Function Operator">≃∎</a>
</pre>
<p>We can mix and match these different notions of structure at will. For example, a more convenient definition of function univalent structure uses an equivalence action on the domain:</p>
<pre class="Agda"><a id="functionStr"></a><a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" id="16922" href="1Lab.Univalence.SIP.html#16922" class="Function">functionStr</a> <a id="16934" class="Symbol">:</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="16936" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="16946" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="16948" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="16950" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="16960" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="16962" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a> <a id="16964" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="16966" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="16976" class="Symbol">_</a> <a id="16978" class="Symbol">(λ</a> <a id="16981" href="1Lab.Univalence.SIP.html#16981" class="Bound">X</a> <a id="16983" class="Symbol">→</a> <a id="16985" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="16987" href="1Lab.Univalence.SIP.html#16981" class="Bound">X</a> <a id="16989" class="Symbol">→</a> <a id="16991" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a> <a id="16993" href="1Lab.Univalence.SIP.html#16981" class="Bound">X</a><a id="16994" class="Symbol">)</a>
<a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" id="16996" href="1Lab.Univalence.SIP.html#16922" class="Function">functionStr</a> <a id="17008" class="Symbol">{</a><a id="17009" class="Argument">S</a> <a id="17011" class="Symbol">=</a> <a id="17013" href="1Lab.Univalence.SIP.html#17013" class="Bound">S</a><a id="17014" class="Symbol">}</a> <a id="17016" href="1Lab.Univalence.SIP.html#17016" class="Bound">act</a> <a id="17020" href="1Lab.Univalence.SIP.html#17020" class="Bound">str</a> <a id="17024" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="17025" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="17032" class="Symbol">(</a><a id="17033" href="1Lab.Univalence.SIP.html#17033" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="17035" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17037" href="1Lab.Univalence.SIP.html#17037" class="Bound">f</a><a id="17038" class="Symbol">)</a> <a id="17040" class="Symbol">(</a><a id="17041" href="1Lab.Univalence.SIP.html#17041" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="17043" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17045" href="1Lab.Univalence.SIP.html#17045" class="Bound">g</a><a id="17046" class="Symbol">)</a> <a id="17048" href="1Lab.Univalence.SIP.html#17048" class="Bound">e</a> <a id="17050" class="Symbol">=</a>
  <a id="17054" class="Symbol">(</a><a id="17055" href="1Lab.Univalence.SIP.html#17055" class="Bound">s</a> <a id="17057" class="Symbol">:</a> <a id="17059" href="1Lab.Univalence.SIP.html#17013" class="Bound">S</a> <a id="17061" href="1Lab.Univalence.SIP.html#17033" class="Bound">A</a><a id="17062" class="Symbol">)</a> <a id="17064" class="Symbol">→</a> <a id="17066" href="1Lab.Univalence.SIP.html#17020" class="Bound">str</a> <a id="17070" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="17071" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="17078" class="Symbol">(</a><a id="17079" href="1Lab.Univalence.SIP.html#17033" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="17081" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17083" href="1Lab.Univalence.SIP.html#17037" class="Bound">f</a> <a id="17085" href="1Lab.Univalence.SIP.html#17055" class="Bound">s</a><a id="17086" class="Symbol">)</a> <a id="17088" class="Symbol">(</a><a id="17089" href="1Lab.Univalence.SIP.html#17041" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="17091" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17093" href="1Lab.Univalence.SIP.html#17045" class="Bound">g</a> <a id="17095" class="Symbol">(</a><a id="17096" href="1Lab.Univalence.SIP.html#17016" class="Bound">act</a> <a id="17100" href="1Lab.Univalence.SIP.html#17048" class="Bound">e</a> <a id="17102" class="Symbol">.</a><a data-type="∑ A B → A" id="17103" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="17107" href="1Lab.Univalence.SIP.html#17055" class="Bound">s</a><a id="17108" class="Symbol">))</a> <a id="17111" href="1Lab.Univalence.SIP.html#17048" class="Bound">e</a>
</pre>
<p>This alternative definition of structure is univalent when <code>T</code> is a univalent structure and <code>S</code> is a transport structure:</p>
<pre class="Agda"><a id="functionStr-univalent"></a><a data-type="(α : EqvAction S₁) →
isTransportStr α →
(τ : Structure ℓ T) → isUnivalent τ → isUnivalent (functionStr α τ)" id="17249" href="1Lab.Univalence.SIP.html#17249" class="Function">functionStr-univalent</a> <a id="17271" class="Symbol">:</a> <a id="17273" class="Symbol">(</a><a id="17274" href="1Lab.Univalence.SIP.html#17274" class="Bound">α</a> <a id="17276" class="Symbol">:</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="17278" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="17288" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="17289" class="Symbol">)</a> <a id="17291" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="17293" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a> <a id="17308" href="1Lab.Univalence.SIP.html#17274" class="Bound">α</a>
                      <a id="17332" class="Symbol">→</a> <a id="17334" class="Symbol">(</a><a id="17335" href="1Lab.Univalence.SIP.html#17335" class="Bound">τ</a> <a id="17337" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="17339" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="17349" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="17351" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a><a id="17352" class="Symbol">)</a> <a id="17354" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="17356" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="17368" href="1Lab.Univalence.SIP.html#17335" class="Bound">τ</a>
                      <a id="17392" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="17394" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="17406" class="Symbol">(</a><a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" id="17407" href="1Lab.Univalence.SIP.html#16922" class="Function">functionStr</a> <a id="17419" href="1Lab.Univalence.SIP.html#17274" class="Bound">α</a> <a id="17421" href="1Lab.Univalence.SIP.html#17335" class="Bound">τ</a><a id="17422" class="Symbol">)</a>
<a data-type="(α : EqvAction S₁) →
isTransportStr α →
(τ : Structure ℓ T) → isUnivalent τ → isUnivalent (functionStr α τ)" id="17424" href="1Lab.Univalence.SIP.html#17249" class="Function">functionStr-univalent</a> <a id="17446" class="Symbol">{</a><a id="17447" class="Argument">S</a> <a id="17449" class="Symbol">=</a> <a id="17451" href="1Lab.Univalence.SIP.html#17451" class="Bound">S</a><a id="17452" class="Symbol">}</a> <a id="17454" class="Symbol">{</a><a id="17455" class="Argument">T</a> <a id="17457" class="Symbol">=</a> <a id="17459" href="1Lab.Univalence.SIP.html#17459" class="Bound">T</a><a id="17460" class="Symbol">}</a> <a id="17462" href="1Lab.Univalence.SIP.html#17462" class="Bound">α</a> <a id="17464" href="1Lab.Univalence.SIP.html#17464" class="Bound">α-tr</a> <a id="17469" href="1Lab.Univalence.SIP.html#17469" class="Bound">τ</a> <a id="17471" href="1Lab.Univalence.SIP.html#17471" class="Bound">τ-univ</a> <a id="17478" class="Symbol">{</a><a id="17479" href="1Lab.Univalence.SIP.html#17479" class="Bound">X</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="17481" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17483" href="1Lab.Univalence.SIP.html#17483" class="Bound">f</a><a id="17484" class="Symbol">}</a> <a id="17486" class="Symbol">{</a><a id="17487" href="1Lab.Univalence.SIP.html#17487" class="Bound">Y</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="17489" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17491" href="1Lab.Univalence.SIP.html#17491" class="Bound">g</a><a id="17492" class="Symbol">}</a> <a id="17494" href="1Lab.Univalence.SIP.html#17494" class="Bound">eqv</a> <a id="17498" class="Symbol">=</a>
  <a id="17502" class="Symbol">((</a><a id="17504" href="1Lab.Univalence.SIP.html#17504" class="Bound">s</a> <a id="17506" class="Symbol">:</a> <a id="17508" href="1Lab.Univalence.SIP.html#17451" class="Bound">S</a> <a id="17510" href="1Lab.Univalence.SIP.html#17479" class="Bound">X</a><a id="17511" class="Symbol">)</a> <a id="17513" class="Symbol">→</a> <a id="17515" href="1Lab.Univalence.SIP.html#17469" class="Bound">τ</a> <a id="17517" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="17518" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="17525" class="Symbol">(</a><a id="17526" href="1Lab.Univalence.SIP.html#17479" class="Bound">X</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="17528" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17530" href="1Lab.Univalence.SIP.html#17483" class="Bound">f</a> <a id="17532" href="1Lab.Univalence.SIP.html#17504" class="Bound">s</a><a id="17533" class="Symbol">)</a> <a id="17535" class="Symbol">(</a><a id="17536" href="1Lab.Univalence.SIP.html#17487" class="Bound">Y</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="17538" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17540" class="Symbol">_)</a> <a id="17543" href="1Lab.Univalence.SIP.html#17494" class="Bound">eqv</a><a id="17546" class="Symbol">)</a>     <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="17552" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a data-type="((x : A) → P x ≃ Q x) → ((x : A) → P x) ≃ ((x : A) → Q x)" id="17555" href="1Lab.Type.Pi.html#663" class="Function">Π-cod≃</a> <a id="17562" class="Symbol">(λ</a> <a id="17565" href="1Lab.Univalence.SIP.html#17565" class="Bound">s</a> <a id="17567" class="Symbol">→</a> <a id="17569" href="1Lab.Univalence.SIP.html#17471" class="Bound">τ-univ</a> <a id="17576" href="1Lab.Univalence.SIP.html#17494" class="Bound">eqv</a> <a data-type="A ≃ B → B ≃ C → A ≃ C" id="17580" href="1Lab.Equiv.html#21156" class="Function Operator">∙e</a> <a data-type="A ≡ B → A ≃ B" id="17583" href="1Lab.Univalence.html#15494" class="Function">pathToEquiv</a> <a id="17595" class="Symbol">(</a><a data-type="(f : (x : A) → B x) (p : x ≡ y) → PathP (λ i → B (p i)) (f x) (f y)" id="17596" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="17599" class="Symbol">(</a><a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="17600" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="17606" class="Symbol">(λ</a> <a id="17609" href="1Lab.Univalence.SIP.html#17609" class="Bound">i</a> <a id="17611" class="Symbol">→</a> <a id="17613" href="1Lab.Univalence.SIP.html#17459" class="Bound">T</a> <a id="17615" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="17616" href="1Lab.Univalence.html#8827" class="Function">ua</a> <a id="17619" href="1Lab.Univalence.SIP.html#17494" class="Bound">eqv</a> <a id="17623" href="1Lab.Univalence.SIP.html#17609" class="Bound">i</a><a id="17624" class="Symbol">))</a> <a id="17627" class="Symbol">(</a><a id="17628" href="1Lab.Univalence.SIP.html#17483" class="Bound">f</a> <a id="17630" href="1Lab.Univalence.SIP.html#17565" class="Bound">s</a><a id="17631" class="Symbol">)</a> <a data-type="(B → C) → (A → B) → A → C" id="17633" href="1Lab.Type.html#2217" class="Function Operator">∘</a> <a id="17635" href="1Lab.Univalence.SIP.html#17491" class="Bound">g</a><a id="17636" class="Symbol">)</a> <a id="17638" class="Symbol">(</a><a id="17639" href="1Lab.Univalence.SIP.html#17464" class="Bound">α-tr</a> <a id="17644" class="Symbol">_</a> <a id="17646" class="Symbol">_)))</a> <a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="17651" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a id="17655" class="Symbol">((</a><a id="17657" href="1Lab.Univalence.SIP.html#17657" class="Bound">s</a> <a id="17659" class="Symbol">:</a> <a id="17661" href="1Lab.Univalence.SIP.html#17451" class="Bound">S</a> <a id="17663" href="1Lab.Univalence.SIP.html#17479" class="Bound">X</a><a id="17664" class="Symbol">)</a> <a id="17666" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="17668" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="17674" class="Symbol">(λ</a> <a id="17677" href="1Lab.Univalence.SIP.html#17677" class="Bound">i</a> <a id="17679" class="Symbol">→</a> <a id="17681" href="1Lab.Univalence.SIP.html#17459" class="Bound">T</a> <a id="17683" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="17684" href="1Lab.Univalence.html#8827" class="Function">ua</a> <a id="17687" href="1Lab.Univalence.SIP.html#17494" class="Bound">eqv</a> <a id="17691" href="1Lab.Univalence.SIP.html#17677" class="Bound">i</a><a id="17692" class="Symbol">))</a> <a id="17695" class="Symbol">(</a><a id="17696" href="1Lab.Univalence.SIP.html#17483" class="Bound">f</a> <a id="17698" href="1Lab.Univalence.SIP.html#17657" class="Bound">s</a><a id="17699" class="Symbol">)</a> <a id="17701" class="Symbol">_)</a>  <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="17705" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a id="17708" class="Symbol">(</a><a data-type="({x₀ : A i0} {x₁ : A i1} → PathP A x₀ x₁ → PathP B (f x₀) (g x₁)) ≃
((x₀ : A i0) → PathP B (f x₀) (g (coe0→1 A x₀)))" id="17709" href="1Lab.Type.Pi.html#4266" class="Function">heteroHomotopy≃Homotopy</a> <a data-type="A ≃ B → B ≃ A" id="17733" href="1Lab.Equiv.html#21246" class="Function Operator">e⁻¹</a><a id="17736" class="Symbol">)</a> <a data-type="A ≃ B → B ≃ C → A ≃ C" id="17738" href="1Lab.Equiv.html#21156" class="Function Operator">∙e</a> <a data-type="({x₀ : A i0} {x₁ : A i1} (p : PathP A x₀ x₁) →
 PathP (λ i → B i (p i)) (f x₀) (g x₁))
≃ PathP (λ i → (x : A i) → B i x) f g" id="17741" href="1Lab.Type.Pi.html#3070" class="Function">funextDep≃</a> <a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="17752" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a id="17756" class="Symbol">_</a>                                                 <a data-type="(A : Type ℓ) → A ≃ A" id="17806" href="1Lab.Equiv.html#23023" class="Function Operator">≃∎</a>
</pre>
<p>To see why <span class="Agda"><a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" href="1Lab.Univalence.SIP.html#16922" class="Function">functionStr</a></span> is more convenient than <span class="Agda"><a data-type="Structure ℓ₁ S₁ →
Structure ℓ₂ T → Structure (ℓ₁ ⊔ S.ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" href="1Lab.Univalence.SIP.html#8474" class="Function">the previous definition</a></span> - which is why it gets the shorter name - it’s convenient to consider how the <span class="Agda"><a data-type="Structure ℓ (λ X → X)" href="1Lab.Univalence.SIP.html#7039" class="Function">pointed structure</a></span> acts on equivalences: <em>not at all</em>. Recall the definition of ∞-magma equivalence generated by <span class="Agda"><a data-type="Structure ℓ₁ S₁ →
Structure ℓ₂ T → Structure (ℓ₁ ⊔ S.ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" href="1Lab.Univalence.SIP.html#8474" class="Function">Str-functionStr</a></span>:</p>
<pre class="Agda"><a id="18194" class="Keyword">private</a>
  <a id="18204" href="1Lab.Univalence.SIP.html#18204" class="Function">_</a> <a id="18206" class="Symbol">:</a> <a id="18208" class="Symbol">{</a><a id="18209" href="1Lab.Univalence.SIP.html#18209" class="Bound">A</a> <a id="18211" href="1Lab.Univalence.SIP.html#18211" class="Bound">B</a> <a id="18213" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="18215" href="1Lab.Univalence.SIP.html#3316" class="Function">TypeWith</a> <a id="18224" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a><a id="18231" class="Symbol">}</a> <a id="18233" class="Symbol">{</a><a id="18234" href="1Lab.Univalence.SIP.html#18234" class="Bound">f</a> <a id="18236" class="Symbol">:</a> <a id="18238" href="1Lab.Univalence.SIP.html#18209" class="Bound">A</a> <a id="18240" class="Symbol">.</a><a data-type="∑ A B → A" id="18241" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="18245" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="18247" href="1Lab.Univalence.SIP.html#18211" class="Bound">B</a> <a id="18249" class="Symbol">.</a><a data-type="∑ A B → A" id="18250" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="18253" class="Symbol">}</a>
    <a id="18259" class="Symbol">→</a> <a id="18261" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a> <a id="18269" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="18270" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="18277" href="1Lab.Univalence.SIP.html#18209" class="Bound">A</a> <a id="18279" href="1Lab.Univalence.SIP.html#18211" class="Bound">B</a> <a id="18281" href="1Lab.Univalence.SIP.html#18234" class="Bound">f</a>
    <a data-type="A → A → Type ℓ" id="18287" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="18289" class="Symbol">(</a> <a id="18291" class="Symbol">{</a><a id="18292" href="1Lab.Univalence.SIP.html#18292" class="Bound">s</a> <a id="18294" class="Symbol">:</a> <a id="18296" href="1Lab.Univalence.SIP.html#18209" class="Bound">A</a> <a id="18298" class="Symbol">.</a><a data-type="∑ A B → A" id="18299" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="18302" class="Symbol">}</a> <a id="18304" class="Symbol">{</a><a id="18305" href="1Lab.Univalence.SIP.html#18305" class="Bound">t</a> <a id="18307" class="Symbol">:</a> <a id="18309" href="1Lab.Univalence.SIP.html#18211" class="Bound">B</a> <a id="18311" class="Symbol">.</a><a data-type="∑ A B → A" id="18312" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="18315" class="Symbol">}</a> <a id="18317" class="Symbol">→</a> <a id="18319" href="1Lab.Univalence.SIP.html#18234" class="Bound">f</a> <a id="18321" class="Symbol">.</a><a data-type="∑ A B → A" id="18322" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="18326" href="1Lab.Univalence.SIP.html#18292" class="Bound">s</a> <a data-type="A → A → Type ℓ" id="18328" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="18330" href="1Lab.Univalence.SIP.html#18305" class="Bound">t</a>
      <a id="18338" class="Symbol">→</a> <a id="18340" class="Symbol">{</a><a id="18341" href="1Lab.Univalence.SIP.html#18341" class="Bound">x</a> <a id="18343" class="Symbol">:</a> <a id="18345" href="1Lab.Univalence.SIP.html#18209" class="Bound">A</a> <a id="18347" class="Symbol">.</a><a data-type="∑ A B → A" id="18348" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="18351" class="Symbol">}</a> <a id="18353" class="Symbol">{</a><a id="18354" href="1Lab.Univalence.SIP.html#18354" class="Bound">y</a> <a id="18356" class="Symbol">:</a> <a id="18358" href="1Lab.Univalence.SIP.html#18211" class="Bound">B</a> <a id="18360" class="Symbol">.</a><a data-type="∑ A B → A" id="18361" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="18364" class="Symbol">}</a> <a id="18366" class="Symbol">→</a> <a id="18368" href="1Lab.Univalence.SIP.html#18234" class="Bound">f</a> <a id="18370" class="Symbol">.</a><a data-type="∑ A B → A" id="18371" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="18375" href="1Lab.Univalence.SIP.html#18341" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="18377" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="18379" href="1Lab.Univalence.SIP.html#18354" class="Bound">y</a>
      <a id="18387" class="Symbol">→</a> <a id="18389" href="1Lab.Univalence.SIP.html#18234" class="Bound">f</a> <a id="18391" class="Symbol">.</a><a data-type="∑ A B → A" id="18392" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="18396" class="Symbol">(</a><a id="18397" href="1Lab.Univalence.SIP.html#18209" class="Bound">A</a> <a id="18399" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="18400" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="18404" href="1Lab.Univalence.SIP.html#18292" class="Bound">s</a> <a id="18406" href="1Lab.Univalence.SIP.html#18341" class="Bound">x</a><a id="18407" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="18409" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="18411" href="1Lab.Univalence.SIP.html#18211" class="Bound">B</a> <a id="18413" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="18414" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="18418" href="1Lab.Univalence.SIP.html#18305" class="Bound">t</a> <a id="18420" href="1Lab.Univalence.SIP.html#18354" class="Bound">y</a><a id="18421" class="Symbol">)</a>
  <a id="18425" class="Symbol">_</a> <a id="18427" class="Symbol">=</a> <a data-type="x ≡ x" id="18429" href="1Lab.Path.html#2137" class="Function">refl</a>
</pre>
<p>Let’s rewrite <span class="Agda"><a href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a></span> using <span class="Agda"><a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" href="1Lab.Univalence.SIP.html#16922" class="Function">functionStr</a></span> to see how it compares:</p>
<pre class="Agda">  <a id="∞-Magma′"></a><a id="18532" href="1Lab.Univalence.SIP.html#18532" class="Function">∞-Magma′</a> <a id="18541" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="18543" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a data-type="Level" id="18553" href="Agda.Primitive.html#764" class="Primitive">lzero</a> <a id="18559" href="1Lab.Univalence.SIP.html#9532" class="Function">binop</a>
  <a id="18567" href="1Lab.Univalence.SIP.html#18532" class="Function">∞-Magma′</a> <a id="18576" class="Symbol">=</a> <a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" id="18578" href="1Lab.Univalence.SIP.html#16922" class="Function">functionStr</a> <a data-type="A → A" id="18590" href="1Lab.Type.html#2348" class="Function">id</a> <a id="18593" class="Symbol">(</a><a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" id="18594" href="1Lab.Univalence.SIP.html#16922" class="Function">functionStr</a> <a data-type="A → A" id="18606" href="1Lab.Type.html#2348" class="Function">id</a> <a data-type="Structure ℓ (λ X → X)" id="18609" href="1Lab.Univalence.SIP.html#7039" class="Function">pointedStr</a><a id="18619" class="Symbol">)</a>

  <a id="18624" href="1Lab.Univalence.SIP.html#18624" class="Function">_</a> <a id="18626" class="Symbol">:</a> <a id="18628" class="Symbol">{</a><a id="18629" href="1Lab.Univalence.SIP.html#18629" class="Bound">A</a> <a id="18631" href="1Lab.Univalence.SIP.html#18631" class="Bound">B</a> <a id="18633" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="18635" href="1Lab.Univalence.SIP.html#3316" class="Function">TypeWith</a> <a id="18644" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a><a id="18651" class="Symbol">}</a> <a id="18653" class="Symbol">{</a><a id="18654" href="1Lab.Univalence.SIP.html#18654" class="Bound">f</a> <a id="18656" class="Symbol">:</a> <a id="18658" href="1Lab.Univalence.SIP.html#18629" class="Bound">A</a> <a id="18660" class="Symbol">.</a><a data-type="∑ A B → A" id="18661" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="18665" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="18667" href="1Lab.Univalence.SIP.html#18631" class="Bound">B</a> <a id="18669" class="Symbol">.</a><a data-type="∑ A B → A" id="18670" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="18673" class="Symbol">}</a>
    <a id="18679" class="Symbol">→</a> <a id="18681" href="1Lab.Univalence.SIP.html#18532" class="Function">∞-Magma′</a> <a id="18690" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="18691" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="18698" href="1Lab.Univalence.SIP.html#18629" class="Bound">A</a> <a id="18700" href="1Lab.Univalence.SIP.html#18631" class="Bound">B</a> <a id="18702" href="1Lab.Univalence.SIP.html#18654" class="Bound">f</a>
    <a data-type="A → A → Type ℓ" id="18708" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="18710" class="Symbol">(</a> <a id="18712" class="Symbol">(</a><a id="18713" href="1Lab.Univalence.SIP.html#18713" class="Bound">x</a> <a id="18715" href="1Lab.Univalence.SIP.html#18715" class="Bound">y</a> <a id="18717" class="Symbol">:</a> <a id="18719" href="1Lab.Univalence.SIP.html#18629" class="Bound">A</a> <a id="18721" class="Symbol">.</a><a data-type="∑ A B → A" id="18722" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="18725" class="Symbol">)</a> <a id="18727" class="Symbol">→</a> <a id="18729" href="1Lab.Univalence.SIP.html#18654" class="Bound">f</a> <a id="18731" class="Symbol">.</a><a data-type="∑ A B → A" id="18732" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="18736" class="Symbol">(</a><a id="18737" href="1Lab.Univalence.SIP.html#18629" class="Bound">A</a> <a id="18739" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="18740" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="18744" href="1Lab.Univalence.SIP.html#18713" class="Bound">x</a> <a id="18746" href="1Lab.Univalence.SIP.html#18715" class="Bound">y</a><a id="18747" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="18749" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="18751" href="1Lab.Univalence.SIP.html#18631" class="Bound">B</a> <a id="18753" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="18754" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="18758" class="Symbol">(</a><a id="18759" href="1Lab.Univalence.SIP.html#18654" class="Bound">f</a> <a id="18761" class="Symbol">.</a><a data-type="∑ A B → A" id="18762" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="18766" href="1Lab.Univalence.SIP.html#18713" class="Bound">x</a><a id="18767" class="Symbol">)</a> <a id="18769" class="Symbol">(</a><a id="18770" href="1Lab.Univalence.SIP.html#18654" class="Bound">f</a> <a id="18772" class="Symbol">.</a><a data-type="∑ A B → A" id="18773" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="18777" href="1Lab.Univalence.SIP.html#18715" class="Bound">y</a><a id="18778" class="Symbol">))</a>
  <a id="18783" class="Symbol">_</a> <a id="18785" class="Symbol">=</a> <a data-type="x ≡ x" id="18787" href="1Lab.Path.html#2137" class="Function">refl</a>
</pre>
<p>Much better! This gets rid of all those redundant paths that were previously present, using the fact that <code>λ X → X</code> <em>does not need to act on equivalences</em>.</p>
<p>In general, transport structures are closed under all of the same operations as univalent structures, which begs the question: Why mention univalent structures at all? The reason is that a definition of structure homomorphism is very often needed, and the data of a univalent structure is perfect to use in the definition of <span class="Agda"><a data-type="isUnivalent σ → (X ≃[ σ ] Y) ≃ (X ≡ Y)" href="1Lab.Univalence.SIP.html#4629" class="Function">SIP</a></span>.</p>
<details>
<summary>
The closure properties of transport structures are in this <code>&lt;details&gt;</code> tag to keep the length of the page shorter
</summary>
<pre class="Agda"><a id="constantAction"></a><a data-type="(A : Type ℓ) → EqvAction (λ X → A)" id="19447" href="1Lab.Univalence.SIP.html#19447" class="Function">constantAction</a> <a id="19462" class="Symbol">:</a> <a id="19464" class="Symbol">(</a><a id="19465" href="1Lab.Univalence.SIP.html#19465" class="Bound">A</a> <a id="19467" class="Symbol">:</a> <a id="19469" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="19474" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a><a id="19475" class="Symbol">)</a> <a id="19477" class="Symbol">→</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="19479" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="19489" class="Symbol">{</a><a id="19490" class="Argument">ℓ</a> <a id="19492" class="Symbol">=</a> <a id="19494" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a><a id="19496" class="Symbol">}</a> <a id="19498" class="Symbol">(λ</a> <a id="19501" href="1Lab.Univalence.SIP.html#19501" class="Bound">X</a> <a id="19503" class="Symbol">→</a> <a id="19505" href="1Lab.Univalence.SIP.html#19465" class="Bound">A</a><a id="19506" class="Symbol">)</a>
<a data-type="(A : Type ℓ) → EqvAction (λ X → A)" id="19508" href="1Lab.Univalence.SIP.html#19447" class="Function">constantAction</a> <a id="19523" href="1Lab.Univalence.SIP.html#19523" class="Bound">A</a> <a id="19525" href="1Lab.Univalence.SIP.html#19525" class="Bound">eqv</a> <a id="19529" class="Symbol">=</a> <a id="19531" class="Symbol">_</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="19533" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="19535" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a>

<a id="constantAction-isTransp"></a><a data-type="isTransportStr (constantAction A)" id="19544" href="1Lab.Univalence.SIP.html#19544" class="Function">constantAction-isTransp</a> <a id="19568" class="Symbol">:</a> <a id="19570" class="Symbol">{</a><a id="19571" href="1Lab.Univalence.SIP.html#19571" class="Bound">A</a> <a id="19573" class="Symbol">:</a> <a id="19575" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="19580" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a><a id="19581" class="Symbol">}</a> <a id="19583" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="19585" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a> <a id="19600" class="Symbol">{</a><a id="19601" class="Argument">ℓ</a> <a id="19603" class="Symbol">=</a> <a id="19605" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a><a id="19607" class="Symbol">}</a> <a id="19609" class="Symbol">(</a><a data-type="(A : Type ℓ) → EqvAction (λ X → A)" id="19610" href="1Lab.Univalence.SIP.html#19447" class="Function">constantAction</a> <a id="19625" href="1Lab.Univalence.SIP.html#19571" class="Bound">A</a><a id="19626" class="Symbol">)</a>
<a data-type="isTransportStr (constantAction A)" id="19628" href="1Lab.Univalence.SIP.html#19544" class="Function">constantAction-isTransp</a> <a id="19652" href="1Lab.Univalence.SIP.html#19652" class="Bound">f</a> <a id="19654" href="1Lab.Univalence.SIP.html#19654" class="Bound">s</a> <a id="19656" class="Symbol">=</a> <a data-type="x ≡ y → y ≡ x" id="19658" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="19662" class="Symbol">(</a><a data-type="(x : A) → transport (λ i → A) x ≡ x" id="19663" href="1Lab.Path.html#12012" class="Function">transport-refl</a> <a id="19678" class="Symbol">_)</a>

<a id="idAction-isTransp"></a><a data-type="isTransportStr id" id="19682" href="1Lab.Univalence.SIP.html#19682" class="Function">idAction-isTransp</a> <a id="19700" class="Symbol">:</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="19702" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a> <a id="19717" class="Symbol">{</a><a id="19718" class="Argument">ℓ</a> <a id="19720" class="Symbol">=</a> <a id="19722" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a><a id="19723" class="Symbol">}</a> <a id="19725" class="Symbol">{</a><a id="19726" class="Argument">ℓ₁</a> <a id="19729" class="Symbol">=</a> <a id="19731" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a><a id="19732" class="Symbol">}</a> <a data-type="A → A" id="19734" href="1Lab.Type.html#2348" class="Function">id</a>
<a data-type="isTransportStr id" id="19737" href="1Lab.Univalence.SIP.html#19682" class="Function">idAction-isTransp</a> <a id="19755" href="1Lab.Univalence.SIP.html#19755" class="Bound">f</a> <a id="19757" href="1Lab.Univalence.SIP.html#19757" class="Bound">s</a> <a id="19759" class="Symbol">=</a> <a data-type="x ≡ y → y ≡ x" id="19761" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="19765" class="Symbol">(</a><a data-type="(x : A) → transport (λ i → A) x ≡ x" id="19766" href="1Lab.Path.html#12012" class="Function">transport-refl</a> <a id="19781" class="Symbol">_)</a>

<a id="productAction"></a><a data-type="EqvAction S₁ → EqvAction T → EqvAction (λ X → S₁ X × T X)" id="19785" href="1Lab.Univalence.SIP.html#19785" class="Function">productAction</a> <a id="19799" class="Symbol">:</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="19801" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="19811" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="19813" class="Symbol">→</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="19815" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="19825" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a> <a id="19827" class="Symbol">→</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="19829" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="19839" class="Symbol">(λ</a> <a id="19842" href="1Lab.Univalence.SIP.html#19842" class="Bound">X</a> <a id="19844" class="Symbol">→</a> <a id="19846" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="19848" href="1Lab.Univalence.SIP.html#19842" class="Bound">X</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="19850" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="19852" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a> <a id="19854" href="1Lab.Univalence.SIP.html#19842" class="Bound">X</a><a id="19855" class="Symbol">)</a>
<a data-type="EqvAction S₁ → EqvAction T → EqvAction (λ X → S₁ X × T X)" id="19857" href="1Lab.Univalence.SIP.html#19785" class="Function">productAction</a> <a id="19871" href="1Lab.Univalence.SIP.html#19871" class="Bound">actx</a> <a id="19876" href="1Lab.Univalence.SIP.html#19876" class="Bound">acty</a> <a id="19881" href="1Lab.Univalence.SIP.html#19881" class="Bound">eqv</a> <a id="19885" class="Symbol">=</a> <a data-type="(e : A ≃ A&#39;) → ((x : A) → P x ≃ Q (e .fst x)) → Σ P ≃ Σ Q" id="19887" href="1Lab.Type.Sigma.html#2110" class="Function">Σ-ap</a> <a id="19892" class="Symbol">(</a><a id="19893" href="1Lab.Univalence.SIP.html#19871" class="Bound">actx</a> <a id="19898" href="1Lab.Univalence.SIP.html#19881" class="Bound">eqv</a><a id="19901" class="Symbol">)</a> <a id="19903" class="Symbol">λ</a> <a id="19905" href="1Lab.Univalence.SIP.html#19905" class="Bound">x</a> <a id="19907" class="Symbol">→</a> <a id="19909" href="1Lab.Univalence.SIP.html#19876" class="Bound">acty</a> <a id="19914" href="1Lab.Univalence.SIP.html#19881" class="Bound">eqv</a>

<a id="productAction-isTransp"></a><a data-type="isTransportStr α →
isTransportStr β → isTransportStr (productAction α β)" id="19919" href="1Lab.Univalence.SIP.html#19919" class="Function">productAction-isTransp</a> <a id="19942" class="Symbol">:</a> <a id="19944" class="Symbol">{</a><a id="19945" href="1Lab.Univalence.SIP.html#19945" class="Bound">α</a> <a id="19947" class="Symbol">:</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="19949" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="19959" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="19960" class="Symbol">}</a> <a id="19962" class="Symbol">{</a><a id="19963" href="1Lab.Univalence.SIP.html#19963" class="Bound">β</a> <a id="19965" class="Symbol">:</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="19967" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="19977" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a><a id="19978" class="Symbol">}</a>
                       <a id="20003" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="20005" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a> <a id="20020" href="1Lab.Univalence.SIP.html#19945" class="Bound">α</a> <a id="20022" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="20024" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a> <a id="20039" href="1Lab.Univalence.SIP.html#19963" class="Bound">β</a>
                       <a id="20064" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="20066" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a> <a id="20081" class="Symbol">(</a><a data-type="EqvAction S₁ → EqvAction T → EqvAction (λ X → S₁ X × T X)" id="20082" href="1Lab.Univalence.SIP.html#19785" class="Function">productAction</a> <a id="20096" href="1Lab.Univalence.SIP.html#19945" class="Bound">α</a> <a id="20098" href="1Lab.Univalence.SIP.html#19963" class="Bound">β</a><a id="20099" class="Symbol">)</a>
<a data-type="isTransportStr α →
isTransportStr β → isTransportStr (productAction α β)" id="20101" href="1Lab.Univalence.SIP.html#19919" class="Function">productAction-isTransp</a> <a id="20124" href="1Lab.Univalence.SIP.html#20124" class="Bound">α-tr</a> <a id="20129" href="1Lab.Univalence.SIP.html#20129" class="Bound">β-tr</a> <a id="20134" href="1Lab.Univalence.SIP.html#20134" class="Bound">e</a> <a id="20136" href="1Lab.Univalence.SIP.html#20136" class="Bound">s</a> <a id="20138" class="Symbol">=</a> <a data-type="(p : x .fst ≡ y .fst) →
PathP (λ i → B (p i)) (x .snd) (y .snd) → x ≡ y" id="20140" href="1Lab.Path.html#55212" class="Function">Σ-PathP</a> <a id="20148" class="Symbol">(</a><a id="20149" href="1Lab.Univalence.SIP.html#20124" class="Bound">α-tr</a> <a id="20154" href="1Lab.Univalence.SIP.html#20134" class="Bound">e</a> <a id="20156" class="Symbol">(</a><a id="20157" href="1Lab.Univalence.SIP.html#20136" class="Bound">s</a> <a id="20159" class="Symbol">.</a><a data-type="∑ A B → A" id="20160" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="20163" class="Symbol">))</a> <a id="20166" class="Symbol">(</a><a id="20167" href="1Lab.Univalence.SIP.html#20129" class="Bound">β-tr</a> <a id="20172" href="1Lab.Univalence.SIP.html#20134" class="Bound">e</a> <a id="20174" class="Symbol">(</a><a id="20175" href="1Lab.Univalence.SIP.html#20136" class="Bound">s</a> <a id="20177" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="20178" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="20181" class="Symbol">))</a>

<a id="functionAction"></a><a data-type="EqvAction S₁ → EqvAction T → EqvAction (λ X → S₁ X → T X)" id="20185" href="1Lab.Univalence.SIP.html#20185" class="Function">functionAction</a> <a id="20200" class="Symbol">:</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="20202" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="20212" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="20214" class="Symbol">→</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="20216" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="20226" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a> <a id="20228" class="Symbol">→</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="20230" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="20240" class="Symbol">(λ</a> <a id="20243" href="1Lab.Univalence.SIP.html#20243" class="Bound">X</a> <a id="20245" class="Symbol">→</a> <a id="20247" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="20249" href="1Lab.Univalence.SIP.html#20243" class="Bound">X</a> <a id="20251" class="Symbol">→</a> <a id="20253" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a> <a id="20255" href="1Lab.Univalence.SIP.html#20243" class="Bound">X</a><a id="20256" class="Symbol">)</a>
<a data-type="EqvAction S₁ → EqvAction T → EqvAction (λ X → S₁ X → T X)" id="20258" href="1Lab.Univalence.SIP.html#20185" class="Function">functionAction</a> <a id="20273" href="1Lab.Univalence.SIP.html#20273" class="Bound">actx</a> <a id="20278" href="1Lab.Univalence.SIP.html#20278" class="Bound">acty</a> <a id="20283" href="1Lab.Univalence.SIP.html#20283" class="Bound">eqv</a> <a id="20287" class="Symbol">=</a> <a data-type="A ≃ B → C ≃ D → (A → C) ≃ (B → D)" id="20289" href="1Lab.Type.Pi.html#1721" class="Function">function≃</a> <a id="20299" class="Symbol">(</a><a id="20300" href="1Lab.Univalence.SIP.html#20273" class="Bound">actx</a> <a id="20305" href="1Lab.Univalence.SIP.html#20283" class="Bound">eqv</a><a id="20308" class="Symbol">)</a> <a id="20310" class="Symbol">(</a><a id="20311" href="1Lab.Univalence.SIP.html#20278" class="Bound">acty</a> <a id="20316" href="1Lab.Univalence.SIP.html#20283" class="Bound">eqv</a><a id="20319" class="Symbol">)</a>

<a id="functionAction-isTransp"></a><a data-type="isTransportStr α →
isTransportStr β → isTransportStr (functionAction α β)" id="20322" href="1Lab.Univalence.SIP.html#20322" class="Function">functionAction-isTransp</a> <a id="20346" class="Symbol">:</a> <a id="20348" class="Symbol">{</a><a id="20349" href="1Lab.Univalence.SIP.html#20349" class="Bound">α</a> <a id="20351" class="Symbol">:</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="20353" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="20363" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="20364" class="Symbol">}</a> <a id="20366" class="Symbol">{</a><a id="20367" href="1Lab.Univalence.SIP.html#20367" class="Bound">β</a> <a id="20369" class="Symbol">:</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="20371" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="20381" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a><a id="20382" class="Symbol">}</a>
                        <a id="20408" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="20410" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a> <a id="20425" href="1Lab.Univalence.SIP.html#20349" class="Bound">α</a> <a id="20427" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="20429" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a> <a id="20444" href="1Lab.Univalence.SIP.html#20367" class="Bound">β</a>
                        <a id="20470" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="20472" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a> <a id="20487" class="Symbol">(</a><a data-type="EqvAction S₁ → EqvAction T → EqvAction (λ X → S₁ X → T X)" id="20488" href="1Lab.Univalence.SIP.html#20185" class="Function">functionAction</a> <a id="20503" href="1Lab.Univalence.SIP.html#20349" class="Bound">α</a> <a id="20505" href="1Lab.Univalence.SIP.html#20367" class="Bound">β</a><a id="20506" class="Symbol">)</a>
<a data-type="isTransportStr α →
isTransportStr β → isTransportStr (functionAction α β)" id="20508" href="1Lab.Univalence.SIP.html#20322" class="Function">functionAction-isTransp</a> <a id="20532" class="Symbol">{</a><a id="20533" class="Argument">S</a> <a id="20535" class="Symbol">=</a> <a id="20537" href="1Lab.Univalence.SIP.html#20537" class="Bound">S</a><a id="20538" class="Symbol">}</a> <a id="20540" class="Symbol">{</a><a id="20541" class="Argument">α</a> <a id="20543" class="Symbol">=</a> <a id="20545" href="1Lab.Univalence.SIP.html#20545" class="Bound">α</a><a id="20546" class="Symbol">}</a> <a id="20548" class="Symbol">{</a><a id="20549" class="Argument">β</a> <a id="20551" class="Symbol">=</a> <a id="20553" href="1Lab.Univalence.SIP.html#20553" class="Bound">β</a><a id="20554" class="Symbol">}</a> <a id="20556" href="1Lab.Univalence.SIP.html#20556" class="Bound">α-tr</a> <a id="20561" href="1Lab.Univalence.SIP.html#20561" class="Bound">β-tr</a> <a id="20566" href="1Lab.Univalence.SIP.html#20566" class="Bound">eqv</a> <a id="20570" href="1Lab.Univalence.SIP.html#20570" class="Bound">f</a> <a id="20572" class="Symbol">=</a>
  <a data-type="((x : A) → f x ≡ g x) → f ≡ g" id="20576" href="1Lab.Path.html#56413" class="Function">funext</a> <a id="20583" class="Symbol">λ</a> <a id="20585" href="1Lab.Univalence.SIP.html#20585" class="Bound">x</a> <a id="20587" class="Symbol">→</a> <a data-type="(f : (x : A) → B x) (p : x ≡ y) → PathP (λ i → B (p i)) (f x) (f y)" id="20589" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="20592" class="Symbol">(</a><a id="20593" href="1Lab.Univalence.SIP.html#20553" class="Bound">β</a> <a id="20595" href="1Lab.Univalence.SIP.html#20566" class="Bound">eqv</a> <a id="20599" class="Symbol">.</a><a data-type="∑ A B → A" id="20600" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="(B → C) → (A → B) → A → C" id="20604" href="1Lab.Type.html#2217" class="Function Operator">∘</a> <a id="20606" href="1Lab.Univalence.SIP.html#20570" class="Bound">f</a><a id="20607" class="Symbol">)</a> <a id="20609" class="Symbol">(</a><a data-type="(α : EqvAction S₁) →
isTransportStr α →
(e : X ≃ Y) (t : S₁ Y) →
equiv→inverse (α e .snd) t ≡ subst S₁ (sym (ua e)) t" id="20610" href="1Lab.Univalence.SIP.html#15733" class="Function">transportStr⁻¹</a> <a id="20625" href="1Lab.Univalence.SIP.html#20545" class="Bound">α</a> <a id="20627" href="1Lab.Univalence.SIP.html#20556" class="Bound">α-tr</a> <a id="20632" href="1Lab.Univalence.SIP.html#20566" class="Bound">eqv</a> <a id="20636" href="1Lab.Univalence.SIP.html#20585" class="Bound">x</a><a id="20637" class="Symbol">)</a>
             <a data-type="x ≡ y → y ≡ z → x ≡ z" id="20652" href="1Lab.Path.html#38031" class="Function Operator">∙</a> <a id="20654" href="1Lab.Univalence.SIP.html#20561" class="Bound">β-tr</a> <a id="20659" href="1Lab.Univalence.SIP.html#20566" class="Bound">eqv</a> <a id="20663" class="Symbol">(</a><a id="20664" href="1Lab.Univalence.SIP.html#20570" class="Bound">f</a> <a id="20666" class="Symbol">(</a><a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="20667" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="20673" href="1Lab.Univalence.SIP.html#20537" class="Bound">S</a> <a id="20675" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="20676" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="20680" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="20681" href="1Lab.Univalence.html#8827" class="Function">ua</a> <a id="20684" href="1Lab.Univalence.SIP.html#20566" class="Bound">eqv</a><a id="20687" class="Symbol">))</a> <a id="20690" href="1Lab.Univalence.SIP.html#20585" class="Bound">x</a><a id="20691" class="Symbol">))</a>
</pre>
</details>
<h1 id="adding-axioms"><a href="#adding-axioms" class="header-link">Adding Axioms<span class="header-link-emoji">🔗</span></a></h1>
<p>Most mathematical objects of interest aren’t merely sets with structure. More often, the objects we’re interested in have <em>stuff</em> (the underlying type), <em>structure</em> (such as a <code class="sourceCode agda">SNS</code>), and <em>properties</em> - for instance, equations imposed on the structure. A concrete example may help:</p>
<ul>
<li><p>A <strong>pointed <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>

-magma</span></strong> is a pointed type equipped with a binary operation;</p></li>
<li><p>A <strong>monoid</strong> is a pointed <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>

-magma</span> with additional data witnessing that a) the type is a set; b) the operation is associative; and c) the point acts as a left- and right- identity for the operation.</p></li>
</ul>
<p>Fortunately, the SIP again applies here: If you augment a standard notion of structure with <em>axioms</em>, then equality of structures with axioms is still isomorphism of the underlying structures. For this, we require that the axioms be <a data-type="Type ℓ → Type ℓ" href="1Lab.HLevel.html#2594">valued in propositions</a>.</p>
<pre class="Agda"><a id="21604" class="Keyword">module</a> <a id="21611" href="1Lab.Univalence.SIP.html#21611" class="Module">_</a>
  <a id="21615" class="Symbol">(</a><a id="21616" href="1Lab.Univalence.SIP.html#21616" class="Bound">σ</a> <a id="21618" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="21620" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="21630" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="21632" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="21633" class="Symbol">)</a>
  <a id="21637" class="Symbol">(</a><a id="21638" href="1Lab.Univalence.SIP.html#21638" class="Bound">axioms</a> <a id="21645" class="Symbol">:</a> <a id="21647" class="Symbol">(</a><a id="21648" href="1Lab.Univalence.SIP.html#21648" class="Bound">X</a> <a id="21650" class="Symbol">:</a> <a id="21652" class="Symbol">_)</a> <a id="21655" class="Symbol">→</a> <a id="21657" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="21659" href="1Lab.Univalence.SIP.html#21648" class="Bound">X</a> <a id="21661" class="Symbol">→</a> <a id="21663" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="21668" href="1Lab.Univalence.SIP.html#3458" class="Generalizable">ℓ₃</a><a id="21670" class="Symbol">)</a>
  <a id="21674" class="Keyword">where</a>
</pre>
<p>First, the notion of structure that you get is just a lifting of the underlying structure <code>σ</code> to ignore the witnesses for the axioms:</p>
<pre class="Agda">  <a data-type="(σ : Structure ℓ S₁) (axioms : (X : Type S.ℓ) → S₁ X → Type ℓ₃) →
Structure ℓ (λ X → Σ (axioms X))" id="21830" href="1Lab.Univalence.SIP.html#21830" class="Function">axiomsStr</a> <a id="21840" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="21842" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="21852" href="1Lab.Univalence.SIP.html#21630" class="Bound">ℓ</a> <a id="21854" class="Symbol">(λ</a> <a id="21857" href="1Lab.Univalence.SIP.html#21857" class="Bound">X</a> <a id="21859" class="Symbol">→</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="21861" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="21864" href="1Lab.Univalence.SIP.html#21864" class="Bound">s</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="21866" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="21868" href="1Lab.Univalence.SIP.html#21632" class="Bound">S</a> <a id="21870" href="1Lab.Univalence.SIP.html#21857" class="Bound">X</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="21872" href="1Lab.Type.html#1563" class="Function">]</a> <a id="21874" class="Symbol">(</a><a id="21875" href="1Lab.Univalence.SIP.html#21638" class="Bound">axioms</a> <a id="21882" href="1Lab.Univalence.SIP.html#21857" class="Bound">X</a> <a id="21884" href="1Lab.Univalence.SIP.html#21864" class="Bound">s</a><a id="21885" class="Symbol">))</a>
  <a data-type="(σ : Structure ℓ S₁) (axioms : (X : Type S.ℓ) → S₁ X → Type ℓ₃) →
Structure ℓ (λ X → Σ (axioms X))" id="21890" href="1Lab.Univalence.SIP.html#21830" class="Function">axiomsStr</a> <a id="21900" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="21901" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="21908" class="Symbol">(</a><a id="21909" href="1Lab.Univalence.SIP.html#21909" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="21911" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="21913" href="1Lab.Univalence.SIP.html#21913" class="Bound">s</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="21915" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="21917" href="1Lab.Univalence.SIP.html#21917" class="Bound">a</a><a id="21918" class="Symbol">)</a> <a id="21920" class="Symbol">(</a><a id="21921" href="1Lab.Univalence.SIP.html#21921" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="21923" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="21925" href="1Lab.Univalence.SIP.html#21925" class="Bound">t</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="21927" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="21929" href="1Lab.Univalence.SIP.html#21929" class="Bound">b</a><a id="21930" class="Symbol">)</a> <a id="21932" href="1Lab.Univalence.SIP.html#21932" class="Bound">f</a> <a id="21934" class="Symbol">=</a>
    <a id="21940" href="1Lab.Univalence.SIP.html#21616" class="Bound">σ</a> <a id="21942" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="21943" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="21950" class="Symbol">(</a><a id="21951" href="1Lab.Univalence.SIP.html#21909" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="21953" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="21955" href="1Lab.Univalence.SIP.html#21913" class="Bound">s</a><a id="21956" class="Symbol">)</a> <a id="21958" class="Symbol">(</a><a id="21959" href="1Lab.Univalence.SIP.html#21921" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="21961" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="21963" href="1Lab.Univalence.SIP.html#21925" class="Bound">t</a><a id="21964" class="Symbol">)</a> <a id="21966" href="1Lab.Univalence.SIP.html#21932" class="Bound">f</a>
</pre>
<p>Then, if the axioms are propositional, a calculation by equivalence reasoning concludes what we wanted: <span class="Agda"><a data-type="(σ : Structure ℓ S₁) (axioms : (X : Type S.ℓ) → S₁ X → Type ℓ₃) →
Structure ℓ (λ X → Σ (axioms X))" href="1Lab.Univalence.SIP.html#21830" class="Function">axiomsStr</a></span> is univalent.</p>
<pre class="Agda">  <a id="22121" class="Keyword">module</a> <a id="22128" href="1Lab.Univalence.SIP.html#22128" class="Module">_</a>
    <a id="22134" class="Symbol">(</a><a id="22135" href="1Lab.Univalence.SIP.html#22135" class="Bound">univ</a> <a id="22140" class="Symbol">:</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="22142" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="22154" href="1Lab.Univalence.SIP.html#21616" class="Bound">σ</a><a id="22155" class="Symbol">)</a>
    <a id="22161" class="Symbol">(</a><a id="22162" href="1Lab.Univalence.SIP.html#22162" class="Bound">axioms-prop</a> <a id="22174" class="Symbol">:</a> <a id="22176" class="Symbol">∀</a> <a id="22178" class="Symbol">{</a><a id="22179" href="1Lab.Univalence.SIP.html#22179" class="Bound">X</a><a id="22180" class="Symbol">}</a> <a id="22182" class="Symbol">{</a><a id="22183" href="1Lab.Univalence.SIP.html#22183" class="Bound">s</a><a id="22184" class="Symbol">}</a> <a id="22186" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="22188" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="22195" class="Symbol">(</a><a id="22196" href="1Lab.Univalence.SIP.html#21638" class="Bound">axioms</a> <a id="22203" href="1Lab.Univalence.SIP.html#22179" class="Bound">X</a> <a id="22205" href="1Lab.Univalence.SIP.html#22183" class="Bound">s</a><a id="22206" class="Symbol">))</a> <a id="22209" class="Keyword">where</a>
    <a data-type="(σ : Structure ℓ S₁) (axioms : (X : Type S.ℓ) → S₁ X → Type ℓ₃)
(univ : isUnivalent σ) (axioms-prop : isProp (axioms X s)) →
isUnivalent (axiomsStr σ axioms)" id="22219" href="1Lab.Univalence.SIP.html#22219" class="Function">axiomsStr-univalent</a> <a id="22239" class="Symbol">:</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="22241" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a data-type="(σ : Structure ℓ S₁) (axioms : (X : Type S.ℓ) → S₁ X → Type ℓ₃) →
Structure ℓ (λ X → Σ (axioms X))" id="22253" href="1Lab.Univalence.SIP.html#21830" class="Function">axiomsStr</a>
    <a data-type="(σ : Structure ℓ S₁) (axioms : (X : Type S.ℓ) → S₁ X → Type ℓ₃)
(univ : isUnivalent σ) (axioms-prop : isProp (axioms X s)) →
isUnivalent (axiomsStr σ axioms)" id="22267" href="1Lab.Univalence.SIP.html#22219" class="Function">axiomsStr-univalent</a> <a id="22287" class="Symbol">{</a><a id="22288" class="Argument">X</a> <a id="22290" class="Symbol">=</a> <a id="22292" href="1Lab.Univalence.SIP.html#22292" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="22294" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="22296" href="1Lab.Univalence.SIP.html#22296" class="Bound">s</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="22298" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="22300" href="1Lab.Univalence.SIP.html#22300" class="Bound">a</a><a id="22301" class="Symbol">}</a> <a id="22303" class="Symbol">{</a><a id="22304" class="Argument">Y</a> <a id="22306" class="Symbol">=</a> <a id="22308" href="1Lab.Univalence.SIP.html#22308" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="22310" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="22312" href="1Lab.Univalence.SIP.html#22312" class="Bound">t</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="22314" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="22316" href="1Lab.Univalence.SIP.html#22316" class="Bound">b</a><a id="22317" class="Symbol">}</a> <a id="22319" href="1Lab.Univalence.SIP.html#22319" class="Bound">f</a> <a id="22321" class="Symbol">=</a>
      <a id="22329" href="1Lab.Univalence.SIP.html#21616" class="Bound">σ</a> <a id="22331" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="22332" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="22339" class="Symbol">(</a><a id="22340" href="1Lab.Univalence.SIP.html#22292" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="22342" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="22344" href="1Lab.Univalence.SIP.html#22296" class="Bound">s</a><a id="22345" class="Symbol">)</a> <a id="22347" class="Symbol">(</a><a id="22348" href="1Lab.Univalence.SIP.html#22308" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="22350" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="22352" href="1Lab.Univalence.SIP.html#22312" class="Bound">t</a><a id="22353" class="Symbol">)</a> <a id="22355" href="1Lab.Univalence.SIP.html#22319" class="Bound">f</a>
        <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="22365" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a id="22368" href="1Lab.Univalence.SIP.html#22135" class="Bound">univ</a> <a id="22373" href="1Lab.Univalence.SIP.html#22319" class="Bound">f</a> <a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="22375" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
      <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="22383" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="22389" class="Symbol">(λ</a> <a id="22392" href="1Lab.Univalence.SIP.html#22392" class="Bound">i</a> <a id="22394" class="Symbol">→</a> <a id="22396" href="1Lab.Univalence.SIP.html#21632" class="Bound">S</a> <a id="22398" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="22399" href="1Lab.Univalence.html#8827" class="Function">ua</a> <a id="22402" href="1Lab.Univalence.SIP.html#22319" class="Bound">f</a> <a id="22404" href="1Lab.Univalence.SIP.html#22392" class="Bound">i</a><a id="22405" class="Symbol">))</a> <a id="22408" href="1Lab.Univalence.SIP.html#22296" class="Bound">s</a> <a id="22410" href="1Lab.Univalence.SIP.html#22312" class="Bound">t</a> 
        <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="22421" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a data-type="((x : A) → isContr (B x)) → Σ B ≃ A" id="22424" href="1Lab.Type.Sigma.html#7441" class="Function">Σ-contract</a> <a id="22435" class="Symbol">(λ</a> <a id="22438" href="1Lab.Univalence.SIP.html#22438" class="Bound">x</a> <a id="22440" class="Symbol">→</a> <a data-type="(n : Nat) → isHLevel (A i1) n → isHLevel (PathP A x y) n" id="22442" href="1Lab.HLevel.html#10007" class="Function">isHLevelPathP</a> <a id="22456" class="Number">0</a> <a id="22458" class="Symbol">(</a><a data-type="(centre₁ : A) (paths₁ : (x : A) → centre₁ ≡ x) → isContr A" id="22459" href="1Lab.HLevel.html#1382" class="InductiveConstructor">contr</a> <a id="22465" href="1Lab.Univalence.SIP.html#22316" class="Bound">b</a> <a id="22467" class="Symbol">(</a><a id="22468" href="1Lab.Univalence.SIP.html#22162" class="Bound">axioms-prop</a> <a id="22480" href="1Lab.Univalence.SIP.html#22316" class="Bound">b</a><a id="22481" class="Symbol">)))</a> <a data-type="A ≃ B → B ≃ A" id="22485" href="1Lab.Equiv.html#21246" class="Function Operator">e⁻¹</a> <a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="22489" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
      <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="22497" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="22500" href="1Lab.Univalence.SIP.html#22500" class="Bound">p</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="22502" href="1Lab.Type.html#1563" class="Function">∈</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="22504" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="22510" class="Symbol">(λ</a> <a id="22513" href="1Lab.Univalence.SIP.html#22513" class="Bound">i</a> <a id="22515" class="Symbol">→</a> <a id="22517" href="1Lab.Univalence.SIP.html#21632" class="Bound">S</a> <a id="22519" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="22520" href="1Lab.Univalence.html#8827" class="Function">ua</a> <a id="22523" href="1Lab.Univalence.SIP.html#22319" class="Bound">f</a> <a id="22525" href="1Lab.Univalence.SIP.html#22513" class="Bound">i</a><a id="22526" class="Symbol">))</a> <a id="22529" href="1Lab.Univalence.SIP.html#22296" class="Bound">s</a> <a id="22531" href="1Lab.Univalence.SIP.html#22312" class="Bound">t</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="22533" href="1Lab.Type.html#1563" class="Function">]</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="22535" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="22541" class="Symbol">(λ</a> <a id="22544" href="1Lab.Univalence.SIP.html#22544" class="Bound">i</a> <a id="22546" class="Symbol">→</a> <a id="22548" href="1Lab.Univalence.SIP.html#21638" class="Bound">axioms</a> <a id="22555" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="22556" href="1Lab.Univalence.html#8827" class="Function">ua</a> <a id="22559" href="1Lab.Univalence.SIP.html#22319" class="Bound">f</a> <a id="22561" href="1Lab.Univalence.SIP.html#22544" class="Bound">i</a><a id="22562" class="Symbol">)</a> <a id="22564" class="Symbol">(</a><a id="22565" href="1Lab.Univalence.SIP.html#22500" class="Bound">p</a> <a id="22567" href="1Lab.Univalence.SIP.html#22544" class="Bound">i</a><a id="22568" class="Symbol">))</a> <a id="22571" href="1Lab.Univalence.SIP.html#22300" class="Bound">a</a> <a id="22573" href="1Lab.Univalence.SIP.html#22316" class="Bound">b</a>
        <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="22583" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a data-type="Iso A B → A ≃ B" id="22586" href="1Lab.Equiv.html#20090" class="Function">Iso→Equiv</a> <a data-type="Iso (Σ (λ p → PathP (λ i → B i (p i)) (x .snd) (y .snd)))
(PathP (λ i → Σ (B i)) x y)" id="22596" href="1Lab.Type.Sigma.html#553" class="Function">Σ-PathP-iso</a> <a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="22608" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
      <a id="22616" class="Symbol">_</a>
        <a data-type="(A : Type ℓ) → A ≃ A" id="22626" href="1Lab.Equiv.html#23023" class="Function Operator">≃∎</a>
</pre>
<p>Here, another facet of the trade-offs between transport and univalent structures make themselves clear: It’s possible (albeit less than straightforward) to add axioms to a <em>univalent</em> structure, but without imposing further structure on the axioms themselves, it is not clear how to add axioms to a <em>transport</em> structure.</p>
<p>Regardless, a very useful consequence of the SIP is that axioms can be lifted from equivalent underlying structures. For instance: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span>

 can be defined as both unary numbers (the construction of <code class="sourceCode agda">Nat</code>), or as binary numbers. If you prove that <code class="sourceCode agda">Nat</code> is a monoid, and <code>Nat ≃ Bin</code> as pointed ∞-magmas, then <code>Bin</code> inherits the monoid structure.</p>
<pre class="Agda"><a id="transferAxioms"></a><a data-type="(A : TypeWith (axiomsStr σ axioms)) (B : TypeWith σ) →
(A .fst , A .snd .fst) ≃[ σ ] B → axioms (B .fst) (B .snd)" id="23328" href="1Lab.Univalence.SIP.html#23328" class="Function">transferAxioms</a> 
  <a id="23346" class="Symbol">:</a> <a id="23348" class="Symbol">{</a><a id="23349" href="1Lab.Univalence.SIP.html#23349" class="Bound">σ</a> <a id="23351" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="23353" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="23363" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="23365" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="23366" class="Symbol">}</a> <a id="23368" class="Symbol">{</a><a id="23369" href="1Lab.Univalence.SIP.html#23369" class="Bound">univ</a> <a id="23374" class="Symbol">:</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="23376" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="23388" href="1Lab.Univalence.SIP.html#23349" class="Bound">σ</a><a id="23389" class="Symbol">}</a>
    <a id="23395" class="Symbol">{</a><a id="23396" href="1Lab.Univalence.SIP.html#23396" class="Bound">axioms</a> <a id="23403" class="Symbol">:</a> <a id="23405" class="Symbol">(</a><a id="23406" href="1Lab.Univalence.SIP.html#23406" class="Bound">X</a> <a id="23408" class="Symbol">:</a> <a id="23410" class="Symbol">_)</a> <a id="23413" class="Symbol">→</a> <a id="23415" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="23417" href="1Lab.Univalence.SIP.html#23406" class="Bound">X</a> <a id="23419" class="Symbol">→</a> <a id="23421" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="23426" href="1Lab.Univalence.SIP.html#3458" class="Generalizable">ℓ₃</a><a id="23428" class="Symbol">}</a>
  <a id="23432" class="Symbol">→</a> <a id="23434" class="Symbol">(</a><a id="23435" href="1Lab.Univalence.SIP.html#23435" class="Bound">A</a> <a id="23437" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="23439" href="1Lab.Univalence.SIP.html#3316" class="Function">TypeWith</a> <a id="23448" class="Symbol">(</a><a data-type="(σ : Structure ℓ S₁) (axioms : (X : Type S.ℓ) → S₁ X → Type ℓ₃) →
Structure ℓ (λ X → Σ (axioms X))" id="23449" href="1Lab.Univalence.SIP.html#21830" class="Function">axiomsStr</a> <a id="23459" href="1Lab.Univalence.SIP.html#23349" class="Bound">σ</a> <a id="23461" href="1Lab.Univalence.SIP.html#23396" class="Bound">axioms</a><a id="23467" class="Symbol">))</a> <a id="23470" class="Symbol">(</a><a id="23471" href="1Lab.Univalence.SIP.html#23471" class="Bound">B</a> <a id="23473" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="23475" href="1Lab.Univalence.SIP.html#3316" class="Function">TypeWith</a> <a id="23484" href="1Lab.Univalence.SIP.html#23349" class="Bound">σ</a><a id="23485" class="Symbol">)</a>
  <a id="23489" class="Symbol">→</a> <a id="23491" class="Symbol">(</a><a id="23492" href="1Lab.Univalence.SIP.html#23435" class="Bound">A</a> <a id="23494" class="Symbol">.</a><a data-type="∑ A B → A" id="23495" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="23499" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23501" href="1Lab.Univalence.SIP.html#23435" class="Bound">A</a> <a id="23503" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="23504" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="23508" class="Symbol">.</a><a data-type="∑ A B → A" id="23509" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="23512" class="Symbol">)</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="23514" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">≃[</a> <a id="23517" href="1Lab.Univalence.SIP.html#23349" class="Bound">σ</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="23519" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">]</a> <a id="23521" href="1Lab.Univalence.SIP.html#23471" class="Bound">B</a>
  <a id="23525" class="Symbol">→</a> <a id="23527" href="1Lab.Univalence.SIP.html#23396" class="Bound">axioms</a> <a id="23534" class="Symbol">(</a><a id="23535" href="1Lab.Univalence.SIP.html#23471" class="Bound">B</a> <a id="23537" class="Symbol">.</a><a data-type="∑ A B → A" id="23538" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="23541" class="Symbol">)</a> <a id="23543" class="Symbol">(</a><a id="23544" href="1Lab.Univalence.SIP.html#23471" class="Bound">B</a> <a id="23546" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="23547" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="23550" class="Symbol">)</a>
<a data-type="(A : TypeWith (axiomsStr σ axioms)) (B : TypeWith σ) →
(A .fst , A .snd .fst) ≃[ σ ] B → axioms (B .fst) (B .snd)" id="23552" href="1Lab.Univalence.SIP.html#23328" class="Function">transferAxioms</a> <a id="23567" class="Symbol">{</a><a id="23568" class="Argument">univ</a> <a id="23573" class="Symbol">=</a> <a id="23575" href="1Lab.Univalence.SIP.html#23575" class="Bound">univ</a><a id="23579" class="Symbol">}</a> <a id="23581" class="Symbol">{</a><a id="23582" class="Argument">axioms</a> <a id="23589" class="Symbol">=</a> <a id="23591" href="1Lab.Univalence.SIP.html#23591" class="Bound">axioms</a><a id="23597" class="Symbol">}</a> <a id="23599" href="1Lab.Univalence.SIP.html#23599" class="Bound">A</a> <a id="23601" href="1Lab.Univalence.SIP.html#23601" class="Bound">B</a> <a id="23603" href="1Lab.Univalence.SIP.html#23603" class="Bound">eqv</a> <a id="23607" class="Symbol">=</a>
  <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="23611" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="23617" class="Symbol">(λ</a> <a id="23620" class="Symbol">{</a> <a id="23622" class="Symbol">(</a><a id="23623" href="1Lab.Univalence.SIP.html#23623" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="23625" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23627" href="1Lab.Univalence.SIP.html#23627" class="Bound">y</a><a id="23628" class="Symbol">)</a> <a id="23630" class="Symbol">→</a> <a id="23632" href="1Lab.Univalence.SIP.html#23591" class="Bound">axioms</a> <a id="23639" href="1Lab.Univalence.SIP.html#23623" class="Bound">x</a> <a id="23641" href="1Lab.Univalence.SIP.html#23627" class="Bound">y</a> <a id="23643" class="Symbol">})</a> <a id="23646" class="Symbol">(</a><a data-type="isUnivalent σ → X ≃[ σ ] Y → X ≡ Y" id="23647" href="1Lab.Univalence.SIP.html#5488" class="Function">sip</a> <a id="23651" href="1Lab.Univalence.SIP.html#23575" class="Bound">univ</a> <a id="23656" href="1Lab.Univalence.SIP.html#23603" class="Bound">eqv</a><a id="23659" class="Symbol">)</a> <a id="23661" class="Symbol">(</a><a id="23662" href="1Lab.Univalence.SIP.html#23599" class="Bound">A</a> <a id="23664" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="23665" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="23669" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="23670" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="23673" class="Symbol">)</a>
</pre>
<h1 id="a-language-for-structures"><a href="#a-language-for-structures" class="header-link">A Language for Structures<span class="header-link-emoji">🔗</span></a></h1>
<p>The structure combinators can be abstracted away into a <em>language</em> for defining structures. A <span class="Agda"><a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" href="1Lab.Univalence.SIP.html#23978" class="Datatype">StrTm</a></span> describes a structure, that may be <code class="sourceCode agda" data-ident="interp">interpreted</code> into a family of types, and defines both transport and univalent structures.</p>
<pre class="Agda"><a id="23973" class="Keyword">data</a> <a id="StrTm"></a><a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="23978" href="1Lab.Univalence.SIP.html#23978" class="Datatype">StrTm</a> <a id="23984" href="1Lab.Univalence.SIP.html#23984" class="Bound">ℓ</a> <a id="23986" class="Symbol">:</a> <a id="23988" class="Symbol">(</a><a id="23989" href="1Lab.Univalence.SIP.html#23989" class="Bound">ℓ₁</a> <a id="23992" class="Symbol">:</a> <a data-type="Type" id="23994" href="Agda.Primitive.html#597" class="Postulate">Level</a><a id="23999" class="Symbol">)</a> <a id="24001" class="Symbol">→</a> <a id="24003" class="Symbol">(</a><a id="24004" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="24009" href="1Lab.Univalence.SIP.html#23984" class="Bound">ℓ</a> <a id="24011" class="Symbol">→</a> <a id="24013" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="24018" href="1Lab.Univalence.SIP.html#23989" class="Bound">ℓ₁</a><a id="24020" class="Symbol">)</a> <a id="24022" class="Symbol">→</a> <a id="24024" href="1Lab.Type.html#409" class="Primitive">Typeω</a> <a id="24030" class="Keyword">where</a>
  <a id="StrTm.s-const"></a><a data-type="(A : Type ℓ₁) → StrTm ℓ ℓ₁ (λ X → A)" id="24038" href="1Lab.Univalence.SIP.html#24038" class="InductiveConstructor">s-const</a> <a id="24046" class="Symbol">:</a> <a id="24048" class="Symbol">∀</a> <a id="24050" class="Symbol">{</a><a id="24051" href="1Lab.Univalence.SIP.html#24051" class="Bound">ℓ₁</a><a id="24053" class="Symbol">}</a> <a id="24055" class="Symbol">(</a><a id="24056" href="1Lab.Univalence.SIP.html#24056" class="Bound">A</a> <a id="24058" class="Symbol">:</a> <a id="24060" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="24065" href="1Lab.Univalence.SIP.html#24051" class="Bound">ℓ₁</a><a id="24067" class="Symbol">)</a> <a id="24069" class="Symbol">→</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="24071" href="1Lab.Univalence.SIP.html#23978" class="Datatype">StrTm</a> <a id="24077" href="1Lab.Univalence.SIP.html#23984" class="Bound">ℓ</a> <a id="24079" href="1Lab.Univalence.SIP.html#24051" class="Bound">ℓ₁</a> <a id="24082" class="Symbol">(λ</a> <a id="24085" href="1Lab.Univalence.SIP.html#24085" class="Bound">X</a> <a id="24087" class="Symbol">→</a> <a id="24089" href="1Lab.Univalence.SIP.html#24056" class="Bound">A</a><a id="24090" class="Symbol">)</a>
  <a id="StrTm.s∙"></a><a data-type="StrTm ℓ ℓ (λ X → X)" id="24094" href="1Lab.Univalence.SIP.html#24094" class="InductiveConstructor">s∙</a>      <a id="24102" class="Symbol">:</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="24104" href="1Lab.Univalence.SIP.html#23978" class="Datatype">StrTm</a> <a id="24110" href="1Lab.Univalence.SIP.html#23984" class="Bound">ℓ</a> <a id="24112" href="1Lab.Univalence.SIP.html#23984" class="Bound">ℓ</a> <a id="24114" class="Symbol">(λ</a> <a id="24117" href="1Lab.Univalence.SIP.html#24117" class="Bound">X</a> <a id="24119" class="Symbol">→</a> <a id="24121" href="1Lab.Univalence.SIP.html#24117" class="Bound">X</a><a id="24122" class="Symbol">)</a>
  <a id="StrTm._s→_"></a><a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="24126" href="1Lab.Univalence.SIP.html#24126" class="InductiveConstructor Operator">_s→_</a>    <a id="24134" class="Symbol">:</a> <a id="24136" class="Symbol">∀</a> <a id="24138" class="Symbol">{</a><a id="24139" href="1Lab.Univalence.SIP.html#24139" class="Bound">ℓ₁</a> <a id="24142" href="1Lab.Univalence.SIP.html#24142" class="Bound">ℓ₂</a><a id="24144" class="Symbol">}</a> <a id="24146" class="Symbol">{</a><a id="24147" href="1Lab.Univalence.SIP.html#24147" class="Bound">S</a><a id="24148" class="Symbol">}</a> <a id="24150" class="Symbol">{</a><a id="24151" href="1Lab.Univalence.SIP.html#24151" class="Bound">T</a><a id="24152" class="Symbol">}</a> <a id="24154" class="Symbol">→</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="24156" href="1Lab.Univalence.SIP.html#23978" class="Datatype">StrTm</a> <a id="24162" href="1Lab.Univalence.SIP.html#23984" class="Bound">ℓ</a> <a id="24164" href="1Lab.Univalence.SIP.html#24139" class="Bound">ℓ₁</a> <a id="24167" href="1Lab.Univalence.SIP.html#24147" class="Bound">S</a> <a id="24169" class="Symbol">→</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="24171" href="1Lab.Univalence.SIP.html#23978" class="Datatype">StrTm</a> <a id="24177" href="1Lab.Univalence.SIP.html#23984" class="Bound">ℓ</a> <a id="24179" href="1Lab.Univalence.SIP.html#24142" class="Bound">ℓ₂</a> <a id="24182" href="1Lab.Univalence.SIP.html#24151" class="Bound">T</a> <a id="24184" class="Symbol">→</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="24186" href="1Lab.Univalence.SIP.html#23978" class="Datatype">StrTm</a> <a id="24192" href="1Lab.Univalence.SIP.html#23984" class="Bound">ℓ</a> <a id="24194" class="Symbol">(</a><a id="24195" href="1Lab.Univalence.SIP.html#24139" class="Bound">ℓ₁</a> <a data-type="Level → Level → Level" id="24198" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="24200" href="1Lab.Univalence.SIP.html#24142" class="Bound">ℓ₂</a><a id="24202" class="Symbol">)</a> <a id="24204" class="Symbol">(λ</a> <a id="24207" href="1Lab.Univalence.SIP.html#24207" class="Bound">X</a> <a id="24209" class="Symbol">→</a> <a id="24211" href="1Lab.Univalence.SIP.html#24147" class="Bound">S</a> <a id="24213" href="1Lab.Univalence.SIP.html#24207" class="Bound">X</a> <a id="24215" class="Symbol">→</a> <a id="24217" href="1Lab.Univalence.SIP.html#24151" class="Bound">T</a> <a id="24219" href="1Lab.Univalence.SIP.html#24207" class="Bound">X</a><a id="24220" class="Symbol">)</a>
  <a id="StrTm._s×_"></a><a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="24224" href="1Lab.Univalence.SIP.html#24224" class="InductiveConstructor Operator">_s×_</a>    <a id="24232" class="Symbol">:</a> <a id="24234" class="Symbol">∀</a> <a id="24236" class="Symbol">{</a><a id="24237" href="1Lab.Univalence.SIP.html#24237" class="Bound">ℓ₁</a> <a id="24240" href="1Lab.Univalence.SIP.html#24240" class="Bound">ℓ₂</a><a id="24242" class="Symbol">}</a> <a id="24244" class="Symbol">{</a><a id="24245" href="1Lab.Univalence.SIP.html#24245" class="Bound">S</a><a id="24246" class="Symbol">}</a> <a id="24248" class="Symbol">{</a><a id="24249" href="1Lab.Univalence.SIP.html#24249" class="Bound">T</a><a id="24250" class="Symbol">}</a> <a id="24252" class="Symbol">→</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="24254" href="1Lab.Univalence.SIP.html#23978" class="Datatype">StrTm</a> <a id="24260" href="1Lab.Univalence.SIP.html#23984" class="Bound">ℓ</a> <a id="24262" href="1Lab.Univalence.SIP.html#24237" class="Bound">ℓ₁</a> <a id="24265" href="1Lab.Univalence.SIP.html#24245" class="Bound">S</a> <a id="24267" class="Symbol">→</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="24269" href="1Lab.Univalence.SIP.html#23978" class="Datatype">StrTm</a> <a id="24275" href="1Lab.Univalence.SIP.html#23984" class="Bound">ℓ</a> <a id="24277" href="1Lab.Univalence.SIP.html#24240" class="Bound">ℓ₂</a> <a id="24280" href="1Lab.Univalence.SIP.html#24249" class="Bound">T</a> <a id="24282" class="Symbol">→</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="24284" href="1Lab.Univalence.SIP.html#23978" class="Datatype">StrTm</a> <a id="24290" href="1Lab.Univalence.SIP.html#23984" class="Bound">ℓ</a> <a id="24292" class="Symbol">(</a><a id="24293" href="1Lab.Univalence.SIP.html#24237" class="Bound">ℓ₁</a> <a data-type="Level → Level → Level" id="24296" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="24298" href="1Lab.Univalence.SIP.html#24240" class="Bound">ℓ₂</a><a id="24300" class="Symbol">)</a> <a id="24302" class="Symbol">(λ</a> <a id="24305" href="1Lab.Univalence.SIP.html#24305" class="Bound">X</a> <a id="24307" class="Symbol">→</a> <a id="24309" href="1Lab.Univalence.SIP.html#24245" class="Bound">S</a> <a id="24311" href="1Lab.Univalence.SIP.html#24305" class="Bound">X</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="24313" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="24315" href="1Lab.Univalence.SIP.html#24249" class="Bound">T</a> <a id="24317" href="1Lab.Univalence.SIP.html#24305" class="Bound">X</a><a id="24318" class="Symbol">)</a>

<a id="24321" class="Keyword">infixr</a> <a id="24328" class="Number">30</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="24331" href="1Lab.Univalence.SIP.html#24126" class="InductiveConstructor Operator">_s→_</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="24336" href="1Lab.Univalence.SIP.html#24224" class="InductiveConstructor Operator">_s×_</a>
</pre>
<p>Since each term of the language corresponds to one of the combinators for building univalent structures, a pair of <em>mutually recursive</em> functions lets us derive a <span class="Agda"><a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a></span> and an <span class="Agda"><a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" href="1Lab.Univalence.SIP.html#13541" class="Function">action on equivalences</a></span> from a term, at the same time.</p>
<pre class="Agda"><a id="tm→Structure"></a><a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="24623" href="1Lab.Univalence.SIP.html#24623" class="Function">tm→Structure</a> <a id="24636" class="Symbol">:</a> <a id="24638" class="Symbol">(</a><a id="24639" href="1Lab.Univalence.SIP.html#24639" class="Bound">s</a> <a id="24641" class="Symbol">:</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="24643" href="1Lab.Univalence.SIP.html#23978" class="Datatype">StrTm</a> <a id="24649" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="24651" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a> <a id="24654" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="24655" class="Symbol">)</a> <a id="24657" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="24659" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="24669" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a> <a id="24672" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a>
<a id="tm→Action"></a><a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="24674" href="1Lab.Univalence.SIP.html#24674" class="Function">tm→Action</a> <a id="24684" class="Symbol">:</a> <a id="24686" class="Symbol">(</a><a id="24687" href="1Lab.Univalence.SIP.html#24687" class="Bound">s</a> <a id="24689" class="Symbol">:</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="24691" href="1Lab.Univalence.SIP.html#23978" class="Datatype">StrTm</a> <a id="24697" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="24699" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a> <a id="24702" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="24703" class="Symbol">)</a> <a id="24705" class="Symbol">→</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="24707" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="24717" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a>

<a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="24720" href="1Lab.Univalence.SIP.html#24623" class="Function">tm→Structure</a> <a id="24733" class="Symbol">(</a><a data-type="(A : Type ℓ₁) → StrTm ℓ ℓ₁ (λ X → A)" id="24734" href="1Lab.Univalence.SIP.html#24038" class="InductiveConstructor">s-const</a> <a id="24742" href="1Lab.Univalence.SIP.html#24742" class="Bound">x</a><a id="24743" class="Symbol">)</a> <a id="24745" class="Symbol">=</a> <a data-type="(A : Type ℓ) → Structure ℓ (λ X → A)" id="24747" href="1Lab.Univalence.SIP.html#6188" class="Function">constantStr</a> <a id="24759" href="1Lab.Univalence.SIP.html#24742" class="Bound">x</a>
<a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="24761" href="1Lab.Univalence.SIP.html#24623" class="Function">tm→Structure</a> <a data-type="StrTm ℓ ℓ (λ X → X)" id="24774" href="1Lab.Univalence.SIP.html#24094" class="InductiveConstructor">s∙</a> <a id="24777" class="Symbol">=</a> <a data-type="Structure ℓ (λ X → X)" id="24779" href="1Lab.Univalence.SIP.html#7039" class="Function">pointedStr</a>
<a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="24790" href="1Lab.Univalence.SIP.html#24623" class="Function">tm→Structure</a> <a id="24803" class="Symbol">(</a><a id="24804" href="1Lab.Univalence.SIP.html#24804" class="Bound">s</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="24806" href="1Lab.Univalence.SIP.html#24126" class="InductiveConstructor Operator">s→</a> <a id="24809" href="1Lab.Univalence.SIP.html#24809" class="Bound">s₁</a><a id="24811" class="Symbol">)</a> <a id="24813" class="Symbol">=</a> <a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" id="24815" href="1Lab.Univalence.SIP.html#16922" class="Function">functionStr</a> <a id="24827" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="24828" href="1Lab.Univalence.SIP.html#24674" class="Function">tm→Action</a> <a id="24838" href="1Lab.Univalence.SIP.html#24804" class="Bound">s</a><a id="24839" class="Symbol">)</a> <a id="24841" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="24842" href="1Lab.Univalence.SIP.html#24623" class="Function">tm→Structure</a> <a id="24855" href="1Lab.Univalence.SIP.html#24809" class="Bound">s₁</a><a id="24857" class="Symbol">)</a>
<a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="24859" href="1Lab.Univalence.SIP.html#24623" class="Function">tm→Structure</a> <a id="24872" class="Symbol">(</a><a id="24873" href="1Lab.Univalence.SIP.html#24873" class="Bound">s</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="24875" href="1Lab.Univalence.SIP.html#24224" class="InductiveConstructor Operator">s×</a> <a id="24878" href="1Lab.Univalence.SIP.html#24878" class="Bound">s₁</a><a id="24880" class="Symbol">)</a> <a id="24882" class="Symbol">=</a> <a data-type="Structure ℓ S₁ →
Structure ℓ₂ T → Structure (ℓ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="24884" href="1Lab.Univalence.SIP.html#7539" class="Function">productStr</a> <a id="24895" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="24896" href="1Lab.Univalence.SIP.html#24623" class="Function">tm→Structure</a> <a id="24909" href="1Lab.Univalence.SIP.html#24873" class="Bound">s</a><a id="24910" class="Symbol">)</a> <a id="24912" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="24913" href="1Lab.Univalence.SIP.html#24623" class="Function">tm→Structure</a> <a id="24926" href="1Lab.Univalence.SIP.html#24878" class="Bound">s₁</a><a id="24928" class="Symbol">)</a>

<a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="24931" href="1Lab.Univalence.SIP.html#24674" class="Function">tm→Action</a> <a id="24941" class="Symbol">(</a><a data-type="(A : Type ℓ₁) → StrTm ℓ ℓ₁ (λ X → A)" id="24942" href="1Lab.Univalence.SIP.html#24038" class="InductiveConstructor">s-const</a> <a id="24950" href="1Lab.Univalence.SIP.html#24950" class="Bound">x₁</a><a id="24952" class="Symbol">)</a> <a id="24954" href="1Lab.Univalence.SIP.html#24954" class="Bound">x</a> <a id="24956" class="Symbol">=</a> <a id="24958" class="Symbol">_</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="24960" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="24962" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a>
<a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="24970" href="1Lab.Univalence.SIP.html#24674" class="Function">tm→Action</a> <a data-type="StrTm ℓ ℓ (λ X → X)" id="24980" href="1Lab.Univalence.SIP.html#24094" class="InductiveConstructor">s∙</a> <a id="24983" href="1Lab.Univalence.SIP.html#24983" class="Bound">x</a> <a id="24985" class="Symbol">=</a> <a id="24987" href="1Lab.Univalence.SIP.html#24983" class="Bound">x</a>
<a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="24989" href="1Lab.Univalence.SIP.html#24674" class="Function">tm→Action</a> <a id="24999" class="Symbol">(</a><a id="25000" href="1Lab.Univalence.SIP.html#25000" class="Bound">s</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="25002" href="1Lab.Univalence.SIP.html#24126" class="InductiveConstructor Operator">s→</a> <a id="25005" href="1Lab.Univalence.SIP.html#25005" class="Bound">s₁</a><a id="25007" class="Symbol">)</a> <a id="25009" class="Symbol">=</a> <a data-type="EqvAction S₁ → EqvAction T → EqvAction (λ X → S₁ X → T X)" id="25011" href="1Lab.Univalence.SIP.html#20185" class="Function">functionAction</a> <a id="25026" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="25027" href="1Lab.Univalence.SIP.html#24674" class="Function">tm→Action</a> <a id="25037" href="1Lab.Univalence.SIP.html#25000" class="Bound">s</a><a id="25038" class="Symbol">)</a> <a id="25040" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="25041" href="1Lab.Univalence.SIP.html#24674" class="Function">tm→Action</a> <a id="25051" href="1Lab.Univalence.SIP.html#25005" class="Bound">s₁</a><a id="25053" class="Symbol">)</a>
<a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="25055" href="1Lab.Univalence.SIP.html#24674" class="Function">tm→Action</a> <a id="25065" class="Symbol">(</a><a id="25066" href="1Lab.Univalence.SIP.html#25066" class="Bound">s</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="25068" href="1Lab.Univalence.SIP.html#24224" class="InductiveConstructor Operator">s×</a> <a id="25071" href="1Lab.Univalence.SIP.html#25071" class="Bound">s₁</a><a id="25073" class="Symbol">)</a> <a id="25075" class="Symbol">=</a> <a data-type="EqvAction S₁ → EqvAction T → EqvAction (λ X → S₁ X × T X)" id="25077" href="1Lab.Univalence.SIP.html#19785" class="Function">productAction</a> <a id="25091" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="25092" href="1Lab.Univalence.SIP.html#24674" class="Function">tm→Action</a> <a id="25102" href="1Lab.Univalence.SIP.html#25066" class="Bound">s</a><a id="25103" class="Symbol">)</a> <a id="25105" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="25106" href="1Lab.Univalence.SIP.html#24674" class="Function">tm→Action</a> <a id="25116" href="1Lab.Univalence.SIP.html#25071" class="Bound">s₁</a><a id="25118" class="Symbol">)</a>
</pre>
<p>The reason for this mutual recursion is the same reason that transport structures are considered in the first place: <span class="Agda"><a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" href="1Lab.Univalence.SIP.html#16922" class="Function">functionStr</a></span> gives much better results for the definition of homomorphism than can be gotten directly using <span class="Agda"><a data-type="Structure ℓ₁ S₁ →
Structure ℓ₂ T → Structure (ℓ₁ ⊔ S.ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" href="1Lab.Univalence.SIP.html#8474" class="Function">Str-functionStr</a></span>. As an example of using the language, and the generated definition of homomorphism, consider pointed ∞-magmas:</p>
<pre class="Agda"><a id="25503" class="Keyword">private</a>
  <a id="Pointed∞Magma"></a><a id="25513" href="1Lab.Univalence.SIP.html#25513" class="Function">Pointed∞Magma</a> <a id="25527" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="25529" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a data-type="Level" id="25539" href="Agda.Primitive.html#764" class="Primitive">lzero</a> <a id="25545" class="Symbol">_</a>
  <a id="25549" href="1Lab.Univalence.SIP.html#25513" class="Function">Pointed∞Magma</a> <a id="25563" class="Symbol">=</a> <a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="25565" href="1Lab.Univalence.SIP.html#24623" class="Function">tm→Structure</a> <a id="25578" class="Symbol">(</a><a data-type="StrTm ℓ ℓ (λ X → X)" id="25579" href="1Lab.Univalence.SIP.html#24094" class="InductiveConstructor">s∙</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="25582" href="1Lab.Univalence.SIP.html#24224" class="InductiveConstructor Operator">s×</a> <a id="25585" class="Symbol">(</a><a data-type="StrTm ℓ ℓ (λ X → X)" id="25586" href="1Lab.Univalence.SIP.html#24094" class="InductiveConstructor">s∙</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="25589" href="1Lab.Univalence.SIP.html#24126" class="InductiveConstructor Operator">s→</a> <a id="25592" class="Symbol">(</a><a data-type="StrTm ℓ ℓ (λ X → X)" id="25593" href="1Lab.Univalence.SIP.html#24094" class="InductiveConstructor">s∙</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="25596" href="1Lab.Univalence.SIP.html#24126" class="InductiveConstructor Operator">s→</a> <a data-type="StrTm ℓ ℓ (λ X → X)" id="25599" href="1Lab.Univalence.SIP.html#24094" class="InductiveConstructor">s∙</a><a id="25601" class="Symbol">)))</a>

  <a id="25608" href="1Lab.Univalence.SIP.html#25608" class="Function">_</a> <a id="25610" class="Symbol">:</a> <a id="25612" class="Symbol">{</a><a id="25613" href="1Lab.Univalence.SIP.html#25613" class="Bound">A</a> <a id="25615" href="1Lab.Univalence.SIP.html#25615" class="Bound">B</a> <a id="25617" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="25619" href="1Lab.Univalence.SIP.html#3316" class="Function">TypeWith</a> <a id="25628" href="1Lab.Univalence.SIP.html#25513" class="Function">Pointed∞Magma</a><a id="25641" class="Symbol">}</a> <a id="25643" class="Symbol">{</a><a id="25644" href="1Lab.Univalence.SIP.html#25644" class="Bound">f</a> <a id="25646" class="Symbol">:</a> <a id="25648" href="1Lab.Univalence.SIP.html#25613" class="Bound">A</a> <a id="25650" class="Symbol">.</a><a data-type="∑ A B → A" id="25651" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="25655" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="25657" href="1Lab.Univalence.SIP.html#25615" class="Bound">B</a> <a id="25659" class="Symbol">.</a><a data-type="∑ A B → A" id="25660" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="25663" class="Symbol">}</a>
    <a id="25669" class="Symbol">→</a> <a id="25671" href="1Lab.Univalence.SIP.html#25513" class="Function">Pointed∞Magma</a> <a id="25685" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="25686" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="25693" href="1Lab.Univalence.SIP.html#25613" class="Bound">A</a> <a id="25695" href="1Lab.Univalence.SIP.html#25615" class="Bound">B</a> <a id="25697" href="1Lab.Univalence.SIP.html#25644" class="Bound">f</a>
    <a data-type="A → A → Type ℓ" id="25703" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="25705" class="Symbol">(</a> <a id="25707" class="Symbol">(</a><a id="25708" href="1Lab.Univalence.SIP.html#25644" class="Bound">f</a> <a id="25710" class="Symbol">.</a><a data-type="∑ A B → A" id="25711" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="25715" class="Symbol">(</a><a id="25716" href="1Lab.Univalence.SIP.html#25613" class="Bound">A</a> <a id="25718" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="25719" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="25723" class="Symbol">.</a><a data-type="∑ A B → A" id="25724" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="25727" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="25729" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="25731" href="1Lab.Univalence.SIP.html#25615" class="Bound">B</a> <a id="25733" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="25734" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="25738" class="Symbol">.</a><a data-type="∑ A B → A" id="25739" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="25742" class="Symbol">)</a>
      <a data-type="Type a → Type b → Type (a ⊔ b)" id="25750" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="25752" class="Symbol">((</a><a id="25754" href="1Lab.Univalence.SIP.html#25754" class="Bound">x</a> <a id="25756" href="1Lab.Univalence.SIP.html#25756" class="Bound">y</a> <a id="25758" class="Symbol">:</a> <a id="25760" href="1Lab.Univalence.SIP.html#25613" class="Bound">A</a> <a id="25762" class="Symbol">.</a><a data-type="∑ A B → A" id="25763" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="25766" class="Symbol">)</a> <a id="25768" class="Symbol">→</a> <a id="25770" href="1Lab.Univalence.SIP.html#25644" class="Bound">f</a> <a id="25772" class="Symbol">.</a><a data-type="∑ A B → A" id="25773" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="25777" class="Symbol">(</a><a id="25778" href="1Lab.Univalence.SIP.html#25613" class="Bound">A</a> <a id="25780" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="25781" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="25785" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="25786" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="25790" href="1Lab.Univalence.SIP.html#25754" class="Bound">x</a> <a id="25792" href="1Lab.Univalence.SIP.html#25756" class="Bound">y</a><a id="25793" class="Symbol">)</a>
                        <a data-type="A → A → Type ℓ" id="25819" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="25821" href="1Lab.Univalence.SIP.html#25615" class="Bound">B</a> <a id="25823" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="25824" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="25828" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="25829" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="25833" class="Symbol">(</a><a id="25834" href="1Lab.Univalence.SIP.html#25644" class="Bound">f</a> <a id="25836" class="Symbol">.</a><a data-type="∑ A B → A" id="25837" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="25841" href="1Lab.Univalence.SIP.html#25754" class="Bound">x</a><a id="25842" class="Symbol">)</a> <a id="25844" class="Symbol">(</a><a id="25845" href="1Lab.Univalence.SIP.html#25644" class="Bound">f</a> <a id="25847" class="Symbol">.</a><a data-type="∑ A B → A" id="25848" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="25852" href="1Lab.Univalence.SIP.html#25756" class="Bound">y</a><a id="25853" class="Symbol">)))</a>
  <a id="25859" class="Symbol">_</a> <a id="25861" class="Symbol">=</a> <a data-type="x ≡ x" id="25863" href="1Lab.Path.html#2137" class="Function">refl</a>
</pre>
<p>A homomorphic equivalence of pointed ∞-magmas is an equivalence of their underlying types that preserves the basepoint and is homomorphic over the operation. The use of <span class="Agda"><a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" href="1Lab.Univalence.SIP.html#24674" class="Function">tm→Action</a></span> in contravariant positions is responsible for making sure the computed <span class="Agda"><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a></span> doesn’t have any redundant paths in argument positions.</p>
<p>A mutually <em>inductive</em> argument proves that <span class="Agda"><a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" href="1Lab.Univalence.SIP.html#24674" class="Function">tm→Action</a></span> produces transport structures, and that <span class="Agda"><a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" href="1Lab.Univalence.SIP.html#24623" class="Function">tm→Structure</a></span> produces univalent structures. At every case, the proof is by appeal to a lemma that was proved above.</p>
<pre class="Agda"><a id="tm→Structure-univalent"></a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isUnivalent (tm→Structure s)" id="26442" href="1Lab.Univalence.SIP.html#26442" class="Function">tm→Structure-univalent</a> <a id="26465" class="Symbol">:</a> <a id="26467" class="Symbol">(</a><a id="26468" href="1Lab.Univalence.SIP.html#26468" class="Bound">s</a> <a id="26470" class="Symbol">:</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="26472" href="1Lab.Univalence.SIP.html#23978" class="Datatype">StrTm</a> <a id="26478" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="26480" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a> <a id="26483" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="26484" class="Symbol">)</a> <a id="26486" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="26488" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="26500" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="26501" href="1Lab.Univalence.SIP.html#24623" class="Function">tm→Structure</a> <a id="26514" href="1Lab.Univalence.SIP.html#26468" class="Bound">s</a><a id="26515" class="Symbol">)</a>
<a id="tm→Action-isTransp"></a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isTransportStr (tm→Action s)" id="26517" href="1Lab.Univalence.SIP.html#26517" class="Function">tm→Action-isTransp</a> <a id="26536" class="Symbol">:</a> <a id="26538" class="Symbol">(</a><a id="26539" href="1Lab.Univalence.SIP.html#26539" class="Bound">s</a> <a id="26541" class="Symbol">:</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="26543" href="1Lab.Univalence.SIP.html#23978" class="Datatype">StrTm</a> <a id="26549" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="26551" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a> <a id="26554" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="26555" class="Symbol">)</a> <a id="26557" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="26559" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a> <a id="26574" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="26575" href="1Lab.Univalence.SIP.html#24674" class="Function">tm→Action</a> <a id="26585" href="1Lab.Univalence.SIP.html#26539" class="Bound">s</a><a id="26586" class="Symbol">)</a>

<a data-type="(s : StrTm ℓ ℓ₁ S₁) → isUnivalent (tm→Structure s)" id="26589" href="1Lab.Univalence.SIP.html#26442" class="Function">tm→Structure-univalent</a> <a id="26612" class="Symbol">(</a><a data-type="(A : Type ℓ₁) → StrTm ℓ ℓ₁ (λ X → A)" id="26613" href="1Lab.Univalence.SIP.html#24038" class="InductiveConstructor">s-const</a> <a id="26621" href="1Lab.Univalence.SIP.html#26621" class="Bound">x</a><a id="26622" class="Symbol">)</a> <a id="26624" class="Symbol">=</a> <a data-type="isUnivalent (constantStr A)" id="26626" href="1Lab.Univalence.SIP.html#6293" class="Function">constantStr-univalent</a>
<a data-type="(s : StrTm ℓ ℓ₁ S₁) → isUnivalent (tm→Structure s)" id="26648" href="1Lab.Univalence.SIP.html#26442" class="Function">tm→Structure-univalent</a> <a data-type="StrTm ℓ ℓ (λ X → X)" id="26671" href="1Lab.Univalence.SIP.html#24094" class="InductiveConstructor">s∙</a> <a id="26674" class="Symbol">=</a> <a data-type="isUnivalent pointedStr" id="26676" href="1Lab.Univalence.SIP.html#7247" class="Function">pointedStr-univalent</a>
<a data-type="(s : StrTm ℓ ℓ₁ S₁) → isUnivalent (tm→Structure s)" id="26697" href="1Lab.Univalence.SIP.html#26442" class="Function">tm→Structure-univalent</a> <a id="26720" class="Symbol">(</a><a id="26721" href="1Lab.Univalence.SIP.html#26721" class="Bound">s</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="26723" href="1Lab.Univalence.SIP.html#24126" class="InductiveConstructor Operator">s→</a> <a id="26726" href="1Lab.Univalence.SIP.html#26726" class="Bound">s₁</a><a id="26728" class="Symbol">)</a> <a id="26730" class="Symbol">=</a>
  <a data-type="(α : EqvAction S₁) →
isTransportStr α →
(τ : Structure ℓ T) → isUnivalent τ → isUnivalent (functionStr α τ)" id="26734" href="1Lab.Univalence.SIP.html#17249" class="Function">functionStr-univalent</a>
    <a id="26760" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="26761" href="1Lab.Univalence.SIP.html#24674" class="Function">tm→Action</a> <a id="26771" href="1Lab.Univalence.SIP.html#26721" class="Bound">s</a><a id="26772" class="Symbol">)</a> <a id="26774" class="Symbol">(</a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isTransportStr (tm→Action s)" id="26775" href="1Lab.Univalence.SIP.html#26517" class="Function">tm→Action-isTransp</a> <a id="26794" href="1Lab.Univalence.SIP.html#26721" class="Bound">s</a><a id="26795" class="Symbol">)</a>
    <a id="26801" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="26802" href="1Lab.Univalence.SIP.html#24623" class="Function">tm→Structure</a> <a id="26815" href="1Lab.Univalence.SIP.html#26726" class="Bound">s₁</a><a id="26817" class="Symbol">)</a> <a id="26819" class="Symbol">(</a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isUnivalent (tm→Structure s)" id="26820" href="1Lab.Univalence.SIP.html#26442" class="Function">tm→Structure-univalent</a> <a id="26843" href="1Lab.Univalence.SIP.html#26726" class="Bound">s₁</a><a id="26845" class="Symbol">)</a>
<a data-type="(s : StrTm ℓ ℓ₁ S₁) → isUnivalent (tm→Structure s)" id="26847" href="1Lab.Univalence.SIP.html#26442" class="Function">tm→Structure-univalent</a> <a id="26870" class="Symbol">(</a><a id="26871" href="1Lab.Univalence.SIP.html#26871" class="Bound">s</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="26873" href="1Lab.Univalence.SIP.html#24224" class="InductiveConstructor Operator">s×</a> <a id="26876" href="1Lab.Univalence.SIP.html#26876" class="Bound">s₁</a><a id="26878" class="Symbol">)</a> <a id="26880" class="Symbol">=</a>
  <a data-type="isUnivalent σ → isUnivalent τ → isUnivalent (productStr σ τ)" id="26884" href="1Lab.Univalence.SIP.html#7731" class="Function">productStr-univalent</a> <a id="26905" class="Symbol">{</a><a id="26906" class="Argument">σ</a> <a id="26908" class="Symbol">=</a> <a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="26910" href="1Lab.Univalence.SIP.html#24623" class="Function">tm→Structure</a> <a id="26923" href="1Lab.Univalence.SIP.html#26871" class="Bound">s</a><a id="26924" class="Symbol">}</a> <a id="26926" class="Symbol">{</a><a id="26927" class="Argument">τ</a> <a id="26929" class="Symbol">=</a> <a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="26931" href="1Lab.Univalence.SIP.html#24623" class="Function">tm→Structure</a> <a id="26944" href="1Lab.Univalence.SIP.html#26876" class="Bound">s₁</a><a id="26946" class="Symbol">}</a>
    <a id="26952" class="Symbol">(</a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isUnivalent (tm→Structure s)" id="26953" href="1Lab.Univalence.SIP.html#26442" class="Function">tm→Structure-univalent</a> <a id="26976" href="1Lab.Univalence.SIP.html#26871" class="Bound">s</a><a id="26977" class="Symbol">)</a> <a id="26979" class="Symbol">(</a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isUnivalent (tm→Structure s)" id="26980" href="1Lab.Univalence.SIP.html#26442" class="Function">tm→Structure-univalent</a> <a id="27003" href="1Lab.Univalence.SIP.html#26876" class="Bound">s₁</a><a id="27005" class="Symbol">)</a>

<a data-type="(s : StrTm ℓ ℓ₁ S₁) → isTransportStr (tm→Action s)" id="27008" href="1Lab.Univalence.SIP.html#26517" class="Function">tm→Action-isTransp</a> <a id="27027" class="Symbol">(</a><a data-type="(A : Type ℓ₁) → StrTm ℓ ℓ₁ (λ X → A)" id="27028" href="1Lab.Univalence.SIP.html#24038" class="InductiveConstructor">s-const</a> <a id="27036" href="1Lab.Univalence.SIP.html#27036" class="Bound">x</a><a id="27037" class="Symbol">)</a> <a id="27039" class="Symbol">=</a> <a data-type="isTransportStr (constantAction A)" id="27041" href="1Lab.Univalence.SIP.html#19544" class="Function">constantAction-isTransp</a>
<a data-type="(s : StrTm ℓ ℓ₁ S₁) → isTransportStr (tm→Action s)" id="27065" href="1Lab.Univalence.SIP.html#26517" class="Function">tm→Action-isTransp</a> <a data-type="StrTm ℓ ℓ (λ X → X)" id="27084" href="1Lab.Univalence.SIP.html#24094" class="InductiveConstructor">s∙</a> <a id="27087" class="Symbol">=</a> <a data-type="isTransportStr id" id="27089" href="1Lab.Univalence.SIP.html#19682" class="Function">idAction-isTransp</a>
<a data-type="(s : StrTm ℓ ℓ₁ S₁) → isTransportStr (tm→Action s)" id="27107" href="1Lab.Univalence.SIP.html#26517" class="Function">tm→Action-isTransp</a> <a id="27126" class="Symbol">(</a><a id="27127" href="1Lab.Univalence.SIP.html#27127" class="Bound">s</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="27129" href="1Lab.Univalence.SIP.html#24126" class="InductiveConstructor Operator">s→</a> <a id="27132" href="1Lab.Univalence.SIP.html#27132" class="Bound">s₁</a><a id="27134" class="Symbol">)</a> <a id="27136" class="Symbol">=</a>
  <a data-type="isTransportStr α →
isTransportStr β → isTransportStr (functionAction α β)" id="27140" href="1Lab.Univalence.SIP.html#20322" class="Function">functionAction-isTransp</a> <a id="27164" class="Symbol">{</a><a id="27165" class="Argument">α</a> <a id="27167" class="Symbol">=</a> <a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="27169" href="1Lab.Univalence.SIP.html#24674" class="Function">tm→Action</a> <a id="27179" href="1Lab.Univalence.SIP.html#27127" class="Bound">s</a><a id="27180" class="Symbol">}</a> <a id="27182" class="Symbol">{</a><a id="27183" class="Argument">β</a> <a id="27185" class="Symbol">=</a> <a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="27187" href="1Lab.Univalence.SIP.html#24674" class="Function">tm→Action</a> <a id="27197" href="1Lab.Univalence.SIP.html#27132" class="Bound">s₁</a><a id="27199" class="Symbol">}</a>
    <a id="27205" class="Symbol">(</a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isTransportStr (tm→Action s)" id="27206" href="1Lab.Univalence.SIP.html#26517" class="Function">tm→Action-isTransp</a> <a id="27225" href="1Lab.Univalence.SIP.html#27127" class="Bound">s</a><a id="27226" class="Symbol">)</a> <a id="27228" class="Symbol">(</a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isTransportStr (tm→Action s)" id="27229" href="1Lab.Univalence.SIP.html#26517" class="Function">tm→Action-isTransp</a> <a id="27248" href="1Lab.Univalence.SIP.html#27132" class="Bound">s₁</a><a id="27250" class="Symbol">)</a>
<a data-type="(s : StrTm ℓ ℓ₁ S₁) → isTransportStr (tm→Action s)" id="27252" href="1Lab.Univalence.SIP.html#26517" class="Function">tm→Action-isTransp</a> <a id="27271" class="Symbol">(</a><a id="27272" href="1Lab.Univalence.SIP.html#27272" class="Bound">s</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="27274" href="1Lab.Univalence.SIP.html#24224" class="InductiveConstructor Operator">s×</a> <a id="27277" href="1Lab.Univalence.SIP.html#27277" class="Bound">s₁</a><a id="27279" class="Symbol">)</a> <a id="27281" class="Symbol">=</a>
  <a data-type="isTransportStr α →
isTransportStr β → isTransportStr (productAction α β)" id="27285" href="1Lab.Univalence.SIP.html#19919" class="Function">productAction-isTransp</a> <a id="27308" class="Symbol">{</a><a id="27309" class="Argument">α</a> <a id="27311" class="Symbol">=</a> <a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="27313" href="1Lab.Univalence.SIP.html#24674" class="Function">tm→Action</a> <a id="27323" href="1Lab.Univalence.SIP.html#27272" class="Bound">s</a><a id="27324" class="Symbol">}</a> <a id="27326" class="Symbol">{</a><a id="27327" class="Argument">β</a> <a id="27329" class="Symbol">=</a> <a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="27331" href="1Lab.Univalence.SIP.html#24674" class="Function">tm→Action</a> <a id="27341" href="1Lab.Univalence.SIP.html#27277" class="Bound">s₁</a><a id="27343" class="Symbol">}</a>
    <a id="27349" class="Symbol">(</a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isTransportStr (tm→Action s)" id="27350" href="1Lab.Univalence.SIP.html#26517" class="Function">tm→Action-isTransp</a> <a id="27369" href="1Lab.Univalence.SIP.html#27272" class="Bound">s</a><a id="27370" class="Symbol">)</a> <a id="27372" class="Symbol">(</a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isTransportStr (tm→Action s)" id="27373" href="1Lab.Univalence.SIP.html#26517" class="Function">tm→Action-isTransp</a> <a id="27392" href="1Lab.Univalence.SIP.html#27277" class="Bound">s₁</a><a id="27394" class="Symbol">)</a>
</pre>
<h2 id="descriptions-of-structures"><a href="#descriptions-of-structures" class="header-link">Descriptions of Structures<span class="header-link-emoji">🔗</span></a></h2>
<p>To make convenient descriptions of structures-with-axioms, we introduce a record type, <span class="Agda"><a data-type="(ℓ ℓ₁ : Level) (S₁ : Type ℓ → Type ℓ₁) (ax : Level) → Typeω" href="1Lab.Univalence.SIP.html#27633" class="Record">StrDesc</a></span>, which packages together the structure term and the properties that are imposed:</p>
<pre class="Agda"><a id="27626" class="Keyword">record</a> <a id="StrDesc"></a><a data-type="(ℓ ℓ₁ : Level) (S₁ : Type ℓ → Type ℓ₁) (ax : Level) → Typeω" id="27633" href="1Lab.Univalence.SIP.html#27633" class="Record">StrDesc</a> <a id="27641" href="1Lab.Univalence.SIP.html#27641" class="Bound">ℓ</a> <a id="27643" href="1Lab.Univalence.SIP.html#27643" class="Bound">ℓ₁</a> <a id="27646" href="1Lab.Univalence.SIP.html#27646" class="Bound">S</a> <a id="27648" href="1Lab.Univalence.SIP.html#27648" class="Bound">ax</a> <a id="27651" class="Symbol">:</a> <a id="27653" href="1Lab.Type.html#409" class="Primitive">Typeω</a> <a id="27659" class="Keyword">where</a>
  <a id="27667" class="Keyword">field</a>
    <a id="StrDesc.descriptor"></a><a data-type="StrDesc ℓ ℓ₁ S₁ ax → StrTm ℓ ℓ₁ S₁" id="27677" href="1Lab.Univalence.SIP.html#27677" class="Field">descriptor</a> <a id="27688" class="Symbol">:</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="27690" href="1Lab.Univalence.SIP.html#23978" class="Datatype">StrTm</a> <a id="27696" href="1Lab.Univalence.SIP.html#27641" class="Bound">ℓ</a> <a id="27698" href="1Lab.Univalence.SIP.html#27643" class="Bound">ℓ₁</a> <a id="27701" href="1Lab.Univalence.SIP.html#27646" class="Bound">S</a>

    <a id="StrDesc.axioms"></a><a data-type="StrDesc ℓ ℓ₁ S₁ ax → (X : Type ℓ) → S₁ X → Type ax" id="27708" href="1Lab.Univalence.SIP.html#27708" class="Field">axioms</a> <a id="27715" class="Symbol">:</a> <a id="27717" class="Symbol">∀</a> <a id="27719" href="1Lab.Univalence.SIP.html#27719" class="Bound">X</a> <a id="27721" class="Symbol">→</a> <a id="27723" href="1Lab.Univalence.SIP.html#27646" class="Bound">S</a> <a id="27725" href="1Lab.Univalence.SIP.html#27719" class="Bound">X</a> <a id="27727" class="Symbol">→</a> <a id="27729" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="27734" href="1Lab.Univalence.SIP.html#27648" class="Bound">ax</a>
    <a id="StrDesc.axioms-prop"></a><a data-type="(r : StrDesc ℓ ℓ₁ S₁ ax) (X : Type ℓ) (s : S₁ X) →
isProp (r .axioms X s)" id="27741" href="1Lab.Univalence.SIP.html#27741" class="Field">axioms-prop</a> <a id="27753" class="Symbol">:</a> <a id="27755" class="Symbol">∀</a> <a id="27757" href="1Lab.Univalence.SIP.html#27757" class="Bound">X</a> <a id="27759" href="1Lab.Univalence.SIP.html#27759" class="Bound">s</a> <a id="27761" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="27763" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="27770" class="Symbol">(</a><a data-type="StrDesc ℓ ℓ₁ S₁ ax → (X : Type ℓ) → S₁ X → Type ax" id="27771" href="1Lab.Univalence.SIP.html#27708" class="Field">axioms</a> <a id="27778" href="1Lab.Univalence.SIP.html#27757" class="Bound">X</a> <a id="27780" href="1Lab.Univalence.SIP.html#27759" class="Bound">s</a><a id="27781" class="Symbol">)</a>

<a id="Desc→Fam"></a><a data-type="StrDesc ℓ ℓ₁ S₁ ax → Type ℓ → Type (ℓ₁ ⊔ ax)" id="27784" href="1Lab.Univalence.SIP.html#27784" class="Function">Desc→Fam</a> <a id="27793" class="Symbol">:</a> <a id="27795" class="Symbol">∀</a> <a id="27797" class="Symbol">{</a><a id="27798" href="1Lab.Univalence.SIP.html#27798" class="Bound">ax</a><a id="27800" class="Symbol">}</a> <a id="27802" class="Symbol">→</a> <a data-type="(ℓ ℓ₁ : Level) (S₁ : Type ℓ → Type ℓ₁) (ax : Level) → Typeω" id="27804" href="1Lab.Univalence.SIP.html#27633" class="Record">StrDesc</a> <a id="27812" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="27814" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a> <a id="27817" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="27819" href="1Lab.Univalence.SIP.html#27798" class="Bound">ax</a> <a id="27822" class="Symbol">→</a> <a id="27824" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="27829" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="27831" class="Symbol">→</a> <a id="27833" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="27838" class="Symbol">(</a><a id="27839" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a> <a data-type="Level → Level → Level" id="27842" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="27844" href="1Lab.Univalence.SIP.html#27798" class="Bound">ax</a><a id="27846" class="Symbol">)</a>
<a data-type="StrDesc ℓ ℓ₁ S₁ ax → Type ℓ → Type (ℓ₁ ⊔ ax)" id="27848" href="1Lab.Univalence.SIP.html#27784" class="Function">Desc→Fam</a> <a id="27857" class="Symbol">{</a><a id="27858" class="Argument">S</a> <a id="27860" class="Symbol">=</a> <a id="27862" href="1Lab.Univalence.SIP.html#27862" class="Bound">S</a><a id="27863" class="Symbol">}</a> <a id="27865" href="1Lab.Univalence.SIP.html#27865" class="Bound">desc</a> <a id="27870" href="1Lab.Univalence.SIP.html#27870" class="Bound">X</a> <a id="27872" class="Symbol">=</a>
  <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="27876" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="27879" href="1Lab.Univalence.SIP.html#27879" class="Bound">S</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="27881" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="27883" href="1Lab.Univalence.SIP.html#27862" class="Bound">S</a> <a id="27885" href="1Lab.Univalence.SIP.html#27870" class="Bound">X</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="27887" href="1Lab.Type.html#1563" class="Function">]</a>
    <a id="27893" class="Symbol">(</a><a id="27894" href="1Lab.Univalence.SIP.html#27865" class="Bound">desc</a> <a id="27899" class="Symbol">.</a><a data-type="StrDesc ℓ ℓ₁ S₁ ax → (X : Type ℓ) → S₁ X → Type ax" id="27900" href="1Lab.Univalence.SIP.html#27708" class="Field">StrDesc.axioms</a> <a id="27915" class="Symbol">_</a> <a id="27917" href="1Lab.Univalence.SIP.html#27879" class="Bound">S</a><a id="27918" class="Symbol">)</a>

<a id="Desc→Str"></a><a data-type="(S₁ : StrDesc ℓ ℓ₁ S₂ ax) → Structure ℓ₁ (Desc→Fam S₁)" id="27921" href="1Lab.Univalence.SIP.html#27921" class="Function">Desc→Str</a> <a id="27930" class="Symbol">:</a> <a id="27932" class="Symbol">∀</a> <a id="27934" class="Symbol">{</a><a id="27935" href="1Lab.Univalence.SIP.html#27935" class="Bound">ax</a><a id="27937" class="Symbol">}</a> <a id="27939" class="Symbol">→</a> <a id="27941" class="Symbol">(</a><a id="27942" href="1Lab.Univalence.SIP.html#27942" class="Bound">S</a> <a id="27944" class="Symbol">:</a> <a data-type="(ℓ ℓ₁ : Level) (S₁ : Type ℓ → Type ℓ₁) (ax : Level) → Typeω" id="27946" href="1Lab.Univalence.SIP.html#27633" class="Record">StrDesc</a> <a id="27954" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="27956" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a> <a id="27959" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="27961" href="1Lab.Univalence.SIP.html#27935" class="Bound">ax</a><a id="27963" class="Symbol">)</a> <a id="27965" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="27967" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="27977" class="Symbol">_</a> <a id="27979" class="Symbol">(</a><a data-type="StrDesc ℓ ℓ₁ S₁ ax → Type ℓ → Type (ℓ₁ ⊔ ax)" id="27980" href="1Lab.Univalence.SIP.html#27784" class="Function">Desc→Fam</a> <a id="27989" href="1Lab.Univalence.SIP.html#27942" class="Bound">S</a><a id="27990" class="Symbol">)</a>
<a data-type="(S₁ : StrDesc ℓ ℓ₁ S₂ ax) → Structure ℓ₁ (Desc→Fam S₁)" id="27992" href="1Lab.Univalence.SIP.html#27921" class="Function">Desc→Str</a> <a id="28001" href="1Lab.Univalence.SIP.html#28001" class="Bound">desc</a> <a id="28006" class="Symbol">=</a> <a data-type="(σ : Structure ℓ S₁) (axioms : (X : Type S.ℓ) → S₁ X → Type ℓ₃) →
Structure ℓ (λ X → Σ (axioms X))" id="28008" href="1Lab.Univalence.SIP.html#21830" class="Function">axiomsStr</a> <a id="28018" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="28019" href="1Lab.Univalence.SIP.html#24623" class="Function">tm→Structure</a> <a data-type="StrDesc ℓ ℓ₁ S₁ ax → StrTm ℓ ℓ₁ S₁" id="28032" href="1Lab.Univalence.SIP.html#27677" class="Field">descriptor</a><a id="28042" class="Symbol">)</a> <a data-type="StrDesc ℓ ℓ₁ S₁ ax → (X : Type ℓ) → S₁ X → Type ax" id="28044" href="1Lab.Univalence.SIP.html#27708" class="Field">axioms</a>
  <a id="28053" class="Keyword">where</a> <a id="28059" class="Keyword">open</a> <a data-type="(ℓ ℓ₁ : Level) (S₁ : Type ℓ → Type ℓ₁) (ax : Level) → Typeω" id="28064" href="1Lab.Univalence.SIP.html#27633" class="Module">StrDesc</a> <a id="28072" href="1Lab.Univalence.SIP.html#28001" class="Bound">desc</a>

<a id="Desc→isUnivalent"></a><a data-type="(S₁ : StrDesc ℓ ℓ₁ S₂ ax) → isUnivalent (Desc→Str S₁)" id="28078" href="1Lab.Univalence.SIP.html#28078" class="Function">Desc→isUnivalent</a> <a id="28095" class="Symbol">:</a> <a id="28097" class="Symbol">∀</a> <a id="28099" class="Symbol">{</a><a id="28100" href="1Lab.Univalence.SIP.html#28100" class="Bound">ax</a><a id="28102" class="Symbol">}</a> <a id="28104" class="Symbol">→</a> <a id="28106" class="Symbol">(</a><a id="28107" href="1Lab.Univalence.SIP.html#28107" class="Bound">S</a> <a id="28109" class="Symbol">:</a> <a data-type="(ℓ ℓ₁ : Level) (S₁ : Type ℓ → Type ℓ₁) (ax : Level) → Typeω" id="28111" href="1Lab.Univalence.SIP.html#27633" class="Record">StrDesc</a> <a id="28119" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="28121" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a> <a id="28124" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="28126" href="1Lab.Univalence.SIP.html#28100" class="Bound">ax</a><a id="28128" class="Symbol">)</a> <a id="28130" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="28132" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="28144" class="Symbol">(</a><a data-type="(S₁ : StrDesc ℓ ℓ₁ S₂ ax) → Structure ℓ₁ (Desc→Fam S₁)" id="28145" href="1Lab.Univalence.SIP.html#27921" class="Function">Desc→Str</a> <a id="28154" href="1Lab.Univalence.SIP.html#28107" class="Bound">S</a><a id="28155" class="Symbol">)</a>
<a data-type="(S₁ : StrDesc ℓ ℓ₁ S₂ ax) → isUnivalent (Desc→Str S₁)" id="28157" href="1Lab.Univalence.SIP.html#28078" class="Function">Desc→isUnivalent</a> <a id="28174" href="1Lab.Univalence.SIP.html#28174" class="Bound">desc</a> <a id="28179" class="Symbol">=</a>
  <a data-type="(σ : Structure ℓ S₁) (axioms : (X : Type S.ℓ) → S₁ X → Type ℓ₃)
(univ : isUnivalent σ) (axioms-prop : isProp (axioms X s)) →
isUnivalent (axiomsStr σ axioms)" id="28183" href="1Lab.Univalence.SIP.html#22219" class="Function">axiomsStr-univalent</a>
    <a id="28207" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="28208" href="1Lab.Univalence.SIP.html#24623" class="Function">tm→Structure</a> <a data-type="StrDesc ℓ ℓ₁ S₁ ax → StrTm ℓ ℓ₁ S₁" id="28221" href="1Lab.Univalence.SIP.html#27677" class="Function">descriptor</a><a id="28231" class="Symbol">)</a> <a data-type="StrDesc ℓ ℓ₁ S₁ ax → (X : Type ℓ) → S₁ X → Type ax" id="28233" href="1Lab.Univalence.SIP.html#27708" class="Function">axioms</a>
    <a id="28244" class="Symbol">(</a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isUnivalent (tm→Structure s)" id="28245" href="1Lab.Univalence.SIP.html#26442" class="Function">tm→Structure-univalent</a> <a data-type="StrDesc ℓ ℓ₁ S₁ ax → StrTm ℓ ℓ₁ S₁" id="28268" href="1Lab.Univalence.SIP.html#27677" class="Function">descriptor</a><a id="28278" class="Symbol">)</a> <a id="28280" class="Symbol">(λ</a> <a id="28283" class="Symbol">{</a><a id="28284" href="1Lab.Univalence.SIP.html#28284" class="Bound">X</a><a id="28285" class="Symbol">}</a> <a id="28287" class="Symbol">{</a><a id="28288" href="1Lab.Univalence.SIP.html#28288" class="Bound">s</a><a id="28289" class="Symbol">}</a> <a id="28291" class="Symbol">→</a> <a data-type="(r : StrDesc ℓ ℓ₁ S₁ ax) (X : Type ℓ) (s : S₁ X) →
isProp (r .axioms X s)" id="28293" href="1Lab.Univalence.SIP.html#27741" class="Function">axioms-prop</a> <a id="28305" href="1Lab.Univalence.SIP.html#28284" class="Bound">X</a> <a id="28307" href="1Lab.Univalence.SIP.html#28288" class="Bound">s</a><a id="28308" class="Symbol">)</a>
  <a id="28312" class="Keyword">where</a> <a id="28318" class="Keyword">open</a> <a data-type="(ℓ ℓ₁ : Level) (S₁ : Type ℓ → Type ℓ₁) (ax : Level) → Typeω" id="28323" href="1Lab.Univalence.SIP.html#27633" class="Module">StrDesc</a> <a id="28331" href="1Lab.Univalence.SIP.html#28174" class="Bound">desc</a>
</pre>
  </article>
</div>

</main>
</body>
</html>