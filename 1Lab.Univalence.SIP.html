<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8"></meta>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"></meta>
  <meta name="keywords" content="Agda,categories,topos"></meta>

  <title>1Lab.Univalence.SIP - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css"></link>
  <link rel="stylesheet" href="/css/katex.min.css"></link>
  <link rel="stylesheet" href="/css/agda-cats.css"></link>

  <meta name="twitter:card" content="summary"></meta>
  <meta name="twitter:title" content="1Lab.Univalence.SIP - 1Lab"></meta>
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png"></meta>

  <meta name="og:title" content="1Lab.Univalence.SIP - 1Lab"></meta>
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png"></meta>
  <meta name="og:site-name" content="1Lab"></meta>
  <meta name="og:type" content="website"></meta>

    <meta name="og:description" content="&lt;p&gt;The structure identity principle characterises identifications in “types-with-structure” as being exactly the equivalences that preserve that structure. In a sense, it augments univalence with the notion of preservation of structure.&lt;/p&gt;"></meta>
  <meta name="twitter:description" content="&lt;p&gt;The structure identity principle characterises identifications in “types-with-structure” as being exactly the equivalences that preserve that structure. In a sense, it augments univalence with the notion of preservation of structure.&lt;/p&gt;"></meta>
  <meta name="description" content="&lt;p&gt;The structure identity principle characterises identifications in “types-with-structure” as being exactly the equivalences that preserve that structure. In a sense, it augments univalence with the notion of preservation of structure.&lt;/p&gt;"></meta>
  
  <script src="/equations.js" type="text/javascript"></script>
  <script src="/highlight-hover.js" type="text/javascript"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>
</head>

<body>
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">1Lab.Univalence.SIP</a>
              </h3>

      <!-- Cube logo -->
      <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px"></img>

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr></hr>
      <ul>
      <li><a href="#structure-identity-principle"><a href="#structure-identity-principle" class="header-link">Structure Identity Principle<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#the-principle"><a href="#the-principle" class="header-link">The principle<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#structure-combinators"><a href="#structure-combinators" class="header-link">Structure Combinators<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#example-infty-magmas"><a href="#example-infty-magmas" class="header-link">Example: <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>-magmas</span><span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#transport-structures"><a href="#transport-structures" class="header-link">Transport Structures<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#adding-axioms"><a href="#adding-axioms" class="header-link">Adding Axioms<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#a-language-for-structures"><a href="#a-language-for-structures" class="header-link">A Language for Structures<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#descriptions-of-structures"><a href="#descriptions-of-structures" class="header-link">Descriptions of Structures<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      </ul>
      <hr></hr>

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>
      </div>

      <hr></hr>

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
              <a href="index.html">️back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/6731e1f5d20e637eb6f85687815d2a65470f643d/src/1Lab/Univalence/SIP.lagda.md">link to source</a> <br />
                <hr></hr> <div class="author-list">Written by Amélia Liao, Guilherme Silva and uni</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="index.html">️back to index</a>
      </div>
      
      <!-- Font toggle checkbox -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>
    </div>

<pre class="Agda"><a id="275" class="Keyword">open</a> <a id="280" class="Keyword">import</a> <a id="287" href="1Lab.Path.Groupoid.html" class="Module">1Lab.Path.Groupoid</a>
<a id="306" class="Keyword">open</a> <a id="311" class="Keyword">import</a> <a id="318" href="1Lab.Type.Sigma.html" class="Module">1Lab.Type.Sigma</a>
<a id="334" class="Keyword">open</a> <a id="339" class="Keyword">import</a> <a id="346" href="1Lab.Univalence.html" class="Module">1Lab.Univalence</a>
<a id="362" class="Keyword">open</a> <a id="367" class="Keyword">import</a> <a id="374" href="1Lab.Type.Pi.html" class="Module">1Lab.Type.Pi</a>
<a id="387" class="Keyword">open</a> <a id="392" class="Keyword">import</a> <a id="399" href="1Lab.HLevel.html" class="Module">1Lab.HLevel</a>
<a id="411" class="Keyword">open</a> <a id="416" class="Keyword">import</a> <a id="423" href="1Lab.Equiv.html" class="Module">1Lab.Equiv</a>
<a id="434" class="Keyword">open</a> <a id="439" class="Keyword">import</a> <a id="446" href="1Lab.Path.html" class="Module">1Lab.Path</a>
<a id="456" class="Keyword">open</a> <a id="461" class="Keyword">import</a> <a id="468" href="1Lab.Type.html" class="Module">1Lab.Type</a>

<a id="479" class="Keyword">module</a> <a id="486" href="1Lab.Univalence.SIP.html" class="Module">1Lab.Univalence.SIP</a> <a id="506" class="Keyword">where</a>
</pre>
<h1 id="structure-identity-principle"><a href="#structure-identity-principle" class="header-link">Structure Identity Principle<span class="header-link-emoji">🔗</span></a></h1>
<p>In mathematics in general, it’s often <em>notationally</em> helpful to identify isomorphic <em>structures</em> (e.g.: groups) in a proof. However, when this mathematics is done using material set theory as a foundations, this identification is merely a shorthand — nothing <em>prevents</em> you from distinguishing isomorphic groups in ZFC by, for instance, asking about membership of a particular set in the underlying set of each group.</p>
<p>In univalent mathematics, it’s a theorem that no family of types can distinguish between isomorphic structures. <a href="1Lab.Univalence.html">Univalence</a> is this statement, but for <em>types</em>. For structures built out of types, it seems like we would need a bit more power, but in reality, we don’t!</p>
<p>“Structure Identity Principle” is the name for several related theorems in Homotopy Type Theory, which generically say that “paths on a structure are isomorphisms of that structure”.</p>
<p>For instance, the version in the HoTT Book says that if a structure <code>S</code> on the objects of a univalent category <code>S</code> can be described in a certain way, then the category of <code>S</code>-structured objects of <code>C</code> is univalent. As a benefit, the Book version of the SIP characterises the <em>homomorphisms</em> of <code>S</code>-structures, not just the <em>isomorphisms</em>. As a downside, it only applies to <a data-type="Type ℓ → Type ℓ" href="1Lab.HLevel.html#3342">set-level</a> structures.</p>
<pre class="Agda"><a id="1942" class="Keyword">record</a>
  <a id="Structure"></a><a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="1951" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a> <a id="1961" class="Symbol">{</a><a id="1962" href="1Lab.Univalence.SIP.html#1962" class="Bound">ℓ₁</a> <a id="1965" href="1Lab.Univalence.SIP.html#1965" class="Bound">ℓ₂</a><a id="1967" class="Symbol">}</a> <a id="1969" class="Symbol">(</a><a id="1970" href="1Lab.Univalence.SIP.html#1970" class="Bound">ℓ₃</a> <a id="1973" class="Symbol">:</a> <a id="1975" class="Symbol">_)</a> <a id="1978" class="Symbol">(</a><a id="1979" href="1Lab.Univalence.SIP.html#1979" class="Bound">S</a> <a id="1981" class="Symbol">:</a> <a id="1983" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="1988" href="1Lab.Univalence.SIP.html#1962" class="Bound">ℓ₁</a> <a id="1991" class="Symbol">→</a> <a id="1993" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="1998" href="1Lab.Univalence.SIP.html#1965" class="Bound">ℓ₂</a><a id="2000" class="Symbol">)</a> <a id="2002" class="Symbol">:</a> <a id="2004" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2009" class="Symbol">(</a><a data-type="Level → Level" id="2010" href="Agda.Primitive.html#780" class="Primitive">lsuc</a> <a id="2015" class="Symbol">(</a><a id="2016" href="1Lab.Univalence.SIP.html#1962" class="Bound">ℓ₁</a> <a data-type="Level → Level → Level" id="2019" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="2021" href="1Lab.Univalence.SIP.html#1970" class="Bound">ℓ₃</a><a id="2023" class="Symbol">)</a> <a data-type="Level → Level → Level" id="2025" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="2027" href="1Lab.Univalence.SIP.html#1965" class="Bound">ℓ₂</a><a id="2029" class="Symbol">)</a>
  <a id="2033" class="Keyword">where</a>

  <a id="2042" class="Keyword">constructor</a> <a id="HomT→Str"></a><a data-type="(is-hom₁ : (A B₁ : Σ S₁) → A .fst ≃ B₁ .fst → Type ℓ₃) →
Structure ℓ₃ S₁" id="2054" href="1Lab.Univalence.SIP.html#2054" class="InductiveConstructor">HomT→Str</a>
  <a id="2065" class="Keyword">field</a>
</pre>
<p>The material on this page, especially the definition of <span class="Agda"><a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" href="1Lab.Univalence.SIP.html#3849" class="Function">isUnivalent</a></span> and <span class="Agda"><a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" href="1Lab.Univalence.SIP.html#14125" class="Function">isTransportStr</a></span>, is adapted from <cite><a href="https://arxiv.org/abs/2009.05547">Internalizing Representation Independence with Univalence</a></cite>. The SIP formalised here says, very generically, that a <span class="Agda"><a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a></span> is a family of types <code>S : Type → Type</code>, and a <span class="Agda"><a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" href="1Lab.Univalence.SIP.html#3323" class="Function">type with</a></span> structure is an inhabitant of the <a href="1Lab.Type.html#1649">total space</a> <code>Σ S</code>.</p>
<p>What sets a <span class="Agda"><a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a></span> apart from a type family is a notion of <em>homomorphic equivalence</em>: Given an equivalence of the underlying types, the predicate <code>is-hom (A , x) (B , y) eqv</code> should represent what it means for <code>eqv</code> to take the <code>x</code>-structure on <code>A</code> to the <code>y</code>-structure on <code>B</code>.</p>
<pre class="Agda">   <a id="Structure.is-hom"></a><a data-type="Structure ℓ₃ S₁ → (A B₁ : Σ S₁) → A .fst ≃ B₁ .fst → Type ℓ₃" id="2879" href="1Lab.Univalence.SIP.html#2879" class="Field">is-hom</a> <a id="2886" class="Symbol">:</a> <a id="2888" class="Symbol">(</a><a id="2889" href="1Lab.Univalence.SIP.html#2889" class="Bound">A</a> <a id="2891" href="1Lab.Univalence.SIP.html#2891" class="Bound">B</a> <a id="2893" class="Symbol">:</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="2895" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="2897" href="1Lab.Univalence.SIP.html#1979" class="Bound">S</a><a id="2898" class="Symbol">)</a> <a id="2900" class="Symbol">→</a> <a id="2902" class="Symbol">(</a><a id="2903" href="1Lab.Univalence.SIP.html#2889" class="Bound">A</a> <a id="2905" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="2906" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="2910" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="2912" href="1Lab.Univalence.SIP.html#2891" class="Bound">B</a> <a id="2914" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="2915" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="2918" class="Symbol">)</a> <a id="2920" class="Symbol">→</a> <a id="2922" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2927" href="1Lab.Univalence.SIP.html#1970" class="Bound">ℓ₃</a>
</pre>
<p>As a grounding example, consider equipping types with group structure: If <code>(A , _⋆_)</code> and <code>(B , _*_)</code> are types with group structure (with many fields omitted!), and <code>f : A → B</code> is the underlying map of an equivalence <code>A ≃ B</code>, then <span class="Agda"><a data-type="Structure ℓ₃ S₁ → (A B₁ : Σ S₁) → A .fst ≃ B₁ .fst → Type ℓ₃" href="1Lab.Univalence.SIP.html#2879" class="Field">is-hom</a></span> would be <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mo stretchy="false">(</mo><mi>x</mi><mi>y</mi><mspace></mspace><mspace width="0.1111em"></mspace><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333em"></mspace><mi>A</mi><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo>⋆</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall (x y\colon A) f(x \star y) = f(x) * f(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∀</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋆</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> - the “usual” definition of group homomorphism.</p>
<pre class="Agda"><a id="3300" class="Keyword">open</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="3305" href="1Lab.Univalence.SIP.html#1951" class="Module">Structure</a> <a id="3315" class="Keyword">public</a>

<a id="TypeWith"></a><a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="3323" href="1Lab.Univalence.SIP.html#3323" class="Function">TypeWith</a> <a id="3332" class="Symbol">:</a> <a id="3334" class="Symbol">∀</a> <a id="3336" class="Symbol">{</a><a id="3337" href="1Lab.Univalence.SIP.html#3337" class="Bound">ℓ</a> <a id="3339" href="1Lab.Univalence.SIP.html#3339" class="Bound">ℓ₁</a> <a id="3342" href="1Lab.Univalence.SIP.html#3342" class="Bound">ℓ₂</a><a id="3344" class="Symbol">}</a> <a id="3346" class="Symbol">{</a><a id="3347" href="1Lab.Univalence.SIP.html#3347" class="Bound">S</a> <a id="3349" class="Symbol">:</a> <a id="3351" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3356" href="1Lab.Univalence.SIP.html#3337" class="Bound">ℓ</a> <a id="3358" class="Symbol">→</a> <a id="3360" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3365" href="1Lab.Univalence.SIP.html#3339" class="Bound">ℓ₁</a><a id="3367" class="Symbol">}</a> <a id="3369" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="3371" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a> <a id="3381" href="1Lab.Univalence.SIP.html#3342" class="Bound">ℓ₂</a> <a id="3384" href="1Lab.Univalence.SIP.html#3347" class="Bound">S</a> <a id="3386" class="Symbol">→</a> <a id="3388" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3393" class="Symbol">_</a>
<a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="3395" href="1Lab.Univalence.SIP.html#3323" class="Function">TypeWith</a> <a id="3404" class="Symbol">{</a><a id="3405" class="Argument">S</a> <a id="3407" class="Symbol">=</a> <a id="3409" href="1Lab.Univalence.SIP.html#3409" class="Bound">S</a><a id="3410" class="Symbol">}</a> <a id="3412" class="Symbol">_</a> <a id="3414" class="Symbol">=</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="3416" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="3418" href="1Lab.Univalence.SIP.html#3409" class="Bound">S</a>
</pre>
<!--
<pre class="Agda"><a id="3438" class="Keyword">private</a> <a id="3446" class="Keyword">variable</a>
  <a id="3457" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a> <a id="3459" href="1Lab.Univalence.SIP.html#3459" class="Generalizable">ℓ₁</a> <a id="3462" href="1Lab.Univalence.SIP.html#3462" class="Generalizable">ℓ₂</a> <a id="3465" href="1Lab.Univalence.SIP.html#3465" class="Generalizable">ℓ₃</a> <a id="3468" class="Symbol">:</a> <a id="3470" href="Agda.Primitive.html#597" class="Postulate">Level</a>
  <a id="3478" href="1Lab.Univalence.SIP.html#3478" class="Generalizable">A</a> <a id="3480" class="Symbol">:</a> <a id="3482" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3487" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a>
  <a id="3491" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a> <a id="3493" href="1Lab.Univalence.SIP.html#3493" class="Generalizable">T</a> <a id="3495" class="Symbol">:</a> <a id="3497" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3502" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a> <a id="3504" class="Symbol">→</a> <a id="3506" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3511" href="1Lab.Univalence.SIP.html#3459" class="Generalizable">ℓ₁</a>
</pre>-->
<p>A structure is said to be <strong>univalent</strong> if a homomorphic equivalence of structures <code>A</code>, <code>B</code> induces a path of the structures, over the univalence axiom — that is, if <span class="Agda"><a data-type="Structure ℓ₃ S₁ → (A B₁ : Σ S₁) → A .fst ≃ B₁ .fst → Type ℓ₃" href="1Lab.Univalence.SIP.html#2879" class="Field">is-hom</a></span> agrees with what it means for “S X” and “S Y” to be identified, where this identification is dependent on one induced by univalence.</p>
<pre class="Agda"><a id="isUnivalent"></a><a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="3849" href="1Lab.Univalence.SIP.html#3849" class="Function">isUnivalent</a> <a id="3861" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="3863" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a> <a id="3873" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a> <a id="3875" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a> <a id="3877" class="Symbol">→</a> <a id="3879" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3884" class="Symbol">_</a>
<a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="3886" href="1Lab.Univalence.SIP.html#3849" class="Function">isUnivalent</a> <a id="3898" class="Symbol">{</a><a id="3899" class="Argument">S</a> <a id="3901" class="Symbol">=</a> <a id="3903" href="1Lab.Univalence.SIP.html#3903" class="Bound">S</a><a id="3904" class="Symbol">}</a> <a id="3906" href="1Lab.Univalence.SIP.html#3906" class="Bound">ι</a> <a id="3908" class="Symbol">=</a>
  <a id="3912" class="Symbol">∀</a> <a id="3914" class="Symbol">{</a><a id="3915" href="1Lab.Univalence.SIP.html#3915" class="Bound">X</a> <a id="3917" href="1Lab.Univalence.SIP.html#3917" class="Bound">Y</a><a id="3918" class="Symbol">}</a>
  <a id="3922" class="Symbol">→</a> <a id="3924" class="Symbol">(</a><a id="3925" href="1Lab.Univalence.SIP.html#3925" class="Bound">f</a> <a id="3927" class="Symbol">:</a> <a id="3929" href="1Lab.Univalence.SIP.html#3915" class="Bound">X</a> <a id="3931" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="3932" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="3936" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="3938" href="1Lab.Univalence.SIP.html#3917" class="Bound">Y</a> <a id="3940" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="3941" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="3944" class="Symbol">)</a>
  <a id="3948" class="Symbol">→</a> <a id="3950" href="1Lab.Univalence.SIP.html#3906" class="Bound">ι</a> <a id="3952" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B₁ : Σ S₁) → A .fst ≃ B₁ .fst → Type ℓ₃" id="3953" href="1Lab.Univalence.SIP.html#2879" class="Field">is-hom</a> <a id="3960" href="1Lab.Univalence.SIP.html#3915" class="Bound">X</a> <a id="3962" href="1Lab.Univalence.SIP.html#3917" class="Bound">Y</a> <a id="3964" href="1Lab.Univalence.SIP.html#3925" class="Bound">f</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="3966" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="3968" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="3974" class="Symbol">(λ</a> <a id="3977" href="1Lab.Univalence.SIP.html#3977" class="Bound">i</a> <a id="3979" class="Symbol">→</a> <a id="3981" href="1Lab.Univalence.SIP.html#3903" class="Bound">S</a> <a id="3983" class="Symbol">(</a><a data-type="A ≃ B₁ → A ≡ B₁" id="3984" href="1Lab.Univalence.html#8828" class="Function">ua</a> <a id="3987" href="1Lab.Univalence.SIP.html#3925" class="Bound">f</a> <a id="3989" href="1Lab.Univalence.SIP.html#3977" class="Bound">i</a><a id="3990" class="Symbol">))</a> <a id="3993" class="Symbol">(</a><a id="3994" href="1Lab.Univalence.SIP.html#3915" class="Bound">X</a> <a id="3996" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="3997" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="4000" class="Symbol">)</a> <a id="4002" class="Symbol">(</a><a id="4003" href="1Lab.Univalence.SIP.html#3917" class="Bound">Y</a> <a id="4005" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="4006" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="4009" class="Symbol">)</a>
</pre>
<p>The notation <span class="Agda"><a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" href="1Lab.Univalence.SIP.html#4222" class="Function Operator">A ≃[ σ ] B</a></span> stands for the type of σ-homomorphic equivalences, i.e. those equivalences of the types underlying <code>A</code> and <code>B</code> that σ identifies as being homomorphic.</p>
<pre class="Agda"><a id="_≃[_]_"></a><a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="4222" href="1Lab.Univalence.SIP.html#4222" class="Function Operator">_≃[_]_</a> <a id="4229" class="Symbol">:</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="4231" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="4233" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a> <a id="4235" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="4237" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a> <a id="4247" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a> <a id="4249" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a> <a id="4251" class="Symbol">→</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="4253" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="4255" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a> <a id="4257" class="Symbol">→</a> <a id="4259" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="4264" class="Symbol">_</a>
<a id="4266" href="1Lab.Univalence.SIP.html#4266" class="Bound">A</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="4268" href="1Lab.Univalence.SIP.html#4222" class="Function Operator">≃[</a> <a id="4271" href="1Lab.Univalence.SIP.html#4271" class="Bound">σ</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="4273" href="1Lab.Univalence.SIP.html#4222" class="Function Operator">]</a> <a id="4275" href="1Lab.Univalence.SIP.html#4275" class="Bound">B</a> <a id="4277" class="Symbol">=</a>
  <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="4281" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="4284" href="1Lab.Univalence.SIP.html#4284" class="Bound">f</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="4286" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="4288" href="1Lab.Univalence.SIP.html#4266" class="Bound">A</a> <a id="4290" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="4291" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="4295" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="4297" href="1Lab.Univalence.SIP.html#4275" class="Bound">B</a> <a id="4299" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="4300" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="4304" href="1Lab.Type.html#1563" class="Function">]</a>
   <a id="4309" class="Symbol">(</a><a id="4310" href="1Lab.Univalence.SIP.html#4271" class="Bound">σ</a> <a id="4312" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B₁ : Σ S₁) → A .fst ≃ B₁ .fst → Type ℓ₃" id="4313" href="1Lab.Univalence.SIP.html#2879" class="Field">is-hom</a> <a id="4320" href="1Lab.Univalence.SIP.html#4266" class="Bound">A</a> <a id="4322" href="1Lab.Univalence.SIP.html#4275" class="Bound">B</a> <a id="4324" href="1Lab.Univalence.SIP.html#4284" class="Bound">f</a><a id="4325" class="Symbol">)</a>
</pre>
<h2 id="the-principle"><a href="#the-principle" class="header-link">The principle<span class="header-link-emoji">🔗</span></a></h2>
<p>The <strong>structure identity principle</strong> says that, if <code>S</code> is a <span class="Agda"><a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" href="1Lab.Univalence.SIP.html#3849" class="Function">univalent structure</a></span>, then the path space of <code>Σ S</code> is equivalent to the space of S-homomorphic equivalences of types. Again using groups as a grounding example: identification of groups is group isomorphism.</p>
<pre class="Agda"><a id="SIP"></a><a data-type="isUnivalent σ → (X ≃[ σ ] Y) ≃ (X ≡ Y)" id="4653" href="1Lab.Univalence.SIP.html#4653" class="Function">SIP</a> <a id="4657" class="Symbol">:</a> <a id="4659" class="Symbol">{</a><a id="4660" href="1Lab.Univalence.SIP.html#4660" class="Bound">σ</a> <a id="4662" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="4664" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a> <a id="4674" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a> <a id="4676" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a><a id="4677" class="Symbol">}</a> <a id="4679" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="4681" href="1Lab.Univalence.SIP.html#3849" class="Function">isUnivalent</a> <a id="4693" href="1Lab.Univalence.SIP.html#4660" class="Bound">σ</a> <a id="4695" class="Symbol">→</a> <a id="4697" class="Symbol">{</a><a id="4698" href="1Lab.Univalence.SIP.html#4698" class="Bound">X</a> <a id="4700" href="1Lab.Univalence.SIP.html#4700" class="Bound">Y</a> <a id="4702" class="Symbol">:</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="4704" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="4706" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a><a id="4707" class="Symbol">}</a> <a id="4709" class="Symbol">→</a> <a id="4711" class="Symbol">(</a><a id="4712" href="1Lab.Univalence.SIP.html#4698" class="Bound">X</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="4714" href="1Lab.Univalence.SIP.html#4222" class="Function Operator">≃[</a> <a id="4717" href="1Lab.Univalence.SIP.html#4660" class="Bound">σ</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="4719" href="1Lab.Univalence.SIP.html#4222" class="Function Operator">]</a> <a id="4721" href="1Lab.Univalence.SIP.html#4700" class="Bound">Y</a><a id="4722" class="Symbol">)</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="4724" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="4726" class="Symbol">(</a><a id="4727" href="1Lab.Univalence.SIP.html#4698" class="Bound">X</a> <a data-type="A → A → Type ℓ" id="4729" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="4731" href="1Lab.Univalence.SIP.html#4700" class="Bound">Y</a><a id="4732" class="Symbol">)</a>
<a data-type="isUnivalent σ → (X ≃[ σ ] Y) ≃ (X ≡ Y)" id="4734" href="1Lab.Univalence.SIP.html#4653" class="Function">SIP</a> <a id="4738" class="Symbol">{</a><a id="4739" class="Argument">S</a> <a id="4741" class="Symbol">=</a> <a id="4743" href="1Lab.Univalence.SIP.html#4743" class="Bound">S</a><a id="4744" class="Symbol">}</a> <a id="4746" class="Symbol">{</a><a id="4747" class="Argument">σ</a> <a id="4749" class="Symbol">=</a> <a id="4751" href="1Lab.Univalence.SIP.html#4751" class="Bound">σ</a><a id="4752" class="Symbol">}</a> <a id="4754" href="1Lab.Univalence.SIP.html#4754" class="Bound">is-univ</a> <a id="4762" class="Symbol">{</a><a id="4763" href="1Lab.Univalence.SIP.html#4763" class="Bound">X</a><a id="4764" class="Symbol">}</a> <a id="4766" class="Symbol">{</a><a id="4767" href="1Lab.Univalence.SIP.html#4767" class="Bound">Y</a><a id="4768" class="Symbol">}</a> <a id="4770" class="Symbol">=</a>
  <a id="4774" href="1Lab.Univalence.SIP.html#4763" class="Bound">X</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="4776" href="1Lab.Univalence.SIP.html#4222" class="Function Operator">≃[</a> <a id="4779" href="1Lab.Univalence.SIP.html#4751" class="Bound">σ</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="4781" href="1Lab.Univalence.SIP.html#4222" class="Function Operator">]</a> <a id="4783" href="1Lab.Univalence.SIP.html#4767" class="Bound">Y</a>                                                       <a data-type="(A : Type ℓ) → A ≃ B₁ → A ≃ B₁" id="4839" href="1Lab.Equiv.html#22956" class="Function Operator">≃⟨⟩</a>
  <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="4845" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="4848" href="1Lab.Univalence.SIP.html#4848" class="Bound">e</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="4850" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="4852" href="1Lab.Univalence.SIP.html#4763" class="Bound">X</a> <a id="4854" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="4855" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="4859" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="4861" href="1Lab.Univalence.SIP.html#4767" class="Bound">Y</a> <a id="4863" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="4864" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="4868" href="1Lab.Type.html#1563" class="Function">]</a> <a id="4870" class="Symbol">(</a><a id="4871" href="1Lab.Univalence.SIP.html#4751" class="Bound">σ</a> <a id="4873" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B₁ : Σ S₁) → A .fst ≃ B₁ .fst → Type ℓ₃" id="4874" href="1Lab.Univalence.SIP.html#2879" class="Field">is-hom</a> <a id="4881" href="1Lab.Univalence.SIP.html#4763" class="Bound">X</a> <a id="4883" href="1Lab.Univalence.SIP.html#4767" class="Bound">Y</a> <a id="4885" href="1Lab.Univalence.SIP.html#4848" class="Bound">e</a><a id="4886" class="Symbol">)</a>                       <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" id="4910" href="1Lab.Equiv.html#22842" class="Function Operator">≃⟨</a> <a data-type="(e : A ≃ A&#39;) → ((x : A) → P x ≃ Q (e .fst x)) → Σ P ≃ Σ Q" id="4913" href="1Lab.Type.Sigma.html#2110" class="Function">Σ-ap</a> <a id="4918" class="Symbol">(</a><a data-type="A ≃ B₁ → A ≡ B₁" id="4919" href="1Lab.Univalence.html#8828" class="Function">ua</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="4922" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv ua" id="4924" href="1Lab.Univalence.html#16852" class="Function">univalence⁻¹</a><a id="4936" class="Symbol">)</a> <a id="4938" href="1Lab.Univalence.SIP.html#4754" class="Bound">is-univ</a> <a data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" id="4946" href="1Lab.Equiv.html#22842" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="4950" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="4953" href="1Lab.Univalence.SIP.html#4953" class="Bound">p</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="4955" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="4957" href="1Lab.Univalence.SIP.html#4763" class="Bound">X</a> <a id="4959" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="4960" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="A → A → Type ℓ" id="4964" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="4966" href="1Lab.Univalence.SIP.html#4767" class="Bound">Y</a> <a id="4968" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="4969" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="4973" href="1Lab.Type.html#1563" class="Function">]</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="4975" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="4981" class="Symbol">(λ</a> <a id="4984" href="1Lab.Univalence.SIP.html#4984" class="Bound">i</a> <a id="4986" class="Symbol">→</a> <a id="4988" href="1Lab.Univalence.SIP.html#4743" class="Bound">S</a> <a id="4990" class="Symbol">(</a><a id="4991" href="1Lab.Univalence.SIP.html#4953" class="Bound">p</a> <a id="4993" href="1Lab.Univalence.SIP.html#4984" class="Bound">i</a><a id="4994" class="Symbol">))</a> <a id="4997" class="Symbol">(</a><a id="4998" href="1Lab.Univalence.SIP.html#4763" class="Bound">X</a> <a id="5000" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="5001" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="5004" class="Symbol">)</a> <a id="5006" class="Symbol">(</a><a id="5007" href="1Lab.Univalence.SIP.html#4767" class="Bound">Y</a> <a id="5009" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="5010" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="5013" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" id="5015" href="1Lab.Equiv.html#22842" class="Function Operator">≃⟨</a> <a data-type="Iso A B₁ → A ≃ B₁" id="5018" href="1Lab.Equiv.html#20100" class="Function">Iso→Equiv</a> <a data-type="Iso (Σ (λ p → PathP (λ i → B₁ i (p i)) (x .snd) (y .snd)))
(PathP (λ i → Σ (B₁ i)) x y)" id="5028" href="1Lab.Type.Sigma.html#553" class="Function">Σ-PathP-iso</a> <a data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" id="5040" href="1Lab.Equiv.html#22842" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a id="5044" class="Symbol">(</a><a id="5045" href="1Lab.Univalence.SIP.html#4763" class="Bound">X</a> <a data-type="A → A → Type ℓ" id="5047" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="5049" href="1Lab.Univalence.SIP.html#4767" class="Bound">Y</a><a id="5050" class="Symbol">)</a>                                                          <a data-type="(A : Type ℓ) → A ≃ A" id="5109" href="1Lab.Equiv.html#23033" class="Function Operator">≃∎</a>
</pre>
<p>The proof of the <span class="Agda"><a data-type="isUnivalent σ → (X ≃[ σ ] Y) ≃ (X ≡ Y)" href="1Lab.Univalence.SIP.html#4653" class="Function">SIP</a></span> follows essentially from <span class="Agda"><a data-type="isEquiv ua" href="1Lab.Univalence.html#16852" class="Function">univalence</a></span>, and the fact that <span class="Agda"><a data-type="(e : A ≃ A&#39;) → ((x : A) → P x ≃ Q (e .fst x)) → Σ P ≃ Σ Q" href="1Lab.Type.Sigma.html#2110" class="Function">Σ types respect equivalences</a></span>. In one fell swoop, we convert from the type of homomorphic equivalences to a dependent pair of paths. By the characterisation of <span class="Agda"><a data-type="Iso (Σ (λ p → PathP (λ i → B₁ i (p i)) (x .snd) (y .snd)))
(PathP (λ i → Σ (B₁ i)) x y)" href="1Lab.Type.Sigma.html#553" class="Function">path spaces of Σ types</a></span>, this latter pair is equivalent to <code>X ≡ Y</code>.</p>
<pre class="Agda"><a id="sip"></a><a data-type="isUnivalent σ → X ≃[ σ ] Y → X ≡ Y" id="5512" href="1Lab.Univalence.SIP.html#5512" class="Function">sip</a> <a id="5516" class="Symbol">:</a> <a id="5518" class="Symbol">{</a><a id="5519" href="1Lab.Univalence.SIP.html#5519" class="Bound">σ</a> <a id="5521" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="5523" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a> <a id="5533" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a> <a id="5535" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a><a id="5536" class="Symbol">}</a> <a id="5538" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="5540" href="1Lab.Univalence.SIP.html#3849" class="Function">isUnivalent</a> <a id="5552" href="1Lab.Univalence.SIP.html#5519" class="Bound">σ</a> <a id="5554" class="Symbol">→</a> <a id="5556" class="Symbol">{</a><a id="5557" href="1Lab.Univalence.SIP.html#5557" class="Bound">X</a> <a id="5559" href="1Lab.Univalence.SIP.html#5559" class="Bound">Y</a> <a id="5561" class="Symbol">:</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="5563" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="5565" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a><a id="5566" class="Symbol">}</a> <a id="5568" class="Symbol">→</a> <a id="5570" class="Symbol">(</a><a id="5571" href="1Lab.Univalence.SIP.html#5557" class="Bound">X</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="5573" href="1Lab.Univalence.SIP.html#4222" class="Function Operator">≃[</a> <a id="5576" href="1Lab.Univalence.SIP.html#5519" class="Bound">σ</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="5578" href="1Lab.Univalence.SIP.html#4222" class="Function Operator">]</a> <a id="5580" href="1Lab.Univalence.SIP.html#5559" class="Bound">Y</a><a id="5581" class="Symbol">)</a> <a id="5583" class="Symbol">→</a> <a id="5585" class="Symbol">(</a><a id="5586" href="1Lab.Univalence.SIP.html#5557" class="Bound">X</a> <a data-type="A → A → Type ℓ" id="5588" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="5590" href="1Lab.Univalence.SIP.html#5559" class="Bound">Y</a><a id="5591" class="Symbol">)</a>
<a data-type="isUnivalent σ → X ≃[ σ ] Y → X ≡ Y" id="5593" href="1Lab.Univalence.SIP.html#5512" class="Function">sip</a> <a id="5597" href="1Lab.Univalence.SIP.html#5597" class="Bound">σ</a> <a id="5599" class="Symbol">=</a> <a data-type="isUnivalent σ → (X ≃[ σ ] Y) ≃ (X ≡ Y)" id="5601" href="1Lab.Univalence.SIP.html#4653" class="Function">SIP</a> <a id="5605" href="1Lab.Univalence.SIP.html#5597" class="Bound">σ</a> <a id="5607" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="5608" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a>
</pre>
<h1 id="structure-combinators"><a href="#structure-combinators" class="header-link">Structure Combinators<span class="header-link-emoji">🔗</span></a></h1>
<p>Univalent structures can be built up in an algebraic manner through the use of <em>structure combinators</em>. These express closure of structures under a number of type formers. For instance, if <code>S</code> and <code>T</code> are univalent structures, then so is <code>λ X → S X → T X</code>.</p>
<p>The simplest case of univalent structure is the <em>constant structure</em>, which is what you get when you equip a type <code>X</code> with a choice of inhabitant of some other type <code>Y</code>, unrelated to <code>X</code>. Since the given function is <code>f : A → B</code>, it can’t act on <code>T</code>, so the notion of homomorphism is independent of <code>f</code>.</p>
<pre class="Agda"><a id="constantStr"></a><a data-type="(A : Type ℓ) → Structure ℓ (λ X → A)" id="6212" href="1Lab.Univalence.SIP.html#6212" class="Function">constantStr</a> <a id="6224" class="Symbol">:</a> <a id="6226" class="Symbol">(</a><a id="6227" href="1Lab.Univalence.SIP.html#6227" class="Bound">A</a> <a id="6229" class="Symbol">:</a> <a id="6231" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="6236" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a><a id="6237" class="Symbol">)</a> <a id="6239" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="6241" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a> <a id="6251" class="Symbol">{</a><a id="6252" href="1Lab.Univalence.SIP.html#3459" class="Generalizable">ℓ₁</a><a id="6254" class="Symbol">}</a> <a id="6256" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a> <a id="6258" class="Symbol">(λ</a> <a id="6261" href="1Lab.Univalence.SIP.html#6261" class="Bound">X</a> <a id="6263" class="Symbol">→</a> <a id="6265" href="1Lab.Univalence.SIP.html#6227" class="Bound">A</a><a id="6266" class="Symbol">)</a>
<a data-type="(A : Type ℓ) → Structure ℓ (λ X → A)" id="6268" href="1Lab.Univalence.SIP.html#6212" class="Function">constantStr</a> <a id="6280" href="1Lab.Univalence.SIP.html#6280" class="Bound">T</a> <a id="6282" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B₁ : Σ S₁) → A .fst ≃ B₁ .fst → Type ℓ₃" id="6283" href="1Lab.Univalence.SIP.html#2879" class="Field">is-hom</a> <a id="6290" class="Symbol">(</a><a id="6291" href="1Lab.Univalence.SIP.html#6291" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="6293" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="6295" href="1Lab.Univalence.SIP.html#6295" class="Bound">x</a><a id="6296" class="Symbol">)</a> <a id="6298" class="Symbol">(</a><a id="6299" href="1Lab.Univalence.SIP.html#6299" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="6301" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="6303" href="1Lab.Univalence.SIP.html#6303" class="Bound">y</a><a id="6304" class="Symbol">)</a> <a id="6306" href="1Lab.Univalence.SIP.html#6306" class="Bound">f</a> <a id="6308" class="Symbol">=</a> <a id="6310" href="1Lab.Univalence.SIP.html#6295" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="6312" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="6314" href="1Lab.Univalence.SIP.html#6303" class="Bound">y</a>

<a id="constantStr-univalent"></a><a data-type="isUnivalent (constantStr A)" id="6317" href="1Lab.Univalence.SIP.html#6317" class="Function">constantStr-univalent</a> <a id="6339" class="Symbol">:</a> <a id="6341" class="Symbol">{</a><a id="6342" href="1Lab.Univalence.SIP.html#6342" class="Bound">A</a> <a id="6344" class="Symbol">:</a> <a id="6346" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="6351" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a><a id="6352" class="Symbol">}</a> <a id="6354" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="6356" href="1Lab.Univalence.SIP.html#3849" class="Function">isUnivalent</a> <a id="6368" class="Symbol">(</a><a data-type="(A : Type ℓ) → Structure ℓ (λ X → A)" id="6369" href="1Lab.Univalence.SIP.html#6212" class="Function">constantStr</a> <a id="6381" class="Symbol">{</a><a id="6382" class="Argument">ℓ₁</a> <a id="6385" class="Symbol">=</a> <a id="6387" href="1Lab.Univalence.SIP.html#3459" class="Generalizable">ℓ₁</a><a id="6389" class="Symbol">}</a> <a id="6391" href="1Lab.Univalence.SIP.html#6342" class="Bound">A</a><a id="6392" class="Symbol">)</a>
<a data-type="isUnivalent (constantStr A)" id="6394" href="1Lab.Univalence.SIP.html#6317" class="Function">constantStr-univalent</a> <a id="6416" href="1Lab.Univalence.SIP.html#6416" class="Bound">f</a> <a id="6418" class="Symbol">=</a> <a id="6420" class="Symbol">_</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="6422" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="6424" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a>
</pre>
<p>The next simplest case is considering the identity function as a structure. In that case, the resulting structured type is that of a <em>pointed type</em>, whence the name <span class="Agda"><a data-type="Structure ℓ (λ X → X)" href="1Lab.Univalence.SIP.html#7063" class="Function">pointedStr</a></span>.</p>
<p>The name <span class="Agda"><a data-type="Structure ℓ (λ X → X)" href="1Lab.Univalence.SIP.html#7063" class="Function">pointedStr</a></span> breaks down when it is used with some of the other combinators: A type equipped with the <span class="Agda"><a data-type="Structure ℓ S₁ →
Structure ℓ₂ T → Structure (ℓ ⊔ ℓ₂) (λ X → S₁ X × T X)" href="1Lab.Univalence.SIP.html#7563" class="Function">product</a></span> of two <span class="Agda"><a data-type="Structure ℓ (λ X → X)" href="1Lab.Univalence.SIP.html#7063" class="Function">pointed structures</a></span> is indeed a “bipointed structure”, but a type equipped with <span class="Agda"><a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" href="1Lab.Univalence.SIP.html#16946" class="Function">maps between</a></span> two <span class="Agda"><a data-type="Structure ℓ (λ X → X)" href="1Lab.Univalence.SIP.html#7063" class="Function">pointed structures</a></span> is a type equipped with an endomorphism, which does not necessitate a point.</p>
<pre class="Agda"><a id="pointedStr"></a><a data-type="Structure ℓ (λ X → X)" id="7063" href="1Lab.Univalence.SIP.html#7063" class="Function">pointedStr</a> <a id="7074" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="7076" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a> <a id="7086" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a> <a id="7088" class="Symbol">(λ</a> <a id="7091" href="1Lab.Univalence.SIP.html#7091" class="Bound">X</a> <a id="7093" class="Symbol">→</a> <a id="7095" href="1Lab.Univalence.SIP.html#7091" class="Bound">X</a><a id="7096" class="Symbol">)</a>
<a data-type="Structure ℓ (λ X → X)" id="7098" href="1Lab.Univalence.SIP.html#7063" class="Function">pointedStr</a> <a id="7109" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B₁ : Σ S₁) → A .fst ≃ B₁ .fst → Type ℓ₃" id="7110" href="1Lab.Univalence.SIP.html#2879" class="Field">is-hom</a> <a id="7117" class="Symbol">(</a><a id="7118" href="1Lab.Univalence.SIP.html#7118" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="7120" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7122" href="1Lab.Univalence.SIP.html#7122" class="Bound">x</a><a id="7123" class="Symbol">)</a> <a id="7125" class="Symbol">(</a><a id="7126" href="1Lab.Univalence.SIP.html#7126" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="7128" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7130" href="1Lab.Univalence.SIP.html#7130" class="Bound">y</a><a id="7131" class="Symbol">)</a> <a id="7133" href="1Lab.Univalence.SIP.html#7133" class="Bound">f</a> <a id="7135" class="Symbol">=</a> <a id="7137" href="1Lab.Univalence.SIP.html#7133" class="Bound">f</a> <a id="7139" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="7140" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="7144" href="1Lab.Univalence.SIP.html#7122" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="7146" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="7148" href="1Lab.Univalence.SIP.html#7130" class="Bound">y</a>
</pre>
<p>This is univalent by <span class="Agda"><a data-type="(e : A ≃ B₁) → (e .fst x ≡ y) ≃ PathP (λ i → ua e i) x y" href="1Lab.Univalence.html#14307" class="Function">uaPathP≃Path</a></span>, which says <code>PathP (ua f) x y</code> is equivalent to <code>f .fst x ≡ y</code>.</p>
<pre class="Agda"><a id="pointedStr-univalent"></a><a data-type="isUnivalent pointedStr" id="7271" href="1Lab.Univalence.SIP.html#7271" class="Function">pointedStr-univalent</a> <a id="7292" class="Symbol">:</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="7294" href="1Lab.Univalence.SIP.html#3849" class="Function">isUnivalent</a> <a id="7306" class="Symbol">(</a><a data-type="Structure ℓ (λ X → X)" id="7307" href="1Lab.Univalence.SIP.html#7063" class="Function">pointedStr</a> <a id="7318" class="Symbol">{</a><a id="7319" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a><a id="7320" class="Symbol">})</a>
<a data-type="isUnivalent pointedStr" id="7323" href="1Lab.Univalence.SIP.html#7271" class="Function">pointedStr-univalent</a> <a id="7344" href="1Lab.Univalence.SIP.html#7344" class="Bound">f</a> <a id="7346" class="Symbol">=</a> <a data-type="(e : A ≃ B₁) → (e .fst x ≡ y) ≃ PathP (λ i → ua e i) x y" id="7348" href="1Lab.Univalence.html#14307" class="Function">uaPathP≃Path</a> <a id="7361" class="Symbol">_</a>
</pre>
<p>If <code>S</code> and <code>T</code> are univalent structures, then so is their pointwise product. The notion of a <code>S × T</code>-homomorphism is that of a function homomorphic for both <code>S</code> and <code>T</code>, simultaneously:</p>
<pre class="Agda"><a id="productStr"></a><a data-type="Structure ℓ S₁ →
Structure ℓ₂ T → Structure (ℓ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="7563" href="1Lab.Univalence.SIP.html#7563" class="Function">productStr</a> <a id="7574" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="7576" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a> <a id="7586" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a> <a id="7588" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a> <a id="7590" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="7592" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a> <a id="7602" href="1Lab.Univalence.SIP.html#3462" class="Generalizable">ℓ₂</a> <a id="7605" href="1Lab.Univalence.SIP.html#3493" class="Generalizable">T</a> <a id="7607" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="7609" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a> <a id="7619" class="Symbol">_</a> <a id="7621" class="Symbol">(λ</a> <a id="7624" href="1Lab.Univalence.SIP.html#7624" class="Bound">X</a> <a id="7626" class="Symbol">→</a> <a id="7628" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a> <a id="7630" href="1Lab.Univalence.SIP.html#7624" class="Bound">X</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="7632" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="7634" href="1Lab.Univalence.SIP.html#3493" class="Generalizable">T</a> <a id="7636" href="1Lab.Univalence.SIP.html#7624" class="Bound">X</a><a id="7637" class="Symbol">)</a>
<a data-type="Structure ℓ S₁ →
Structure ℓ₂ T → Structure (ℓ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="7639" href="1Lab.Univalence.SIP.html#7563" class="Function">productStr</a> <a id="7650" href="1Lab.Univalence.SIP.html#7650" class="Bound">S</a> <a id="7652" href="1Lab.Univalence.SIP.html#7652" class="Bound">T</a> <a id="7654" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B₁ : Σ S₁) → A .fst ≃ B₁ .fst → Type ℓ₃" id="7655" href="1Lab.Univalence.SIP.html#2879" class="Field">is-hom</a> <a id="7662" class="Symbol">(</a><a id="7663" href="1Lab.Univalence.SIP.html#7663" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="7665" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7667" href="1Lab.Univalence.SIP.html#7667" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="7669" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7671" href="1Lab.Univalence.SIP.html#7671" class="Bound">y</a><a id="7672" class="Symbol">)</a> <a id="7674" class="Symbol">(</a><a id="7675" href="1Lab.Univalence.SIP.html#7675" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="7677" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7679" href="1Lab.Univalence.SIP.html#7679" class="Bound">x&#39;</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="7682" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7684" href="1Lab.Univalence.SIP.html#7684" class="Bound">y&#39;</a><a id="7686" class="Symbol">)</a> <a id="7688" href="1Lab.Univalence.SIP.html#7688" class="Bound">f</a> <a id="7690" class="Symbol">=</a>
  <a id="7694" href="1Lab.Univalence.SIP.html#7650" class="Bound">S</a> <a id="7696" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B₁ : Σ S₁) → A .fst ≃ B₁ .fst → Type ℓ₃" id="7697" href="1Lab.Univalence.SIP.html#2879" class="Field">is-hom</a> <a id="7704" class="Symbol">(</a><a id="7705" href="1Lab.Univalence.SIP.html#7663" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="7707" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7709" href="1Lab.Univalence.SIP.html#7667" class="Bound">x</a><a id="7710" class="Symbol">)</a> <a id="7712" class="Symbol">(</a><a id="7713" href="1Lab.Univalence.SIP.html#7675" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="7715" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7717" href="1Lab.Univalence.SIP.html#7679" class="Bound">x&#39;</a><a id="7719" class="Symbol">)</a> <a id="7721" href="1Lab.Univalence.SIP.html#7688" class="Bound">f</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="7723" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="7725" href="1Lab.Univalence.SIP.html#7652" class="Bound">T</a> <a id="7727" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B₁ : Σ S₁) → A .fst ≃ B₁ .fst → Type ℓ₃" id="7728" href="1Lab.Univalence.SIP.html#2879" class="Field">is-hom</a> <a id="7735" class="Symbol">(</a><a id="7736" href="1Lab.Univalence.SIP.html#7663" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="7738" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7740" href="1Lab.Univalence.SIP.html#7671" class="Bound">y</a><a id="7741" class="Symbol">)</a> <a id="7743" class="Symbol">(</a><a id="7744" href="1Lab.Univalence.SIP.html#7675" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="7746" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7748" href="1Lab.Univalence.SIP.html#7684" class="Bound">y&#39;</a><a id="7750" class="Symbol">)</a> <a id="7752" href="1Lab.Univalence.SIP.html#7688" class="Bound">f</a>

<a id="productStr-univalent"></a><a data-type="isUnivalent σ → isUnivalent τ → isUnivalent (productStr σ τ)" id="7755" href="1Lab.Univalence.SIP.html#7755" class="Function">productStr-univalent</a> <a id="7776" class="Symbol">:</a> <a id="7778" class="Symbol">{</a><a id="7779" href="1Lab.Univalence.SIP.html#7779" class="Bound">σ</a> <a id="7781" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="7783" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a> <a id="7793" href="1Lab.Univalence.SIP.html#3459" class="Generalizable">ℓ₁</a> <a id="7796" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a><a id="7797" class="Symbol">}</a> <a id="7799" class="Symbol">{</a><a id="7800" href="1Lab.Univalence.SIP.html#7800" class="Bound">τ</a> <a id="7802" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="7804" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a> <a id="7814" href="1Lab.Univalence.SIP.html#3462" class="Generalizable">ℓ₂</a> <a id="7817" href="1Lab.Univalence.SIP.html#3493" class="Generalizable">T</a><a id="7818" class="Symbol">}</a>
                     <a id="7841" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="7843" href="1Lab.Univalence.SIP.html#3849" class="Function">isUnivalent</a> <a id="7855" href="1Lab.Univalence.SIP.html#7779" class="Bound">σ</a> <a id="7857" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="7859" href="1Lab.Univalence.SIP.html#3849" class="Function">isUnivalent</a> <a id="7871" href="1Lab.Univalence.SIP.html#7800" class="Bound">τ</a>
                     <a id="7894" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="7896" href="1Lab.Univalence.SIP.html#3849" class="Function">isUnivalent</a> <a id="7908" class="Symbol">(</a><a data-type="Structure ℓ S₁ →
Structure ℓ₂ T → Structure (ℓ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="7909" href="1Lab.Univalence.SIP.html#7563" class="Function">productStr</a> <a id="7920" href="1Lab.Univalence.SIP.html#7779" class="Bound">σ</a> <a id="7922" href="1Lab.Univalence.SIP.html#7800" class="Bound">τ</a><a id="7923" class="Symbol">)</a>
<a data-type="isUnivalent σ → isUnivalent τ → isUnivalent (productStr σ τ)" id="7925" href="1Lab.Univalence.SIP.html#7755" class="Function">productStr-univalent</a> <a id="7946" class="Symbol">{</a><a id="7947" class="Argument">S</a> <a id="7949" class="Symbol">=</a> <a id="7951" href="1Lab.Univalence.SIP.html#7951" class="Bound">S</a><a id="7952" class="Symbol">}</a> <a id="7954" class="Symbol">{</a><a id="7955" class="Argument">T</a> <a id="7957" class="Symbol">=</a> <a id="7959" href="1Lab.Univalence.SIP.html#7959" class="Bound">T</a><a id="7960" class="Symbol">}</a> <a id="7962" class="Symbol">{</a><a id="7963" class="Argument">σ</a> <a id="7965" class="Symbol">=</a> <a id="7967" href="1Lab.Univalence.SIP.html#7967" class="Bound">σ</a><a id="7968" class="Symbol">}</a> <a id="7970" class="Symbol">{</a><a id="7971" href="1Lab.Univalence.SIP.html#7971" class="Bound">τ</a><a id="7972" class="Symbol">}</a> <a id="7974" href="1Lab.Univalence.SIP.html#7974" class="Bound">θ₁</a> <a id="7977" href="1Lab.Univalence.SIP.html#7977" class="Bound">θ₂</a> <a id="7980" class="Symbol">{</a><a id="7981" href="1Lab.Univalence.SIP.html#7981" class="Bound">X</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="7983" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7985" href="1Lab.Univalence.SIP.html#7985" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="7987" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7989" href="1Lab.Univalence.SIP.html#7989" class="Bound">y</a><a id="7990" class="Symbol">}</a> <a id="7992" class="Symbol">{</a><a id="7993" href="1Lab.Univalence.SIP.html#7993" class="Bound">Y</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="7995" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7997" href="1Lab.Univalence.SIP.html#7997" class="Bound">x&#39;</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="8000" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8002" href="1Lab.Univalence.SIP.html#8002" class="Bound">y&#39;</a><a id="8004" class="Symbol">}</a> <a id="8006" href="1Lab.Univalence.SIP.html#8006" class="Bound">f</a> <a id="8008" class="Symbol">=</a>
  <a id="8012" class="Symbol">(</a><a id="8013" href="1Lab.Univalence.SIP.html#7967" class="Bound">σ</a> <a id="8015" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B₁ : Σ S₁) → A .fst ≃ B₁ .fst → Type ℓ₃" id="8016" href="1Lab.Univalence.SIP.html#2879" class="Field">is-hom</a> <a id="8023" class="Symbol">(</a><a id="8024" href="1Lab.Univalence.SIP.html#7981" class="Bound">X</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="8026" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8028" href="1Lab.Univalence.SIP.html#7985" class="Bound">x</a><a id="8029" class="Symbol">)</a> <a id="8031" class="Symbol">(</a><a id="8032" href="1Lab.Univalence.SIP.html#7993" class="Bound">Y</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="8034" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8036" href="1Lab.Univalence.SIP.html#7997" class="Bound">x&#39;</a><a id="8038" class="Symbol">)</a> <a id="8040" class="Symbol">_</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="8042" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="8044" href="1Lab.Univalence.SIP.html#7971" class="Bound">τ</a> <a id="8046" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B₁ : Σ S₁) → A .fst ≃ B₁ .fst → Type ℓ₃" id="8047" href="1Lab.Univalence.SIP.html#2879" class="Field">is-hom</a> <a id="8054" class="Symbol">(</a><a id="8055" href="1Lab.Univalence.SIP.html#7981" class="Bound">X</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="8057" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8059" href="1Lab.Univalence.SIP.html#7989" class="Bound">y</a><a id="8060" class="Symbol">)</a> <a id="8062" class="Symbol">(</a><a id="8063" href="1Lab.Univalence.SIP.html#7993" class="Bound">Y</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="8065" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8067" href="1Lab.Univalence.SIP.html#8002" class="Bound">y&#39;</a><a id="8069" class="Symbol">)</a> <a id="8071" class="Symbol">_)</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" id="8074" href="1Lab.Equiv.html#22842" class="Function Operator">≃⟨</a> <a data-type="(e : A ≃ A&#39;) → ((x : A) → P x ≃ Q (e .fst x)) → Σ P ≃ Σ Q" id="8077" href="1Lab.Type.Sigma.html#2110" class="Function">Σ-ap</a> <a id="8082" class="Symbol">(</a><a id="8083" href="1Lab.Univalence.SIP.html#7974" class="Bound">θ₁</a> <a id="8086" href="1Lab.Univalence.SIP.html#8006" class="Bound">f</a><a id="8087" class="Symbol">)</a> <a id="8089" class="Symbol">(λ</a> <a id="8092" href="1Lab.Univalence.SIP.html#8092" class="Bound">_</a> <a id="8094" class="Symbol">→</a> <a id="8096" href="1Lab.Univalence.SIP.html#7977" class="Bound">θ₂</a> <a id="8099" href="1Lab.Univalence.SIP.html#8006" class="Bound">f</a><a id="8100" class="Symbol">)</a> <a data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" id="8102" href="1Lab.Equiv.html#22842" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a id="8106" class="Symbol">(</a><a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="8107" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="8113" class="Symbol">_</a> <a id="8115" class="Symbol">_</a> <a id="8117" class="Symbol">_</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="8119" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="8121" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="8127" class="Symbol">_</a> <a id="8129" class="Symbol">_</a> <a id="8131" class="Symbol">_)</a>                                   <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" id="8168" href="1Lab.Equiv.html#22842" class="Function Operator">≃⟨</a> <a data-type="Iso A B₁ → A ≃ B₁" id="8171" href="1Lab.Equiv.html#20100" class="Function">Iso→Equiv</a> <a data-type="Iso (Σ (λ p → PathP (λ i → B₁ i (p i)) (x .snd) (y .snd)))
(PathP (λ i → Σ (B₁ i)) x y)" id="8181" href="1Lab.Type.Sigma.html#553" class="Function">Σ-PathP-iso</a> <a data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" id="8193" href="1Lab.Equiv.html#22842" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="8197" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="8203" class="Symbol">(λ</a> <a id="8206" href="1Lab.Univalence.SIP.html#8206" class="Bound">i</a> <a id="8208" class="Symbol">→</a> <a id="8210" href="1Lab.Univalence.SIP.html#7951" class="Bound">S</a> <a id="8212" class="Symbol">(</a><a data-type="A ≃ B₁ → A ≡ B₁" id="8213" href="1Lab.Univalence.html#8828" class="Function">ua</a> <a id="8216" href="1Lab.Univalence.SIP.html#8006" class="Bound">f</a> <a id="8218" href="1Lab.Univalence.SIP.html#8206" class="Bound">i</a><a id="8219" class="Symbol">)</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="8221" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="8223" href="1Lab.Univalence.SIP.html#7959" class="Bound">T</a> <a id="8225" class="Symbol">(</a><a data-type="A ≃ B₁ → A ≡ B₁" id="8226" href="1Lab.Univalence.html#8828" class="Function">ua</a> <a id="8229" href="1Lab.Univalence.SIP.html#8006" class="Bound">f</a> <a id="8231" href="1Lab.Univalence.SIP.html#8206" class="Bound">i</a><a id="8232" class="Symbol">))</a> <a id="8235" class="Symbol">(</a><a id="8236" href="1Lab.Univalence.SIP.html#7985" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="8238" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8240" href="1Lab.Univalence.SIP.html#7989" class="Bound">y</a><a id="8241" class="Symbol">)</a> <a id="8243" class="Symbol">(</a><a id="8244" href="1Lab.Univalence.SIP.html#7997" class="Bound">x&#39;</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="8247" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8249" href="1Lab.Univalence.SIP.html#8002" class="Bound">y&#39;</a><a id="8251" class="Symbol">)</a>       <a data-type="(A : Type ℓ) → A ≃ A" id="8259" href="1Lab.Equiv.html#23033" class="Function Operator">≃∎</a>
</pre>
<p>If <code>S</code> and <code>T</code> are univalent structures, then so are the families of functions between them. For reasons we’ll see below, this is called <span class="Agda"><a data-type="Structure ℓ₁ S₁ →
Structure ℓ₂ T → Structure (ℓ₁ ⊔ S.ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" href="1Lab.Univalence.SIP.html#8498" class="Function">Str-functionStr</a></span> (a rather redundant name!) instead of <span class="Agda"><a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" href="1Lab.Univalence.SIP.html#16946" class="Function">functionStr</a></span>.</p>
<pre class="Agda"><a id="Str-functionStr"></a><a data-type="Structure ℓ₁ S₁ →
Structure ℓ₂ T → Structure (ℓ₁ ⊔ S.ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="8498" href="1Lab.Univalence.SIP.html#8498" class="Function">Str-functionStr</a> <a id="8514" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="8516" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a> <a id="8526" href="1Lab.Univalence.SIP.html#3459" class="Generalizable">ℓ₁</a> <a id="8529" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a> <a id="8531" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="8533" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a> <a id="8543" href="1Lab.Univalence.SIP.html#3462" class="Generalizable">ℓ₂</a> <a id="8546" href="1Lab.Univalence.SIP.html#3493" class="Generalizable">T</a> <a id="8548" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="8550" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a> <a id="8560" class="Symbol">_</a> <a id="8562" class="Symbol">(λ</a> <a id="8565" href="1Lab.Univalence.SIP.html#8565" class="Bound">X</a> <a id="8567" class="Symbol">→</a> <a id="8569" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a> <a id="8571" href="1Lab.Univalence.SIP.html#8565" class="Bound">X</a> <a id="8573" class="Symbol">→</a> <a id="8575" href="1Lab.Univalence.SIP.html#3493" class="Generalizable">T</a> <a id="8577" href="1Lab.Univalence.SIP.html#8565" class="Bound">X</a><a id="8578" class="Symbol">)</a>
<a data-type="Structure ℓ₁ S₁ →
Structure ℓ₂ T → Structure (ℓ₁ ⊔ S.ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="8580" href="1Lab.Univalence.SIP.html#8498" class="Function">Str-functionStr</a> <a id="8596" class="Symbol">{</a><a id="8597" class="Argument">S</a> <a id="8599" class="Symbol">=</a> <a id="8601" href="1Lab.Univalence.SIP.html#8601" class="Bound">S</a><a id="8602" class="Symbol">}</a> <a id="8604" href="1Lab.Univalence.SIP.html#8604" class="Bound">σ</a> <a id="8606" href="1Lab.Univalence.SIP.html#8606" class="Bound">τ</a> <a id="8608" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B₁ : Σ S₁) → A .fst ≃ B₁ .fst → Type ℓ₃" id="8609" href="1Lab.Univalence.SIP.html#2879" class="Field">is-hom</a> <a id="8616" class="Symbol">(</a><a id="8617" href="1Lab.Univalence.SIP.html#8617" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="8619" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8621" href="1Lab.Univalence.SIP.html#8621" class="Bound">f</a><a id="8622" class="Symbol">)</a> <a id="8624" class="Symbol">(</a><a id="8625" href="1Lab.Univalence.SIP.html#8625" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="8627" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8629" href="1Lab.Univalence.SIP.html#8629" class="Bound">g</a><a id="8630" class="Symbol">)</a> <a id="8632" href="1Lab.Univalence.SIP.html#8632" class="Bound">h</a> <a id="8634" class="Symbol">=</a>
  <a id="8638" class="Symbol">{</a><a id="8639" href="1Lab.Univalence.SIP.html#8639" class="Bound">s</a> <a id="8641" class="Symbol">:</a> <a id="8643" href="1Lab.Univalence.SIP.html#8601" class="Bound">S</a> <a id="8645" href="1Lab.Univalence.SIP.html#8617" class="Bound">A</a><a id="8646" class="Symbol">}</a> <a id="8648" class="Symbol">{</a><a id="8649" href="1Lab.Univalence.SIP.html#8649" class="Bound">t</a> <a id="8651" class="Symbol">:</a> <a id="8653" href="1Lab.Univalence.SIP.html#8601" class="Bound">S</a> <a id="8655" href="1Lab.Univalence.SIP.html#8625" class="Bound">B</a><a id="8656" class="Symbol">}</a> <a id="8658" class="Symbol">→</a> <a id="8660" href="1Lab.Univalence.SIP.html#8604" class="Bound">σ</a> <a id="8662" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B₁ : Σ S₁) → A .fst ≃ B₁ .fst → Type ℓ₃" id="8663" href="1Lab.Univalence.SIP.html#2879" class="Field">is-hom</a> <a id="8670" class="Symbol">(</a><a id="8671" href="1Lab.Univalence.SIP.html#8617" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="8673" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8675" href="1Lab.Univalence.SIP.html#8639" class="Bound">s</a><a id="8676" class="Symbol">)</a> <a id="8678" class="Symbol">(</a><a id="8679" href="1Lab.Univalence.SIP.html#8625" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="8681" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8683" href="1Lab.Univalence.SIP.html#8649" class="Bound">t</a><a id="8684" class="Symbol">)</a> <a id="8686" href="1Lab.Univalence.SIP.html#8632" class="Bound">h</a>
                      <a id="8710" class="Symbol">→</a> <a id="8712" href="1Lab.Univalence.SIP.html#8606" class="Bound">τ</a> <a id="8714" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B₁ : Σ S₁) → A .fst ≃ B₁ .fst → Type ℓ₃" id="8715" href="1Lab.Univalence.SIP.html#2879" class="Field">is-hom</a> <a id="8722" class="Symbol">(</a><a id="8723" href="1Lab.Univalence.SIP.html#8617" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="8725" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8727" href="1Lab.Univalence.SIP.html#8621" class="Bound">f</a> <a id="8729" href="1Lab.Univalence.SIP.html#8639" class="Bound">s</a><a id="8730" class="Symbol">)</a> <a id="8732" class="Symbol">(</a><a id="8733" href="1Lab.Univalence.SIP.html#8625" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="8735" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8737" href="1Lab.Univalence.SIP.html#8629" class="Bound">g</a> <a id="8739" href="1Lab.Univalence.SIP.html#8649" class="Bound">t</a><a id="8740" class="Symbol">)</a> <a id="8742" href="1Lab.Univalence.SIP.html#8632" class="Bound">h</a>

<a id="Str-functionStr-univalent"></a><a data-type="isUnivalent σ → isUnivalent τ → isUnivalent (Str-functionStr σ τ)" id="8745" href="1Lab.Univalence.SIP.html#8745" class="Function">Str-functionStr-univalent</a> <a id="8771" class="Symbol">:</a> <a id="8773" class="Symbol">{</a><a id="8774" href="1Lab.Univalence.SIP.html#8774" class="Bound">σ</a> <a id="8776" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="8778" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a> <a id="8788" href="1Lab.Univalence.SIP.html#3459" class="Generalizable">ℓ₁</a> <a id="8791" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a><a id="8792" class="Symbol">}</a> <a id="8794" class="Symbol">{</a><a id="8795" href="1Lab.Univalence.SIP.html#8795" class="Bound">τ</a> <a id="8797" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="8799" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a> <a id="8809" href="1Lab.Univalence.SIP.html#3462" class="Generalizable">ℓ₂</a> <a id="8812" href="1Lab.Univalence.SIP.html#3493" class="Generalizable">T</a><a id="8813" class="Symbol">}</a>
                          <a id="8841" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="8843" href="1Lab.Univalence.SIP.html#3849" class="Function">isUnivalent</a> <a id="8855" href="1Lab.Univalence.SIP.html#8774" class="Bound">σ</a> <a id="8857" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="8859" href="1Lab.Univalence.SIP.html#3849" class="Function">isUnivalent</a> <a id="8871" href="1Lab.Univalence.SIP.html#8795" class="Bound">τ</a>
                          <a id="8899" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="8901" href="1Lab.Univalence.SIP.html#3849" class="Function">isUnivalent</a> <a id="8913" class="Symbol">(</a><a data-type="Structure ℓ₁ S₁ →
Structure ℓ₂ T → Structure (ℓ₁ ⊔ S.ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="8914" href="1Lab.Univalence.SIP.html#8498" class="Function">Str-functionStr</a> <a id="8930" href="1Lab.Univalence.SIP.html#8774" class="Bound">σ</a> <a id="8932" href="1Lab.Univalence.SIP.html#8795" class="Bound">τ</a><a id="8933" class="Symbol">)</a>
<a data-type="isUnivalent σ → isUnivalent τ → isUnivalent (Str-functionStr σ τ)" id="8935" href="1Lab.Univalence.SIP.html#8745" class="Function">Str-functionStr-univalent</a> <a id="8961" class="Symbol">{</a><a id="8962" class="Argument">S</a> <a id="8964" class="Symbol">=</a> <a id="8966" href="1Lab.Univalence.SIP.html#8966" class="Bound">S</a><a id="8967" class="Symbol">}</a> <a id="8969" class="Symbol">{</a><a id="8970" class="Argument">T</a> <a id="8972" class="Symbol">=</a> <a id="8974" href="1Lab.Univalence.SIP.html#8974" class="Bound">T</a><a id="8975" class="Symbol">}</a> <a id="8977" class="Symbol">{</a><a id="8978" class="Argument">σ</a> <a id="8980" class="Symbol">=</a> <a id="8982" href="1Lab.Univalence.SIP.html#8982" class="Bound">σ</a><a id="8983" class="Symbol">}</a> <a id="8985" class="Symbol">{</a><a id="8986" href="1Lab.Univalence.SIP.html#8986" class="Bound">τ</a><a id="8987" class="Symbol">}</a> <a id="8989" href="1Lab.Univalence.SIP.html#8989" class="Bound">θ₁</a> <a id="8992" href="1Lab.Univalence.SIP.html#8992" class="Bound">θ₂</a> <a id="8995" href="1Lab.Univalence.SIP.html#8995" class="Bound">eqv</a> <a id="8999" class="Symbol">=</a>
  <a data-type="((x : A) → P x ≃ Q x) → ({x : A} → P x) ≃ ({x : A} → Q x)" id="9003" href="1Lab.Type.Pi.html#1118" class="Function">Π-impl-cod≃</a> <a id="9015" class="Symbol">(λ</a> <a id="9018" href="1Lab.Univalence.SIP.html#9018" class="Bound">s</a> <a id="9020" class="Symbol">→</a> <a data-type="((x : A) → P x ≃ Q x) → ({x : A} → P x) ≃ ({x : A} → Q x)" id="9022" href="1Lab.Type.Pi.html#1118" class="Function">Π-impl-cod≃</a> <a id="9034" class="Symbol">λ</a> <a id="9036" href="1Lab.Univalence.SIP.html#9036" class="Bound">t</a> <a id="9038" class="Symbol">→</a> <a data-type="A ≃ B₁ → C ≃ D → (A → C) ≃ (B₁ → D)" id="9040" href="1Lab.Type.Pi.html#1721" class="Function">function≃</a> <a id="9050" class="Symbol">(</a><a id="9051" href="1Lab.Univalence.SIP.html#8989" class="Bound">θ₁</a> <a id="9054" href="1Lab.Univalence.SIP.html#8995" class="Bound">eqv</a><a id="9057" class="Symbol">)</a> <a id="9059" class="Symbol">(</a><a id="9060" href="1Lab.Univalence.SIP.html#8992" class="Bound">θ₂</a> <a id="9063" href="1Lab.Univalence.SIP.html#8995" class="Bound">eqv</a><a id="9066" class="Symbol">))</a> <a data-type="A ≃ B₁ → B₁ ≃ C → A ≃ C" id="9069" href="1Lab.Equiv.html#21166" class="Function Operator">∙e</a> <a data-type="({x₀ : A i0} {x₁ : A i1} (p : PathP A x₀ x₁) →
 PathP (λ i → B₁ i (p i)) (f x₀) (g x₁))
≃ PathP (λ i → (x : A i) → B₁ i x) f g" id="9072" href="1Lab.Type.Pi.html#3103" class="Function">funextDep≃</a>
</pre>
<h2 id="example-infty-magmas"><a href="#example-infty-magmas" class="header-link">Example: <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>-magmas</span><span class="header-link-emoji">🔗</span></a></h2>
<p>We provide an example of applying the SIP, and the structure combinators: <strong><span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>-magmas</span></strong>. Recall that a <a href="https://ncatlab.org/nlab/show/magma">magma</a> is a <a data-type="(ℓ : Level) → Type (lsuc ℓ)" href="1Lab.HLevel.html#3398">Set</a> equipped with a binary operation, with no further conditions imposed. In HoTT, we can relax this even further: An <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>-magma</span> is a <span class="Agda"><a href="1Lab.Type.html#394" class="Primitive">Type</a></span> - that is, an <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>-groupoid</span> - equipped with a binary operation.</p>
<pre class="Agda"><a id="9546" class="Keyword">private</a>
  <a id="binop"></a><a id="9556" href="1Lab.Univalence.SIP.html#9556" class="Function">binop</a> <a id="9562" class="Symbol">:</a> <a id="9564" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="9569" class="Symbol">→</a> <a id="9571" href="1Lab.Type.html#394" class="Primitive">Type</a>
  <a id="9578" href="1Lab.Univalence.SIP.html#9556" class="Function">binop</a> <a id="9584" href="1Lab.Univalence.SIP.html#9584" class="Bound">X</a> <a id="9586" class="Symbol">=</a> <a id="9588" href="1Lab.Univalence.SIP.html#9584" class="Bound">X</a> <a id="9590" class="Symbol">→</a> <a id="9592" href="1Lab.Univalence.SIP.html#9584" class="Bound">X</a> <a id="9594" class="Symbol">→</a> <a id="9596" href="1Lab.Univalence.SIP.html#9584" class="Bound">X</a>
</pre>
<p>We can impose a <span class="Agda"><a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a></span> on <span class="Agda"><a href="1Lab.Univalence.SIP.html#9556" class="Function">binop</a></span> by applying nested <span class="Agda"><a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" href="1Lab.Univalence.SIP.html#16946" class="Function">functionStr</a></span> and <span class="Agda"><a data-type="Structure ℓ (λ X → X)" href="1Lab.Univalence.SIP.html#7063" class="Function">pointedStr</a></span>. Since this structure is built out of structure combinators, it’s automatically univalent:</p>
<pre class="Agda">  <a id="∞-Magma"></a><a id="9822" href="1Lab.Univalence.SIP.html#9822" class="Function">∞-Magma</a> <a id="9830" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="9832" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a> <a data-type="Level" id="9842" href="Agda.Primitive.html#764" class="Primitive">lzero</a> <a id="9848" href="1Lab.Univalence.SIP.html#9556" class="Function">binop</a>
  <a id="9856" href="1Lab.Univalence.SIP.html#9822" class="Function">∞-Magma</a> <a id="9864" class="Symbol">=</a> <a data-type="Structure ℓ₁ S₁ →
Structure ℓ₂ T → Structure (ℓ₁ ⊔ S.ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="9866" href="1Lab.Univalence.SIP.html#8498" class="Function">Str-functionStr</a> <a data-type="Structure ℓ (λ X → X)" id="9882" href="1Lab.Univalence.SIP.html#7063" class="Function">pointedStr</a> <a id="9893" class="Symbol">(</a><a data-type="Structure ℓ₁ S₁ →
Structure ℓ₂ T → Structure (ℓ₁ ⊔ S.ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="9894" href="1Lab.Univalence.SIP.html#8498" class="Function">Str-functionStr</a> <a data-type="Structure ℓ (λ X → X)" id="9910" href="1Lab.Univalence.SIP.html#7063" class="Function">pointedStr</a> <a data-type="Structure ℓ (λ X → X)" id="9921" href="1Lab.Univalence.SIP.html#7063" class="Function">pointedStr</a><a id="9931" class="Symbol">)</a>

  <a id="∞-Magma-univ"></a><a id="9936" href="1Lab.Univalence.SIP.html#9936" class="Function">∞-Magma-univ</a> <a id="9949" class="Symbol">:</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="9951" href="1Lab.Univalence.SIP.html#3849" class="Function">isUnivalent</a> <a id="9963" href="1Lab.Univalence.SIP.html#9822" class="Function">∞-Magma</a>
  <a id="9973" href="1Lab.Univalence.SIP.html#9936" class="Function">∞-Magma-univ</a> <a id="9986" class="Symbol">=</a>
    <a data-type="isUnivalent σ → isUnivalent τ → isUnivalent (Str-functionStr σ τ)" id="9992" href="1Lab.Univalence.SIP.html#8745" class="Function">Str-functionStr-univalent</a> <a id="10018" class="Symbol">{</a><a id="10019" class="Argument">τ</a> <a id="10021" class="Symbol">=</a> <a data-type="Structure ℓ₁ S₁ →
Structure ℓ₂ T → Structure (ℓ₁ ⊔ S.ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="10023" href="1Lab.Univalence.SIP.html#8498" class="Function">Str-functionStr</a> <a data-type="Structure ℓ (λ X → X)" id="10039" href="1Lab.Univalence.SIP.html#7063" class="Function">pointedStr</a> <a data-type="Structure ℓ (λ X → X)" id="10050" href="1Lab.Univalence.SIP.html#7063" class="Function">pointedStr</a><a id="10060" class="Symbol">}</a>
      <a data-type="isUnivalent pointedStr" id="10068" href="1Lab.Univalence.SIP.html#7271" class="Function">pointedStr-univalent</a>
      <a id="10095" class="Symbol">(</a><a data-type="isUnivalent σ → isUnivalent τ → isUnivalent (Str-functionStr σ τ)" id="10096" href="1Lab.Univalence.SIP.html#8745" class="Function">Str-functionStr-univalent</a> <a id="10122" class="Symbol">{</a><a id="10123" class="Argument">τ</a> <a id="10125" class="Symbol">=</a> <a data-type="Structure ℓ (λ X → X)" id="10127" href="1Lab.Univalence.SIP.html#7063" class="Function">pointedStr</a><a id="10137" class="Symbol">}</a>
        <a data-type="isUnivalent pointedStr" id="10147" href="1Lab.Univalence.SIP.html#7271" class="Function">pointedStr-univalent</a>
        <a data-type="isUnivalent pointedStr" id="10176" href="1Lab.Univalence.SIP.html#7271" class="Function">pointedStr-univalent</a><a id="10196" class="Symbol">)</a>
</pre>
<p>The type of <span class="Agda"><a href="1Lab.Univalence.SIP.html#9822" class="Function">∞-Magma</a></span> homomorphisms generated by this equivalence is slightly inconvenient: Instead of getting <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo>⋆</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mi>x</mi><mo>∗</mo><mi>f</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">f (x \star y) = f x * f y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋆</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>,</span> we get something that is parameterised over two paths:</p>
<pre class="Agda">  <a id="10416" href="1Lab.Univalence.SIP.html#10416" class="Function">_</a> <a id="10418" class="Symbol">:</a> <a id="10420" class="Symbol">{</a><a id="10421" href="1Lab.Univalence.SIP.html#10421" class="Bound">A</a> <a id="10423" href="1Lab.Univalence.SIP.html#10423" class="Bound">B</a> <a id="10425" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="10427" href="1Lab.Univalence.SIP.html#3323" class="Function">TypeWith</a> <a id="10436" href="1Lab.Univalence.SIP.html#9822" class="Function">∞-Magma</a><a id="10443" class="Symbol">}</a> <a id="10445" class="Symbol">{</a><a id="10446" href="1Lab.Univalence.SIP.html#10446" class="Bound">f</a> <a id="10448" class="Symbol">:</a> <a id="10450" href="1Lab.Univalence.SIP.html#10421" class="Bound">A</a> <a id="10452" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="10453" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="10457" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="10459" href="1Lab.Univalence.SIP.html#10423" class="Bound">B</a> <a id="10461" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="10462" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="10465" class="Symbol">}</a>
    <a id="10471" class="Symbol">→</a> <a id="10473" href="1Lab.Univalence.SIP.html#9822" class="Function">∞-Magma</a> <a id="10481" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B₁ : Σ S₁) → A .fst ≃ B₁ .fst → Type ℓ₃" id="10482" href="1Lab.Univalence.SIP.html#2879" class="Field">is-hom</a> <a id="10489" href="1Lab.Univalence.SIP.html#10421" class="Bound">A</a> <a id="10491" href="1Lab.Univalence.SIP.html#10423" class="Bound">B</a> <a id="10493" href="1Lab.Univalence.SIP.html#10446" class="Bound">f</a>
    <a data-type="A → A → Type ℓ" id="10499" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10501" class="Symbol">(</a> <a id="10503" class="Symbol">{</a><a id="10504" href="1Lab.Univalence.SIP.html#10504" class="Bound">s</a> <a id="10506" class="Symbol">:</a> <a id="10508" href="1Lab.Univalence.SIP.html#10421" class="Bound">A</a> <a id="10510" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="10511" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="10514" class="Symbol">}</a> <a id="10516" class="Symbol">{</a><a id="10517" href="1Lab.Univalence.SIP.html#10517" class="Bound">t</a> <a id="10519" class="Symbol">:</a> <a id="10521" href="1Lab.Univalence.SIP.html#10423" class="Bound">B</a> <a id="10523" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="10524" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="10527" class="Symbol">}</a> <a id="10529" class="Symbol">→</a> <a id="10531" href="1Lab.Univalence.SIP.html#10446" class="Bound">f</a> <a id="10533" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="10534" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10538" href="1Lab.Univalence.SIP.html#10504" class="Bound">s</a> <a data-type="A → A → Type ℓ" id="10540" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10542" href="1Lab.Univalence.SIP.html#10517" class="Bound">t</a>
      <a id="10550" class="Symbol">→</a> <a id="10552" class="Symbol">{</a><a id="10553" href="1Lab.Univalence.SIP.html#10553" class="Bound">x</a> <a id="10555" class="Symbol">:</a> <a id="10557" href="1Lab.Univalence.SIP.html#10421" class="Bound">A</a> <a id="10559" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="10560" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="10563" class="Symbol">}</a> <a id="10565" class="Symbol">{</a><a id="10566" href="1Lab.Univalence.SIP.html#10566" class="Bound">y</a> <a id="10568" class="Symbol">:</a> <a id="10570" href="1Lab.Univalence.SIP.html#10423" class="Bound">B</a> <a id="10572" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="10573" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="10576" class="Symbol">}</a> <a id="10578" class="Symbol">→</a> <a id="10580" href="1Lab.Univalence.SIP.html#10446" class="Bound">f</a> <a id="10582" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="10583" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10587" href="1Lab.Univalence.SIP.html#10553" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="10589" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10591" href="1Lab.Univalence.SIP.html#10566" class="Bound">y</a>
      <a id="10599" class="Symbol">→</a> <a id="10601" href="1Lab.Univalence.SIP.html#10446" class="Bound">f</a> <a id="10603" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="10604" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10608" class="Symbol">(</a><a id="10609" href="1Lab.Univalence.SIP.html#10421" class="Bound">A</a> <a id="10611" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="10612" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10616" href="1Lab.Univalence.SIP.html#10504" class="Bound">s</a> <a id="10618" href="1Lab.Univalence.SIP.html#10553" class="Bound">x</a><a id="10619" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="10621" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10623" href="1Lab.Univalence.SIP.html#10423" class="Bound">B</a> <a id="10625" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="10626" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10630" href="1Lab.Univalence.SIP.html#10517" class="Bound">t</a> <a id="10632" href="1Lab.Univalence.SIP.html#10566" class="Bound">y</a><a id="10633" class="Symbol">)</a>
  <a id="10637" class="Symbol">_</a> <a id="10639" class="Symbol">=</a> <a data-type="x ≡ x" id="10641" href="1Lab.Path.html#3591" class="Function">refl</a>
</pre>
<p>This condition, although it looks a lot more complicated, is essentially the same as the standard notion:</p>
<pre class="Agda">  <a id="fixup"></a><a id="10768" href="1Lab.Univalence.SIP.html#10768" class="Function">fixup</a> <a id="10774" class="Symbol">:</a> <a id="10776" class="Symbol">{</a><a id="10777" href="1Lab.Univalence.SIP.html#10777" class="Bound">A</a> <a id="10779" href="1Lab.Univalence.SIP.html#10779" class="Bound">B</a> <a id="10781" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="10783" href="1Lab.Univalence.SIP.html#3323" class="Function">TypeWith</a> <a id="10792" href="1Lab.Univalence.SIP.html#9822" class="Function">∞-Magma</a><a id="10799" class="Symbol">}</a> <a id="10801" class="Symbol">{</a><a id="10802" href="1Lab.Univalence.SIP.html#10802" class="Bound">f</a> <a id="10804" class="Symbol">:</a> <a id="10806" href="1Lab.Univalence.SIP.html#10777" class="Bound">A</a> <a id="10808" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="10809" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="10813" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="10815" href="1Lab.Univalence.SIP.html#10779" class="Bound">B</a> <a id="10817" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="10818" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="10821" class="Symbol">}</a>
        <a id="10831" class="Symbol">→</a> <a id="10833" class="Symbol">((</a><a id="10835" href="1Lab.Univalence.SIP.html#10835" class="Bound">x</a> <a id="10837" href="1Lab.Univalence.SIP.html#10837" class="Bound">y</a> <a id="10839" class="Symbol">:</a> <a id="10841" href="1Lab.Univalence.SIP.html#10777" class="Bound">A</a> <a id="10843" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="10844" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="10847" class="Symbol">)</a> <a id="10849" class="Symbol">→</a> <a id="10851" href="1Lab.Univalence.SIP.html#10802" class="Bound">f</a> <a id="10853" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="10854" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10858" class="Symbol">(</a><a id="10859" href="1Lab.Univalence.SIP.html#10777" class="Bound">A</a> <a id="10861" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="10862" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10866" href="1Lab.Univalence.SIP.html#10835" class="Bound">x</a> <a id="10868" href="1Lab.Univalence.SIP.html#10837" class="Bound">y</a><a id="10869" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="10871" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10873" href="1Lab.Univalence.SIP.html#10779" class="Bound">B</a> <a id="10875" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="10876" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10880" class="Symbol">(</a><a id="10881" href="1Lab.Univalence.SIP.html#10802" class="Bound">f</a> <a id="10883" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="10884" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10888" href="1Lab.Univalence.SIP.html#10835" class="Bound">x</a><a id="10889" class="Symbol">)</a> <a id="10891" class="Symbol">(</a><a id="10892" href="1Lab.Univalence.SIP.html#10802" class="Bound">f</a> <a id="10894" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="10895" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10899" href="1Lab.Univalence.SIP.html#10837" class="Bound">y</a><a id="10900" class="Symbol">))</a>
        <a id="10911" class="Symbol">→</a> <a id="10913" href="1Lab.Univalence.SIP.html#9822" class="Function">∞-Magma</a> <a id="10921" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B₁ : Σ S₁) → A .fst ≃ B₁ .fst → Type ℓ₃" id="10922" href="1Lab.Univalence.SIP.html#2879" class="Field">is-hom</a> <a id="10929" href="1Lab.Univalence.SIP.html#10777" class="Bound">A</a> <a id="10931" href="1Lab.Univalence.SIP.html#10779" class="Bound">B</a> <a id="10933" href="1Lab.Univalence.SIP.html#10802" class="Bound">f</a>
  <a id="10937" href="1Lab.Univalence.SIP.html#10768" class="Function">fixup</a> <a id="10943" class="Symbol">{</a><a id="10944" class="Argument">A</a> <a id="10946" class="Symbol">=</a> <a id="10948" href="1Lab.Univalence.SIP.html#10948" class="Bound">A</a><a id="10949" class="Symbol">}</a> <a id="10951" class="Symbol">{</a><a id="10952" href="1Lab.Univalence.SIP.html#10952" class="Bound">B</a><a id="10953" class="Symbol">}</a> <a id="10955" class="Symbol">{</a><a id="10956" href="1Lab.Univalence.SIP.html#10956" class="Bound">f</a><a id="10957" class="Symbol">}</a> <a id="10959" href="1Lab.Univalence.SIP.html#10959" class="Bound">path</a> <a id="10964" class="Symbol">{</a><a id="10965" href="1Lab.Univalence.SIP.html#10965" class="Bound">s</a><a id="10966" class="Symbol">}</a> <a id="10968" class="Symbol">{</a><a id="10969" href="1Lab.Univalence.SIP.html#10969" class="Bound">t</a><a id="10970" class="Symbol">}</a> <a id="10972" href="1Lab.Univalence.SIP.html#10972" class="Bound">p</a> <a id="10974" class="Symbol">{</a><a id="10975" href="1Lab.Univalence.SIP.html#10975" class="Bound">s₁</a><a id="10977" class="Symbol">}</a> <a id="10979" class="Symbol">{</a><a id="10980" href="1Lab.Univalence.SIP.html#10980" class="Bound">t₁</a><a id="10982" class="Symbol">}</a> <a id="10984" href="1Lab.Univalence.SIP.html#10984" class="Bound">q</a> <a id="10986" class="Symbol">=</a>
    <a id="10992" href="1Lab.Univalence.SIP.html#10956" class="Bound">f</a> <a id="10994" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="10995" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10999" class="Symbol">(</a><a id="11000" href="1Lab.Univalence.SIP.html#10948" class="Bound">A</a> <a id="11002" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="11003" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11007" href="1Lab.Univalence.SIP.html#10965" class="Bound">s</a> <a id="11009" href="1Lab.Univalence.SIP.html#10975" class="Bound">s₁</a><a id="11011" class="Symbol">)</a>     <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="11017" href="1Lab.Path.html#46757" class="Function">≡⟨</a> <a id="11020" href="1Lab.Univalence.SIP.html#10959" class="Bound">path</a> <a id="11025" class="Symbol">_</a> <a id="11027" class="Symbol">_</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="11029" href="1Lab.Path.html#46757" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="11035" href="1Lab.Univalence.SIP.html#10952" class="Bound">B</a> <a id="11037" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="11038" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11042" class="Symbol">(</a><a id="11043" href="1Lab.Univalence.SIP.html#10956" class="Bound">f</a> <a id="11045" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="11046" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="11050" href="1Lab.Univalence.SIP.html#10965" class="Bound">s</a><a id="11051" class="Symbol">)</a> <a id="11053" class="Symbol">(</a><a id="11054" href="1Lab.Univalence.SIP.html#10956" class="Bound">f</a> <a id="11056" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="11057" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="11061" href="1Lab.Univalence.SIP.html#10975" class="Bound">s₁</a><a id="11063" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="11065" href="1Lab.Path.html#46757" class="Function">≡⟨</a> <a data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" id="11068" href="1Lab.Path.html#21240" class="Function">ap₂</a> <a id="11072" class="Symbol">(</a><a id="11073" href="1Lab.Univalence.SIP.html#10952" class="Bound">B</a> <a id="11075" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="11076" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="11079" class="Symbol">)</a> <a id="11081" href="1Lab.Univalence.SIP.html#10972" class="Bound">p</a> <a id="11083" href="1Lab.Univalence.SIP.html#10984" class="Bound">q</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="11085" href="1Lab.Path.html#46757" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
    <a id="11091" href="1Lab.Univalence.SIP.html#10952" class="Bound">B</a> <a id="11093" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="11094" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11098" href="1Lab.Univalence.SIP.html#10969" class="Bound">t</a>     <a id="11104" href="1Lab.Univalence.SIP.html#10980" class="Bound">t₁</a>     <a data-type="(x : A) → x ≡ x" id="11111" href="1Lab.Path.html#46987" class="Function Operator">∎</a>
</pre>
<p>As an example, we equip the type of booleans with two ∞-magma structures, one given by conjunction, one by disjunction, and prove that <span class="Agda"><a data-type="Bool → Bool" href="Data.Bool.html#1190" class="Function">not</a></span> identifies them, as ∞-magmas:</p>
<div class="mathpar">
<pre class="Agda">  <a id="11327" class="Keyword">open</a> <a id="11332" class="Keyword">import</a> <a id="11339" href="Data.Bool.html" class="Module">Data.Bool</a>
</pre>
</pre>
</div>
<div class="mathpar">
<pre class="Agda">  <a id="Conj"></a><a id="11397" href="1Lab.Univalence.SIP.html#11397" class="Function">Conj</a> <a id="11402" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="11404" href="1Lab.Univalence.SIP.html#3323" class="Function">TypeWith</a> <a id="11413" href="1Lab.Univalence.SIP.html#9822" class="Function">∞-Magma</a>
  <a id="11423" href="1Lab.Univalence.SIP.html#11397" class="Function">Conj</a> <a id="11428" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="11429" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="11433" class="Symbol">=</a> <a data-type="Type" id="11435" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="11442" href="1Lab.Univalence.SIP.html#11397" class="Function">Conj</a> <a id="11447" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="11448" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="11452" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="11458" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="11464" class="Symbol">=</a> <a data-type="Bool" id="11466" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="11474" href="1Lab.Univalence.SIP.html#11397" class="Function">Conj</a> <a id="11479" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="11480" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="11484" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="11490" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="11496" class="Symbol">=</a> <a data-type="Bool" id="11498" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="11506" href="1Lab.Univalence.SIP.html#11397" class="Function">Conj</a> <a id="11511" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="11512" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="11516" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a data-type="Bool" id="11522" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="11528" class="Symbol">=</a> <a data-type="Bool" id="11530" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="11538" href="1Lab.Univalence.SIP.html#11397" class="Function">Conj</a> <a id="11543" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="11544" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="11548" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a data-type="Bool" id="11554" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="11560" class="Symbol">=</a> <a data-type="Bool" id="11562" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
</pre>
<pre class="Agda">  <a id="Disj"></a><a id="11582" href="1Lab.Univalence.SIP.html#11582" class="Function">Disj</a> <a id="11587" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="11589" href="1Lab.Univalence.SIP.html#3323" class="Function">TypeWith</a> <a id="11598" href="1Lab.Univalence.SIP.html#9822" class="Function">∞-Magma</a>
  <a id="11608" href="1Lab.Univalence.SIP.html#11582" class="Function">Disj</a> <a id="11613" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="11614" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="11618" class="Symbol">=</a> <a data-type="Type" id="11620" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="11627" href="1Lab.Univalence.SIP.html#11582" class="Function">Disj</a> <a id="11632" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="11633" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="11637" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="11643" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="11649" class="Symbol">=</a> <a data-type="Bool" id="11651" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="11659" href="1Lab.Univalence.SIP.html#11582" class="Function">Disj</a> <a id="11664" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="11665" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="11669" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="11675" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="11681" class="Symbol">=</a> <a data-type="Bool" id="11683" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
  <a id="11690" href="1Lab.Univalence.SIP.html#11582" class="Function">Disj</a> <a id="11695" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="11696" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="11700" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a data-type="Bool" id="11706" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="11712" class="Symbol">=</a> <a data-type="Bool" id="11714" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
  <a id="11721" href="1Lab.Univalence.SIP.html#11582" class="Function">Disj</a> <a id="11726" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="11727" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="11731" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a data-type="Bool" id="11737" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="11743" class="Symbol">=</a> <a data-type="Bool" id="11745" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
</pre>
</div>
<p>I claim that <span class="Agda"><a data-type="Bool → Bool" href="Data.Bool.html#1190" class="Function">not</a></span> is a <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>-magma</span> isomorphism between <span class="Agda"><a href="1Lab.Univalence.SIP.html#11397" class="Function">Conj</a></span> and <span class="Agda"><a href="1Lab.Univalence.SIP.html#11582" class="Function">Disj</a></span>:</p>
<pre class="Agda">  <a id="not-iso"></a><a id="11872" href="1Lab.Univalence.SIP.html#11872" class="Function">not-iso</a> <a id="11880" class="Symbol">:</a> <a id="11882" href="1Lab.Univalence.SIP.html#11397" class="Function">Conj</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="11887" href="1Lab.Univalence.SIP.html#4222" class="Function Operator">≃[</a> <a id="11890" href="1Lab.Univalence.SIP.html#9822" class="Function">∞-Magma</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="11898" href="1Lab.Univalence.SIP.html#4222" class="Function Operator">]</a> <a id="11900" href="1Lab.Univalence.SIP.html#11582" class="Function">Disj</a>
  <a id="11907" href="1Lab.Univalence.SIP.html#11872" class="Function">not-iso</a> <a id="11915" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="11916" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="11920" class="Symbol">=</a> <a data-type="Bool → Bool" id="11922" href="Data.Bool.html#1190" class="Function">not</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="11926" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv not" id="11928" href="Data.Bool.html#7030" class="Function">isEquiv-not</a>
  <a id="11942" href="1Lab.Univalence.SIP.html#11872" class="Function">not-iso</a> <a id="11950" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="11951" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11955" class="Symbol">=</a> <a id="11957" href="1Lab.Univalence.SIP.html#10768" class="Function">fixup</a> <a id="11963" class="Symbol">{</a><a id="11964" class="Argument">A</a> <a id="11966" class="Symbol">=</a> <a id="11968" href="1Lab.Univalence.SIP.html#11397" class="Function">Conj</a><a id="11972" class="Symbol">}</a> <a id="11974" class="Symbol">{</a><a id="11975" class="Argument">B</a> <a id="11977" class="Symbol">=</a> <a id="11979" href="1Lab.Univalence.SIP.html#11582" class="Function">Disj</a><a id="11983" class="Symbol">}</a> <a id="11985" class="Symbol">{</a><a id="11986" class="Argument">f</a> <a id="11988" class="Symbol">=</a> <a id="11990" class="Symbol">_</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="11992" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv not" id="11994" href="Data.Bool.html#7030" class="Function">isEquiv-not</a><a id="12005" class="Symbol">}</a> <a id="12007" class="Symbol">λ</a> <a id="12009" class="Keyword">where</a>
    <a data-type="Bool" id="12019" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="12025" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="12031" class="Symbol">→</a> <a data-type="x ≡ x" id="12033" href="1Lab.Path.html#3591" class="Function">refl</a>
    <a data-type="Bool" id="12042" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="12048" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="12053" class="Symbol">→</a> <a data-type="x ≡ x" id="12055" href="1Lab.Path.html#3591" class="Function">refl</a>
    <a data-type="Bool" id="12064" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="Bool" id="12069" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="12075" class="Symbol">→</a> <a data-type="x ≡ x" id="12077" href="1Lab.Path.html#3591" class="Function">refl</a>
    <a data-type="Bool" id="12086" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="Bool" id="12091" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="12096" class="Symbol">→</a> <a data-type="x ≡ x" id="12098" href="1Lab.Path.html#3591" class="Function">refl</a>
</pre>
<p>It’s not clear that this should be the case, especially since the case analysis obfuscates the result further. However, writing <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∧</mo></mrow><annotation encoding="application/x-tex">\land</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∧</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∨</mo></mrow><annotation encoding="application/x-tex">\lor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∨</span></span></span></span> for the actions of <span class="Agda"><a href="1Lab.Univalence.SIP.html#11397" class="Function">Conj</a></span> and <span class="Agda"><a href="1Lab.Univalence.SIP.html#11582" class="Function">Disj</a></span> (as one should!), then we see that <span class="Agda"><a href="1Lab.Univalence.SIP.html#11872" class="Function">not-iso</a></span> says exactly that</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">¬</mi><mo stretchy="false">(</mo><mi>x</mi><mo>∧</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">¬</mi><mi>x</mi><mo>∨</mo><mi mathvariant="normal">¬</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">
\neg (x \land y) = \neg x \lor \neg y
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">¬</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord">¬</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></span></p>
<p>From this and the SIP we get that <span class="Agda"><a href="1Lab.Univalence.SIP.html#11397" class="Function">Conj</a></span> and <span class="Agda"><a href="1Lab.Univalence.SIP.html#11582" class="Function">Disj</a></span> are the same <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>-magma:</span></p>
<pre class="Agda">  <a id="Conj≡Disj"></a><a id="12528" href="1Lab.Univalence.SIP.html#12528" class="Function">Conj≡Disj</a> <a id="12538" class="Symbol">:</a> <a id="12540" href="1Lab.Univalence.SIP.html#11397" class="Function">Conj</a> <a data-type="A → A → Type ℓ" id="12545" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="12547" href="1Lab.Univalence.SIP.html#11582" class="Function">Disj</a>
  <a id="12554" href="1Lab.Univalence.SIP.html#12528" class="Function">Conj≡Disj</a> <a id="12564" class="Symbol">=</a> <a data-type="isUnivalent σ → X ≃[ σ ] Y → X ≡ Y" id="12566" href="1Lab.Univalence.SIP.html#5512" class="Function">sip</a> <a id="12570" href="1Lab.Univalence.SIP.html#9936" class="Function">∞-Magma-univ</a> <a id="12583" href="1Lab.Univalence.SIP.html#11872" class="Function">not-iso</a>
</pre>
<p>We have a similar phenomenon that happens with NAND and NOR:</p>
<div class="mathpar">
<pre class="Agda">  <a id="Nand"></a><a id="12688" href="1Lab.Univalence.SIP.html#12688" class="Function">Nand</a> <a id="12693" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="12695" href="1Lab.Univalence.SIP.html#3323" class="Function">TypeWith</a> <a id="12704" href="1Lab.Univalence.SIP.html#9822" class="Function">∞-Magma</a>
  <a id="12714" href="1Lab.Univalence.SIP.html#12688" class="Function">Nand</a> <a id="12719" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="12720" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="12724" class="Symbol">=</a> <a data-type="Type" id="12726" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="12733" href="1Lab.Univalence.SIP.html#12688" class="Function">Nand</a> <a id="12738" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="12739" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="12743" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="12749" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="12755" class="Symbol">=</a> <a data-type="Bool" id="12757" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
  <a id="12764" href="1Lab.Univalence.SIP.html#12688" class="Function">Nand</a> <a id="12769" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="12770" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="12774" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="12780" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="12786" class="Symbol">=</a> <a data-type="Bool" id="12788" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
  <a id="12795" href="1Lab.Univalence.SIP.html#12688" class="Function">Nand</a> <a id="12800" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="12801" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="12805" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a data-type="Bool" id="12811" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="12817" class="Symbol">=</a> <a data-type="Bool" id="12819" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
  <a id="12826" href="1Lab.Univalence.SIP.html#12688" class="Function">Nand</a> <a id="12831" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="12832" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="12836" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a data-type="Bool" id="12842" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="12848" class="Symbol">=</a> <a data-type="Bool" id="12850" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
</pre>
<pre class="Agda">  <a id="Nor"></a><a id="12871" href="1Lab.Univalence.SIP.html#12871" class="Function">Nor</a> <a id="12875" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="12877" href="1Lab.Univalence.SIP.html#3323" class="Function">TypeWith</a> <a id="12886" href="1Lab.Univalence.SIP.html#9822" class="Function">∞-Magma</a>
  <a id="12896" href="1Lab.Univalence.SIP.html#12871" class="Function">Nor</a> <a id="12900" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="12901" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="12905" class="Symbol">=</a> <a data-type="Type" id="12907" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="12914" href="1Lab.Univalence.SIP.html#12871" class="Function">Nor</a> <a id="12918" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="12919" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="12923" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="12929" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="12935" class="Symbol">=</a> <a data-type="Bool" id="12937" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
  <a id="12944" href="1Lab.Univalence.SIP.html#12871" class="Function">Nor</a> <a id="12948" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="12949" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="12953" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="12959" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="12965" class="Symbol">=</a> <a data-type="Bool" id="12967" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="12975" href="1Lab.Univalence.SIP.html#12871" class="Function">Nor</a> <a id="12979" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="12980" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="12984" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a data-type="Bool" id="12990" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="12996" class="Symbol">=</a> <a data-type="Bool" id="12998" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="13006" href="1Lab.Univalence.SIP.html#12871" class="Function">Nor</a> <a id="13010" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="13011" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="13015" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a data-type="Bool" id="13021" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="13027" class="Symbol">=</a> <a data-type="Bool" id="13029" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
</pre>
</div>
<pre class="Agda">  <a id="not-iso&#39;"></a><a id="13057" href="1Lab.Univalence.SIP.html#13057" class="Function">not-iso&#39;</a> <a id="13066" class="Symbol">:</a> <a id="13068" href="1Lab.Univalence.SIP.html#12688" class="Function">Nand</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="13073" href="1Lab.Univalence.SIP.html#4222" class="Function Operator">≃[</a> <a id="13076" href="1Lab.Univalence.SIP.html#9822" class="Function">∞-Magma</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="13084" href="1Lab.Univalence.SIP.html#4222" class="Function Operator">]</a> <a id="13086" href="1Lab.Univalence.SIP.html#12871" class="Function">Nor</a>
  <a id="13092" href="1Lab.Univalence.SIP.html#13057" class="Function">not-iso&#39;</a> <a id="13101" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="13102" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="13106" class="Symbol">=</a> <a data-type="Bool → Bool" id="13108" href="Data.Bool.html#1190" class="Function">not</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="13112" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv not" id="13114" href="Data.Bool.html#7030" class="Function">isEquiv-not</a>
  <a id="13128" href="1Lab.Univalence.SIP.html#13057" class="Function">not-iso&#39;</a> <a id="13137" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="13138" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="13142" class="Symbol">=</a> <a id="13144" href="1Lab.Univalence.SIP.html#10768" class="Function">fixup</a> <a id="13150" class="Symbol">{</a><a id="13151" class="Argument">A</a> <a id="13153" class="Symbol">=</a> <a id="13155" href="1Lab.Univalence.SIP.html#12688" class="Function">Nand</a><a id="13159" class="Symbol">}</a> <a id="13161" class="Symbol">{</a><a id="13162" class="Argument">B</a> <a id="13164" class="Symbol">=</a> <a id="13166" href="1Lab.Univalence.SIP.html#12871" class="Function">Nor</a><a id="13169" class="Symbol">}</a> <a id="13171" class="Symbol">{</a><a id="13172" class="Argument">f</a> <a id="13174" class="Symbol">=</a> <a id="13176" class="Symbol">_</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="13178" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv not" id="13180" href="Data.Bool.html#7030" class="Function">isEquiv-not</a><a id="13191" class="Symbol">}</a> <a id="13193" class="Symbol">λ</a> <a id="13195" class="Keyword">where</a>
    <a data-type="Bool" id="13205" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="13211" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="13217" class="Symbol">→</a> <a data-type="x ≡ x" id="13219" href="1Lab.Path.html#3591" class="Function">refl</a>
    <a data-type="Bool" id="13228" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="13234" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="13239" class="Symbol">→</a> <a data-type="x ≡ x" id="13241" href="1Lab.Path.html#3591" class="Function">refl</a>
    <a data-type="Bool" id="13250" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="Bool" id="13255" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="13261" class="Symbol">→</a> <a data-type="x ≡ x" id="13263" href="1Lab.Path.html#3591" class="Function">refl</a>
    <a data-type="Bool" id="13272" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="Bool" id="13277" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="13282" class="Symbol">→</a> <a data-type="x ≡ x" id="13284" href="1Lab.Path.html#3591" class="Function">refl</a>
</pre>
<h1 id="transport-structures"><a href="#transport-structures" class="header-link">Transport Structures<span class="header-link-emoji">🔗</span></a></h1>
<p>As an alternative to equipping a type family <code>S : Type → Type</code> with a notion of S-homomorphism, we can equip it with a notion of <em>action</em>. Equipping a structure with a notion of action canonically equips it with a notion of homomorphism:</p>
<pre class="Agda"><a id="EqvAction"></a><a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="13565" href="1Lab.Univalence.SIP.html#13565" class="Function">EqvAction</a> <a id="13575" class="Symbol">:</a> <a id="13577" class="Symbol">(</a><a id="13578" href="1Lab.Univalence.SIP.html#13578" class="Bound">S</a> <a id="13580" class="Symbol">:</a> <a id="13582" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13587" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a> <a id="13589" class="Symbol">→</a> <a id="13591" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13596" href="1Lab.Univalence.SIP.html#3459" class="Generalizable">ℓ₁</a><a id="13598" class="Symbol">)</a> <a id="13600" class="Symbol">→</a> <a id="13602" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13607" class="Symbol">_</a>
<a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="13609" href="1Lab.Univalence.SIP.html#13565" class="Function">EqvAction</a> <a id="13619" class="Symbol">{</a><a id="13620" class="Argument">ℓ</a> <a id="13622" class="Symbol">=</a> <a id="13624" href="1Lab.Univalence.SIP.html#13624" class="Bound">ℓ</a><a id="13625" class="Symbol">}</a> <a id="13627" href="1Lab.Univalence.SIP.html#13627" class="Bound">S</a> <a id="13629" class="Symbol">=</a> <a id="13631" class="Symbol">{</a><a id="13632" href="1Lab.Univalence.SIP.html#13632" class="Bound">X</a> <a id="13634" href="1Lab.Univalence.SIP.html#13634" class="Bound">Y</a> <a id="13636" class="Symbol">:</a> <a id="13638" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13643" href="1Lab.Univalence.SIP.html#13624" class="Bound">ℓ</a><a id="13644" class="Symbol">}</a> <a id="13646" class="Symbol">→</a> <a id="13648" class="Symbol">(</a><a id="13649" href="1Lab.Univalence.SIP.html#13632" class="Bound">X</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="13651" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="13653" href="1Lab.Univalence.SIP.html#13634" class="Bound">Y</a><a id="13654" class="Symbol">)</a> <a id="13656" class="Symbol">→</a> <a id="13658" class="Symbol">(</a><a id="13659" href="1Lab.Univalence.SIP.html#13627" class="Bound">S</a> <a id="13661" href="1Lab.Univalence.SIP.html#13632" class="Bound">X</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="13663" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="13665" href="1Lab.Univalence.SIP.html#13627" class="Bound">S</a> <a id="13667" href="1Lab.Univalence.SIP.html#13634" class="Bound">Y</a><a id="13668" class="Symbol">)</a>

<a id="Action→Structure"></a><a data-type="EqvAction S₁ → Structure ℓ₁ S₁" id="13671" href="1Lab.Univalence.SIP.html#13671" class="Function">Action→Structure</a> <a id="13688" class="Symbol">:</a> <a id="13690" class="Symbol">{</a><a id="13691" href="1Lab.Univalence.SIP.html#13691" class="Bound">S</a> <a id="13693" class="Symbol">:</a> <a id="13695" href="1Lab.Type.html#394" class="Primitive">Type</a>  <a id="13701" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a> <a id="13703" class="Symbol">→</a> <a id="13705" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13710" href="1Lab.Univalence.SIP.html#3459" class="Generalizable">ℓ₁</a><a id="13712" class="Symbol">}</a> <a id="13714" class="Symbol">→</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="13716" href="1Lab.Univalence.SIP.html#13565" class="Function">EqvAction</a> <a id="13726" href="1Lab.Univalence.SIP.html#13691" class="Bound">S</a> <a id="13728" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="13730" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a> <a id="13740" class="Symbol">_</a> <a id="13742" href="1Lab.Univalence.SIP.html#13691" class="Bound">S</a>
<a data-type="EqvAction S₁ → Structure ℓ₁ S₁" id="13744" href="1Lab.Univalence.SIP.html#13671" class="Function">Action→Structure</a> <a id="13761" href="1Lab.Univalence.SIP.html#13761" class="Bound">act</a> <a id="13765" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B₁ : Σ S₁) → A .fst ≃ B₁ .fst → Type ℓ₃" id="13766" href="1Lab.Univalence.SIP.html#2879" class="Field">is-hom</a> <a id="13773" class="Symbol">(</a><a id="13774" href="1Lab.Univalence.SIP.html#13774" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="13776" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="13778" href="1Lab.Univalence.SIP.html#13778" class="Bound">x</a><a id="13779" class="Symbol">)</a> <a id="13781" class="Symbol">(</a><a id="13782" href="1Lab.Univalence.SIP.html#13782" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="13784" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="13786" href="1Lab.Univalence.SIP.html#13786" class="Bound">y</a><a id="13787" class="Symbol">)</a> <a id="13789" href="1Lab.Univalence.SIP.html#13789" class="Bound">f</a> <a id="13791" class="Symbol">=</a> <a id="13793" href="1Lab.Univalence.SIP.html#13761" class="Bound">act</a> <a id="13797" href="1Lab.Univalence.SIP.html#13789" class="Bound">f</a> <a id="13799" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="13800" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="13804" href="1Lab.Univalence.SIP.html#13778" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="13806" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="13808" href="1Lab.Univalence.SIP.html#13786" class="Bound">y</a>
</pre>
<p>A <strong>transport structure</strong> is a structure <code>S : Type → Type</code> with a choice of equivalence action <code>α : EqvAction S</code> which agrees with the “intrinsic” notion of equivalence action that is induced by <a href="1Lab.Path.html#computation">the computation rules for transport</a>.</p>
<pre class="Agda"><a id="isTransportStr"></a><a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="14125" href="1Lab.Univalence.SIP.html#14125" class="Function">isTransportStr</a> <a id="14140" class="Symbol">:</a> <a id="14142" class="Symbol">{</a><a id="14143" href="1Lab.Univalence.SIP.html#14143" class="Bound">S</a> <a id="14145" class="Symbol">:</a> <a id="14147" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14152" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a> <a id="14154" class="Symbol">→</a> <a id="14156" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14161" href="1Lab.Univalence.SIP.html#3459" class="Generalizable">ℓ₁</a><a id="14163" class="Symbol">}</a> <a id="14165" class="Symbol">→</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="14167" href="1Lab.Univalence.SIP.html#13565" class="Function">EqvAction</a> <a id="14177" href="1Lab.Univalence.SIP.html#14143" class="Bound">S</a> <a id="14179" class="Symbol">→</a> <a id="14181" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14186" class="Symbol">_</a>
<a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="14188" href="1Lab.Univalence.SIP.html#14125" class="Function">isTransportStr</a> <a id="14203" class="Symbol">{</a><a id="14204" class="Argument">ℓ</a> <a id="14206" class="Symbol">=</a> <a id="14208" href="1Lab.Univalence.SIP.html#14208" class="Bound">ℓ</a><a id="14209" class="Symbol">}</a> <a id="14211" class="Symbol">{</a><a id="14212" class="Argument">S</a> <a id="14214" class="Symbol">=</a> <a id="14216" href="1Lab.Univalence.SIP.html#14216" class="Bound">S</a><a id="14217" class="Symbol">}</a> <a id="14219" href="1Lab.Univalence.SIP.html#14219" class="Bound">act</a> <a id="14223" class="Symbol">=</a>
  <a id="14227" class="Symbol">{</a><a id="14228" href="1Lab.Univalence.SIP.html#14228" class="Bound">X</a> <a id="14230" href="1Lab.Univalence.SIP.html#14230" class="Bound">Y</a> <a id="14232" class="Symbol">:</a> <a id="14234" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14239" href="1Lab.Univalence.SIP.html#14208" class="Bound">ℓ</a><a id="14240" class="Symbol">}</a> <a id="14242" class="Symbol">(</a><a id="14243" href="1Lab.Univalence.SIP.html#14243" class="Bound">e</a> <a id="14245" class="Symbol">:</a> <a id="14247" href="1Lab.Univalence.SIP.html#14228" class="Bound">X</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="14249" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="14251" href="1Lab.Univalence.SIP.html#14230" class="Bound">Y</a><a id="14252" class="Symbol">)</a> <a id="14254" class="Symbol">(</a><a id="14255" href="1Lab.Univalence.SIP.html#14255" class="Bound">s</a> <a id="14257" class="Symbol">:</a> <a id="14259" href="1Lab.Univalence.SIP.html#14216" class="Bound">S</a> <a id="14261" href="1Lab.Univalence.SIP.html#14228" class="Bound">X</a><a id="14262" class="Symbol">)</a> <a id="14264" class="Symbol">→</a> <a id="14266" href="1Lab.Univalence.SIP.html#14219" class="Bound">act</a> <a id="14270" href="1Lab.Univalence.SIP.html#14243" class="Bound">e</a> <a id="14272" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="14273" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="14277" href="1Lab.Univalence.SIP.html#14255" class="Bound">s</a> <a data-type="A → A → Type ℓ" id="14279" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="14281" href="1Lab.Path.html#15372" class="Function">subst</a> <a id="14287" href="1Lab.Univalence.SIP.html#14216" class="Bound">S</a> <a id="14289" class="Symbol">(</a><a data-type="A ≃ B₁ → A ≡ B₁" id="14290" href="1Lab.Univalence.html#8828" class="Function">ua</a> <a id="14293" href="1Lab.Univalence.SIP.html#14243" class="Bound">e</a><a id="14294" class="Symbol">)</a> <a id="14296" href="1Lab.Univalence.SIP.html#14255" class="Bound">s</a>
</pre>
<p>While the above definition of <code class="sourceCode agda">transport structure</code> is natural, it can sometimes be unwieldy to work with. Using <span class="Agda"><a data-type="(P : (B₁ : Type ℓ) → A ≃ B₁ → Type ℓ&#39;) →
P A ((λ x → x) , idEquiv) → (e : A ≃ B₁) → P B₁ e" href="1Lab.Univalence.html#19819" class="Function">univalence</a></span>, the condition for being a transport structure can be weakened to “preserves the identity equivalence”, with no loss of generality:</p>
<pre class="Agda"><a id="preservesId"></a><a data-type="EqvAction S₁ → Type (lsuc ℓ)" id="14597" href="1Lab.Univalence.SIP.html#14597" class="Function">preservesId</a> <a id="14609" class="Symbol">:</a> <a id="14611" class="Symbol">{</a><a id="14612" href="1Lab.Univalence.SIP.html#14612" class="Bound">S</a> <a id="14614" class="Symbol">:</a> <a id="14616" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14621" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a> <a id="14623" class="Symbol">→</a> <a id="14625" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14630" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a><a id="14631" class="Symbol">}</a> <a id="14633" class="Symbol">→</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="14635" href="1Lab.Univalence.SIP.html#13565" class="Function">EqvAction</a> <a id="14645" href="1Lab.Univalence.SIP.html#14612" class="Bound">S</a> <a id="14647" class="Symbol">→</a> <a id="14649" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14654" class="Symbol">_</a>
<a data-type="EqvAction S₁ → Type (lsuc ℓ)" id="14656" href="1Lab.Univalence.SIP.html#14597" class="Function">preservesId</a> <a id="14668" class="Symbol">{</a><a id="14669" class="Argument">ℓ</a> <a id="14671" class="Symbol">=</a> <a id="14673" href="1Lab.Univalence.SIP.html#14673" class="Bound">ℓ</a><a id="14674" class="Symbol">}</a> <a id="14676" class="Symbol">{</a><a id="14677" class="Argument">S</a> <a id="14679" class="Symbol">=</a> <a id="14681" href="1Lab.Univalence.SIP.html#14681" class="Bound">S</a><a id="14682" class="Symbol">}</a> <a id="14684" href="1Lab.Univalence.SIP.html#14684" class="Bound">act</a> <a id="14688" class="Symbol">=</a>
  <a id="14692" class="Symbol">{</a><a id="14693" href="1Lab.Univalence.SIP.html#14693" class="Bound">X</a> <a id="14695" class="Symbol">:</a> <a id="14697" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14702" href="1Lab.Univalence.SIP.html#14673" class="Bound">ℓ</a><a id="14703" class="Symbol">}</a> <a id="14705" class="Symbol">(</a><a id="14706" href="1Lab.Univalence.SIP.html#14706" class="Bound">s</a> <a id="14708" class="Symbol">:</a> <a id="14710" href="1Lab.Univalence.SIP.html#14681" class="Bound">S</a> <a id="14712" href="1Lab.Univalence.SIP.html#14693" class="Bound">X</a><a id="14713" class="Symbol">)</a> <a id="14715" class="Symbol">→</a> <a id="14717" href="1Lab.Univalence.SIP.html#14684" class="Bound">act</a> <a id="14721" class="Symbol">(</a><a data-type="A → A" id="14722" href="1Lab.Type.html#2348" class="Function">id</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="14725" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="14727" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="14734" class="Symbol">)</a> <a id="14736" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="14737" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="14741" href="1Lab.Univalence.SIP.html#14706" class="Bound">s</a> <a data-type="A → A → Type ℓ" id="14743" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="14745" href="1Lab.Univalence.SIP.html#14706" class="Bound">s</a>
</pre>
<p>The proof is by equivalence induction: To show something about all <code>Y : Type, x : X ≃ Y</code> (with X fixed), it suffices to cover the case where <code>Y</code> is <code>X</code> and <code>e</code> is the identity equivalence. This case is by the assumption that <span class="Agda"><a data-type="EqvAction S₁ → Type (lsuc ℓ)" href="1Lab.Univalence.SIP.html#14597" class="Function">σ preserves id</a></span>.</p>
<pre class="Agda"><a id="preservesId→isTransportStr"></a><a data-type="(σ : EqvAction S₁) → preservesId σ → isTransportStr σ" id="15029" href="1Lab.Univalence.SIP.html#15029" class="Function">preservesId→isTransportStr</a> <a id="15056" class="Symbol">:</a> <a id="15058" class="Symbol">(</a><a id="15059" href="1Lab.Univalence.SIP.html#15059" class="Bound">σ</a> <a id="15061" class="Symbol">:</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="15063" href="1Lab.Univalence.SIP.html#13565" class="Function">EqvAction</a> <a id="15073" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a><a id="15074" class="Symbol">)</a> <a id="15076" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ)" id="15078" href="1Lab.Univalence.SIP.html#14597" class="Function">preservesId</a> <a id="15090" href="1Lab.Univalence.SIP.html#15059" class="Bound">σ</a> <a id="15092" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="15094" href="1Lab.Univalence.SIP.html#14125" class="Function">isTransportStr</a> <a id="15109" href="1Lab.Univalence.SIP.html#15059" class="Bound">σ</a>
<a data-type="(σ : EqvAction S₁) → preservesId σ → isTransportStr σ" id="15111" href="1Lab.Univalence.SIP.html#15029" class="Function">preservesId→isTransportStr</a> <a id="15138" class="Symbol">{</a><a id="15139" class="Argument">S</a> <a id="15141" class="Symbol">=</a> <a id="15143" href="1Lab.Univalence.SIP.html#15143" class="Bound">S</a><a id="15144" class="Symbol">}</a> <a id="15146" href="1Lab.Univalence.SIP.html#15146" class="Bound">σ</a> <a id="15148" href="1Lab.Univalence.SIP.html#15148" class="Bound">pres-id</a> <a id="15156" href="1Lab.Univalence.SIP.html#15156" class="Bound">e</a> <a id="15158" href="1Lab.Univalence.SIP.html#15158" class="Bound">s</a> <a id="15160" class="Symbol">=</a>
  <a data-type="(P : (B₁ : Type ℓ) → A ≃ B₁ → Type ℓ&#39;) →
P A ((λ x → x) , idEquiv) → (e : A ≃ B₁) → P B₁ e" id="15164" href="1Lab.Univalence.html#19819" class="Function">EquivJ</a> <a id="15171" class="Symbol">(λ</a> <a id="15174" href="1Lab.Univalence.SIP.html#15174" class="Bound">_</a> <a id="15176" href="1Lab.Univalence.SIP.html#15176" class="Bound">e</a> <a id="15178" class="Symbol">→</a> <a id="15180" href="1Lab.Univalence.SIP.html#15146" class="Bound">σ</a> <a id="15182" href="1Lab.Univalence.SIP.html#15176" class="Bound">e</a> <a id="15184" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="15185" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="15189" href="1Lab.Univalence.SIP.html#15158" class="Bound">s</a> <a data-type="A → A → Type ℓ" id="15191" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="15193" href="1Lab.Path.html#15372" class="Function">subst</a> <a id="15199" href="1Lab.Univalence.SIP.html#15143" class="Bound">S</a> <a id="15201" class="Symbol">(</a><a data-type="A ≃ B₁ → A ≡ B₁" id="15202" href="1Lab.Univalence.html#8828" class="Function">ua</a> <a id="15205" href="1Lab.Univalence.SIP.html#15176" class="Bound">e</a><a id="15206" class="Symbol">)</a> <a id="15208" href="1Lab.Univalence.SIP.html#15158" class="Bound">s</a><a id="15209" class="Symbol">)</a> <a id="15211" href="1Lab.Univalence.SIP.html#15405" class="Function">lemma&#39;</a> <a id="15218" href="1Lab.Univalence.SIP.html#15156" class="Bound">e</a>
  <a id="15222" class="Keyword">where</a>
</pre>
<p>Unfortunately we can not directly use the assumption that <code>σ</code> preserves <span class="Agda"><a data-type="A → A" href="1Lab.Type.html#2348" class="Function">id</a></span> in the proof, but it can be used as the final step in an equational proof:</p>
<pre class="Agda">    <a id="15405" href="1Lab.Univalence.SIP.html#15405" class="Function">lemma&#39;</a> <a id="15412" class="Symbol">:</a> <a id="15414" href="1Lab.Univalence.SIP.html#15146" class="Bound">σ</a> <a id="15416" class="Symbol">(</a><a data-type="A → A" id="15417" href="1Lab.Type.html#2348" class="Function">id</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="15420" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="15422" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="15429" class="Symbol">)</a> <a id="15431" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="15432" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="15436" href="1Lab.Univalence.SIP.html#15158" class="Bound">s</a> <a data-type="A → A → Type ℓ" id="15438" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="15440" href="1Lab.Path.html#15372" class="Function">subst</a> <a id="15446" href="1Lab.Univalence.SIP.html#15143" class="Bound">S</a> <a id="15448" class="Symbol">(</a><a data-type="A ≃ B₁ → A ≡ B₁" id="15449" href="1Lab.Univalence.html#8828" class="Function">ua</a> <a id="15452" class="Symbol">(</a><a data-type="A → A" id="15453" href="1Lab.Type.html#2348" class="Function">id</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="15456" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="15458" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="15465" class="Symbol">))</a> <a id="15468" href="1Lab.Univalence.SIP.html#15158" class="Bound">s</a>
    <a id="15474" href="1Lab.Univalence.SIP.html#15405" class="Function">lemma&#39;</a> <a id="15481" class="Symbol">=</a>
      <a data-type="x ≡ y → y ≡ x" id="15489" href="1Lab.Path.html#10628" class="Function">sym</a> <a id="15493" class="Symbol">(</a>
        <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="15503" href="1Lab.Path.html#15372" class="Function">subst</a> <a id="15509" href="1Lab.Univalence.SIP.html#15143" class="Bound">S</a> <a id="15511" class="Symbol">(</a><a data-type="A ≃ B₁ → A ≡ B₁" id="15512" href="1Lab.Univalence.html#8828" class="Function">ua</a> <a id="15515" class="Symbol">(</a><a data-type="A → A" id="15516" href="1Lab.Type.html#2348" class="Function">id</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="15519" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="15521" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="15528" class="Symbol">))</a> <a id="15531" href="1Lab.Univalence.SIP.html#15158" class="Bound">s</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="15533" href="1Lab.Path.html#46757" class="Function">≡⟨</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="15536" href="1Lab.Path.html#20807" class="Function">ap</a> <a id="15539" class="Symbol">(λ</a> <a id="15542" href="1Lab.Univalence.SIP.html#15542" class="Bound">p</a> <a id="15544" class="Symbol">→</a> <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="15546" href="1Lab.Path.html#15372" class="Function">subst</a> <a id="15552" href="1Lab.Univalence.SIP.html#15143" class="Bound">S</a> <a id="15554" href="1Lab.Univalence.SIP.html#15542" class="Bound">p</a> <a id="15556" href="1Lab.Univalence.SIP.html#15158" class="Bound">s</a><a id="15557" class="Symbol">)</a> <a data-type="ua ((λ x → x) , idEquiv) ≡ refl" id="15559" href="1Lab.Univalence.html#16277" class="Function">uaIdEquiv</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="15569" href="1Lab.Path.html#46757" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a data-type="A ≡ B₁ → A → B₁" id="15579" href="1Lab.Path.html#11846" class="Function">transport</a> <a data-type="x ≡ x" id="15589" href="1Lab.Path.html#3591" class="Function">refl</a> <a id="15594" href="1Lab.Univalence.SIP.html#15158" class="Bound">s</a>              <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="15609" href="1Lab.Path.html#46757" class="Function">≡⟨</a> <a data-type="(x : A) → transport (λ i → A) x ≡ x" id="15612" href="1Lab.Path.html#13523" class="Function">transport-refl</a> <a id="15627" class="Symbol">_</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="15629" href="1Lab.Path.html#46757" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a id="15639" href="1Lab.Univalence.SIP.html#15158" class="Bound">s</a>                             <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="15669" href="1Lab.Path.html#46757" class="Function">≡⟨</a> <a data-type="x ≡ y → y ≡ x" id="15672" href="1Lab.Path.html#10628" class="Function">sym</a> <a id="15676" class="Symbol">(</a><a id="15677" href="1Lab.Univalence.SIP.html#15148" class="Bound">pres-id</a> <a id="15685" href="1Lab.Univalence.SIP.html#15158" class="Bound">s</a><a id="15686" class="Symbol">)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="15688" href="1Lab.Path.html#46757" class="Function">⟩</a></span><span class="alternate Function">≡</span></span> 
        <a id="15699" href="1Lab.Univalence.SIP.html#15146" class="Bound">σ</a> <a id="15701" class="Symbol">(</a><a data-type="A → A" id="15702" href="1Lab.Type.html#2348" class="Function">id</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="15705" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="15707" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="15714" class="Symbol">)</a> <a id="15716" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="15717" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="15721" href="1Lab.Univalence.SIP.html#15158" class="Bound">s</a>       <a data-type="(x : A) → x ≡ x" id="15729" href="1Lab.Path.html#46987" class="Function Operator">∎</a>
      <a id="15737" class="Symbol">)</a>
</pre>
<!--
<pre class="Agda"><a id="transportStr⁻¹"></a><a id="15757" href="1Lab.Univalence.SIP.html#15757" class="Function">transportStr⁻¹</a> <a id="15772" class="Symbol">:</a>
  <a id="15776" class="Symbol">{</a><a id="15777" href="1Lab.Univalence.SIP.html#15777" class="Bound">S</a> <a id="15779" class="Symbol">:</a> <a id="15781" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="15786" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a> <a id="15788" class="Symbol">→</a> <a id="15790" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="15795" href="1Lab.Univalence.SIP.html#3462" class="Generalizable">ℓ₂</a><a id="15797" class="Symbol">}</a> <a id="15799" class="Symbol">(</a><a id="15800" href="1Lab.Univalence.SIP.html#15800" class="Bound">α</a> <a id="15802" class="Symbol">:</a> <a id="15804" href="1Lab.Univalence.SIP.html#13565" class="Function">EqvAction</a> <a id="15814" href="1Lab.Univalence.SIP.html#15777" class="Bound">S</a><a id="15815" class="Symbol">)</a> <a id="15817" class="Symbol">(</a><a id="15818" href="1Lab.Univalence.SIP.html#15818" class="Bound">τ</a> <a id="15820" class="Symbol">:</a> <a id="15822" href="1Lab.Univalence.SIP.html#14125" class="Function">isTransportStr</a> <a id="15837" href="1Lab.Univalence.SIP.html#15800" class="Bound">α</a><a id="15838" class="Symbol">)</a>
  <a id="15842" class="Symbol">{</a><a id="15843" href="1Lab.Univalence.SIP.html#15843" class="Bound">X</a> <a id="15845" href="1Lab.Univalence.SIP.html#15845" class="Bound">Y</a> <a id="15847" class="Symbol">:</a> <a id="15849" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="15854" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a><a id="15855" class="Symbol">}</a> <a id="15857" class="Symbol">(</a><a id="15858" href="1Lab.Univalence.SIP.html#15858" class="Bound">e</a> <a id="15860" class="Symbol">:</a> <a id="15862" href="1Lab.Univalence.SIP.html#15843" class="Bound">X</a> <a id="15864" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="15866" href="1Lab.Univalence.SIP.html#15845" class="Bound">Y</a><a id="15867" class="Symbol">)</a> <a id="15869" class="Symbol">(</a><a id="15870" href="1Lab.Univalence.SIP.html#15870" class="Bound">t</a> <a id="15872" class="Symbol">:</a> <a id="15874" href="1Lab.Univalence.SIP.html#15777" class="Bound">S</a> <a id="15876" href="1Lab.Univalence.SIP.html#15845" class="Bound">Y</a><a id="15877" class="Symbol">)</a>
  <a id="15881" class="Symbol">→</a> <a id="15883" href="1Lab.Equiv.html#6391" class="Function">equiv→inverse</a> <a id="15897" class="Symbol">(</a><a id="15898" href="1Lab.Univalence.SIP.html#15800" class="Bound">α</a> <a id="15900" href="1Lab.Univalence.SIP.html#15858" class="Bound">e</a> <a id="15902" class="Symbol">.</a><a id="15903" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="15906" class="Symbol">)</a> <a id="15908" href="1Lab.Univalence.SIP.html#15870" class="Bound">t</a> <a id="15910" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="15912" href="1Lab.Path.html#15372" class="Function">subst</a> <a id="15918" href="1Lab.Univalence.SIP.html#15777" class="Bound">S</a> <a id="15920" class="Symbol">(</a><a id="15921" href="1Lab.Path.html#10628" class="Function">sym</a> <a id="15925" class="Symbol">(</a><a id="15926" href="1Lab.Univalence.html#8828" class="Function">ua</a> <a id="15929" href="1Lab.Univalence.SIP.html#15858" class="Bound">e</a><a id="15930" class="Symbol">))</a> <a id="15933" href="1Lab.Univalence.SIP.html#15870" class="Bound">t</a>
<a id="15935" href="1Lab.Univalence.SIP.html#15757" class="Function">transportStr⁻¹</a> <a id="15950" class="Symbol">{</a><a id="15951" class="Argument">S</a> <a id="15953" class="Symbol">=</a> <a id="15955" href="1Lab.Univalence.SIP.html#15955" class="Bound">S</a><a id="15956" class="Symbol">}</a> <a id="15958" href="1Lab.Univalence.SIP.html#15958" class="Bound">α</a> <a id="15960" href="1Lab.Univalence.SIP.html#15960" class="Bound">τ</a> <a id="15962" href="1Lab.Univalence.SIP.html#15962" class="Bound">e</a> <a id="15964" href="1Lab.Univalence.SIP.html#15964" class="Bound">t</a> <a id="15966" class="Symbol">=</a>
     <a id="15973" href="1Lab.Path.html#10628" class="Function">sym</a> <a id="15977" class="Symbol">(</a><a id="15978" href="1Lab.Path.html#14809" class="Function">transport⁻Transport</a> <a id="15998" class="Symbol">(</a><a id="15999" href="1Lab.Path.html#20807" class="Function">ap</a> <a id="16002" href="1Lab.Univalence.SIP.html#15955" class="Bound">S</a> <a id="16004" class="Symbol">(</a><a id="16005" href="1Lab.Univalence.html#8828" class="Function">ua</a> <a id="16008" href="1Lab.Univalence.SIP.html#15962" class="Bound">e</a><a id="16009" class="Symbol">))</a> <a id="16012" class="Symbol">(</a><a id="16013" href="1Lab.Equiv.html#6391" class="Function">equiv→inverse</a> <a id="16027" class="Symbol">(</a><a id="16028" href="1Lab.Univalence.SIP.html#15958" class="Bound">α</a> <a id="16030" href="1Lab.Univalence.SIP.html#15962" class="Bound">e</a> <a id="16032" class="Symbol">.</a><a id="16033" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="16036" class="Symbol">)</a> <a id="16038" href="1Lab.Univalence.SIP.html#15964" class="Bound">t</a><a id="16039" class="Symbol">))</a>
  <a id="16044" href="1Lab.Path.html#38409" class="Function Operator">··</a> <a id="16047" href="1Lab.Path.html#10628" class="Function">sym</a> <a id="16051" class="Symbol">(</a><a id="16052" href="1Lab.Path.html#20807" class="Function">ap</a> <a id="16055" class="Symbol">(</a><a id="16056" href="1Lab.Path.html#15372" class="Function">subst</a> <a id="16062" href="1Lab.Univalence.SIP.html#15955" class="Bound">S</a> <a id="16064" class="Symbol">(</a><a id="16065" href="1Lab.Path.html#10628" class="Function">sym</a> <a id="16069" class="Symbol">(</a><a id="16070" href="1Lab.Univalence.html#8828" class="Function">ua</a> <a id="16073" href="1Lab.Univalence.SIP.html#15962" class="Bound">e</a><a id="16074" class="Symbol">)))</a> <a id="16078" class="Symbol">(</a><a id="16079" href="1Lab.Univalence.SIP.html#15960" class="Bound">τ</a> <a id="16081" href="1Lab.Univalence.SIP.html#15962" class="Bound">e</a> <a id="16083" class="Symbol">(</a><a id="16084" href="1Lab.Equiv.html#6391" class="Function">equiv→inverse</a> <a id="16098" class="Symbol">(</a><a id="16099" href="1Lab.Univalence.SIP.html#15958" class="Bound">α</a> <a id="16101" href="1Lab.Univalence.SIP.html#15962" class="Bound">e</a> <a id="16103" class="Symbol">.</a><a id="16104" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="16107" class="Symbol">)</a> <a id="16109" href="1Lab.Univalence.SIP.html#15964" class="Bound">t</a><a id="16110" class="Symbol">)))</a>
  <a id="16116" href="1Lab.Path.html#38409" class="Function Operator">··</a> <a id="16119" href="1Lab.Path.html#20807" class="Function">ap</a> <a id="16122" class="Symbol">(</a><a id="16123" href="1Lab.Path.html#15372" class="Function">subst</a> <a id="16129" href="1Lab.Univalence.SIP.html#15955" class="Bound">S</a> <a id="16131" class="Symbol">(</a><a id="16132" href="1Lab.Path.html#10628" class="Function">sym</a> <a id="16136" class="Symbol">(</a><a id="16137" href="1Lab.Univalence.html#8828" class="Function">ua</a> <a id="16140" href="1Lab.Univalence.SIP.html#15962" class="Bound">e</a><a id="16141" class="Symbol">)))</a> <a id="16145" class="Symbol">(</a><a id="16146" href="1Lab.Equiv.html#6488" class="Function">equiv→section</a> <a id="16160" class="Symbol">(</a><a id="16161" href="1Lab.Univalence.SIP.html#15958" class="Bound">α</a> <a id="16163" href="1Lab.Univalence.SIP.html#15962" class="Bound">e</a> <a id="16165" class="Symbol">.</a><a id="16166" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="16169" class="Symbol">)</a> <a id="16171" href="1Lab.Univalence.SIP.html#15964" class="Bound">t</a><a id="16172" class="Symbol">)</a>
</pre>-->
<p>If <code>S</code> is a <code class="sourceCode agda" id="isTransportStr">transport structure</code>, then its canonical equipment as a <span class="Agda"><a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a></span> is univalent:</p>
<pre class="Agda"><a id="isTransp→isUnivalent"></a><a data-type="(a : EqvAction S₁) →
isTransportStr a → isUnivalent (Action→Structure a)" id="16319" href="1Lab.Univalence.SIP.html#16319" class="Function">isTransp→isUnivalent</a> <a id="16340" class="Symbol">:</a> <a id="16342" class="Symbol">{</a><a id="16343" href="1Lab.Univalence.SIP.html#16343" class="Bound">S</a> <a id="16345" class="Symbol">:</a> <a id="16347" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="16352" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a> <a id="16354" class="Symbol">→</a> <a id="16356" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="16361" href="1Lab.Univalence.SIP.html#3459" class="Generalizable">ℓ₁</a><a id="16363" class="Symbol">}</a> <a id="16365" class="Symbol">(</a><a id="16366" href="1Lab.Univalence.SIP.html#16366" class="Bound">a</a> <a id="16368" class="Symbol">:</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="16370" href="1Lab.Univalence.SIP.html#13565" class="Function">EqvAction</a> <a id="16380" href="1Lab.Univalence.SIP.html#16343" class="Bound">S</a><a id="16381" class="Symbol">)</a>
                     <a id="16404" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="16406" href="1Lab.Univalence.SIP.html#14125" class="Function">isTransportStr</a> <a id="16421" href="1Lab.Univalence.SIP.html#16366" class="Bound">a</a>
                     <a id="16444" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="16446" href="1Lab.Univalence.SIP.html#3849" class="Function">isUnivalent</a> <a id="16458" class="Symbol">(</a><a data-type="EqvAction S₁ → Structure ℓ₁ S₁" id="16459" href="1Lab.Univalence.SIP.html#13671" class="Function">Action→Structure</a> <a id="16476" href="1Lab.Univalence.SIP.html#16366" class="Bound">a</a><a id="16477" class="Symbol">)</a>
<a data-type="(a : EqvAction S₁) →
isTransportStr a → isUnivalent (Action→Structure a)" id="16479" href="1Lab.Univalence.SIP.html#16319" class="Function">isTransp→isUnivalent</a> <a id="16500" class="Symbol">{</a><a id="16501" class="Argument">S</a> <a id="16503" class="Symbol">=</a> <a id="16505" href="1Lab.Univalence.SIP.html#16505" class="Bound">S</a><a id="16506" class="Symbol">}</a> <a id="16508" href="1Lab.Univalence.SIP.html#16508" class="Bound">act</a> <a id="16512" href="1Lab.Univalence.SIP.html#16512" class="Bound">is-tr</a> <a id="16518" class="Symbol">{</a><a id="16519" href="1Lab.Univalence.SIP.html#16519" class="Bound">X</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="16521" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="16523" href="1Lab.Univalence.SIP.html#16523" class="Bound">s</a><a id="16524" class="Symbol">}</a> <a id="16526" class="Symbol">{</a><a id="16527" href="1Lab.Univalence.SIP.html#16527" class="Bound">Y</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="16529" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="16531" href="1Lab.Univalence.SIP.html#16531" class="Bound">t</a><a id="16532" class="Symbol">}</a> <a id="16534" href="1Lab.Univalence.SIP.html#16534" class="Bound">eqv</a> <a id="16538" class="Symbol">=</a>
  <a id="16542" href="1Lab.Univalence.SIP.html#16508" class="Bound">act</a> <a id="16546" href="1Lab.Univalence.SIP.html#16534" class="Bound">eqv</a> <a id="16550" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="16551" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="16555" href="1Lab.Univalence.SIP.html#16523" class="Bound">s</a> <a data-type="A → A → Type ℓ" id="16557" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="16559" href="1Lab.Univalence.SIP.html#16531" class="Bound">t</a>              <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" id="16574" href="1Lab.Equiv.html#22842" class="Function Operator">≃⟨</a> <a data-type="A ≡ B₁ → A ≃ B₁" id="16577" href="1Lab.Univalence.html#15495" class="Function">pathToEquiv</a> <a id="16589" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="16590" href="1Lab.Path.html#20807" class="Function">ap</a> <a id="16593" class="Symbol">(</a><a data-type="A → A → Type ℓ" id="16594" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">_≡</a> <a id="16597" href="1Lab.Univalence.SIP.html#16531" class="Bound">t</a><a id="16598" class="Symbol">)</a> <a id="16600" class="Symbol">(</a><a id="16601" href="1Lab.Univalence.SIP.html#16512" class="Bound">is-tr</a> <a id="16607" href="1Lab.Univalence.SIP.html#16534" class="Bound">eqv</a> <a id="16611" href="1Lab.Univalence.SIP.html#16523" class="Bound">s</a><a id="16612" class="Symbol">))</a> <a data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" id="16615" href="1Lab.Equiv.html#22842" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="16619" href="1Lab.Path.html#15372" class="Function">subst</a> <a id="16625" href="1Lab.Univalence.SIP.html#16505" class="Bound">S</a> <a id="16627" class="Symbol">(</a><a data-type="A ≃ B₁ → A ≡ B₁" id="16628" href="1Lab.Univalence.html#8828" class="Function">ua</a> <a id="16631" href="1Lab.Univalence.SIP.html#16534" class="Bound">eqv</a><a id="16634" class="Symbol">)</a> <a id="16636" href="1Lab.Univalence.SIP.html#16523" class="Bound">s</a> <a data-type="A → A → Type ℓ" id="16638" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="16640" href="1Lab.Univalence.SIP.html#16531" class="Bound">t</a>          <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" id="16651" href="1Lab.Equiv.html#22842" class="Function Operator">≃⟨</a> <a data-type="A ≡ B₁ → A ≃ B₁" id="16654" href="1Lab.Univalence.html#15495" class="Function">pathToEquiv</a> <a id="16666" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="16667" href="1Lab.Path.html#10628" class="Function">sym</a> <a id="16671" class="Symbol">(</a><a data-type="(P : I → Type ℓ) (p : P i0) (q : P i1) →
PathP P p q ≡ Path (P i1) (transport P p) q" id="16672" href="1Lab.Path.html#49223" class="Function">PathP≡Path</a> <a id="16683" class="Symbol">(λ</a> <a id="16686" href="1Lab.Univalence.SIP.html#16686" class="Bound">i</a> <a id="16688" class="Symbol">→</a> <a id="16690" href="1Lab.Univalence.SIP.html#16505" class="Bound">S</a> <a id="16692" class="Symbol">(</a><a data-type="A ≃ B₁ → A ≡ B₁" id="16693" href="1Lab.Univalence.html#8828" class="Function">ua</a> <a id="16696" href="1Lab.Univalence.SIP.html#16534" class="Bound">eqv</a> <a id="16700" href="1Lab.Univalence.SIP.html#16686" class="Bound">i</a><a id="16701" class="Symbol">))</a> <a id="16704" href="1Lab.Univalence.SIP.html#16523" class="Bound">s</a> <a id="16706" href="1Lab.Univalence.SIP.html#16531" class="Bound">t</a><a id="16707" class="Symbol">))</a> <a data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" id="16710" href="1Lab.Equiv.html#22842" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="16714" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="16720" class="Symbol">(λ</a> <a id="16723" href="1Lab.Univalence.SIP.html#16723" class="Bound">i</a> <a id="16725" class="Symbol">→</a> <a id="16727" href="1Lab.Univalence.SIP.html#16505" class="Bound">S</a> <a id="16729" class="Symbol">(</a><a data-type="A ≃ B₁ → A ≡ B₁" id="16730" href="1Lab.Univalence.html#8828" class="Function">ua</a> <a id="16733" href="1Lab.Univalence.SIP.html#16534" class="Bound">eqv</a> <a id="16737" href="1Lab.Univalence.SIP.html#16723" class="Bound">i</a><a id="16738" class="Symbol">))</a> <a id="16741" href="1Lab.Univalence.SIP.html#16523" class="Bound">s</a> <a id="16743" href="1Lab.Univalence.SIP.html#16531" class="Bound">t</a>  <a data-type="(A : Type ℓ) → A ≃ A" id="16746" href="1Lab.Equiv.html#23033" class="Function Operator">≃∎</a>
</pre>
<p>We can mix and match these different notions of structure at will. For example, a more convenient definition of function univalent structure uses an equivalence action on the domain:</p>
<pre class="Agda"><a id="functionStr"></a><a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" id="16946" href="1Lab.Univalence.SIP.html#16946" class="Function">functionStr</a> <a id="16958" class="Symbol">:</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="16960" href="1Lab.Univalence.SIP.html#13565" class="Function">EqvAction</a> <a id="16970" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a> <a id="16972" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="16974" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a> <a id="16984" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a> <a id="16986" href="1Lab.Univalence.SIP.html#3493" class="Generalizable">T</a> <a id="16988" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="16990" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a> <a id="17000" class="Symbol">_</a> <a id="17002" class="Symbol">(λ</a> <a id="17005" href="1Lab.Univalence.SIP.html#17005" class="Bound">X</a> <a id="17007" class="Symbol">→</a> <a id="17009" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a> <a id="17011" href="1Lab.Univalence.SIP.html#17005" class="Bound">X</a> <a id="17013" class="Symbol">→</a> <a id="17015" href="1Lab.Univalence.SIP.html#3493" class="Generalizable">T</a> <a id="17017" href="1Lab.Univalence.SIP.html#17005" class="Bound">X</a><a id="17018" class="Symbol">)</a>
<a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" id="17020" href="1Lab.Univalence.SIP.html#16946" class="Function">functionStr</a> <a id="17032" class="Symbol">{</a><a id="17033" class="Argument">S</a> <a id="17035" class="Symbol">=</a> <a id="17037" href="1Lab.Univalence.SIP.html#17037" class="Bound">S</a><a id="17038" class="Symbol">}</a> <a id="17040" href="1Lab.Univalence.SIP.html#17040" class="Bound">act</a> <a id="17044" href="1Lab.Univalence.SIP.html#17044" class="Bound">str</a> <a id="17048" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B₁ : Σ S₁) → A .fst ≃ B₁ .fst → Type ℓ₃" id="17049" href="1Lab.Univalence.SIP.html#2879" class="Field">is-hom</a> <a id="17056" class="Symbol">(</a><a id="17057" href="1Lab.Univalence.SIP.html#17057" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="17059" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17061" href="1Lab.Univalence.SIP.html#17061" class="Bound">f</a><a id="17062" class="Symbol">)</a> <a id="17064" class="Symbol">(</a><a id="17065" href="1Lab.Univalence.SIP.html#17065" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="17067" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17069" href="1Lab.Univalence.SIP.html#17069" class="Bound">g</a><a id="17070" class="Symbol">)</a> <a id="17072" href="1Lab.Univalence.SIP.html#17072" class="Bound">e</a> <a id="17074" class="Symbol">=</a>
  <a id="17078" class="Symbol">(</a><a id="17079" href="1Lab.Univalence.SIP.html#17079" class="Bound">s</a> <a id="17081" class="Symbol">:</a> <a id="17083" href="1Lab.Univalence.SIP.html#17037" class="Bound">S</a> <a id="17085" href="1Lab.Univalence.SIP.html#17057" class="Bound">A</a><a id="17086" class="Symbol">)</a> <a id="17088" class="Symbol">→</a> <a id="17090" href="1Lab.Univalence.SIP.html#17044" class="Bound">str</a> <a id="17094" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B₁ : Σ S₁) → A .fst ≃ B₁ .fst → Type ℓ₃" id="17095" href="1Lab.Univalence.SIP.html#2879" class="Field">is-hom</a> <a id="17102" class="Symbol">(</a><a id="17103" href="1Lab.Univalence.SIP.html#17057" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="17105" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17107" href="1Lab.Univalence.SIP.html#17061" class="Bound">f</a> <a id="17109" href="1Lab.Univalence.SIP.html#17079" class="Bound">s</a><a id="17110" class="Symbol">)</a> <a id="17112" class="Symbol">(</a><a id="17113" href="1Lab.Univalence.SIP.html#17065" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="17115" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17117" href="1Lab.Univalence.SIP.html#17069" class="Bound">g</a> <a id="17119" class="Symbol">(</a><a id="17120" href="1Lab.Univalence.SIP.html#17040" class="Bound">act</a> <a id="17124" href="1Lab.Univalence.SIP.html#17072" class="Bound">e</a> <a id="17126" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="17127" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="17131" href="1Lab.Univalence.SIP.html#17079" class="Bound">s</a><a id="17132" class="Symbol">))</a> <a id="17135" href="1Lab.Univalence.SIP.html#17072" class="Bound">e</a>
</pre>
<p>This alternative definition of structure is univalent when <code>T</code> is a univalent structure and <code>S</code> is a transport structure:</p>
<pre class="Agda"><a id="functionStr-univalent"></a><a data-type="(α : EqvAction S₁) →
isTransportStr α →
(τ : Structure ℓ T) → isUnivalent τ → isUnivalent (functionStr α τ)" id="17273" href="1Lab.Univalence.SIP.html#17273" class="Function">functionStr-univalent</a> <a id="17295" class="Symbol">:</a> <a id="17297" class="Symbol">(</a><a id="17298" href="1Lab.Univalence.SIP.html#17298" class="Bound">α</a> <a id="17300" class="Symbol">:</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="17302" href="1Lab.Univalence.SIP.html#13565" class="Function">EqvAction</a> <a id="17312" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a><a id="17313" class="Symbol">)</a> <a id="17315" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="17317" href="1Lab.Univalence.SIP.html#14125" class="Function">isTransportStr</a> <a id="17332" href="1Lab.Univalence.SIP.html#17298" class="Bound">α</a>
                      <a id="17356" class="Symbol">→</a> <a id="17358" class="Symbol">(</a><a id="17359" href="1Lab.Univalence.SIP.html#17359" class="Bound">τ</a> <a id="17361" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="17363" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a> <a id="17373" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a> <a id="17375" href="1Lab.Univalence.SIP.html#3493" class="Generalizable">T</a><a id="17376" class="Symbol">)</a> <a id="17378" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="17380" href="1Lab.Univalence.SIP.html#3849" class="Function">isUnivalent</a> <a id="17392" href="1Lab.Univalence.SIP.html#17359" class="Bound">τ</a>
                      <a id="17416" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="17418" href="1Lab.Univalence.SIP.html#3849" class="Function">isUnivalent</a> <a id="17430" class="Symbol">(</a><a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" id="17431" href="1Lab.Univalence.SIP.html#16946" class="Function">functionStr</a> <a id="17443" href="1Lab.Univalence.SIP.html#17298" class="Bound">α</a> <a id="17445" href="1Lab.Univalence.SIP.html#17359" class="Bound">τ</a><a id="17446" class="Symbol">)</a>
<a data-type="(α : EqvAction S₁) →
isTransportStr α →
(τ : Structure ℓ T) → isUnivalent τ → isUnivalent (functionStr α τ)" id="17448" href="1Lab.Univalence.SIP.html#17273" class="Function">functionStr-univalent</a> <a id="17470" class="Symbol">{</a><a id="17471" class="Argument">S</a> <a id="17473" class="Symbol">=</a> <a id="17475" href="1Lab.Univalence.SIP.html#17475" class="Bound">S</a><a id="17476" class="Symbol">}</a> <a id="17478" class="Symbol">{</a><a id="17479" class="Argument">T</a> <a id="17481" class="Symbol">=</a> <a id="17483" href="1Lab.Univalence.SIP.html#17483" class="Bound">T</a><a id="17484" class="Symbol">}</a> <a id="17486" href="1Lab.Univalence.SIP.html#17486" class="Bound">α</a> <a id="17488" href="1Lab.Univalence.SIP.html#17488" class="Bound">α-tr</a> <a id="17493" href="1Lab.Univalence.SIP.html#17493" class="Bound">τ</a> <a id="17495" href="1Lab.Univalence.SIP.html#17495" class="Bound">τ-univ</a> <a id="17502" class="Symbol">{</a><a id="17503" href="1Lab.Univalence.SIP.html#17503" class="Bound">X</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="17505" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17507" href="1Lab.Univalence.SIP.html#17507" class="Bound">f</a><a id="17508" class="Symbol">}</a> <a id="17510" class="Symbol">{</a><a id="17511" href="1Lab.Univalence.SIP.html#17511" class="Bound">Y</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="17513" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17515" href="1Lab.Univalence.SIP.html#17515" class="Bound">g</a><a id="17516" class="Symbol">}</a> <a id="17518" href="1Lab.Univalence.SIP.html#17518" class="Bound">eqv</a> <a id="17522" class="Symbol">=</a>
  <a id="17526" class="Symbol">((</a><a id="17528" href="1Lab.Univalence.SIP.html#17528" class="Bound">s</a> <a id="17530" class="Symbol">:</a> <a id="17532" href="1Lab.Univalence.SIP.html#17475" class="Bound">S</a> <a id="17534" href="1Lab.Univalence.SIP.html#17503" class="Bound">X</a><a id="17535" class="Symbol">)</a> <a id="17537" class="Symbol">→</a> <a id="17539" href="1Lab.Univalence.SIP.html#17493" class="Bound">τ</a> <a id="17541" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B₁ : Σ S₁) → A .fst ≃ B₁ .fst → Type ℓ₃" id="17542" href="1Lab.Univalence.SIP.html#2879" class="Field">is-hom</a> <a id="17549" class="Symbol">(</a><a id="17550" href="1Lab.Univalence.SIP.html#17503" class="Bound">X</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="17552" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17554" href="1Lab.Univalence.SIP.html#17507" class="Bound">f</a> <a id="17556" href="1Lab.Univalence.SIP.html#17528" class="Bound">s</a><a id="17557" class="Symbol">)</a> <a id="17559" class="Symbol">(</a><a id="17560" href="1Lab.Univalence.SIP.html#17511" class="Bound">Y</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="17562" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17564" class="Symbol">_)</a> <a id="17567" href="1Lab.Univalence.SIP.html#17518" class="Bound">eqv</a><a id="17570" class="Symbol">)</a>     <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" id="17576" href="1Lab.Equiv.html#22842" class="Function Operator">≃⟨</a> <a data-type="((x : A) → P x ≃ Q x) → ((x : A) → P x) ≃ ((x : A) → Q x)" id="17579" href="1Lab.Type.Pi.html#663" class="Function">Π-cod≃</a> <a id="17586" class="Symbol">(λ</a> <a id="17589" href="1Lab.Univalence.SIP.html#17589" class="Bound">s</a> <a id="17591" class="Symbol">→</a> <a id="17593" href="1Lab.Univalence.SIP.html#17495" class="Bound">τ-univ</a> <a id="17600" href="1Lab.Univalence.SIP.html#17518" class="Bound">eqv</a> <a data-type="A ≃ B₁ → B₁ ≃ C → A ≃ C" id="17604" href="1Lab.Equiv.html#21166" class="Function Operator">∙e</a> <a data-type="A ≡ B₁ → A ≃ B₁" id="17607" href="1Lab.Univalence.html#15495" class="Function">pathToEquiv</a> <a id="17619" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="17620" href="1Lab.Path.html#20807" class="Function">ap</a> <a id="17623" class="Symbol">(</a><a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="17624" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="17630" class="Symbol">(λ</a> <a id="17633" href="1Lab.Univalence.SIP.html#17633" class="Bound">i</a> <a id="17635" class="Symbol">→</a> <a id="17637" href="1Lab.Univalence.SIP.html#17483" class="Bound">T</a> <a id="17639" class="Symbol">(</a><a data-type="A ≃ B₁ → A ≡ B₁" id="17640" href="1Lab.Univalence.html#8828" class="Function">ua</a> <a id="17643" href="1Lab.Univalence.SIP.html#17518" class="Bound">eqv</a> <a id="17647" href="1Lab.Univalence.SIP.html#17633" class="Bound">i</a><a id="17648" class="Symbol">))</a> <a id="17651" class="Symbol">(</a><a id="17652" href="1Lab.Univalence.SIP.html#17507" class="Bound">f</a> <a id="17654" href="1Lab.Univalence.SIP.html#17589" class="Bound">s</a><a id="17655" class="Symbol">)</a> <a data-type="(B₁ → C) → (A → B₁) → A → C" id="17657" href="1Lab.Type.html#2217" class="Function Operator">∘</a> <a id="17659" href="1Lab.Univalence.SIP.html#17515" class="Bound">g</a><a id="17660" class="Symbol">)</a> <a id="17662" class="Symbol">(</a><a id="17663" href="1Lab.Univalence.SIP.html#17488" class="Bound">α-tr</a> <a id="17668" class="Symbol">_</a> <a id="17670" class="Symbol">_)))</a> <a data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" id="17675" href="1Lab.Equiv.html#22842" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a id="17679" class="Symbol">((</a><a id="17681" href="1Lab.Univalence.SIP.html#17681" class="Bound">s</a> <a id="17683" class="Symbol">:</a> <a id="17685" href="1Lab.Univalence.SIP.html#17475" class="Bound">S</a> <a id="17687" href="1Lab.Univalence.SIP.html#17503" class="Bound">X</a><a id="17688" class="Symbol">)</a> <a id="17690" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="17692" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="17698" class="Symbol">(λ</a> <a id="17701" href="1Lab.Univalence.SIP.html#17701" class="Bound">i</a> <a id="17703" class="Symbol">→</a> <a id="17705" href="1Lab.Univalence.SIP.html#17483" class="Bound">T</a> <a id="17707" class="Symbol">(</a><a data-type="A ≃ B₁ → A ≡ B₁" id="17708" href="1Lab.Univalence.html#8828" class="Function">ua</a> <a id="17711" href="1Lab.Univalence.SIP.html#17518" class="Bound">eqv</a> <a id="17715" href="1Lab.Univalence.SIP.html#17701" class="Bound">i</a><a id="17716" class="Symbol">))</a> <a id="17719" class="Symbol">(</a><a id="17720" href="1Lab.Univalence.SIP.html#17507" class="Bound">f</a> <a id="17722" href="1Lab.Univalence.SIP.html#17681" class="Bound">s</a><a id="17723" class="Symbol">)</a> <a id="17725" class="Symbol">_)</a>  <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" id="17729" href="1Lab.Equiv.html#22842" class="Function Operator">≃⟨</a> <a id="17732" class="Symbol">(</a><a data-type="({x₀ : A i0} {x₁ : A i1} → PathP A x₀ x₁ → PathP B₁ (f x₀) (g x₁))
≃ ((x₀ : A i0) → PathP B₁ (f x₀) (g (coe0→1 A x₀)))" id="17733" href="1Lab.Type.Pi.html#4299" class="Function">heteroHomotopy≃Homotopy</a> <a data-type="A ≃ B₁ → B₁ ≃ A" id="17757" href="1Lab.Equiv.html#21256" class="Function Operator">e⁻¹</a><a id="17760" class="Symbol">)</a> <a data-type="A ≃ B₁ → B₁ ≃ C → A ≃ C" id="17762" href="1Lab.Equiv.html#21166" class="Function Operator">∙e</a> <a data-type="({x₀ : A i0} {x₁ : A i1} (p : PathP A x₀ x₁) →
 PathP (λ i → B₁ i (p i)) (f x₀) (g x₁))
≃ PathP (λ i → (x : A i) → B₁ i x) f g" id="17765" href="1Lab.Type.Pi.html#3103" class="Function">funextDep≃</a> <a data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" id="17776" href="1Lab.Equiv.html#22842" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a id="17780" class="Symbol">_</a>                                                 <a data-type="(A : Type ℓ) → A ≃ A" id="17830" href="1Lab.Equiv.html#23033" class="Function Operator">≃∎</a>
</pre>
<p>To see why <span class="Agda"><a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" href="1Lab.Univalence.SIP.html#16946" class="Function">functionStr</a></span> is more convenient than <span class="Agda"><a data-type="Structure ℓ₁ S₁ →
Structure ℓ₂ T → Structure (ℓ₁ ⊔ S.ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" href="1Lab.Univalence.SIP.html#8498" class="Function">the previous definition</a></span> - which is why it gets the shorter name - it’s convenient to consider how the <span class="Agda"><a data-type="Structure ℓ (λ X → X)" href="1Lab.Univalence.SIP.html#7063" class="Function">pointed structure</a></span> acts on equivalences: <em>not at all</em>. Recall the definition of ∞-magma equivalence generated by <span class="Agda"><a data-type="Structure ℓ₁ S₁ →
Structure ℓ₂ T → Structure (ℓ₁ ⊔ S.ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" href="1Lab.Univalence.SIP.html#8498" class="Function">Str-functionStr</a></span>:</p>
<pre class="Agda"><a id="18218" class="Keyword">private</a>
  <a id="18228" href="1Lab.Univalence.SIP.html#18228" class="Function">_</a> <a id="18230" class="Symbol">:</a> <a id="18232" class="Symbol">{</a><a id="18233" href="1Lab.Univalence.SIP.html#18233" class="Bound">A</a> <a id="18235" href="1Lab.Univalence.SIP.html#18235" class="Bound">B</a> <a id="18237" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="18239" href="1Lab.Univalence.SIP.html#3323" class="Function">TypeWith</a> <a id="18248" href="1Lab.Univalence.SIP.html#9822" class="Function">∞-Magma</a><a id="18255" class="Symbol">}</a> <a id="18257" class="Symbol">{</a><a id="18258" href="1Lab.Univalence.SIP.html#18258" class="Bound">f</a> <a id="18260" class="Symbol">:</a> <a id="18262" href="1Lab.Univalence.SIP.html#18233" class="Bound">A</a> <a id="18264" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="18265" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="18269" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="18271" href="1Lab.Univalence.SIP.html#18235" class="Bound">B</a> <a id="18273" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="18274" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="18277" class="Symbol">}</a>
    <a id="18283" class="Symbol">→</a> <a id="18285" href="1Lab.Univalence.SIP.html#9822" class="Function">∞-Magma</a> <a id="18293" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B₁ : Σ S₁) → A .fst ≃ B₁ .fst → Type ℓ₃" id="18294" href="1Lab.Univalence.SIP.html#2879" class="Field">is-hom</a> <a id="18301" href="1Lab.Univalence.SIP.html#18233" class="Bound">A</a> <a id="18303" href="1Lab.Univalence.SIP.html#18235" class="Bound">B</a> <a id="18305" href="1Lab.Univalence.SIP.html#18258" class="Bound">f</a>
    <a data-type="A → A → Type ℓ" id="18311" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="18313" class="Symbol">(</a> <a id="18315" class="Symbol">{</a><a id="18316" href="1Lab.Univalence.SIP.html#18316" class="Bound">s</a> <a id="18318" class="Symbol">:</a> <a id="18320" href="1Lab.Univalence.SIP.html#18233" class="Bound">A</a> <a id="18322" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="18323" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="18326" class="Symbol">}</a> <a id="18328" class="Symbol">{</a><a id="18329" href="1Lab.Univalence.SIP.html#18329" class="Bound">t</a> <a id="18331" class="Symbol">:</a> <a id="18333" href="1Lab.Univalence.SIP.html#18235" class="Bound">B</a> <a id="18335" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="18336" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="18339" class="Symbol">}</a> <a id="18341" class="Symbol">→</a> <a id="18343" href="1Lab.Univalence.SIP.html#18258" class="Bound">f</a> <a id="18345" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="18346" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="18350" href="1Lab.Univalence.SIP.html#18316" class="Bound">s</a> <a data-type="A → A → Type ℓ" id="18352" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="18354" href="1Lab.Univalence.SIP.html#18329" class="Bound">t</a>
      <a id="18362" class="Symbol">→</a> <a id="18364" class="Symbol">{</a><a id="18365" href="1Lab.Univalence.SIP.html#18365" class="Bound">x</a> <a id="18367" class="Symbol">:</a> <a id="18369" href="1Lab.Univalence.SIP.html#18233" class="Bound">A</a> <a id="18371" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="18372" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="18375" class="Symbol">}</a> <a id="18377" class="Symbol">{</a><a id="18378" href="1Lab.Univalence.SIP.html#18378" class="Bound">y</a> <a id="18380" class="Symbol">:</a> <a id="18382" href="1Lab.Univalence.SIP.html#18235" class="Bound">B</a> <a id="18384" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="18385" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="18388" class="Symbol">}</a> <a id="18390" class="Symbol">→</a> <a id="18392" href="1Lab.Univalence.SIP.html#18258" class="Bound">f</a> <a id="18394" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="18395" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="18399" href="1Lab.Univalence.SIP.html#18365" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="18401" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="18403" href="1Lab.Univalence.SIP.html#18378" class="Bound">y</a>
      <a id="18411" class="Symbol">→</a> <a id="18413" href="1Lab.Univalence.SIP.html#18258" class="Bound">f</a> <a id="18415" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="18416" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="18420" class="Symbol">(</a><a id="18421" href="1Lab.Univalence.SIP.html#18233" class="Bound">A</a> <a id="18423" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="18424" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="18428" href="1Lab.Univalence.SIP.html#18316" class="Bound">s</a> <a id="18430" href="1Lab.Univalence.SIP.html#18365" class="Bound">x</a><a id="18431" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="18433" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="18435" href="1Lab.Univalence.SIP.html#18235" class="Bound">B</a> <a id="18437" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="18438" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="18442" href="1Lab.Univalence.SIP.html#18329" class="Bound">t</a> <a id="18444" href="1Lab.Univalence.SIP.html#18378" class="Bound">y</a><a id="18445" class="Symbol">)</a>
  <a id="18449" class="Symbol">_</a> <a id="18451" class="Symbol">=</a> <a data-type="x ≡ x" id="18453" href="1Lab.Path.html#3591" class="Function">refl</a>
</pre>
<p>Let’s rewrite <span class="Agda"><a href="1Lab.Univalence.SIP.html#9822" class="Function">∞-Magma</a></span> using <span class="Agda"><a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" href="1Lab.Univalence.SIP.html#16946" class="Function">functionStr</a></span> to see how it compares:</p>
<pre class="Agda">  <a id="∞-Magma′"></a><a id="18556" href="1Lab.Univalence.SIP.html#18556" class="Function">∞-Magma′</a> <a id="18565" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="18567" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a> <a data-type="Level" id="18577" href="Agda.Primitive.html#764" class="Primitive">lzero</a> <a id="18583" href="1Lab.Univalence.SIP.html#9556" class="Function">binop</a>
  <a id="18591" href="1Lab.Univalence.SIP.html#18556" class="Function">∞-Magma′</a> <a id="18600" class="Symbol">=</a> <a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" id="18602" href="1Lab.Univalence.SIP.html#16946" class="Function">functionStr</a> <a data-type="A → A" id="18614" href="1Lab.Type.html#2348" class="Function">id</a> <a id="18617" class="Symbol">(</a><a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" id="18618" href="1Lab.Univalence.SIP.html#16946" class="Function">functionStr</a> <a data-type="A → A" id="18630" href="1Lab.Type.html#2348" class="Function">id</a> <a data-type="Structure ℓ (λ X → X)" id="18633" href="1Lab.Univalence.SIP.html#7063" class="Function">pointedStr</a><a id="18643" class="Symbol">)</a>

  <a id="18648" href="1Lab.Univalence.SIP.html#18648" class="Function">_</a> <a id="18650" class="Symbol">:</a> <a id="18652" class="Symbol">{</a><a id="18653" href="1Lab.Univalence.SIP.html#18653" class="Bound">A</a> <a id="18655" href="1Lab.Univalence.SIP.html#18655" class="Bound">B</a> <a id="18657" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="18659" href="1Lab.Univalence.SIP.html#3323" class="Function">TypeWith</a> <a id="18668" href="1Lab.Univalence.SIP.html#9822" class="Function">∞-Magma</a><a id="18675" class="Symbol">}</a> <a id="18677" class="Symbol">{</a><a id="18678" href="1Lab.Univalence.SIP.html#18678" class="Bound">f</a> <a id="18680" class="Symbol">:</a> <a id="18682" href="1Lab.Univalence.SIP.html#18653" class="Bound">A</a> <a id="18684" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="18685" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="18689" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="18691" href="1Lab.Univalence.SIP.html#18655" class="Bound">B</a> <a id="18693" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="18694" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="18697" class="Symbol">}</a>
    <a id="18703" class="Symbol">→</a> <a id="18705" href="1Lab.Univalence.SIP.html#18556" class="Function">∞-Magma′</a> <a id="18714" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B₁ : Σ S₁) → A .fst ≃ B₁ .fst → Type ℓ₃" id="18715" href="1Lab.Univalence.SIP.html#2879" class="Field">is-hom</a> <a id="18722" href="1Lab.Univalence.SIP.html#18653" class="Bound">A</a> <a id="18724" href="1Lab.Univalence.SIP.html#18655" class="Bound">B</a> <a id="18726" href="1Lab.Univalence.SIP.html#18678" class="Bound">f</a>
    <a data-type="A → A → Type ℓ" id="18732" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="18734" class="Symbol">(</a> <a id="18736" class="Symbol">(</a><a id="18737" href="1Lab.Univalence.SIP.html#18737" class="Bound">x</a> <a id="18739" href="1Lab.Univalence.SIP.html#18739" class="Bound">y</a> <a id="18741" class="Symbol">:</a> <a id="18743" href="1Lab.Univalence.SIP.html#18653" class="Bound">A</a> <a id="18745" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="18746" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="18749" class="Symbol">)</a> <a id="18751" class="Symbol">→</a> <a id="18753" href="1Lab.Univalence.SIP.html#18678" class="Bound">f</a> <a id="18755" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="18756" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="18760" class="Symbol">(</a><a id="18761" href="1Lab.Univalence.SIP.html#18653" class="Bound">A</a> <a id="18763" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="18764" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="18768" href="1Lab.Univalence.SIP.html#18737" class="Bound">x</a> <a id="18770" href="1Lab.Univalence.SIP.html#18739" class="Bound">y</a><a id="18771" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="18773" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="18775" href="1Lab.Univalence.SIP.html#18655" class="Bound">B</a> <a id="18777" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="18778" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="18782" class="Symbol">(</a><a id="18783" href="1Lab.Univalence.SIP.html#18678" class="Bound">f</a> <a id="18785" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="18786" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="18790" href="1Lab.Univalence.SIP.html#18737" class="Bound">x</a><a id="18791" class="Symbol">)</a> <a id="18793" class="Symbol">(</a><a id="18794" href="1Lab.Univalence.SIP.html#18678" class="Bound">f</a> <a id="18796" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="18797" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="18801" href="1Lab.Univalence.SIP.html#18739" class="Bound">y</a><a id="18802" class="Symbol">))</a>
  <a id="18807" class="Symbol">_</a> <a id="18809" class="Symbol">=</a> <a data-type="x ≡ x" id="18811" href="1Lab.Path.html#3591" class="Function">refl</a>
</pre>
<p>Much better! This gets rid of all those redundant paths that were previously present, using the fact that <code>λ X → X</code> <em>does not need to act on equivalences</em>.</p>
<p>In general, transport structures are closed under all of the same operations as univalent structures, which begs the question: Why mention univalent structures at all? The reason is that a definition of structure homomorphism is very often needed, and the data of a univalent structure is perfect to use in the definition of <span class="Agda"><a data-type="isUnivalent σ → (X ≃[ σ ] Y) ≃ (X ≡ Y)" href="1Lab.Univalence.SIP.html#4653" class="Function">SIP</a></span>.</p>
<details>
<summary>
The closure properties of transport structures are in this <code>&lt;details&gt;</code> tag to keep the length of the page shorter
</summary>
<pre class="Agda"><a id="constantAction"></a><a data-type="(A : Type ℓ) → EqvAction (λ X → A)" id="19471" href="1Lab.Univalence.SIP.html#19471" class="Function">constantAction</a> <a id="19486" class="Symbol">:</a> <a id="19488" class="Symbol">(</a><a id="19489" href="1Lab.Univalence.SIP.html#19489" class="Bound">A</a> <a id="19491" class="Symbol">:</a> <a id="19493" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="19498" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a><a id="19499" class="Symbol">)</a> <a id="19501" class="Symbol">→</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="19503" href="1Lab.Univalence.SIP.html#13565" class="Function">EqvAction</a> <a id="19513" class="Symbol">{</a><a id="19514" class="Argument">ℓ</a> <a id="19516" class="Symbol">=</a> <a id="19518" href="1Lab.Univalence.SIP.html#3459" class="Generalizable">ℓ₁</a><a id="19520" class="Symbol">}</a> <a id="19522" class="Symbol">(λ</a> <a id="19525" href="1Lab.Univalence.SIP.html#19525" class="Bound">X</a> <a id="19527" class="Symbol">→</a> <a id="19529" href="1Lab.Univalence.SIP.html#19489" class="Bound">A</a><a id="19530" class="Symbol">)</a>
<a data-type="(A : Type ℓ) → EqvAction (λ X → A)" id="19532" href="1Lab.Univalence.SIP.html#19471" class="Function">constantAction</a> <a id="19547" href="1Lab.Univalence.SIP.html#19547" class="Bound">A</a> <a id="19549" href="1Lab.Univalence.SIP.html#19549" class="Bound">eqv</a> <a id="19553" class="Symbol">=</a> <a id="19555" class="Symbol">_</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="19557" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="19559" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a>

<a id="constantAction-isTransp"></a><a data-type="isTransportStr (constantAction A)" id="19568" href="1Lab.Univalence.SIP.html#19568" class="Function">constantAction-isTransp</a> <a id="19592" class="Symbol">:</a> <a id="19594" class="Symbol">{</a><a id="19595" href="1Lab.Univalence.SIP.html#19595" class="Bound">A</a> <a id="19597" class="Symbol">:</a> <a id="19599" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="19604" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a><a id="19605" class="Symbol">}</a> <a id="19607" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="19609" href="1Lab.Univalence.SIP.html#14125" class="Function">isTransportStr</a> <a id="19624" class="Symbol">{</a><a id="19625" class="Argument">ℓ</a> <a id="19627" class="Symbol">=</a> <a id="19629" href="1Lab.Univalence.SIP.html#3459" class="Generalizable">ℓ₁</a><a id="19631" class="Symbol">}</a> <a id="19633" class="Symbol">(</a><a data-type="(A : Type ℓ) → EqvAction (λ X → A)" id="19634" href="1Lab.Univalence.SIP.html#19471" class="Function">constantAction</a> <a id="19649" href="1Lab.Univalence.SIP.html#19595" class="Bound">A</a><a id="19650" class="Symbol">)</a>
<a data-type="isTransportStr (constantAction A)" id="19652" href="1Lab.Univalence.SIP.html#19568" class="Function">constantAction-isTransp</a> <a id="19676" href="1Lab.Univalence.SIP.html#19676" class="Bound">f</a> <a id="19678" href="1Lab.Univalence.SIP.html#19678" class="Bound">s</a> <a id="19680" class="Symbol">=</a> <a data-type="x ≡ y → y ≡ x" id="19682" href="1Lab.Path.html#10628" class="Function">sym</a> <a id="19686" class="Symbol">(</a><a data-type="(x : A) → transport (λ i → A) x ≡ x" id="19687" href="1Lab.Path.html#13523" class="Function">transport-refl</a> <a id="19702" class="Symbol">_)</a>

<a id="idAction-isTransp"></a><a data-type="isTransportStr id" id="19706" href="1Lab.Univalence.SIP.html#19706" class="Function">idAction-isTransp</a> <a id="19724" class="Symbol">:</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="19726" href="1Lab.Univalence.SIP.html#14125" class="Function">isTransportStr</a> <a id="19741" class="Symbol">{</a><a id="19742" class="Argument">ℓ</a> <a id="19744" class="Symbol">=</a> <a id="19746" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a><a id="19747" class="Symbol">}</a> <a id="19749" class="Symbol">{</a><a id="19750" class="Argument">ℓ₁</a> <a id="19753" class="Symbol">=</a> <a id="19755" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a><a id="19756" class="Symbol">}</a> <a data-type="A → A" id="19758" href="1Lab.Type.html#2348" class="Function">id</a>
<a data-type="isTransportStr id" id="19761" href="1Lab.Univalence.SIP.html#19706" class="Function">idAction-isTransp</a> <a id="19779" href="1Lab.Univalence.SIP.html#19779" class="Bound">f</a> <a id="19781" href="1Lab.Univalence.SIP.html#19781" class="Bound">s</a> <a id="19783" class="Symbol">=</a> <a data-type="x ≡ y → y ≡ x" id="19785" href="1Lab.Path.html#10628" class="Function">sym</a> <a id="19789" class="Symbol">(</a><a data-type="(x : A) → transport (λ i → A) x ≡ x" id="19790" href="1Lab.Path.html#13523" class="Function">transport-refl</a> <a id="19805" class="Symbol">_)</a>

<a id="productAction"></a><a data-type="EqvAction S₁ → EqvAction T → EqvAction (λ X → S₁ X × T X)" id="19809" href="1Lab.Univalence.SIP.html#19809" class="Function">productAction</a> <a id="19823" class="Symbol">:</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="19825" href="1Lab.Univalence.SIP.html#13565" class="Function">EqvAction</a> <a id="19835" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a> <a id="19837" class="Symbol">→</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="19839" href="1Lab.Univalence.SIP.html#13565" class="Function">EqvAction</a> <a id="19849" href="1Lab.Univalence.SIP.html#3493" class="Generalizable">T</a> <a id="19851" class="Symbol">→</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="19853" href="1Lab.Univalence.SIP.html#13565" class="Function">EqvAction</a> <a id="19863" class="Symbol">(λ</a> <a id="19866" href="1Lab.Univalence.SIP.html#19866" class="Bound">X</a> <a id="19868" class="Symbol">→</a> <a id="19870" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a> <a id="19872" href="1Lab.Univalence.SIP.html#19866" class="Bound">X</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="19874" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="19876" href="1Lab.Univalence.SIP.html#3493" class="Generalizable">T</a> <a id="19878" href="1Lab.Univalence.SIP.html#19866" class="Bound">X</a><a id="19879" class="Symbol">)</a>
<a data-type="EqvAction S₁ → EqvAction T → EqvAction (λ X → S₁ X × T X)" id="19881" href="1Lab.Univalence.SIP.html#19809" class="Function">productAction</a> <a id="19895" href="1Lab.Univalence.SIP.html#19895" class="Bound">actx</a> <a id="19900" href="1Lab.Univalence.SIP.html#19900" class="Bound">acty</a> <a id="19905" href="1Lab.Univalence.SIP.html#19905" class="Bound">eqv</a> <a id="19909" class="Symbol">=</a> <a data-type="(e : A ≃ A&#39;) → ((x : A) → P x ≃ Q (e .fst x)) → Σ P ≃ Σ Q" id="19911" href="1Lab.Type.Sigma.html#2110" class="Function">Σ-ap</a> <a id="19916" class="Symbol">(</a><a id="19917" href="1Lab.Univalence.SIP.html#19895" class="Bound">actx</a> <a id="19922" href="1Lab.Univalence.SIP.html#19905" class="Bound">eqv</a><a id="19925" class="Symbol">)</a> <a id="19927" class="Symbol">λ</a> <a id="19929" href="1Lab.Univalence.SIP.html#19929" class="Bound">x</a> <a id="19931" class="Symbol">→</a> <a id="19933" href="1Lab.Univalence.SIP.html#19900" class="Bound">acty</a> <a id="19938" href="1Lab.Univalence.SIP.html#19905" class="Bound">eqv</a>

<a id="productAction-isTransp"></a><a data-type="isTransportStr α →
isTransportStr β → isTransportStr (productAction α β)" id="19943" href="1Lab.Univalence.SIP.html#19943" class="Function">productAction-isTransp</a> <a id="19966" class="Symbol">:</a> <a id="19968" class="Symbol">{</a><a id="19969" href="1Lab.Univalence.SIP.html#19969" class="Bound">α</a> <a id="19971" class="Symbol">:</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="19973" href="1Lab.Univalence.SIP.html#13565" class="Function">EqvAction</a> <a id="19983" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a><a id="19984" class="Symbol">}</a> <a id="19986" class="Symbol">{</a><a id="19987" href="1Lab.Univalence.SIP.html#19987" class="Bound">β</a> <a id="19989" class="Symbol">:</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="19991" href="1Lab.Univalence.SIP.html#13565" class="Function">EqvAction</a> <a id="20001" href="1Lab.Univalence.SIP.html#3493" class="Generalizable">T</a><a id="20002" class="Symbol">}</a>
                       <a id="20027" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="20029" href="1Lab.Univalence.SIP.html#14125" class="Function">isTransportStr</a> <a id="20044" href="1Lab.Univalence.SIP.html#19969" class="Bound">α</a> <a id="20046" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="20048" href="1Lab.Univalence.SIP.html#14125" class="Function">isTransportStr</a> <a id="20063" href="1Lab.Univalence.SIP.html#19987" class="Bound">β</a>
                       <a id="20088" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="20090" href="1Lab.Univalence.SIP.html#14125" class="Function">isTransportStr</a> <a id="20105" class="Symbol">(</a><a data-type="EqvAction S₁ → EqvAction T → EqvAction (λ X → S₁ X × T X)" id="20106" href="1Lab.Univalence.SIP.html#19809" class="Function">productAction</a> <a id="20120" href="1Lab.Univalence.SIP.html#19969" class="Bound">α</a> <a id="20122" href="1Lab.Univalence.SIP.html#19987" class="Bound">β</a><a id="20123" class="Symbol">)</a>
<a data-type="isTransportStr α →
isTransportStr β → isTransportStr (productAction α β)" id="20125" href="1Lab.Univalence.SIP.html#19943" class="Function">productAction-isTransp</a> <a id="20148" href="1Lab.Univalence.SIP.html#20148" class="Bound">α-tr</a> <a id="20153" href="1Lab.Univalence.SIP.html#20153" class="Bound">β-tr</a> <a id="20158" href="1Lab.Univalence.SIP.html#20158" class="Bound">e</a> <a id="20160" href="1Lab.Univalence.SIP.html#20160" class="Bound">s</a> <a id="20162" class="Symbol">=</a> <a data-type="(p : x .fst ≡ y .fst) →
PathP (λ i → B₁ (p i)) (x .snd) (y .snd) → x ≡ y" id="20164" href="1Lab.Path.html#57258" class="Function">Σ-PathP</a> <a id="20172" class="Symbol">(</a><a id="20173" href="1Lab.Univalence.SIP.html#20148" class="Bound">α-tr</a> <a id="20178" href="1Lab.Univalence.SIP.html#20158" class="Bound">e</a> <a id="20180" class="Symbol">(</a><a id="20181" href="1Lab.Univalence.SIP.html#20160" class="Bound">s</a> <a id="20183" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="20184" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="20187" class="Symbol">))</a> <a id="20190" class="Symbol">(</a><a id="20191" href="1Lab.Univalence.SIP.html#20153" class="Bound">β-tr</a> <a id="20196" href="1Lab.Univalence.SIP.html#20158" class="Bound">e</a> <a id="20198" class="Symbol">(</a><a id="20199" href="1Lab.Univalence.SIP.html#20160" class="Bound">s</a> <a id="20201" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="20202" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="20205" class="Symbol">))</a>

<a id="functionAction"></a><a data-type="EqvAction S₁ → EqvAction T → EqvAction (λ X → S₁ X → T X)" id="20209" href="1Lab.Univalence.SIP.html#20209" class="Function">functionAction</a> <a id="20224" class="Symbol">:</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="20226" href="1Lab.Univalence.SIP.html#13565" class="Function">EqvAction</a> <a id="20236" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a> <a id="20238" class="Symbol">→</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="20240" href="1Lab.Univalence.SIP.html#13565" class="Function">EqvAction</a> <a id="20250" href="1Lab.Univalence.SIP.html#3493" class="Generalizable">T</a> <a id="20252" class="Symbol">→</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="20254" href="1Lab.Univalence.SIP.html#13565" class="Function">EqvAction</a> <a id="20264" class="Symbol">(λ</a> <a id="20267" href="1Lab.Univalence.SIP.html#20267" class="Bound">X</a> <a id="20269" class="Symbol">→</a> <a id="20271" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a> <a id="20273" href="1Lab.Univalence.SIP.html#20267" class="Bound">X</a> <a id="20275" class="Symbol">→</a> <a id="20277" href="1Lab.Univalence.SIP.html#3493" class="Generalizable">T</a> <a id="20279" href="1Lab.Univalence.SIP.html#20267" class="Bound">X</a><a id="20280" class="Symbol">)</a>
<a data-type="EqvAction S₁ → EqvAction T → EqvAction (λ X → S₁ X → T X)" id="20282" href="1Lab.Univalence.SIP.html#20209" class="Function">functionAction</a> <a id="20297" href="1Lab.Univalence.SIP.html#20297" class="Bound">actx</a> <a id="20302" href="1Lab.Univalence.SIP.html#20302" class="Bound">acty</a> <a id="20307" href="1Lab.Univalence.SIP.html#20307" class="Bound">eqv</a> <a id="20311" class="Symbol">=</a> <a data-type="A ≃ B₁ → C ≃ D → (A → C) ≃ (B₁ → D)" id="20313" href="1Lab.Type.Pi.html#1721" class="Function">function≃</a> <a id="20323" class="Symbol">(</a><a id="20324" href="1Lab.Univalence.SIP.html#20297" class="Bound">actx</a> <a id="20329" href="1Lab.Univalence.SIP.html#20307" class="Bound">eqv</a><a id="20332" class="Symbol">)</a> <a id="20334" class="Symbol">(</a><a id="20335" href="1Lab.Univalence.SIP.html#20302" class="Bound">acty</a> <a id="20340" href="1Lab.Univalence.SIP.html#20307" class="Bound">eqv</a><a id="20343" class="Symbol">)</a>

<a id="functionAction-isTransp"></a><a data-type="isTransportStr α →
isTransportStr β → isTransportStr (functionAction α β)" id="20346" href="1Lab.Univalence.SIP.html#20346" class="Function">functionAction-isTransp</a> <a id="20370" class="Symbol">:</a> <a id="20372" class="Symbol">{</a><a id="20373" href="1Lab.Univalence.SIP.html#20373" class="Bound">α</a> <a id="20375" class="Symbol">:</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="20377" href="1Lab.Univalence.SIP.html#13565" class="Function">EqvAction</a> <a id="20387" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a><a id="20388" class="Symbol">}</a> <a id="20390" class="Symbol">{</a><a id="20391" href="1Lab.Univalence.SIP.html#20391" class="Bound">β</a> <a id="20393" class="Symbol">:</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="20395" href="1Lab.Univalence.SIP.html#13565" class="Function">EqvAction</a> <a id="20405" href="1Lab.Univalence.SIP.html#3493" class="Generalizable">T</a><a id="20406" class="Symbol">}</a>
                        <a id="20432" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="20434" href="1Lab.Univalence.SIP.html#14125" class="Function">isTransportStr</a> <a id="20449" href="1Lab.Univalence.SIP.html#20373" class="Bound">α</a> <a id="20451" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="20453" href="1Lab.Univalence.SIP.html#14125" class="Function">isTransportStr</a> <a id="20468" href="1Lab.Univalence.SIP.html#20391" class="Bound">β</a>
                        <a id="20494" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="20496" href="1Lab.Univalence.SIP.html#14125" class="Function">isTransportStr</a> <a id="20511" class="Symbol">(</a><a data-type="EqvAction S₁ → EqvAction T → EqvAction (λ X → S₁ X → T X)" id="20512" href="1Lab.Univalence.SIP.html#20209" class="Function">functionAction</a> <a id="20527" href="1Lab.Univalence.SIP.html#20373" class="Bound">α</a> <a id="20529" href="1Lab.Univalence.SIP.html#20391" class="Bound">β</a><a id="20530" class="Symbol">)</a>
<a data-type="isTransportStr α →
isTransportStr β → isTransportStr (functionAction α β)" id="20532" href="1Lab.Univalence.SIP.html#20346" class="Function">functionAction-isTransp</a> <a id="20556" class="Symbol">{</a><a id="20557" class="Argument">S</a> <a id="20559" class="Symbol">=</a> <a id="20561" href="1Lab.Univalence.SIP.html#20561" class="Bound">S</a><a id="20562" class="Symbol">}</a> <a id="20564" class="Symbol">{</a><a id="20565" class="Argument">α</a> <a id="20567" class="Symbol">=</a> <a id="20569" href="1Lab.Univalence.SIP.html#20569" class="Bound">α</a><a id="20570" class="Symbol">}</a> <a id="20572" class="Symbol">{</a><a id="20573" class="Argument">β</a> <a id="20575" class="Symbol">=</a> <a id="20577" href="1Lab.Univalence.SIP.html#20577" class="Bound">β</a><a id="20578" class="Symbol">}</a> <a id="20580" href="1Lab.Univalence.SIP.html#20580" class="Bound">α-tr</a> <a id="20585" href="1Lab.Univalence.SIP.html#20585" class="Bound">β-tr</a> <a id="20590" href="1Lab.Univalence.SIP.html#20590" class="Bound">eqv</a> <a id="20594" href="1Lab.Univalence.SIP.html#20594" class="Bound">f</a> <a id="20596" class="Symbol">=</a>
  <a data-type="((x : A) → f x ≡ g x) → f ≡ g" id="20600" href="1Lab.Path.html#58463" class="Function">funext</a> <a id="20607" class="Symbol">λ</a> <a id="20609" href="1Lab.Univalence.SIP.html#20609" class="Bound">x</a> <a id="20611" class="Symbol">→</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="20613" href="1Lab.Path.html#20807" class="Function">ap</a> <a id="20616" class="Symbol">(</a><a id="20617" href="1Lab.Univalence.SIP.html#20577" class="Bound">β</a> <a id="20619" href="1Lab.Univalence.SIP.html#20590" class="Bound">eqv</a> <a id="20623" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="20624" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="(B₁ → C) → (A → B₁) → A → C" id="20628" href="1Lab.Type.html#2217" class="Function Operator">∘</a> <a id="20630" href="1Lab.Univalence.SIP.html#20594" class="Bound">f</a><a id="20631" class="Symbol">)</a> <a id="20633" class="Symbol">(</a><a data-type="(α : EqvAction S₁) →
isTransportStr α →
(e : X ≃ Y) (t : S₁ Y) →
equiv→inverse (α e .snd) t ≡ subst S₁ (sym (ua e)) t" id="20634" href="1Lab.Univalence.SIP.html#15757" class="Function">transportStr⁻¹</a> <a id="20649" href="1Lab.Univalence.SIP.html#20569" class="Bound">α</a> <a id="20651" href="1Lab.Univalence.SIP.html#20580" class="Bound">α-tr</a> <a id="20656" href="1Lab.Univalence.SIP.html#20590" class="Bound">eqv</a> <a id="20660" href="1Lab.Univalence.SIP.html#20609" class="Bound">x</a><a id="20661" class="Symbol">)</a>
             <a data-type="x ≡ y → y ≡ z → x ≡ z" id="20676" href="1Lab.Path.html#39580" class="Function Operator">∙</a> <a id="20678" href="1Lab.Univalence.SIP.html#20585" class="Bound">β-tr</a> <a id="20683" href="1Lab.Univalence.SIP.html#20590" class="Bound">eqv</a> <a id="20687" class="Symbol">(</a><a id="20688" href="1Lab.Univalence.SIP.html#20594" class="Bound">f</a> <a id="20690" class="Symbol">(</a><a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="20691" href="1Lab.Path.html#15372" class="Function">subst</a> <a id="20697" href="1Lab.Univalence.SIP.html#20561" class="Bound">S</a> <a id="20699" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="20700" href="1Lab.Path.html#10628" class="Function">sym</a> <a id="20704" class="Symbol">(</a><a data-type="A ≃ B₁ → A ≡ B₁" id="20705" href="1Lab.Univalence.html#8828" class="Function">ua</a> <a id="20708" href="1Lab.Univalence.SIP.html#20590" class="Bound">eqv</a><a id="20711" class="Symbol">))</a> <a id="20714" href="1Lab.Univalence.SIP.html#20609" class="Bound">x</a><a id="20715" class="Symbol">))</a>
</pre>
</details>
<h1 id="adding-axioms"><a href="#adding-axioms" class="header-link">Adding Axioms<span class="header-link-emoji">🔗</span></a></h1>
<p>Most mathematical objects of interest aren’t merely sets with structure. More often, the objects we’re interested in have <em>stuff</em> (the underlying type), <em>structure</em> (such as a <code class="sourceCode agda">SNS</code>), and <em>properties</em> - for instance, equations imposed on the structure. A concrete example may help:</p>
<ul>
<li><p>A <strong>pointed <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>-magma</span></strong> is a pointed type equipped with a binary operation;</p></li>
<li><p>A <strong>monoid</strong> is a pointed <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>-magma</span> with additional data witnessing that a) the type is a set; b) the operation is associative; and c) the point acts as a left- and right- identity for the operation.</p></li>
</ul>
<p>Fortunately, the SIP again applies here: If you augment a standard notion of structure with <em>axioms</em>, then identification of structures with axioms is still isomorphism of the underlying structures. For this, we require that the axioms be <a data-type="Type ℓ → Type ℓ" href="1Lab.HLevel.html#2594">valued in propositions</a>.</p>
<pre class="Agda"><a id="21660" class="Keyword">module</a> <a id="21667" href="1Lab.Univalence.SIP.html#21667" class="Module">_</a>
  <a id="21671" class="Symbol">(</a><a id="21672" href="1Lab.Univalence.SIP.html#21672" class="Bound">σ</a> <a id="21674" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="21676" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a> <a id="21686" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a> <a id="21688" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a><a id="21689" class="Symbol">)</a>
  <a id="21693" class="Symbol">(</a><a id="21694" href="1Lab.Univalence.SIP.html#21694" class="Bound">axioms</a> <a id="21701" class="Symbol">:</a> <a id="21703" class="Symbol">(</a><a id="21704" href="1Lab.Univalence.SIP.html#21704" class="Bound">X</a> <a id="21706" class="Symbol">:</a> <a id="21708" class="Symbol">_)</a> <a id="21711" class="Symbol">→</a> <a id="21713" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a> <a id="21715" href="1Lab.Univalence.SIP.html#21704" class="Bound">X</a> <a id="21717" class="Symbol">→</a> <a id="21719" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="21724" href="1Lab.Univalence.SIP.html#3465" class="Generalizable">ℓ₃</a><a id="21726" class="Symbol">)</a>
  <a id="21730" class="Keyword">where</a>
</pre>
<p>First, the notion of structure that you get is just a lifting of the underlying structure <code>σ</code> to ignore the witnesses for the axioms:</p>
<pre class="Agda">  <a data-type="(σ : Structure ℓ S₁) (axioms : (X : Type S.ℓ) → S₁ X → Type ℓ₃) →
Structure ℓ (λ X → Σ (axioms X))" id="21886" href="1Lab.Univalence.SIP.html#21886" class="Function">axiomsStr</a> <a id="21896" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="21898" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a> <a id="21908" href="1Lab.Univalence.SIP.html#21686" class="Bound">ℓ</a> <a id="21910" class="Symbol">(λ</a> <a id="21913" href="1Lab.Univalence.SIP.html#21913" class="Bound">X</a> <a id="21915" class="Symbol">→</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="21917" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="21920" href="1Lab.Univalence.SIP.html#21920" class="Bound">s</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="21922" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="21924" href="1Lab.Univalence.SIP.html#21688" class="Bound">S</a> <a id="21926" href="1Lab.Univalence.SIP.html#21913" class="Bound">X</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="21928" href="1Lab.Type.html#1563" class="Function">]</a> <a id="21930" class="Symbol">(</a><a id="21931" href="1Lab.Univalence.SIP.html#21694" class="Bound">axioms</a> <a id="21938" href="1Lab.Univalence.SIP.html#21913" class="Bound">X</a> <a id="21940" href="1Lab.Univalence.SIP.html#21920" class="Bound">s</a><a id="21941" class="Symbol">))</a>
  <a data-type="(σ : Structure ℓ S₁) (axioms : (X : Type S.ℓ) → S₁ X → Type ℓ₃) →
Structure ℓ (λ X → Σ (axioms X))" id="21946" href="1Lab.Univalence.SIP.html#21886" class="Function">axiomsStr</a> <a id="21956" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B₁ : Σ S₁) → A .fst ≃ B₁ .fst → Type ℓ₃" id="21957" href="1Lab.Univalence.SIP.html#2879" class="Field">is-hom</a> <a id="21964" class="Symbol">(</a><a id="21965" href="1Lab.Univalence.SIP.html#21965" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="21967" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="21969" href="1Lab.Univalence.SIP.html#21969" class="Bound">s</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="21971" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="21973" href="1Lab.Univalence.SIP.html#21973" class="Bound">a</a><a id="21974" class="Symbol">)</a> <a id="21976" class="Symbol">(</a><a id="21977" href="1Lab.Univalence.SIP.html#21977" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="21979" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="21981" href="1Lab.Univalence.SIP.html#21981" class="Bound">t</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="21983" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="21985" href="1Lab.Univalence.SIP.html#21985" class="Bound">b</a><a id="21986" class="Symbol">)</a> <a id="21988" href="1Lab.Univalence.SIP.html#21988" class="Bound">f</a> <a id="21990" class="Symbol">=</a>
    <a id="21996" href="1Lab.Univalence.SIP.html#21672" class="Bound">σ</a> <a id="21998" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B₁ : Σ S₁) → A .fst ≃ B₁ .fst → Type ℓ₃" id="21999" href="1Lab.Univalence.SIP.html#2879" class="Field">is-hom</a> <a id="22006" class="Symbol">(</a><a id="22007" href="1Lab.Univalence.SIP.html#21965" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="22009" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="22011" href="1Lab.Univalence.SIP.html#21969" class="Bound">s</a><a id="22012" class="Symbol">)</a> <a id="22014" class="Symbol">(</a><a id="22015" href="1Lab.Univalence.SIP.html#21977" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="22017" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="22019" href="1Lab.Univalence.SIP.html#21981" class="Bound">t</a><a id="22020" class="Symbol">)</a> <a id="22022" href="1Lab.Univalence.SIP.html#21988" class="Bound">f</a>
</pre>
<p>Then, if the axioms are propositional, a calculation by equivalence reasoning concludes what we wanted: <span class="Agda"><a data-type="(σ : Structure ℓ S₁) (axioms : (X : Type S.ℓ) → S₁ X → Type ℓ₃) →
Structure ℓ (λ X → Σ (axioms X))" href="1Lab.Univalence.SIP.html#21886" class="Function">axiomsStr</a></span> is univalent.</p>
<pre class="Agda">  <a id="22177" class="Keyword">module</a> <a id="22184" href="1Lab.Univalence.SIP.html#22184" class="Module">_</a>
    <a id="22190" class="Symbol">(</a><a id="22191" href="1Lab.Univalence.SIP.html#22191" class="Bound">univ</a> <a id="22196" class="Symbol">:</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="22198" href="1Lab.Univalence.SIP.html#3849" class="Function">isUnivalent</a> <a id="22210" href="1Lab.Univalence.SIP.html#21672" class="Bound">σ</a><a id="22211" class="Symbol">)</a>
    <a id="22217" class="Symbol">(</a><a id="22218" href="1Lab.Univalence.SIP.html#22218" class="Bound">axioms-prop</a> <a id="22230" class="Symbol">:</a> <a id="22232" class="Symbol">∀</a> <a id="22234" class="Symbol">{</a><a id="22235" href="1Lab.Univalence.SIP.html#22235" class="Bound">X</a><a id="22236" class="Symbol">}</a> <a id="22238" class="Symbol">{</a><a id="22239" href="1Lab.Univalence.SIP.html#22239" class="Bound">s</a><a id="22240" class="Symbol">}</a> <a id="22242" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="22244" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="22251" class="Symbol">(</a><a id="22252" href="1Lab.Univalence.SIP.html#21694" class="Bound">axioms</a> <a id="22259" href="1Lab.Univalence.SIP.html#22235" class="Bound">X</a> <a id="22261" href="1Lab.Univalence.SIP.html#22239" class="Bound">s</a><a id="22262" class="Symbol">))</a> <a id="22265" class="Keyword">where</a>
    <a data-type="(σ : Structure ℓ S₁) (axioms : (X : Type S.ℓ) → S₁ X → Type ℓ₃)
(univ : isUnivalent σ) (axioms-prop : isProp (axioms X s)) →
isUnivalent (axiomsStr σ axioms)" id="22275" href="1Lab.Univalence.SIP.html#22275" class="Function">axiomsStr-univalent</a> <a id="22295" class="Symbol">:</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="22297" href="1Lab.Univalence.SIP.html#3849" class="Function">isUnivalent</a> <a data-type="(σ : Structure ℓ S₁) (axioms : (X : Type S.ℓ) → S₁ X → Type ℓ₃) →
Structure ℓ (λ X → Σ (axioms X))" id="22309" href="1Lab.Univalence.SIP.html#21886" class="Function">axiomsStr</a>
    <a data-type="(σ : Structure ℓ S₁) (axioms : (X : Type S.ℓ) → S₁ X → Type ℓ₃)
(univ : isUnivalent σ) (axioms-prop : isProp (axioms X s)) →
isUnivalent (axiomsStr σ axioms)" id="22323" href="1Lab.Univalence.SIP.html#22275" class="Function">axiomsStr-univalent</a> <a id="22343" class="Symbol">{</a><a id="22344" class="Argument">X</a> <a id="22346" class="Symbol">=</a> <a id="22348" href="1Lab.Univalence.SIP.html#22348" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="22350" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="22352" href="1Lab.Univalence.SIP.html#22352" class="Bound">s</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="22354" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="22356" href="1Lab.Univalence.SIP.html#22356" class="Bound">a</a><a id="22357" class="Symbol">}</a> <a id="22359" class="Symbol">{</a><a id="22360" class="Argument">Y</a> <a id="22362" class="Symbol">=</a> <a id="22364" href="1Lab.Univalence.SIP.html#22364" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="22366" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="22368" href="1Lab.Univalence.SIP.html#22368" class="Bound">t</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="22370" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="22372" href="1Lab.Univalence.SIP.html#22372" class="Bound">b</a><a id="22373" class="Symbol">}</a> <a id="22375" href="1Lab.Univalence.SIP.html#22375" class="Bound">f</a> <a id="22377" class="Symbol">=</a>
      <a id="22385" href="1Lab.Univalence.SIP.html#21672" class="Bound">σ</a> <a id="22387" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B₁ : Σ S₁) → A .fst ≃ B₁ .fst → Type ℓ₃" id="22388" href="1Lab.Univalence.SIP.html#2879" class="Field">is-hom</a> <a id="22395" class="Symbol">(</a><a id="22396" href="1Lab.Univalence.SIP.html#22348" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="22398" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="22400" href="1Lab.Univalence.SIP.html#22352" class="Bound">s</a><a id="22401" class="Symbol">)</a> <a id="22403" class="Symbol">(</a><a id="22404" href="1Lab.Univalence.SIP.html#22364" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="22406" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="22408" href="1Lab.Univalence.SIP.html#22368" class="Bound">t</a><a id="22409" class="Symbol">)</a> <a id="22411" href="1Lab.Univalence.SIP.html#22375" class="Bound">f</a>
        <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" id="22421" href="1Lab.Equiv.html#22842" class="Function Operator">≃⟨</a> <a id="22424" href="1Lab.Univalence.SIP.html#22191" class="Bound">univ</a> <a id="22429" href="1Lab.Univalence.SIP.html#22375" class="Bound">f</a> <a data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" id="22431" href="1Lab.Equiv.html#22842" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
      <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="22439" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="22445" class="Symbol">(λ</a> <a id="22448" href="1Lab.Univalence.SIP.html#22448" class="Bound">i</a> <a id="22450" class="Symbol">→</a> <a id="22452" href="1Lab.Univalence.SIP.html#21688" class="Bound">S</a> <a id="22454" class="Symbol">(</a><a data-type="A ≃ B₁ → A ≡ B₁" id="22455" href="1Lab.Univalence.html#8828" class="Function">ua</a> <a id="22458" href="1Lab.Univalence.SIP.html#22375" class="Bound">f</a> <a id="22460" href="1Lab.Univalence.SIP.html#22448" class="Bound">i</a><a id="22461" class="Symbol">))</a> <a id="22464" href="1Lab.Univalence.SIP.html#22352" class="Bound">s</a> <a id="22466" href="1Lab.Univalence.SIP.html#22368" class="Bound">t</a> 
        <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" id="22477" href="1Lab.Equiv.html#22842" class="Function Operator">≃⟨</a> <a data-type="((x : A) → isContr (B₁ x)) → Σ B₁ ≃ A" id="22480" href="1Lab.Type.Sigma.html#7453" class="Function">Σ-contract</a> <a id="22491" class="Symbol">(λ</a> <a id="22494" href="1Lab.Univalence.SIP.html#22494" class="Bound">x</a> <a id="22496" class="Symbol">→</a> <a data-type="(n : Nat) → isHLevel (A i1) n → isHLevel (PathP A x y) n" id="22498" href="1Lab.HLevel.html#10013" class="Function">isHLevelPathP</a> <a id="22512" class="Number">0</a> <a id="22514" class="Symbol">(</a><a data-type="(centre₁ : A) (paths₁ : (x : A) → centre₁ ≡ x) → isContr A" id="22515" href="1Lab.HLevel.html#1382" class="InductiveConstructor">contr</a> <a id="22521" href="1Lab.Univalence.SIP.html#22372" class="Bound">b</a> <a id="22523" class="Symbol">(</a><a id="22524" href="1Lab.Univalence.SIP.html#22218" class="Bound">axioms-prop</a> <a id="22536" href="1Lab.Univalence.SIP.html#22372" class="Bound">b</a><a id="22537" class="Symbol">)))</a> <a data-type="A ≃ B₁ → B₁ ≃ A" id="22541" href="1Lab.Equiv.html#21256" class="Function Operator">e⁻¹</a> <a data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" id="22545" href="1Lab.Equiv.html#22842" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
      <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="22553" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="22556" href="1Lab.Univalence.SIP.html#22556" class="Bound">p</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="22558" href="1Lab.Type.html#1563" class="Function">∈</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="22560" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="22566" class="Symbol">(λ</a> <a id="22569" href="1Lab.Univalence.SIP.html#22569" class="Bound">i</a> <a id="22571" class="Symbol">→</a> <a id="22573" href="1Lab.Univalence.SIP.html#21688" class="Bound">S</a> <a id="22575" class="Symbol">(</a><a data-type="A ≃ B₁ → A ≡ B₁" id="22576" href="1Lab.Univalence.html#8828" class="Function">ua</a> <a id="22579" href="1Lab.Univalence.SIP.html#22375" class="Bound">f</a> <a id="22581" href="1Lab.Univalence.SIP.html#22569" class="Bound">i</a><a id="22582" class="Symbol">))</a> <a id="22585" href="1Lab.Univalence.SIP.html#22352" class="Bound">s</a> <a id="22587" href="1Lab.Univalence.SIP.html#22368" class="Bound">t</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="22589" href="1Lab.Type.html#1563" class="Function">]</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="22591" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="22597" class="Symbol">(λ</a> <a id="22600" href="1Lab.Univalence.SIP.html#22600" class="Bound">i</a> <a id="22602" class="Symbol">→</a> <a id="22604" href="1Lab.Univalence.SIP.html#21694" class="Bound">axioms</a> <a id="22611" class="Symbol">(</a><a data-type="A ≃ B₁ → A ≡ B₁" id="22612" href="1Lab.Univalence.html#8828" class="Function">ua</a> <a id="22615" href="1Lab.Univalence.SIP.html#22375" class="Bound">f</a> <a id="22617" href="1Lab.Univalence.SIP.html#22600" class="Bound">i</a><a id="22618" class="Symbol">)</a> <a id="22620" class="Symbol">(</a><a id="22621" href="1Lab.Univalence.SIP.html#22556" class="Bound">p</a> <a id="22623" href="1Lab.Univalence.SIP.html#22600" class="Bound">i</a><a id="22624" class="Symbol">))</a> <a id="22627" href="1Lab.Univalence.SIP.html#22356" class="Bound">a</a> <a id="22629" href="1Lab.Univalence.SIP.html#22372" class="Bound">b</a>
        <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" id="22639" href="1Lab.Equiv.html#22842" class="Function Operator">≃⟨</a> <a data-type="Iso A B₁ → A ≃ B₁" id="22642" href="1Lab.Equiv.html#20100" class="Function">Iso→Equiv</a> <a data-type="Iso (Σ (λ p → PathP (λ i → B₁ i (p i)) (x .snd) (y .snd)))
(PathP (λ i → Σ (B₁ i)) x y)" id="22652" href="1Lab.Type.Sigma.html#553" class="Function">Σ-PathP-iso</a> <a data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" id="22664" href="1Lab.Equiv.html#22842" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
      <a id="22672" class="Symbol">_</a>
        <a data-type="(A : Type ℓ) → A ≃ A" id="22682" href="1Lab.Equiv.html#23033" class="Function Operator">≃∎</a>
</pre>
<p>Here, another facet of the trade-offs between transport and univalent structures make themselves clear: It’s possible (albeit less than straightforward) to add axioms to a <em>univalent</em> structure, but without imposing further structure on the axioms themselves, it is not clear how to add axioms to a <em>transport</em> structure.</p>
<p>Regardless, a very useful consequence of the SIP is that axioms can be lifted from equivalent underlying structures. For instance: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span> can be defined as both unary numbers (the construction of <code class="sourceCode agda">Nat</code>), or as binary numbers. If you prove that <code class="sourceCode agda">Nat</code> is a monoid, and <code>Nat ≃ Bin</code> as pointed ∞-magmas, then <code>Bin</code> inherits the monoid structure.</p>
<pre class="Agda"><a id="transferAxioms"></a><a data-type="(A : TypeWith (axiomsStr σ axioms)) (B₁ : TypeWith σ) →
(A .fst , A .snd .fst) ≃[ σ ] B₁ → axioms (B₁ .fst) (B₁ .snd)" id="23384" href="1Lab.Univalence.SIP.html#23384" class="Function">transferAxioms</a> 
  <a id="23402" class="Symbol">:</a> <a id="23404" class="Symbol">{</a><a id="23405" href="1Lab.Univalence.SIP.html#23405" class="Bound">σ</a> <a id="23407" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="23409" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a> <a id="23419" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a> <a id="23421" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a><a id="23422" class="Symbol">}</a> <a id="23424" class="Symbol">{</a><a id="23425" href="1Lab.Univalence.SIP.html#23425" class="Bound">univ</a> <a id="23430" class="Symbol">:</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="23432" href="1Lab.Univalence.SIP.html#3849" class="Function">isUnivalent</a> <a id="23444" href="1Lab.Univalence.SIP.html#23405" class="Bound">σ</a><a id="23445" class="Symbol">}</a>
    <a id="23451" class="Symbol">{</a><a id="23452" href="1Lab.Univalence.SIP.html#23452" class="Bound">axioms</a> <a id="23459" class="Symbol">:</a> <a id="23461" class="Symbol">(</a><a id="23462" href="1Lab.Univalence.SIP.html#23462" class="Bound">X</a> <a id="23464" class="Symbol">:</a> <a id="23466" class="Symbol">_)</a> <a id="23469" class="Symbol">→</a> <a id="23471" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a> <a id="23473" href="1Lab.Univalence.SIP.html#23462" class="Bound">X</a> <a id="23475" class="Symbol">→</a> <a id="23477" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="23482" href="1Lab.Univalence.SIP.html#3465" class="Generalizable">ℓ₃</a><a id="23484" class="Symbol">}</a>
  <a id="23488" class="Symbol">→</a> <a id="23490" class="Symbol">(</a><a id="23491" href="1Lab.Univalence.SIP.html#23491" class="Bound">A</a> <a id="23493" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="23495" href="1Lab.Univalence.SIP.html#3323" class="Function">TypeWith</a> <a id="23504" class="Symbol">(</a><a data-type="(σ : Structure ℓ S₁) (axioms : (X : Type S.ℓ) → S₁ X → Type ℓ₃) →
Structure ℓ (λ X → Σ (axioms X))" id="23505" href="1Lab.Univalence.SIP.html#21886" class="Function">axiomsStr</a> <a id="23515" href="1Lab.Univalence.SIP.html#23405" class="Bound">σ</a> <a id="23517" href="1Lab.Univalence.SIP.html#23452" class="Bound">axioms</a><a id="23523" class="Symbol">))</a> <a id="23526" class="Symbol">(</a><a id="23527" href="1Lab.Univalence.SIP.html#23527" class="Bound">B</a> <a id="23529" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="23531" href="1Lab.Univalence.SIP.html#3323" class="Function">TypeWith</a> <a id="23540" href="1Lab.Univalence.SIP.html#23405" class="Bound">σ</a><a id="23541" class="Symbol">)</a>
  <a id="23545" class="Symbol">→</a> <a id="23547" class="Symbol">(</a><a id="23548" href="1Lab.Univalence.SIP.html#23491" class="Bound">A</a> <a id="23550" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="23551" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="23555" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23557" href="1Lab.Univalence.SIP.html#23491" class="Bound">A</a> <a id="23559" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="23560" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="23564" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="23565" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="23568" class="Symbol">)</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="23570" href="1Lab.Univalence.SIP.html#4222" class="Function Operator">≃[</a> <a id="23573" href="1Lab.Univalence.SIP.html#23405" class="Bound">σ</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="23575" href="1Lab.Univalence.SIP.html#4222" class="Function Operator">]</a> <a id="23577" href="1Lab.Univalence.SIP.html#23527" class="Bound">B</a>
  <a id="23581" class="Symbol">→</a> <a id="23583" href="1Lab.Univalence.SIP.html#23452" class="Bound">axioms</a> <a id="23590" class="Symbol">(</a><a id="23591" href="1Lab.Univalence.SIP.html#23527" class="Bound">B</a> <a id="23593" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="23594" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="23597" class="Symbol">)</a> <a id="23599" class="Symbol">(</a><a id="23600" href="1Lab.Univalence.SIP.html#23527" class="Bound">B</a> <a id="23602" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="23603" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="23606" class="Symbol">)</a>
<a data-type="(A : TypeWith (axiomsStr σ axioms)) (B₁ : TypeWith σ) →
(A .fst , A .snd .fst) ≃[ σ ] B₁ → axioms (B₁ .fst) (B₁ .snd)" id="23608" href="1Lab.Univalence.SIP.html#23384" class="Function">transferAxioms</a> <a id="23623" class="Symbol">{</a><a id="23624" class="Argument">univ</a> <a id="23629" class="Symbol">=</a> <a id="23631" href="1Lab.Univalence.SIP.html#23631" class="Bound">univ</a><a id="23635" class="Symbol">}</a> <a id="23637" class="Symbol">{</a><a id="23638" class="Argument">axioms</a> <a id="23645" class="Symbol">=</a> <a id="23647" href="1Lab.Univalence.SIP.html#23647" class="Bound">axioms</a><a id="23653" class="Symbol">}</a> <a id="23655" href="1Lab.Univalence.SIP.html#23655" class="Bound">A</a> <a id="23657" href="1Lab.Univalence.SIP.html#23657" class="Bound">B</a> <a id="23659" href="1Lab.Univalence.SIP.html#23659" class="Bound">eqv</a> <a id="23663" class="Symbol">=</a>
  <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="23667" href="1Lab.Path.html#15372" class="Function">subst</a> <a id="23673" class="Symbol">(λ</a> <a id="23676" class="Symbol">{</a> <a id="23678" class="Symbol">(</a><a id="23679" href="1Lab.Univalence.SIP.html#23679" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="23681" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23683" href="1Lab.Univalence.SIP.html#23683" class="Bound">y</a><a id="23684" class="Symbol">)</a> <a id="23686" class="Symbol">→</a> <a id="23688" href="1Lab.Univalence.SIP.html#23647" class="Bound">axioms</a> <a id="23695" href="1Lab.Univalence.SIP.html#23679" class="Bound">x</a> <a id="23697" href="1Lab.Univalence.SIP.html#23683" class="Bound">y</a> <a id="23699" class="Symbol">})</a> <a id="23702" class="Symbol">(</a><a data-type="isUnivalent σ → X ≃[ σ ] Y → X ≡ Y" id="23703" href="1Lab.Univalence.SIP.html#5512" class="Function">sip</a> <a id="23707" href="1Lab.Univalence.SIP.html#23631" class="Bound">univ</a> <a id="23712" href="1Lab.Univalence.SIP.html#23659" class="Bound">eqv</a><a id="23715" class="Symbol">)</a> <a id="23717" class="Symbol">(</a><a id="23718" href="1Lab.Univalence.SIP.html#23655" class="Bound">A</a> <a id="23720" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="23721" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="23725" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="23726" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="23729" class="Symbol">)</a>
</pre>
<h1 id="a-language-for-structures"><a href="#a-language-for-structures" class="header-link">A Language for Structures<span class="header-link-emoji">🔗</span></a></h1>
<p>The structure combinators can be abstracted away into a <em>language</em> for defining structures. A <span class="Agda"><a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" href="1Lab.Univalence.SIP.html#24034" class="Datatype">StrTm</a></span> describes a structure, that may be <code class="sourceCode agda" data-ident="interp">interpreted</code> into a family of types, and defines both transport and univalent structures.</p>
<pre class="Agda"><a id="24029" class="Keyword">data</a> <a id="StrTm"></a><a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="24034" href="1Lab.Univalence.SIP.html#24034" class="Datatype">StrTm</a> <a id="24040" href="1Lab.Univalence.SIP.html#24040" class="Bound">ℓ</a> <a id="24042" class="Symbol">:</a> <a id="24044" class="Symbol">(</a><a id="24045" href="1Lab.Univalence.SIP.html#24045" class="Bound">ℓ₁</a> <a id="24048" class="Symbol">:</a> <a data-type="Type" id="24050" href="Agda.Primitive.html#597" class="Postulate">Level</a><a id="24055" class="Symbol">)</a> <a id="24057" class="Symbol">→</a> <a id="24059" class="Symbol">(</a><a id="24060" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="24065" href="1Lab.Univalence.SIP.html#24040" class="Bound">ℓ</a> <a id="24067" class="Symbol">→</a> <a id="24069" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="24074" href="1Lab.Univalence.SIP.html#24045" class="Bound">ℓ₁</a><a id="24076" class="Symbol">)</a> <a id="24078" class="Symbol">→</a> <a id="24080" href="1Lab.Type.html#409" class="Primitive">Typeω</a> <a id="24086" class="Keyword">where</a>
  <a id="StrTm.s-const"></a><a data-type="(A : Type ℓ₁) → StrTm ℓ ℓ₁ (λ X → A)" id="24094" href="1Lab.Univalence.SIP.html#24094" class="InductiveConstructor">s-const</a> <a id="24102" class="Symbol">:</a> <a id="24104" class="Symbol">∀</a> <a id="24106" class="Symbol">{</a><a id="24107" href="1Lab.Univalence.SIP.html#24107" class="Bound">ℓ₁</a><a id="24109" class="Symbol">}</a> <a id="24111" class="Symbol">(</a><a id="24112" href="1Lab.Univalence.SIP.html#24112" class="Bound">A</a> <a id="24114" class="Symbol">:</a> <a id="24116" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="24121" href="1Lab.Univalence.SIP.html#24107" class="Bound">ℓ₁</a><a id="24123" class="Symbol">)</a> <a id="24125" class="Symbol">→</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="24127" href="1Lab.Univalence.SIP.html#24034" class="Datatype">StrTm</a> <a id="24133" href="1Lab.Univalence.SIP.html#24040" class="Bound">ℓ</a> <a id="24135" href="1Lab.Univalence.SIP.html#24107" class="Bound">ℓ₁</a> <a id="24138" class="Symbol">(λ</a> <a id="24141" href="1Lab.Univalence.SIP.html#24141" class="Bound">X</a> <a id="24143" class="Symbol">→</a> <a id="24145" href="1Lab.Univalence.SIP.html#24112" class="Bound">A</a><a id="24146" class="Symbol">)</a>
  <a id="StrTm.s∙"></a><a data-type="StrTm ℓ ℓ (λ X → X)" id="24150" href="1Lab.Univalence.SIP.html#24150" class="InductiveConstructor">s∙</a>      <a id="24158" class="Symbol">:</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="24160" href="1Lab.Univalence.SIP.html#24034" class="Datatype">StrTm</a> <a id="24166" href="1Lab.Univalence.SIP.html#24040" class="Bound">ℓ</a> <a id="24168" href="1Lab.Univalence.SIP.html#24040" class="Bound">ℓ</a> <a id="24170" class="Symbol">(λ</a> <a id="24173" href="1Lab.Univalence.SIP.html#24173" class="Bound">X</a> <a id="24175" class="Symbol">→</a> <a id="24177" href="1Lab.Univalence.SIP.html#24173" class="Bound">X</a><a id="24178" class="Symbol">)</a>
  <a id="StrTm._s→_"></a><a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="24182" href="1Lab.Univalence.SIP.html#24182" class="InductiveConstructor Operator">_s→_</a>    <a id="24190" class="Symbol">:</a> <a id="24192" class="Symbol">∀</a> <a id="24194" class="Symbol">{</a><a id="24195" href="1Lab.Univalence.SIP.html#24195" class="Bound">ℓ₁</a> <a id="24198" href="1Lab.Univalence.SIP.html#24198" class="Bound">ℓ₂</a><a id="24200" class="Symbol">}</a> <a id="24202" class="Symbol">{</a><a id="24203" href="1Lab.Univalence.SIP.html#24203" class="Bound">S</a><a id="24204" class="Symbol">}</a> <a id="24206" class="Symbol">{</a><a id="24207" href="1Lab.Univalence.SIP.html#24207" class="Bound">T</a><a id="24208" class="Symbol">}</a> <a id="24210" class="Symbol">→</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="24212" href="1Lab.Univalence.SIP.html#24034" class="Datatype">StrTm</a> <a id="24218" href="1Lab.Univalence.SIP.html#24040" class="Bound">ℓ</a> <a id="24220" href="1Lab.Univalence.SIP.html#24195" class="Bound">ℓ₁</a> <a id="24223" href="1Lab.Univalence.SIP.html#24203" class="Bound">S</a> <a id="24225" class="Symbol">→</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="24227" href="1Lab.Univalence.SIP.html#24034" class="Datatype">StrTm</a> <a id="24233" href="1Lab.Univalence.SIP.html#24040" class="Bound">ℓ</a> <a id="24235" href="1Lab.Univalence.SIP.html#24198" class="Bound">ℓ₂</a> <a id="24238" href="1Lab.Univalence.SIP.html#24207" class="Bound">T</a> <a id="24240" class="Symbol">→</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="24242" href="1Lab.Univalence.SIP.html#24034" class="Datatype">StrTm</a> <a id="24248" href="1Lab.Univalence.SIP.html#24040" class="Bound">ℓ</a> <a id="24250" class="Symbol">(</a><a id="24251" href="1Lab.Univalence.SIP.html#24195" class="Bound">ℓ₁</a> <a data-type="Level → Level → Level" id="24254" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="24256" href="1Lab.Univalence.SIP.html#24198" class="Bound">ℓ₂</a><a id="24258" class="Symbol">)</a> <a id="24260" class="Symbol">(λ</a> <a id="24263" href="1Lab.Univalence.SIP.html#24263" class="Bound">X</a> <a id="24265" class="Symbol">→</a> <a id="24267" href="1Lab.Univalence.SIP.html#24203" class="Bound">S</a> <a id="24269" href="1Lab.Univalence.SIP.html#24263" class="Bound">X</a> <a id="24271" class="Symbol">→</a> <a id="24273" href="1Lab.Univalence.SIP.html#24207" class="Bound">T</a> <a id="24275" href="1Lab.Univalence.SIP.html#24263" class="Bound">X</a><a id="24276" class="Symbol">)</a>
  <a id="StrTm._s×_"></a><a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="24280" href="1Lab.Univalence.SIP.html#24280" class="InductiveConstructor Operator">_s×_</a>    <a id="24288" class="Symbol">:</a> <a id="24290" class="Symbol">∀</a> <a id="24292" class="Symbol">{</a><a id="24293" href="1Lab.Univalence.SIP.html#24293" class="Bound">ℓ₁</a> <a id="24296" href="1Lab.Univalence.SIP.html#24296" class="Bound">ℓ₂</a><a id="24298" class="Symbol">}</a> <a id="24300" class="Symbol">{</a><a id="24301" href="1Lab.Univalence.SIP.html#24301" class="Bound">S</a><a id="24302" class="Symbol">}</a> <a id="24304" class="Symbol">{</a><a id="24305" href="1Lab.Univalence.SIP.html#24305" class="Bound">T</a><a id="24306" class="Symbol">}</a> <a id="24308" class="Symbol">→</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="24310" href="1Lab.Univalence.SIP.html#24034" class="Datatype">StrTm</a> <a id="24316" href="1Lab.Univalence.SIP.html#24040" class="Bound">ℓ</a> <a id="24318" href="1Lab.Univalence.SIP.html#24293" class="Bound">ℓ₁</a> <a id="24321" href="1Lab.Univalence.SIP.html#24301" class="Bound">S</a> <a id="24323" class="Symbol">→</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="24325" href="1Lab.Univalence.SIP.html#24034" class="Datatype">StrTm</a> <a id="24331" href="1Lab.Univalence.SIP.html#24040" class="Bound">ℓ</a> <a id="24333" href="1Lab.Univalence.SIP.html#24296" class="Bound">ℓ₂</a> <a id="24336" href="1Lab.Univalence.SIP.html#24305" class="Bound">T</a> <a id="24338" class="Symbol">→</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="24340" href="1Lab.Univalence.SIP.html#24034" class="Datatype">StrTm</a> <a id="24346" href="1Lab.Univalence.SIP.html#24040" class="Bound">ℓ</a> <a id="24348" class="Symbol">(</a><a id="24349" href="1Lab.Univalence.SIP.html#24293" class="Bound">ℓ₁</a> <a data-type="Level → Level → Level" id="24352" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="24354" href="1Lab.Univalence.SIP.html#24296" class="Bound">ℓ₂</a><a id="24356" class="Symbol">)</a> <a id="24358" class="Symbol">(λ</a> <a id="24361" href="1Lab.Univalence.SIP.html#24361" class="Bound">X</a> <a id="24363" class="Symbol">→</a> <a id="24365" href="1Lab.Univalence.SIP.html#24301" class="Bound">S</a> <a id="24367" href="1Lab.Univalence.SIP.html#24361" class="Bound">X</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="24369" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="24371" href="1Lab.Univalence.SIP.html#24305" class="Bound">T</a> <a id="24373" href="1Lab.Univalence.SIP.html#24361" class="Bound">X</a><a id="24374" class="Symbol">)</a>

<a id="24377" class="Keyword">infixr</a> <a id="24384" class="Number">30</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="24387" href="1Lab.Univalence.SIP.html#24182" class="InductiveConstructor Operator">_s→_</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="24392" href="1Lab.Univalence.SIP.html#24280" class="InductiveConstructor Operator">_s×_</a>
</pre>
<p>Since each term of the language corresponds to one of the combinators for building univalent structures, a pair of <em>mutually recursive</em> functions lets us derive a <span class="Agda"><a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a></span> and an <span class="Agda"><a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" href="1Lab.Univalence.SIP.html#13565" class="Function">action on equivalences</a></span> from a term, at the same time.</p>
<pre class="Agda"><a id="tm→Structure"></a><a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="24679" href="1Lab.Univalence.SIP.html#24679" class="Function">tm→Structure</a> <a id="24692" class="Symbol">:</a> <a id="24694" class="Symbol">(</a><a id="24695" href="1Lab.Univalence.SIP.html#24695" class="Bound">s</a> <a id="24697" class="Symbol">:</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="24699" href="1Lab.Univalence.SIP.html#24034" class="Datatype">StrTm</a> <a id="24705" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a> <a id="24707" href="1Lab.Univalence.SIP.html#3459" class="Generalizable">ℓ₁</a> <a id="24710" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a><a id="24711" class="Symbol">)</a> <a id="24713" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="24715" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a> <a id="24725" href="1Lab.Univalence.SIP.html#3459" class="Generalizable">ℓ₁</a> <a id="24728" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a>
<a id="tm→Action"></a><a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="24730" href="1Lab.Univalence.SIP.html#24730" class="Function">tm→Action</a> <a id="24740" class="Symbol">:</a> <a id="24742" class="Symbol">(</a><a id="24743" href="1Lab.Univalence.SIP.html#24743" class="Bound">s</a> <a id="24745" class="Symbol">:</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="24747" href="1Lab.Univalence.SIP.html#24034" class="Datatype">StrTm</a> <a id="24753" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a> <a id="24755" href="1Lab.Univalence.SIP.html#3459" class="Generalizable">ℓ₁</a> <a id="24758" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a><a id="24759" class="Symbol">)</a> <a id="24761" class="Symbol">→</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="24763" href="1Lab.Univalence.SIP.html#13565" class="Function">EqvAction</a> <a id="24773" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a>

<a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="24776" href="1Lab.Univalence.SIP.html#24679" class="Function">tm→Structure</a> <a id="24789" class="Symbol">(</a><a data-type="(A : Type ℓ₁) → StrTm ℓ ℓ₁ (λ X → A)" id="24790" href="1Lab.Univalence.SIP.html#24094" class="InductiveConstructor">s-const</a> <a id="24798" href="1Lab.Univalence.SIP.html#24798" class="Bound">x</a><a id="24799" class="Symbol">)</a> <a id="24801" class="Symbol">=</a> <a data-type="(A : Type ℓ) → Structure ℓ (λ X → A)" id="24803" href="1Lab.Univalence.SIP.html#6212" class="Function">constantStr</a> <a id="24815" href="1Lab.Univalence.SIP.html#24798" class="Bound">x</a>
<a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="24817" href="1Lab.Univalence.SIP.html#24679" class="Function">tm→Structure</a> <a data-type="StrTm ℓ ℓ (λ X → X)" id="24830" href="1Lab.Univalence.SIP.html#24150" class="InductiveConstructor">s∙</a> <a id="24833" class="Symbol">=</a> <a data-type="Structure ℓ (λ X → X)" id="24835" href="1Lab.Univalence.SIP.html#7063" class="Function">pointedStr</a>
<a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="24846" href="1Lab.Univalence.SIP.html#24679" class="Function">tm→Structure</a> <a id="24859" class="Symbol">(</a><a id="24860" href="1Lab.Univalence.SIP.html#24860" class="Bound">s</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="24862" href="1Lab.Univalence.SIP.html#24182" class="InductiveConstructor Operator">s→</a> <a id="24865" href="1Lab.Univalence.SIP.html#24865" class="Bound">s₁</a><a id="24867" class="Symbol">)</a> <a id="24869" class="Symbol">=</a> <a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" id="24871" href="1Lab.Univalence.SIP.html#16946" class="Function">functionStr</a> <a id="24883" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="24884" href="1Lab.Univalence.SIP.html#24730" class="Function">tm→Action</a> <a id="24894" href="1Lab.Univalence.SIP.html#24860" class="Bound">s</a><a id="24895" class="Symbol">)</a> <a id="24897" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="24898" href="1Lab.Univalence.SIP.html#24679" class="Function">tm→Structure</a> <a id="24911" href="1Lab.Univalence.SIP.html#24865" class="Bound">s₁</a><a id="24913" class="Symbol">)</a>
<a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="24915" href="1Lab.Univalence.SIP.html#24679" class="Function">tm→Structure</a> <a id="24928" class="Symbol">(</a><a id="24929" href="1Lab.Univalence.SIP.html#24929" class="Bound">s</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="24931" href="1Lab.Univalence.SIP.html#24280" class="InductiveConstructor Operator">s×</a> <a id="24934" href="1Lab.Univalence.SIP.html#24934" class="Bound">s₁</a><a id="24936" class="Symbol">)</a> <a id="24938" class="Symbol">=</a> <a data-type="Structure ℓ S₁ →
Structure ℓ₂ T → Structure (ℓ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="24940" href="1Lab.Univalence.SIP.html#7563" class="Function">productStr</a> <a id="24951" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="24952" href="1Lab.Univalence.SIP.html#24679" class="Function">tm→Structure</a> <a id="24965" href="1Lab.Univalence.SIP.html#24929" class="Bound">s</a><a id="24966" class="Symbol">)</a> <a id="24968" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="24969" href="1Lab.Univalence.SIP.html#24679" class="Function">tm→Structure</a> <a id="24982" href="1Lab.Univalence.SIP.html#24934" class="Bound">s₁</a><a id="24984" class="Symbol">)</a>

<a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="24987" href="1Lab.Univalence.SIP.html#24730" class="Function">tm→Action</a> <a id="24997" class="Symbol">(</a><a data-type="(A : Type ℓ₁) → StrTm ℓ ℓ₁ (λ X → A)" id="24998" href="1Lab.Univalence.SIP.html#24094" class="InductiveConstructor">s-const</a> <a id="25006" href="1Lab.Univalence.SIP.html#25006" class="Bound">x₁</a><a id="25008" class="Symbol">)</a> <a id="25010" href="1Lab.Univalence.SIP.html#25010" class="Bound">x</a> <a id="25012" class="Symbol">=</a> <a id="25014" class="Symbol">_</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="25016" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="25018" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a>
<a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="25026" href="1Lab.Univalence.SIP.html#24730" class="Function">tm→Action</a> <a data-type="StrTm ℓ ℓ (λ X → X)" id="25036" href="1Lab.Univalence.SIP.html#24150" class="InductiveConstructor">s∙</a> <a id="25039" href="1Lab.Univalence.SIP.html#25039" class="Bound">x</a> <a id="25041" class="Symbol">=</a> <a id="25043" href="1Lab.Univalence.SIP.html#25039" class="Bound">x</a>
<a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="25045" href="1Lab.Univalence.SIP.html#24730" class="Function">tm→Action</a> <a id="25055" class="Symbol">(</a><a id="25056" href="1Lab.Univalence.SIP.html#25056" class="Bound">s</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="25058" href="1Lab.Univalence.SIP.html#24182" class="InductiveConstructor Operator">s→</a> <a id="25061" href="1Lab.Univalence.SIP.html#25061" class="Bound">s₁</a><a id="25063" class="Symbol">)</a> <a id="25065" class="Symbol">=</a> <a data-type="EqvAction S₁ → EqvAction T → EqvAction (λ X → S₁ X → T X)" id="25067" href="1Lab.Univalence.SIP.html#20209" class="Function">functionAction</a> <a id="25082" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="25083" href="1Lab.Univalence.SIP.html#24730" class="Function">tm→Action</a> <a id="25093" href="1Lab.Univalence.SIP.html#25056" class="Bound">s</a><a id="25094" class="Symbol">)</a> <a id="25096" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="25097" href="1Lab.Univalence.SIP.html#24730" class="Function">tm→Action</a> <a id="25107" href="1Lab.Univalence.SIP.html#25061" class="Bound">s₁</a><a id="25109" class="Symbol">)</a>
<a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="25111" href="1Lab.Univalence.SIP.html#24730" class="Function">tm→Action</a> <a id="25121" class="Symbol">(</a><a id="25122" href="1Lab.Univalence.SIP.html#25122" class="Bound">s</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="25124" href="1Lab.Univalence.SIP.html#24280" class="InductiveConstructor Operator">s×</a> <a id="25127" href="1Lab.Univalence.SIP.html#25127" class="Bound">s₁</a><a id="25129" class="Symbol">)</a> <a id="25131" class="Symbol">=</a> <a data-type="EqvAction S₁ → EqvAction T → EqvAction (λ X → S₁ X × T X)" id="25133" href="1Lab.Univalence.SIP.html#19809" class="Function">productAction</a> <a id="25147" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="25148" href="1Lab.Univalence.SIP.html#24730" class="Function">tm→Action</a> <a id="25158" href="1Lab.Univalence.SIP.html#25122" class="Bound">s</a><a id="25159" class="Symbol">)</a> <a id="25161" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="25162" href="1Lab.Univalence.SIP.html#24730" class="Function">tm→Action</a> <a id="25172" href="1Lab.Univalence.SIP.html#25127" class="Bound">s₁</a><a id="25174" class="Symbol">)</a>
</pre>
<p>The reason for this mutual recursion is the same reason that transport structures are considered in the first place: <span class="Agda"><a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" href="1Lab.Univalence.SIP.html#16946" class="Function">functionStr</a></span> gives much better results for the definition of homomorphism than can be gotten directly using <span class="Agda"><a data-type="Structure ℓ₁ S₁ →
Structure ℓ₂ T → Structure (ℓ₁ ⊔ S.ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" href="1Lab.Univalence.SIP.html#8498" class="Function">Str-functionStr</a></span>. As an example of using the language, and the generated definition of homomorphism, consider pointed ∞-magmas:</p>
<pre class="Agda"><a id="25559" class="Keyword">private</a>
  <a id="Pointed∞Magma"></a><a id="25569" href="1Lab.Univalence.SIP.html#25569" class="Function">Pointed∞Magma</a> <a id="25583" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="25585" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a> <a data-type="Level" id="25595" href="Agda.Primitive.html#764" class="Primitive">lzero</a> <a id="25601" class="Symbol">_</a>
  <a id="25605" href="1Lab.Univalence.SIP.html#25569" class="Function">Pointed∞Magma</a> <a id="25619" class="Symbol">=</a> <a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="25621" href="1Lab.Univalence.SIP.html#24679" class="Function">tm→Structure</a> <a id="25634" class="Symbol">(</a><a data-type="StrTm ℓ ℓ (λ X → X)" id="25635" href="1Lab.Univalence.SIP.html#24150" class="InductiveConstructor">s∙</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="25638" href="1Lab.Univalence.SIP.html#24280" class="InductiveConstructor Operator">s×</a> <a id="25641" class="Symbol">(</a><a data-type="StrTm ℓ ℓ (λ X → X)" id="25642" href="1Lab.Univalence.SIP.html#24150" class="InductiveConstructor">s∙</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="25645" href="1Lab.Univalence.SIP.html#24182" class="InductiveConstructor Operator">s→</a> <a id="25648" class="Symbol">(</a><a data-type="StrTm ℓ ℓ (λ X → X)" id="25649" href="1Lab.Univalence.SIP.html#24150" class="InductiveConstructor">s∙</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="25652" href="1Lab.Univalence.SIP.html#24182" class="InductiveConstructor Operator">s→</a> <a data-type="StrTm ℓ ℓ (λ X → X)" id="25655" href="1Lab.Univalence.SIP.html#24150" class="InductiveConstructor">s∙</a><a id="25657" class="Symbol">)))</a>

  <a id="25664" href="1Lab.Univalence.SIP.html#25664" class="Function">_</a> <a id="25666" class="Symbol">:</a> <a id="25668" class="Symbol">{</a><a id="25669" href="1Lab.Univalence.SIP.html#25669" class="Bound">A</a> <a id="25671" href="1Lab.Univalence.SIP.html#25671" class="Bound">B</a> <a id="25673" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="25675" href="1Lab.Univalence.SIP.html#3323" class="Function">TypeWith</a> <a id="25684" href="1Lab.Univalence.SIP.html#25569" class="Function">Pointed∞Magma</a><a id="25697" class="Symbol">}</a> <a id="25699" class="Symbol">{</a><a id="25700" href="1Lab.Univalence.SIP.html#25700" class="Bound">f</a> <a id="25702" class="Symbol">:</a> <a id="25704" href="1Lab.Univalence.SIP.html#25669" class="Bound">A</a> <a id="25706" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="25707" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="25711" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="25713" href="1Lab.Univalence.SIP.html#25671" class="Bound">B</a> <a id="25715" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="25716" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="25719" class="Symbol">}</a>
    <a id="25725" class="Symbol">→</a> <a id="25727" href="1Lab.Univalence.SIP.html#25569" class="Function">Pointed∞Magma</a> <a id="25741" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B₁ : Σ S₁) → A .fst ≃ B₁ .fst → Type ℓ₃" id="25742" href="1Lab.Univalence.SIP.html#2879" class="Field">is-hom</a> <a id="25749" href="1Lab.Univalence.SIP.html#25669" class="Bound">A</a> <a id="25751" href="1Lab.Univalence.SIP.html#25671" class="Bound">B</a> <a id="25753" href="1Lab.Univalence.SIP.html#25700" class="Bound">f</a>
    <a data-type="A → A → Type ℓ" id="25759" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="25761" class="Symbol">(</a> <a id="25763" class="Symbol">(</a><a id="25764" href="1Lab.Univalence.SIP.html#25700" class="Bound">f</a> <a id="25766" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="25767" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="25771" class="Symbol">(</a><a id="25772" href="1Lab.Univalence.SIP.html#25669" class="Bound">A</a> <a id="25774" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="25775" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="25779" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="25780" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="25783" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="25785" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="25787" href="1Lab.Univalence.SIP.html#25671" class="Bound">B</a> <a id="25789" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="25790" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="25794" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="25795" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="25798" class="Symbol">)</a>
      <a data-type="Type a → Type b → Type (a ⊔ b)" id="25806" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="25808" class="Symbol">((</a><a id="25810" href="1Lab.Univalence.SIP.html#25810" class="Bound">x</a> <a id="25812" href="1Lab.Univalence.SIP.html#25812" class="Bound">y</a> <a id="25814" class="Symbol">:</a> <a id="25816" href="1Lab.Univalence.SIP.html#25669" class="Bound">A</a> <a id="25818" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="25819" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="25822" class="Symbol">)</a> <a id="25824" class="Symbol">→</a> <a id="25826" href="1Lab.Univalence.SIP.html#25700" class="Bound">f</a> <a id="25828" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="25829" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="25833" class="Symbol">(</a><a id="25834" href="1Lab.Univalence.SIP.html#25669" class="Bound">A</a> <a id="25836" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="25837" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="25841" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="25842" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="25846" href="1Lab.Univalence.SIP.html#25810" class="Bound">x</a> <a id="25848" href="1Lab.Univalence.SIP.html#25812" class="Bound">y</a><a id="25849" class="Symbol">)</a>
                        <a data-type="A → A → Type ℓ" id="25875" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="25877" href="1Lab.Univalence.SIP.html#25671" class="Bound">B</a> <a id="25879" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="25880" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="25884" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="25885" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="25889" class="Symbol">(</a><a id="25890" href="1Lab.Univalence.SIP.html#25700" class="Bound">f</a> <a id="25892" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="25893" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="25897" href="1Lab.Univalence.SIP.html#25810" class="Bound">x</a><a id="25898" class="Symbol">)</a> <a id="25900" class="Symbol">(</a><a id="25901" href="1Lab.Univalence.SIP.html#25700" class="Bound">f</a> <a id="25903" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="25904" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="25908" href="1Lab.Univalence.SIP.html#25812" class="Bound">y</a><a id="25909" class="Symbol">)))</a>
  <a id="25915" class="Symbol">_</a> <a id="25917" class="Symbol">=</a> <a data-type="x ≡ x" id="25919" href="1Lab.Path.html#3591" class="Function">refl</a>
</pre>
<p>A homomorphic equivalence of pointed ∞-magmas is an equivalence of their underlying types that preserves the basepoint and is homomorphic over the operation. The use of <span class="Agda"><a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" href="1Lab.Univalence.SIP.html#24730" class="Function">tm→Action</a></span> in contravariant positions is responsible for making sure the computed <span class="Agda"><a data-type="Structure ℓ₃ S₁ → (A B₁ : Σ S₁) → A .fst ≃ B₁ .fst → Type ℓ₃" href="1Lab.Univalence.SIP.html#2879" class="Field">is-hom</a></span> doesn’t have any redundant paths in argument positions.</p>
<p>A mutually <em>inductive</em> argument proves that <span class="Agda"><a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" href="1Lab.Univalence.SIP.html#24730" class="Function">tm→Action</a></span> produces transport structures, and that <span class="Agda"><a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" href="1Lab.Univalence.SIP.html#24679" class="Function">tm→Structure</a></span> produces univalent structures. At every case, the proof is by appeal to a lemma that was proved above.</p>
<pre class="Agda"><a id="tm→Structure-univalent"></a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isUnivalent (tm→Structure s)" id="26498" href="1Lab.Univalence.SIP.html#26498" class="Function">tm→Structure-univalent</a> <a id="26521" class="Symbol">:</a> <a id="26523" class="Symbol">(</a><a id="26524" href="1Lab.Univalence.SIP.html#26524" class="Bound">s</a> <a id="26526" class="Symbol">:</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="26528" href="1Lab.Univalence.SIP.html#24034" class="Datatype">StrTm</a> <a id="26534" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a> <a id="26536" href="1Lab.Univalence.SIP.html#3459" class="Generalizable">ℓ₁</a> <a id="26539" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a><a id="26540" class="Symbol">)</a> <a id="26542" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="26544" href="1Lab.Univalence.SIP.html#3849" class="Function">isUnivalent</a> <a id="26556" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="26557" href="1Lab.Univalence.SIP.html#24679" class="Function">tm→Structure</a> <a id="26570" href="1Lab.Univalence.SIP.html#26524" class="Bound">s</a><a id="26571" class="Symbol">)</a>
<a id="tm→Action-isTransp"></a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isTransportStr (tm→Action s)" id="26573" href="1Lab.Univalence.SIP.html#26573" class="Function">tm→Action-isTransp</a> <a id="26592" class="Symbol">:</a> <a id="26594" class="Symbol">(</a><a id="26595" href="1Lab.Univalence.SIP.html#26595" class="Bound">s</a> <a id="26597" class="Symbol">:</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="26599" href="1Lab.Univalence.SIP.html#24034" class="Datatype">StrTm</a> <a id="26605" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a> <a id="26607" href="1Lab.Univalence.SIP.html#3459" class="Generalizable">ℓ₁</a> <a id="26610" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a><a id="26611" class="Symbol">)</a> <a id="26613" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="26615" href="1Lab.Univalence.SIP.html#14125" class="Function">isTransportStr</a> <a id="26630" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="26631" href="1Lab.Univalence.SIP.html#24730" class="Function">tm→Action</a> <a id="26641" href="1Lab.Univalence.SIP.html#26595" class="Bound">s</a><a id="26642" class="Symbol">)</a>

<a data-type="(s : StrTm ℓ ℓ₁ S₁) → isUnivalent (tm→Structure s)" id="26645" href="1Lab.Univalence.SIP.html#26498" class="Function">tm→Structure-univalent</a> <a id="26668" class="Symbol">(</a><a data-type="(A : Type ℓ₁) → StrTm ℓ ℓ₁ (λ X → A)" id="26669" href="1Lab.Univalence.SIP.html#24094" class="InductiveConstructor">s-const</a> <a id="26677" href="1Lab.Univalence.SIP.html#26677" class="Bound">x</a><a id="26678" class="Symbol">)</a> <a id="26680" class="Symbol">=</a> <a data-type="isUnivalent (constantStr A)" id="26682" href="1Lab.Univalence.SIP.html#6317" class="Function">constantStr-univalent</a>
<a data-type="(s : StrTm ℓ ℓ₁ S₁) → isUnivalent (tm→Structure s)" id="26704" href="1Lab.Univalence.SIP.html#26498" class="Function">tm→Structure-univalent</a> <a data-type="StrTm ℓ ℓ (λ X → X)" id="26727" href="1Lab.Univalence.SIP.html#24150" class="InductiveConstructor">s∙</a> <a id="26730" class="Symbol">=</a> <a data-type="isUnivalent pointedStr" id="26732" href="1Lab.Univalence.SIP.html#7271" class="Function">pointedStr-univalent</a>
<a data-type="(s : StrTm ℓ ℓ₁ S₁) → isUnivalent (tm→Structure s)" id="26753" href="1Lab.Univalence.SIP.html#26498" class="Function">tm→Structure-univalent</a> <a id="26776" class="Symbol">(</a><a id="26777" href="1Lab.Univalence.SIP.html#26777" class="Bound">s</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="26779" href="1Lab.Univalence.SIP.html#24182" class="InductiveConstructor Operator">s→</a> <a id="26782" href="1Lab.Univalence.SIP.html#26782" class="Bound">s₁</a><a id="26784" class="Symbol">)</a> <a id="26786" class="Symbol">=</a>
  <a data-type="(α : EqvAction S₁) →
isTransportStr α →
(τ : Structure ℓ T) → isUnivalent τ → isUnivalent (functionStr α τ)" id="26790" href="1Lab.Univalence.SIP.html#17273" class="Function">functionStr-univalent</a>
    <a id="26816" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="26817" href="1Lab.Univalence.SIP.html#24730" class="Function">tm→Action</a> <a id="26827" href="1Lab.Univalence.SIP.html#26777" class="Bound">s</a><a id="26828" class="Symbol">)</a> <a id="26830" class="Symbol">(</a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isTransportStr (tm→Action s)" id="26831" href="1Lab.Univalence.SIP.html#26573" class="Function">tm→Action-isTransp</a> <a id="26850" href="1Lab.Univalence.SIP.html#26777" class="Bound">s</a><a id="26851" class="Symbol">)</a>
    <a id="26857" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="26858" href="1Lab.Univalence.SIP.html#24679" class="Function">tm→Structure</a> <a id="26871" href="1Lab.Univalence.SIP.html#26782" class="Bound">s₁</a><a id="26873" class="Symbol">)</a> <a id="26875" class="Symbol">(</a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isUnivalent (tm→Structure s)" id="26876" href="1Lab.Univalence.SIP.html#26498" class="Function">tm→Structure-univalent</a> <a id="26899" href="1Lab.Univalence.SIP.html#26782" class="Bound">s₁</a><a id="26901" class="Symbol">)</a>
<a data-type="(s : StrTm ℓ ℓ₁ S₁) → isUnivalent (tm→Structure s)" id="26903" href="1Lab.Univalence.SIP.html#26498" class="Function">tm→Structure-univalent</a> <a id="26926" class="Symbol">(</a><a id="26927" href="1Lab.Univalence.SIP.html#26927" class="Bound">s</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="26929" href="1Lab.Univalence.SIP.html#24280" class="InductiveConstructor Operator">s×</a> <a id="26932" href="1Lab.Univalence.SIP.html#26932" class="Bound">s₁</a><a id="26934" class="Symbol">)</a> <a id="26936" class="Symbol">=</a>
  <a data-type="isUnivalent σ → isUnivalent τ → isUnivalent (productStr σ τ)" id="26940" href="1Lab.Univalence.SIP.html#7755" class="Function">productStr-univalent</a> <a id="26961" class="Symbol">{</a><a id="26962" class="Argument">σ</a> <a id="26964" class="Symbol">=</a> <a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="26966" href="1Lab.Univalence.SIP.html#24679" class="Function">tm→Structure</a> <a id="26979" href="1Lab.Univalence.SIP.html#26927" class="Bound">s</a><a id="26980" class="Symbol">}</a> <a id="26982" class="Symbol">{</a><a id="26983" class="Argument">τ</a> <a id="26985" class="Symbol">=</a> <a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="26987" href="1Lab.Univalence.SIP.html#24679" class="Function">tm→Structure</a> <a id="27000" href="1Lab.Univalence.SIP.html#26932" class="Bound">s₁</a><a id="27002" class="Symbol">}</a>
    <a id="27008" class="Symbol">(</a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isUnivalent (tm→Structure s)" id="27009" href="1Lab.Univalence.SIP.html#26498" class="Function">tm→Structure-univalent</a> <a id="27032" href="1Lab.Univalence.SIP.html#26927" class="Bound">s</a><a id="27033" class="Symbol">)</a> <a id="27035" class="Symbol">(</a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isUnivalent (tm→Structure s)" id="27036" href="1Lab.Univalence.SIP.html#26498" class="Function">tm→Structure-univalent</a> <a id="27059" href="1Lab.Univalence.SIP.html#26932" class="Bound">s₁</a><a id="27061" class="Symbol">)</a>

<a data-type="(s : StrTm ℓ ℓ₁ S₁) → isTransportStr (tm→Action s)" id="27064" href="1Lab.Univalence.SIP.html#26573" class="Function">tm→Action-isTransp</a> <a id="27083" class="Symbol">(</a><a data-type="(A : Type ℓ₁) → StrTm ℓ ℓ₁ (λ X → A)" id="27084" href="1Lab.Univalence.SIP.html#24094" class="InductiveConstructor">s-const</a> <a id="27092" href="1Lab.Univalence.SIP.html#27092" class="Bound">x</a><a id="27093" class="Symbol">)</a> <a id="27095" class="Symbol">=</a> <a data-type="isTransportStr (constantAction A)" id="27097" href="1Lab.Univalence.SIP.html#19568" class="Function">constantAction-isTransp</a>
<a data-type="(s : StrTm ℓ ℓ₁ S₁) → isTransportStr (tm→Action s)" id="27121" href="1Lab.Univalence.SIP.html#26573" class="Function">tm→Action-isTransp</a> <a data-type="StrTm ℓ ℓ (λ X → X)" id="27140" href="1Lab.Univalence.SIP.html#24150" class="InductiveConstructor">s∙</a> <a id="27143" class="Symbol">=</a> <a data-type="isTransportStr id" id="27145" href="1Lab.Univalence.SIP.html#19706" class="Function">idAction-isTransp</a>
<a data-type="(s : StrTm ℓ ℓ₁ S₁) → isTransportStr (tm→Action s)" id="27163" href="1Lab.Univalence.SIP.html#26573" class="Function">tm→Action-isTransp</a> <a id="27182" class="Symbol">(</a><a id="27183" href="1Lab.Univalence.SIP.html#27183" class="Bound">s</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="27185" href="1Lab.Univalence.SIP.html#24182" class="InductiveConstructor Operator">s→</a> <a id="27188" href="1Lab.Univalence.SIP.html#27188" class="Bound">s₁</a><a id="27190" class="Symbol">)</a> <a id="27192" class="Symbol">=</a>
  <a data-type="isTransportStr α →
isTransportStr β → isTransportStr (functionAction α β)" id="27196" href="1Lab.Univalence.SIP.html#20346" class="Function">functionAction-isTransp</a> <a id="27220" class="Symbol">{</a><a id="27221" class="Argument">α</a> <a id="27223" class="Symbol">=</a> <a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="27225" href="1Lab.Univalence.SIP.html#24730" class="Function">tm→Action</a> <a id="27235" href="1Lab.Univalence.SIP.html#27183" class="Bound">s</a><a id="27236" class="Symbol">}</a> <a id="27238" class="Symbol">{</a><a id="27239" class="Argument">β</a> <a id="27241" class="Symbol">=</a> <a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="27243" href="1Lab.Univalence.SIP.html#24730" class="Function">tm→Action</a> <a id="27253" href="1Lab.Univalence.SIP.html#27188" class="Bound">s₁</a><a id="27255" class="Symbol">}</a>
    <a id="27261" class="Symbol">(</a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isTransportStr (tm→Action s)" id="27262" href="1Lab.Univalence.SIP.html#26573" class="Function">tm→Action-isTransp</a> <a id="27281" href="1Lab.Univalence.SIP.html#27183" class="Bound">s</a><a id="27282" class="Symbol">)</a> <a id="27284" class="Symbol">(</a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isTransportStr (tm→Action s)" id="27285" href="1Lab.Univalence.SIP.html#26573" class="Function">tm→Action-isTransp</a> <a id="27304" href="1Lab.Univalence.SIP.html#27188" class="Bound">s₁</a><a id="27306" class="Symbol">)</a>
<a data-type="(s : StrTm ℓ ℓ₁ S₁) → isTransportStr (tm→Action s)" id="27308" href="1Lab.Univalence.SIP.html#26573" class="Function">tm→Action-isTransp</a> <a id="27327" class="Symbol">(</a><a id="27328" href="1Lab.Univalence.SIP.html#27328" class="Bound">s</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="27330" href="1Lab.Univalence.SIP.html#24280" class="InductiveConstructor Operator">s×</a> <a id="27333" href="1Lab.Univalence.SIP.html#27333" class="Bound">s₁</a><a id="27335" class="Symbol">)</a> <a id="27337" class="Symbol">=</a>
  <a data-type="isTransportStr α →
isTransportStr β → isTransportStr (productAction α β)" id="27341" href="1Lab.Univalence.SIP.html#19943" class="Function">productAction-isTransp</a> <a id="27364" class="Symbol">{</a><a id="27365" class="Argument">α</a> <a id="27367" class="Symbol">=</a> <a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="27369" href="1Lab.Univalence.SIP.html#24730" class="Function">tm→Action</a> <a id="27379" href="1Lab.Univalence.SIP.html#27328" class="Bound">s</a><a id="27380" class="Symbol">}</a> <a id="27382" class="Symbol">{</a><a id="27383" class="Argument">β</a> <a id="27385" class="Symbol">=</a> <a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="27387" href="1Lab.Univalence.SIP.html#24730" class="Function">tm→Action</a> <a id="27397" href="1Lab.Univalence.SIP.html#27333" class="Bound">s₁</a><a id="27399" class="Symbol">}</a>
    <a id="27405" class="Symbol">(</a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isTransportStr (tm→Action s)" id="27406" href="1Lab.Univalence.SIP.html#26573" class="Function">tm→Action-isTransp</a> <a id="27425" href="1Lab.Univalence.SIP.html#27328" class="Bound">s</a><a id="27426" class="Symbol">)</a> <a id="27428" class="Symbol">(</a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isTransportStr (tm→Action s)" id="27429" href="1Lab.Univalence.SIP.html#26573" class="Function">tm→Action-isTransp</a> <a id="27448" href="1Lab.Univalence.SIP.html#27333" class="Bound">s₁</a><a id="27450" class="Symbol">)</a>
</pre>
<h2 id="descriptions-of-structures"><a href="#descriptions-of-structures" class="header-link">Descriptions of Structures<span class="header-link-emoji">🔗</span></a></h2>
<p>To make convenient descriptions of structures-with-axioms, we introduce a record type, <span class="Agda"><a data-type="(ℓ ℓ₁ : Level) (S₁ : Type ℓ → Type ℓ₁) (ax : Level) → Typeω" href="1Lab.Univalence.SIP.html#27689" class="Record">StrDesc</a></span>, which packages together the structure term and the properties that are imposed:</p>
<pre class="Agda"><a id="27682" class="Keyword">record</a> <a id="StrDesc"></a><a data-type="(ℓ ℓ₁ : Level) (S₁ : Type ℓ → Type ℓ₁) (ax : Level) → Typeω" id="27689" href="1Lab.Univalence.SIP.html#27689" class="Record">StrDesc</a> <a id="27697" href="1Lab.Univalence.SIP.html#27697" class="Bound">ℓ</a> <a id="27699" href="1Lab.Univalence.SIP.html#27699" class="Bound">ℓ₁</a> <a id="27702" href="1Lab.Univalence.SIP.html#27702" class="Bound">S</a> <a id="27704" href="1Lab.Univalence.SIP.html#27704" class="Bound">ax</a> <a id="27707" class="Symbol">:</a> <a id="27709" href="1Lab.Type.html#409" class="Primitive">Typeω</a> <a id="27715" class="Keyword">where</a>
  <a id="27723" class="Keyword">field</a>
    <a id="StrDesc.descriptor"></a><a data-type="StrDesc ℓ ℓ₁ S₁ ax → StrTm ℓ ℓ₁ S₁" id="27733" href="1Lab.Univalence.SIP.html#27733" class="Field">descriptor</a> <a id="27744" class="Symbol">:</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="27746" href="1Lab.Univalence.SIP.html#24034" class="Datatype">StrTm</a> <a id="27752" href="1Lab.Univalence.SIP.html#27697" class="Bound">ℓ</a> <a id="27754" href="1Lab.Univalence.SIP.html#27699" class="Bound">ℓ₁</a> <a id="27757" href="1Lab.Univalence.SIP.html#27702" class="Bound">S</a>

    <a id="StrDesc.axioms"></a><a data-type="StrDesc ℓ ℓ₁ S₁ ax → (X : Type ℓ) → S₁ X → Type ax" id="27764" href="1Lab.Univalence.SIP.html#27764" class="Field">axioms</a> <a id="27771" class="Symbol">:</a> <a id="27773" class="Symbol">∀</a> <a id="27775" href="1Lab.Univalence.SIP.html#27775" class="Bound">X</a> <a id="27777" class="Symbol">→</a> <a id="27779" href="1Lab.Univalence.SIP.html#27702" class="Bound">S</a> <a id="27781" href="1Lab.Univalence.SIP.html#27775" class="Bound">X</a> <a id="27783" class="Symbol">→</a> <a id="27785" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="27790" href="1Lab.Univalence.SIP.html#27704" class="Bound">ax</a>
    <a id="StrDesc.axioms-prop"></a><a data-type="(r : StrDesc ℓ ℓ₁ S₁ ax) (X : Type ℓ) (s : S₁ X) →
isProp (r .axioms X s)" id="27797" href="1Lab.Univalence.SIP.html#27797" class="Field">axioms-prop</a> <a id="27809" class="Symbol">:</a> <a id="27811" class="Symbol">∀</a> <a id="27813" href="1Lab.Univalence.SIP.html#27813" class="Bound">X</a> <a id="27815" href="1Lab.Univalence.SIP.html#27815" class="Bound">s</a> <a id="27817" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="27819" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="27826" class="Symbol">(</a><a data-type="StrDesc ℓ ℓ₁ S₁ ax → (X : Type ℓ) → S₁ X → Type ax" id="27827" href="1Lab.Univalence.SIP.html#27764" class="Field">axioms</a> <a id="27834" href="1Lab.Univalence.SIP.html#27813" class="Bound">X</a> <a id="27836" href="1Lab.Univalence.SIP.html#27815" class="Bound">s</a><a id="27837" class="Symbol">)</a>

<a id="Desc→Fam"></a><a data-type="StrDesc ℓ ℓ₁ S₁ ax → Type ℓ → Type (ℓ₁ ⊔ ax)" id="27840" href="1Lab.Univalence.SIP.html#27840" class="Function">Desc→Fam</a> <a id="27849" class="Symbol">:</a> <a id="27851" class="Symbol">∀</a> <a id="27853" class="Symbol">{</a><a id="27854" href="1Lab.Univalence.SIP.html#27854" class="Bound">ax</a><a id="27856" class="Symbol">}</a> <a id="27858" class="Symbol">→</a> <a data-type="(ℓ ℓ₁ : Level) (S₁ : Type ℓ → Type ℓ₁) (ax : Level) → Typeω" id="27860" href="1Lab.Univalence.SIP.html#27689" class="Record">StrDesc</a> <a id="27868" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a> <a id="27870" href="1Lab.Univalence.SIP.html#3459" class="Generalizable">ℓ₁</a> <a id="27873" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a> <a id="27875" href="1Lab.Univalence.SIP.html#27854" class="Bound">ax</a> <a id="27878" class="Symbol">→</a> <a id="27880" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="27885" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a> <a id="27887" class="Symbol">→</a> <a id="27889" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="27894" class="Symbol">(</a><a id="27895" href="1Lab.Univalence.SIP.html#3459" class="Generalizable">ℓ₁</a> <a data-type="Level → Level → Level" id="27898" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="27900" href="1Lab.Univalence.SIP.html#27854" class="Bound">ax</a><a id="27902" class="Symbol">)</a>
<a data-type="StrDesc ℓ ℓ₁ S₁ ax → Type ℓ → Type (ℓ₁ ⊔ ax)" id="27904" href="1Lab.Univalence.SIP.html#27840" class="Function">Desc→Fam</a> <a id="27913" class="Symbol">{</a><a id="27914" class="Argument">S</a> <a id="27916" class="Symbol">=</a> <a id="27918" href="1Lab.Univalence.SIP.html#27918" class="Bound">S</a><a id="27919" class="Symbol">}</a> <a id="27921" href="1Lab.Univalence.SIP.html#27921" class="Bound">desc</a> <a id="27926" href="1Lab.Univalence.SIP.html#27926" class="Bound">X</a> <a id="27928" class="Symbol">=</a>
  <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="27932" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="27935" href="1Lab.Univalence.SIP.html#27935" class="Bound">S</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="27937" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="27939" href="1Lab.Univalence.SIP.html#27918" class="Bound">S</a> <a id="27941" href="1Lab.Univalence.SIP.html#27926" class="Bound">X</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="27943" href="1Lab.Type.html#1563" class="Function">]</a>
    <a id="27949" class="Symbol">(</a><a id="27950" href="1Lab.Univalence.SIP.html#27921" class="Bound">desc</a> <a id="27955" class="Symbol">.</a><a data-type="StrDesc ℓ ℓ₁ S₁ ax → (X : Type ℓ) → S₁ X → Type ax" id="27956" href="1Lab.Univalence.SIP.html#27764" class="Field">StrDesc.axioms</a> <a id="27971" class="Symbol">_</a> <a id="27973" href="1Lab.Univalence.SIP.html#27935" class="Bound">S</a><a id="27974" class="Symbol">)</a>

<a id="Desc→Str"></a><a data-type="(S₁ : StrDesc ℓ ℓ₁ S₂ ax) → Structure ℓ₁ (Desc→Fam S₁)" id="27977" href="1Lab.Univalence.SIP.html#27977" class="Function">Desc→Str</a> <a id="27986" class="Symbol">:</a> <a id="27988" class="Symbol">∀</a> <a id="27990" class="Symbol">{</a><a id="27991" href="1Lab.Univalence.SIP.html#27991" class="Bound">ax</a><a id="27993" class="Symbol">}</a> <a id="27995" class="Symbol">→</a> <a id="27997" class="Symbol">(</a><a id="27998" href="1Lab.Univalence.SIP.html#27998" class="Bound">S</a> <a id="28000" class="Symbol">:</a> <a data-type="(ℓ ℓ₁ : Level) (S₁ : Type ℓ → Type ℓ₁) (ax : Level) → Typeω" id="28002" href="1Lab.Univalence.SIP.html#27689" class="Record">StrDesc</a> <a id="28010" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a> <a id="28012" href="1Lab.Univalence.SIP.html#3459" class="Generalizable">ℓ₁</a> <a id="28015" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a> <a id="28017" href="1Lab.Univalence.SIP.html#27991" class="Bound">ax</a><a id="28019" class="Symbol">)</a> <a id="28021" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="28023" href="1Lab.Univalence.SIP.html#1951" class="Record">Structure</a> <a id="28033" class="Symbol">_</a> <a id="28035" class="Symbol">(</a><a data-type="StrDesc ℓ ℓ₁ S₁ ax → Type ℓ → Type (ℓ₁ ⊔ ax)" id="28036" href="1Lab.Univalence.SIP.html#27840" class="Function">Desc→Fam</a> <a id="28045" href="1Lab.Univalence.SIP.html#27998" class="Bound">S</a><a id="28046" class="Symbol">)</a>
<a data-type="(S₁ : StrDesc ℓ ℓ₁ S₂ ax) → Structure ℓ₁ (Desc→Fam S₁)" id="28048" href="1Lab.Univalence.SIP.html#27977" class="Function">Desc→Str</a> <a id="28057" href="1Lab.Univalence.SIP.html#28057" class="Bound">desc</a> <a id="28062" class="Symbol">=</a> <a data-type="(σ : Structure ℓ S₁) (axioms : (X : Type S.ℓ) → S₁ X → Type ℓ₃) →
Structure ℓ (λ X → Σ (axioms X))" id="28064" href="1Lab.Univalence.SIP.html#21886" class="Function">axiomsStr</a> <a id="28074" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="28075" href="1Lab.Univalence.SIP.html#24679" class="Function">tm→Structure</a> <a data-type="StrDesc ℓ ℓ₁ S₁ ax → StrTm ℓ ℓ₁ S₁" id="28088" href="1Lab.Univalence.SIP.html#27733" class="Field">descriptor</a><a id="28098" class="Symbol">)</a> <a data-type="StrDesc ℓ ℓ₁ S₁ ax → (X : Type ℓ) → S₁ X → Type ax" id="28100" href="1Lab.Univalence.SIP.html#27764" class="Field">axioms</a>
  <a id="28109" class="Keyword">where</a> <a id="28115" class="Keyword">open</a> <a data-type="(ℓ ℓ₁ : Level) (S₁ : Type ℓ → Type ℓ₁) (ax : Level) → Typeω" id="28120" href="1Lab.Univalence.SIP.html#27689" class="Module">StrDesc</a> <a id="28128" href="1Lab.Univalence.SIP.html#28057" class="Bound">desc</a>

<a id="Desc→isUnivalent"></a><a data-type="(S₁ : StrDesc ℓ ℓ₁ S₂ ax) → isUnivalent (Desc→Str S₁)" id="28134" href="1Lab.Univalence.SIP.html#28134" class="Function">Desc→isUnivalent</a> <a id="28151" class="Symbol">:</a> <a id="28153" class="Symbol">∀</a> <a id="28155" class="Symbol">{</a><a id="28156" href="1Lab.Univalence.SIP.html#28156" class="Bound">ax</a><a id="28158" class="Symbol">}</a> <a id="28160" class="Symbol">→</a> <a id="28162" class="Symbol">(</a><a id="28163" href="1Lab.Univalence.SIP.html#28163" class="Bound">S</a> <a id="28165" class="Symbol">:</a> <a data-type="(ℓ ℓ₁ : Level) (S₁ : Type ℓ → Type ℓ₁) (ax : Level) → Typeω" id="28167" href="1Lab.Univalence.SIP.html#27689" class="Record">StrDesc</a> <a id="28175" href="1Lab.Univalence.SIP.html#3457" class="Generalizable">ℓ</a> <a id="28177" href="1Lab.Univalence.SIP.html#3459" class="Generalizable">ℓ₁</a> <a id="28180" href="1Lab.Univalence.SIP.html#3491" class="Generalizable">S</a> <a id="28182" href="1Lab.Univalence.SIP.html#28156" class="Bound">ax</a><a id="28184" class="Symbol">)</a> <a id="28186" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="28188" href="1Lab.Univalence.SIP.html#3849" class="Function">isUnivalent</a> <a id="28200" class="Symbol">(</a><a data-type="(S₁ : StrDesc ℓ ℓ₁ S₂ ax) → Structure ℓ₁ (Desc→Fam S₁)" id="28201" href="1Lab.Univalence.SIP.html#27977" class="Function">Desc→Str</a> <a id="28210" href="1Lab.Univalence.SIP.html#28163" class="Bound">S</a><a id="28211" class="Symbol">)</a>
<a data-type="(S₁ : StrDesc ℓ ℓ₁ S₂ ax) → isUnivalent (Desc→Str S₁)" id="28213" href="1Lab.Univalence.SIP.html#28134" class="Function">Desc→isUnivalent</a> <a id="28230" href="1Lab.Univalence.SIP.html#28230" class="Bound">desc</a> <a id="28235" class="Symbol">=</a>
  <a data-type="(σ : Structure ℓ S₁) (axioms : (X : Type S.ℓ) → S₁ X → Type ℓ₃)
(univ : isUnivalent σ) (axioms-prop : isProp (axioms X s)) →
isUnivalent (axiomsStr σ axioms)" id="28239" href="1Lab.Univalence.SIP.html#22275" class="Function">axiomsStr-univalent</a>
    <a id="28263" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="28264" href="1Lab.Univalence.SIP.html#24679" class="Function">tm→Structure</a> <a data-type="StrDesc ℓ ℓ₁ S₁ ax → StrTm ℓ ℓ₁ S₁" id="28277" href="1Lab.Univalence.SIP.html#27733" class="Function">descriptor</a><a id="28287" class="Symbol">)</a> <a data-type="StrDesc ℓ ℓ₁ S₁ ax → (X : Type ℓ) → S₁ X → Type ax" id="28289" href="1Lab.Univalence.SIP.html#27764" class="Function">axioms</a>
    <a id="28300" class="Symbol">(</a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isUnivalent (tm→Structure s)" id="28301" href="1Lab.Univalence.SIP.html#26498" class="Function">tm→Structure-univalent</a> <a data-type="StrDesc ℓ ℓ₁ S₁ ax → StrTm ℓ ℓ₁ S₁" id="28324" href="1Lab.Univalence.SIP.html#27733" class="Function">descriptor</a><a id="28334" class="Symbol">)</a> <a id="28336" class="Symbol">(λ</a> <a id="28339" class="Symbol">{</a><a id="28340" href="1Lab.Univalence.SIP.html#28340" class="Bound">X</a><a id="28341" class="Symbol">}</a> <a id="28343" class="Symbol">{</a><a id="28344" href="1Lab.Univalence.SIP.html#28344" class="Bound">s</a><a id="28345" class="Symbol">}</a> <a id="28347" class="Symbol">→</a> <a data-type="(r : StrDesc ℓ ℓ₁ S₁ ax) (X : Type ℓ) (s : S₁ X) →
isProp (r .axioms X s)" id="28349" href="1Lab.Univalence.SIP.html#27797" class="Function">axioms-prop</a> <a id="28361" href="1Lab.Univalence.SIP.html#28340" class="Bound">X</a> <a id="28363" href="1Lab.Univalence.SIP.html#28344" class="Bound">s</a><a id="28364" class="Symbol">)</a>
  <a id="28368" class="Keyword">where</a> <a id="28374" class="Keyword">open</a> <a data-type="(ℓ ℓ₁ : Level) (S₁ : Type ℓ → Type ℓ₁) (ax : Level) → Typeω" id="28379" href="1Lab.Univalence.SIP.html#27689" class="Module">StrDesc</a> <a id="28387" href="1Lab.Univalence.SIP.html#28230" class="Bound">desc</a>
</pre>
  </article>
</div>

</main>
</body>
</html>
