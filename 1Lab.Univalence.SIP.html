<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>

<head>
  <meta charset="utf-8"></meta>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"></meta>
  <meta name="keywords" content="Agda,categories,topos"></meta>

  <title>1Lab.Univalence.SIP - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css"></link>
  <link rel="stylesheet" href="/css/katex.min.css"></link>
  <link rel="stylesheet" href="/css/agda-cats.css"></link>

  <meta name="twitter:card" content="summary"></meta>
  <meta name="twitter:title" content="1Lab.Univalence.SIP - 1Lab"></meta>
  <meta name="twitter:image" content="https://cubical.1lab.dev/static/cube-128x.png"></meta>

  <meta name="og:title" content="1Lab.Univalence.SIP - 1Lab"></meta>
  <meta name="og:image" content="https://cubical.1lab.dev/static/cube-128x.png"></meta>
  <meta name="og:site-name" content="The 1Lab"></meta>
  <meta name="og:type" content="website"></meta>
    <meta name="og:description" content="&lt;p&gt;The structure identity principle characterises equality in “types-with-structure” as being exactly the equivalences that preserve that structure. In a sense, it augments univalence with the notion of preservation of structure.&lt;/p&gt;"></meta>
  <meta name="twitter:description" content="&lt;p&gt;The structure identity principle characterises equality in “types-with-structure” as being exactly the equivalences that preserve that structure. In a sense, it augments univalence with the notion of preservation of structure.&lt;/p&gt;"></meta>
  
  <script src="/equations.js" type="text/javascript"></script> 
  <script src="/highlight-hover.js" type="text/javascript"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>
</head>

<body>
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0;">
                <a class="Module">1Lab.Univalence.SIP</a>
              </h3>

      <!-- Cube logo -->
      <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto; height: 32px;"></img>
      
      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr></hr>
      <ul class="incremental">
      <li><a href="#structure-identity-principle"><a href="#structure-identity-principle" class="header-link">Structure Identity Principle<span class="header-link-emoji">🔗</span></a></a>
      <ul class="incremental">
      <li><a href="#the-principle"><a href="#the-principle" class="header-link">The principle<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#structure-combinators"><a href="#structure-combinators" class="header-link">Structure Combinators<span class="header-link-emoji">🔗</span></a></a>
      <ul class="incremental">
      <li><a href="#example-infty-magmas"><a href="#example-infty-magmas" class="header-link">Example: <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>-magmas</span><span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#transport-structures"><a href="#transport-structures" class="header-link">Transport Structures<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#adding-axioms"><a href="#adding-axioms" class="header-link">Adding Axioms<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#a-language-for-structures"><a href="#a-language-for-structures" class="header-link">A Language for Structures<span class="header-link-emoji">🔗</span></a></a>
      <ul class="incremental">
      <li><a href="#descriptions-of-structures"><a href="#descriptions-of-structures" class="header-link">Descriptions of Structures<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      </ul>
      <hr></hr>

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>
      </div>

      <hr></hr>

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
              <a href="index.html">️back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/e1d6219e5e4bf2e7dbcc3bef6b8e75da1eaee107/src/1Lab/Univalence/SIP.lagda.md">link to source</a> <br />
      </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="index.html">️back to index</a>
      </div>
      
      <!-- Font toggle checkbox -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>
    </div>

<pre class="Agda"><a id="268" class="Keyword">open</a> <a id="273" class="Keyword">import</a> <a id="280" href="1Lab.Path.Groupoid.html" class="Module">1Lab.Path.Groupoid</a>
<a id="299" class="Keyword">open</a> <a id="304" class="Keyword">import</a> <a id="311" href="1Lab.Type.Sigma.html" class="Module">1Lab.Type.Sigma</a>
<a id="327" class="Keyword">open</a> <a id="332" class="Keyword">import</a> <a id="339" href="1Lab.Univalence.html" class="Module">1Lab.Univalence</a>
<a id="355" class="Keyword">open</a> <a id="360" class="Keyword">import</a> <a id="367" href="1Lab.Type.Pi.html" class="Module">1Lab.Type.Pi</a>
<a id="380" class="Keyword">open</a> <a id="385" class="Keyword">import</a> <a id="392" href="1Lab.HLevel.html" class="Module">1Lab.HLevel</a>
<a id="404" class="Keyword">open</a> <a id="409" class="Keyword">import</a> <a id="416" href="1Lab.Equiv.html" class="Module">1Lab.Equiv</a>
<a id="427" class="Keyword">open</a> <a id="432" class="Keyword">import</a> <a id="439" href="1Lab.Path.html" class="Module">1Lab.Path</a>
<a id="449" class="Keyword">open</a> <a id="454" class="Keyword">import</a> <a id="461" href="1Lab.Type.html" class="Module">1Lab.Type</a>

<a id="472" class="Keyword">module</a> <a id="479" href="1Lab.Univalence.SIP.html" class="Module">1Lab.Univalence.SIP</a> <a id="499" class="Keyword">where</a>
</pre>
<h1 id="structure-identity-principle"><a href="#structure-identity-principle" class="header-link">Structure Identity Principle<span class="header-link-emoji">🔗</span></a></h1>
<p>In mathematics in general, it’s often <em>notationally</em> helpful to identify isomorphic <em>structures</em> (e.g.: groups) in a proof. However, when this mathematics is done using material set theory as a foundations, this identification is merely a shorthand — nothing <em>prevents</em> you from distinguishing isomorphic groups in ZFC by, for instance, asking about membership of a particular set in the underlying set of each group.</p>
<p>In univalent mathematics, it’s a theorem that no family of types can distinguish between isomorphic structures. <a href="1Lab.Univalence.html">Univalence</a> is this statement, but for <em>types</em>. For structures built out of types, it seems like we would need a bit more power, but in reality, we don’t!</p>
<p>“Structure Identity Principle” is the name for several related theorems in Homotopy Type Theory, which generically say that “paths on a structure are isomorphisms of that structure”.</p>
<p>For instance, the version in the HoTT Book says that if a structure <code>S</code> on the objects of a univalent category <code>S</code> can be described in a certain way, then the category of <code>S</code>-structured objects of <code>C</code> is univalent. As a benefit, the Book version of the SIP characterises the <em>homomorphisms</em> of <code>S</code>-structures, not just the <em>isomorphisms</em>. As a downside, it only applies to <a data-type="Type ℓ → Type ℓ" href="1Lab.HLevel.html#3342">set-level</a> structures.</p>
<pre class="Agda"><a id="1935" class="Keyword">record</a>
  <a id="Structure"></a><a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="1944" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="1954" class="Symbol">{</a><a id="1955" href="1Lab.Univalence.SIP.html#1955" class="Bound">ℓ₁</a> <a id="1958" href="1Lab.Univalence.SIP.html#1958" class="Bound">ℓ₂</a><a id="1960" class="Symbol">}</a> <a id="1962" class="Symbol">(</a><a id="1963" href="1Lab.Univalence.SIP.html#1963" class="Bound">ℓ₃</a> <a id="1966" class="Symbol">:</a> <a id="1968" class="Symbol">_)</a> <a id="1971" class="Symbol">(</a><a id="1972" href="1Lab.Univalence.SIP.html#1972" class="Bound">S</a> <a id="1974" class="Symbol">:</a> <a id="1976" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="1981" href="1Lab.Univalence.SIP.html#1955" class="Bound">ℓ₁</a> <a id="1984" class="Symbol">→</a> <a id="1986" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="1991" href="1Lab.Univalence.SIP.html#1958" class="Bound">ℓ₂</a><a id="1993" class="Symbol">)</a> <a id="1995" class="Symbol">:</a> <a id="1997" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2002" class="Symbol">(</a><a data-type="Level → Level" id="2003" href="Agda.Primitive.html#780" class="Primitive">lsuc</a> <a id="2008" class="Symbol">(</a><a id="2009" href="1Lab.Univalence.SIP.html#1955" class="Bound">ℓ₁</a> <a data-type="Level → Level → Level" id="2012" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="2014" href="1Lab.Univalence.SIP.html#1963" class="Bound">ℓ₃</a><a id="2016" class="Symbol">)</a> <a data-type="Level → Level → Level" id="2018" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="2020" href="1Lab.Univalence.SIP.html#1958" class="Bound">ℓ₂</a><a id="2022" class="Symbol">)</a>
  <a id="2026" class="Keyword">where</a>

  <a id="2035" class="Keyword">constructor</a> <a id="HomT→Str"></a><a data-type="(is-hom₁ : (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃) →
Structure ℓ₃ S₁" id="2047" href="1Lab.Univalence.SIP.html#2047" class="InductiveConstructor">HomT→Str</a>
  <a id="2058" class="Keyword">field</a>
</pre>
<p>The material on this page, especially the definition of <span class="Agda"><a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a></span> and <span class="Agda"><a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a></span>, is adapted from <cite><a href="https://arxiv.org/abs/2009.05547">Internalizing Representation Independence with Univalence</a></cite>. The SIP formalised here says, very generically, that a <span class="Agda"><a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a></span> is a family of types <code>S : Type → Type</code>, and a <span class="Agda"><a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" href="1Lab.Univalence.SIP.html#3316" class="Function">type with</a></span> structure is an inhabitant of the <a data-type="(B : A → Type b) → Type (a ⊔ b)" href="1Lab.Type.html#1649">total space</a> <code>Σ S</code>.</p>
<p>What sets a <span class="Agda"><a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a></span> apart from a type family is a notion of <em>homomorphic equivalence</em>: Given an equivalence of the underlying types, the predicate <code>is-hom (A , x) (B , y) eqv</code> should represent what it means for <code>eqv</code> to take the <code>x</code>-structure on <code>A</code> to the <code>y</code>-structure on <code>B</code>.</p>
<pre class="Agda">   <a id="Structure.is-hom"></a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="2872" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="2879" class="Symbol">:</a> <a id="2881" class="Symbol">(</a><a id="2882" href="1Lab.Univalence.SIP.html#2882" class="Bound">A</a> <a id="2884" href="1Lab.Univalence.SIP.html#2884" class="Bound">B</a> <a id="2886" class="Symbol">:</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="2888" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="2890" href="1Lab.Univalence.SIP.html#1972" class="Bound">S</a><a id="2891" class="Symbol">)</a> <a id="2893" class="Symbol">→</a> <a id="2895" class="Symbol">(</a><a id="2896" href="1Lab.Univalence.SIP.html#2882" class="Bound">A</a> <a id="2898" class="Symbol">.</a><a data-type="∑ A B → A" id="2899" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="2903" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="2905" href="1Lab.Univalence.SIP.html#2884" class="Bound">B</a> <a id="2907" class="Symbol">.</a><a data-type="∑ A B → A" id="2908" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="2911" class="Symbol">)</a> <a id="2913" class="Symbol">→</a> <a id="2915" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2920" href="1Lab.Univalence.SIP.html#1963" class="Bound">ℓ₃</a>
</pre>
<p>As a grounding example, consider equipping types with group structure: If <code>(A , _⋆_)</code> and <code>(B , _*_)</code> are types with group structure (with many fields omitted!), and <code>f : A → B</code> is the underlying map of an equivalence <code>A ≃ B</code>, then <span class="Agda"><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a></span> would be <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mo stretchy="false">(</mo><mi>x</mi><mi>y</mi><mspace></mspace><mspace width="0.1111em"></mspace><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333em"></mspace><mi>A</mi><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo>⋆</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\forall (x y\colon A) f(x \star y) = f(x) * f(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∀</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋆</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> - the “usual” definition of group homomorphism.</p>
<pre class="Agda"><a id="3293" class="Keyword">open</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="3298" href="1Lab.Univalence.SIP.html#1944" class="Module">Structure</a> <a id="3308" class="Keyword">public</a>

<a id="TypeWith"></a><a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="3316" href="1Lab.Univalence.SIP.html#3316" class="Function">TypeWith</a> <a id="3325" class="Symbol">:</a> <a id="3327" class="Symbol">∀</a> <a id="3329" class="Symbol">{</a><a id="3330" href="1Lab.Univalence.SIP.html#3330" class="Bound">ℓ</a> <a id="3332" href="1Lab.Univalence.SIP.html#3332" class="Bound">ℓ₁</a> <a id="3335" href="1Lab.Univalence.SIP.html#3335" class="Bound">ℓ₂</a><a id="3337" class="Symbol">}</a> <a id="3339" class="Symbol">{</a><a id="3340" href="1Lab.Univalence.SIP.html#3340" class="Bound">S</a> <a id="3342" class="Symbol">:</a> <a id="3344" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3349" href="1Lab.Univalence.SIP.html#3330" class="Bound">ℓ</a> <a id="3351" class="Symbol">→</a> <a id="3353" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3358" href="1Lab.Univalence.SIP.html#3332" class="Bound">ℓ₁</a><a id="3360" class="Symbol">}</a> <a id="3362" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="3364" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="3374" href="1Lab.Univalence.SIP.html#3335" class="Bound">ℓ₂</a> <a id="3377" href="1Lab.Univalence.SIP.html#3340" class="Bound">S</a> <a id="3379" class="Symbol">→</a> <a id="3381" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3386" class="Symbol">_</a>
<a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="3388" href="1Lab.Univalence.SIP.html#3316" class="Function">TypeWith</a> <a id="3397" class="Symbol">{</a><a id="3398" class="Argument">S</a> <a id="3400" class="Symbol">=</a> <a id="3402" href="1Lab.Univalence.SIP.html#3402" class="Bound">S</a><a id="3403" class="Symbol">}</a> <a id="3405" class="Symbol">_</a> <a id="3407" class="Symbol">=</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="3409" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="3411" href="1Lab.Univalence.SIP.html#3402" class="Bound">S</a>
</pre>
<!--
<pre class="Agda"><a id="3431" class="Keyword">private</a> <a id="3439" class="Keyword">variable</a>
  <a id="3450" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="3452" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a> <a id="3455" href="1Lab.Univalence.SIP.html#3455" class="Generalizable">ℓ₂</a> <a id="3458" href="1Lab.Univalence.SIP.html#3458" class="Generalizable">ℓ₃</a> <a id="3461" class="Symbol">:</a> <a id="3463" href="Agda.Primitive.html#597" class="Postulate">Level</a>
  <a id="3471" href="1Lab.Univalence.SIP.html#3471" class="Generalizable">A</a> <a id="3473" class="Symbol">:</a> <a id="3475" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3480" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a>
  <a id="3484" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="3486" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a> <a id="3488" class="Symbol">:</a> <a id="3490" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3495" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="3497" class="Symbol">→</a> <a id="3499" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3504" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a>
</pre>-->
<p>A structure is said to be <strong>univalent</strong> if a homomorphic equivalence of structures <code>A</code>, <code>B</code> induces a path of the structures, over the univalence axiom — that is, if <span class="Agda"><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a></span> agrees with what it means for “S X” and “S Y” to be equal, where this equality is dependent on one induced by univalence.</p>
<pre class="Agda"><a id="isUnivalent"></a><a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="3831" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="3843" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="3845" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="3855" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="3857" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="3859" class="Symbol">→</a> <a id="3861" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3866" class="Symbol">_</a>
<a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="3868" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="3880" class="Symbol">{</a><a id="3881" class="Argument">S</a> <a id="3883" class="Symbol">=</a> <a id="3885" href="1Lab.Univalence.SIP.html#3885" class="Bound">S</a><a id="3886" class="Symbol">}</a> <a id="3888" href="1Lab.Univalence.SIP.html#3888" class="Bound">ι</a> <a id="3890" class="Symbol">=</a>
  <a id="3894" class="Symbol">∀</a> <a id="3896" class="Symbol">{</a><a id="3897" href="1Lab.Univalence.SIP.html#3897" class="Bound">X</a> <a id="3899" href="1Lab.Univalence.SIP.html#3899" class="Bound">Y</a><a id="3900" class="Symbol">}</a>
  <a id="3904" class="Symbol">→</a> <a id="3906" class="Symbol">(</a><a id="3907" href="1Lab.Univalence.SIP.html#3907" class="Bound">f</a> <a id="3909" class="Symbol">:</a> <a id="3911" href="1Lab.Univalence.SIP.html#3897" class="Bound">X</a> <a id="3913" class="Symbol">.</a><a data-type="∑ A B → A" id="3914" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="3918" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="3920" href="1Lab.Univalence.SIP.html#3899" class="Bound">Y</a> <a id="3922" class="Symbol">.</a><a data-type="∑ A B → A" id="3923" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="3926" class="Symbol">)</a>
  <a id="3930" class="Symbol">→</a> <a id="3932" href="1Lab.Univalence.SIP.html#3888" class="Bound">ι</a> <a id="3934" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="3935" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="3942" href="1Lab.Univalence.SIP.html#3897" class="Bound">X</a> <a id="3944" href="1Lab.Univalence.SIP.html#3899" class="Bound">Y</a> <a id="3946" href="1Lab.Univalence.SIP.html#3907" class="Bound">f</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="3948" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="3950" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="3956" class="Symbol">(λ</a> <a id="3959" href="1Lab.Univalence.SIP.html#3959" class="Bound">i</a> <a id="3961" class="Symbol">→</a> <a id="3963" href="1Lab.Univalence.SIP.html#3885" class="Bound">S</a> <a id="3965" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="3966" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="3969" href="1Lab.Univalence.SIP.html#3907" class="Bound">f</a> <a id="3971" href="1Lab.Univalence.SIP.html#3959" class="Bound">i</a><a id="3972" class="Symbol">))</a> <a id="3975" class="Symbol">(</a><a id="3976" href="1Lab.Univalence.SIP.html#3897" class="Bound">X</a> <a id="3978" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="3979" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="3982" class="Symbol">)</a> <a id="3984" class="Symbol">(</a><a id="3985" href="1Lab.Univalence.SIP.html#3899" class="Bound">Y</a> <a id="3987" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="3988" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="3991" class="Symbol">)</a>
</pre>
<p>The notation <span class="Agda"><a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">A ≃[ σ ] B</a></span> stands for the type of σ-homomorphic equivalences, i.e. those equivalences of the types underlying <code>A</code> and <code>B</code> that σ identifies as being homomorphic.</p>
<pre class="Agda"><a id="_≃[_]_"></a><a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="4204" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">_≃[_]_</a> <a id="4211" class="Symbol">:</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="4213" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="4215" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="4217" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="4219" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="4229" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="4231" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="4233" class="Symbol">→</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="4235" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="4237" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="4239" class="Symbol">→</a> <a id="4241" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="4246" class="Symbol">_</a>
<a id="4248" href="1Lab.Univalence.SIP.html#4248" class="Bound">A</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="4250" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">≃[</a> <a id="4253" href="1Lab.Univalence.SIP.html#4253" class="Bound">σ</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="4255" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">]</a> <a id="4257" href="1Lab.Univalence.SIP.html#4257" class="Bound">B</a> <a id="4259" class="Symbol">=</a>
  <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="4263" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="4266" href="1Lab.Univalence.SIP.html#4266" class="Bound">f</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="4268" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="4270" href="1Lab.Univalence.SIP.html#4248" class="Bound">A</a> <a id="4272" class="Symbol">.</a><a data-type="∑ A B → A" id="4273" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="4277" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="4279" href="1Lab.Univalence.SIP.html#4257" class="Bound">B</a> <a id="4281" class="Symbol">.</a><a data-type="∑ A B → A" id="4282" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="4286" href="1Lab.Type.html#1563" class="Function">]</a>
   <a id="4291" class="Symbol">(</a><a id="4292" href="1Lab.Univalence.SIP.html#4253" class="Bound">σ</a> <a id="4294" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="4295" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="4302" href="1Lab.Univalence.SIP.html#4248" class="Bound">A</a> <a id="4304" href="1Lab.Univalence.SIP.html#4257" class="Bound">B</a> <a id="4306" href="1Lab.Univalence.SIP.html#4266" class="Bound">f</a><a id="4307" class="Symbol">)</a>
</pre>
<h2 id="the-principle"><a href="#the-principle" class="header-link">The principle<span class="header-link-emoji">🔗</span></a></h2>
<p>The <strong>structure identity principle</strong> says that, if <code>S</code> is a <span class="Agda"><a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" href="1Lab.Univalence.SIP.html#3831" class="Function">univalent structure</a></span>, then the path space of <code>Σ S</code> is equivalent to the space of S-homomorphic equivalences of types. Again using groups as a grounding example: equality of groups is group isomorphism.</p>
<pre class="Agda"><a id="SIP"></a><a data-type="isUnivalent σ → (X ≃[ σ ] Y) ≃ (X ≡ Y)" id="4629" href="1Lab.Univalence.SIP.html#4629" class="Function">SIP</a> <a id="4633" class="Symbol">:</a> <a id="4635" class="Symbol">{</a><a id="4636" href="1Lab.Univalence.SIP.html#4636" class="Bound">σ</a> <a id="4638" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="4640" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="4650" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="4652" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="4653" class="Symbol">}</a> <a id="4655" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="4657" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="4669" href="1Lab.Univalence.SIP.html#4636" class="Bound">σ</a> <a id="4671" class="Symbol">→</a> <a id="4673" class="Symbol">{</a><a id="4674" href="1Lab.Univalence.SIP.html#4674" class="Bound">X</a> <a id="4676" href="1Lab.Univalence.SIP.html#4676" class="Bound">Y</a> <a id="4678" class="Symbol">:</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="4680" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="4682" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="4683" class="Symbol">}</a> <a id="4685" class="Symbol">→</a> <a id="4687" class="Symbol">(</a><a id="4688" href="1Lab.Univalence.SIP.html#4674" class="Bound">X</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="4690" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">≃[</a> <a id="4693" href="1Lab.Univalence.SIP.html#4636" class="Bound">σ</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="4695" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">]</a> <a id="4697" href="1Lab.Univalence.SIP.html#4676" class="Bound">Y</a><a id="4698" class="Symbol">)</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="4700" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="4702" class="Symbol">(</a><a id="4703" href="1Lab.Univalence.SIP.html#4674" class="Bound">X</a> <a data-type="A → A → Type ℓ" id="4705" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="4707" href="1Lab.Univalence.SIP.html#4676" class="Bound">Y</a><a id="4708" class="Symbol">)</a>
<a data-type="isUnivalent σ → (X ≃[ σ ] Y) ≃ (X ≡ Y)" id="4710" href="1Lab.Univalence.SIP.html#4629" class="Function">SIP</a> <a id="4714" class="Symbol">{</a><a id="4715" class="Argument">S</a> <a id="4717" class="Symbol">=</a> <a id="4719" href="1Lab.Univalence.SIP.html#4719" class="Bound">S</a><a id="4720" class="Symbol">}</a> <a id="4722" class="Symbol">{</a><a id="4723" class="Argument">σ</a> <a id="4725" class="Symbol">=</a> <a id="4727" href="1Lab.Univalence.SIP.html#4727" class="Bound">σ</a><a id="4728" class="Symbol">}</a> <a id="4730" href="1Lab.Univalence.SIP.html#4730" class="Bound">is-univ</a> <a id="4738" class="Symbol">{</a><a id="4739" href="1Lab.Univalence.SIP.html#4739" class="Bound">X</a><a id="4740" class="Symbol">}</a> <a id="4742" class="Symbol">{</a><a id="4743" href="1Lab.Univalence.SIP.html#4743" class="Bound">Y</a><a id="4744" class="Symbol">}</a> <a id="4746" class="Symbol">=</a>
  <a id="4750" href="1Lab.Univalence.SIP.html#4739" class="Bound">X</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="4752" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">≃[</a> <a id="4755" href="1Lab.Univalence.SIP.html#4727" class="Bound">σ</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="4757" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">]</a> <a id="4759" href="1Lab.Univalence.SIP.html#4743" class="Bound">Y</a>                                                       <a data-type="(A : Type ℓ) → A ≃ B → A ≃ B" id="4815" href="1Lab.Equiv.html#22946" class="Function Operator">≃⟨⟩</a>
  <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="4821" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="4824" href="1Lab.Univalence.SIP.html#4824" class="Bound">e</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="4826" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="4828" href="1Lab.Univalence.SIP.html#4739" class="Bound">X</a> <a id="4830" class="Symbol">.</a><a data-type="∑ A B → A" id="4831" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="4835" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="4837" href="1Lab.Univalence.SIP.html#4743" class="Bound">Y</a> <a id="4839" class="Symbol">.</a><a data-type="∑ A B → A" id="4840" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="4844" href="1Lab.Type.html#1563" class="Function">]</a> <a id="4846" class="Symbol">(</a><a id="4847" href="1Lab.Univalence.SIP.html#4727" class="Bound">σ</a> <a id="4849" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="4850" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="4857" href="1Lab.Univalence.SIP.html#4739" class="Bound">X</a> <a id="4859" href="1Lab.Univalence.SIP.html#4743" class="Bound">Y</a> <a id="4861" href="1Lab.Univalence.SIP.html#4824" class="Bound">e</a><a id="4862" class="Symbol">)</a>                       <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="4886" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a data-type="(e : A ≃ A&#39;) → ((x : A) → P x ≃ Q (e .fst x)) → Σ P ≃ Σ Q" id="4889" href="1Lab.Type.Sigma.html#2110" class="Function">Σ-ap</a> <a id="4894" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="4895" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="4898" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv ua" id="4900" href="1Lab.Univalence.html#16820" class="Function">univalence⁻¹</a><a id="4912" class="Symbol">)</a> <a id="4914" href="1Lab.Univalence.SIP.html#4730" class="Bound">is-univ</a> <a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="4922" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="4926" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="4929" href="1Lab.Univalence.SIP.html#4929" class="Bound">p</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="4931" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="4933" href="1Lab.Univalence.SIP.html#4739" class="Bound">X</a> <a id="4935" class="Symbol">.</a><a data-type="∑ A B → A" id="4936" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="A → A → Type ℓ" id="4940" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="4942" href="1Lab.Univalence.SIP.html#4743" class="Bound">Y</a> <a id="4944" class="Symbol">.</a><a data-type="∑ A B → A" id="4945" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="4949" href="1Lab.Type.html#1563" class="Function">]</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="4951" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="4957" class="Symbol">(λ</a> <a id="4960" href="1Lab.Univalence.SIP.html#4960" class="Bound">i</a> <a id="4962" class="Symbol">→</a> <a id="4964" href="1Lab.Univalence.SIP.html#4719" class="Bound">S</a> <a id="4966" class="Symbol">(</a><a id="4967" href="1Lab.Univalence.SIP.html#4929" class="Bound">p</a> <a id="4969" href="1Lab.Univalence.SIP.html#4960" class="Bound">i</a><a id="4970" class="Symbol">))</a> <a id="4973" class="Symbol">(</a><a id="4974" href="1Lab.Univalence.SIP.html#4739" class="Bound">X</a> <a id="4976" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="4977" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="4980" class="Symbol">)</a> <a id="4982" class="Symbol">(</a><a id="4983" href="1Lab.Univalence.SIP.html#4743" class="Bound">Y</a> <a id="4985" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="4986" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="4989" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="4991" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a data-type="Iso A B → A ≃ B" id="4994" href="1Lab.Equiv.html#20090" class="Function">Iso→Equiv</a> <a data-type="Iso (Σ (λ p → PathP (λ i → B i (p i)) (x .snd) (y .snd)))
(PathP (λ i → Σ (B i)) x y)" id="5004" href="1Lab.Type.Sigma.html#553" class="Function">Σ-PathP-iso</a> <a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="5016" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a id="5020" class="Symbol">(</a><a id="5021" href="1Lab.Univalence.SIP.html#4739" class="Bound">X</a> <a data-type="A → A → Type ℓ" id="5023" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="5025" href="1Lab.Univalence.SIP.html#4743" class="Bound">Y</a><a id="5026" class="Symbol">)</a>                                                          <a data-type="(A : Type ℓ) → A ≃ A" id="5085" href="1Lab.Equiv.html#23023" class="Function Operator">≃∎</a>
</pre>
<p>The proof of the <span class="Agda"><a data-type="isUnivalent σ → (X ≃[ σ ] Y) ≃ (X ≡ Y)" href="1Lab.Univalence.SIP.html#4629" class="Function">SIP</a></span> follows essentially from <span class="Agda"><a data-type="isEquiv ua" href="1Lab.Univalence.html#16820" class="Function">univalence</a></span>, and the fact that <span class="Agda"><a data-type="(e : A ≃ A&#39;) → ((x : A) → P x ≃ Q (e .fst x)) → Σ P ≃ Σ Q" href="1Lab.Type.Sigma.html#2110" class="Function">Σ types respect equivalences</a></span>. In one fell swoop, we convert from the type of homomorphic equivalences to a dependent pair of paths. By the characterisation of <span class="Agda"><a data-type="Iso (Σ (λ p → PathP (λ i → B i (p i)) (x .snd) (y .snd)))
(PathP (λ i → Σ (B i)) x y)" href="1Lab.Type.Sigma.html#553" class="Function">path spaces of Σ types</a></span>, this latter pair is equivalent to <code>X ≡ Y</code>.</p>
<pre class="Agda"><a id="sip"></a><a data-type="isUnivalent σ → X ≃[ σ ] Y → X ≡ Y" id="5488" href="1Lab.Univalence.SIP.html#5488" class="Function">sip</a> <a id="5492" class="Symbol">:</a> <a id="5494" class="Symbol">{</a><a id="5495" href="1Lab.Univalence.SIP.html#5495" class="Bound">σ</a> <a id="5497" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="5499" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="5509" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="5511" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="5512" class="Symbol">}</a> <a id="5514" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="5516" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="5528" href="1Lab.Univalence.SIP.html#5495" class="Bound">σ</a> <a id="5530" class="Symbol">→</a> <a id="5532" class="Symbol">{</a><a id="5533" href="1Lab.Univalence.SIP.html#5533" class="Bound">X</a> <a id="5535" href="1Lab.Univalence.SIP.html#5535" class="Bound">Y</a> <a id="5537" class="Symbol">:</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="5539" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="5541" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="5542" class="Symbol">}</a> <a id="5544" class="Symbol">→</a> <a id="5546" class="Symbol">(</a><a id="5547" href="1Lab.Univalence.SIP.html#5533" class="Bound">X</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="5549" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">≃[</a> <a id="5552" href="1Lab.Univalence.SIP.html#5495" class="Bound">σ</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="5554" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">]</a> <a id="5556" href="1Lab.Univalence.SIP.html#5535" class="Bound">Y</a><a id="5557" class="Symbol">)</a> <a id="5559" class="Symbol">→</a> <a id="5561" class="Symbol">(</a><a id="5562" href="1Lab.Univalence.SIP.html#5533" class="Bound">X</a> <a data-type="A → A → Type ℓ" id="5564" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="5566" href="1Lab.Univalence.SIP.html#5535" class="Bound">Y</a><a id="5567" class="Symbol">)</a>
<a data-type="isUnivalent σ → X ≃[ σ ] Y → X ≡ Y" id="5569" href="1Lab.Univalence.SIP.html#5488" class="Function">sip</a> <a id="5573" href="1Lab.Univalence.SIP.html#5573" class="Bound">σ</a> <a id="5575" class="Symbol">=</a> <a data-type="isUnivalent σ → (X ≃[ σ ] Y) ≃ (X ≡ Y)" id="5577" href="1Lab.Univalence.SIP.html#4629" class="Function">SIP</a> <a id="5581" href="1Lab.Univalence.SIP.html#5573" class="Bound">σ</a> <a id="5583" class="Symbol">.</a><a data-type="∑ A B → A" id="5584" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a>
</pre>
<h1 id="structure-combinators"><a href="#structure-combinators" class="header-link">Structure Combinators<span class="header-link-emoji">🔗</span></a></h1>
<p>Univalent structures can be built up in an algebraic manner through the use of <em>structure combinators</em>. These express closure of structures under a number of type formers. For instance, if <code>S</code> and <code>T</code> are univalent structures, then so is <code>λ X → S X → T X</code>.</p>
<p>The simplest case of univalent structure is the <em>constant structure</em>, which is what you get when you equip a type <code>X</code> with a choice of inhabitant of some other type <code>Y</code>, unrelated to <code>X</code>. Since the given function is <code>f : A → B</code>, it can’t act on <code>T</code>, so the notion of homomorphism is independent of <code>f</code>.</p>
<pre class="Agda"><a id="constantStr"></a><a data-type="(A : Type ℓ) → Structure ℓ (λ X → A)" id="6188" href="1Lab.Univalence.SIP.html#6188" class="Function">constantStr</a> <a id="6200" class="Symbol">:</a> <a id="6202" class="Symbol">(</a><a id="6203" href="1Lab.Univalence.SIP.html#6203" class="Bound">A</a> <a id="6205" class="Symbol">:</a> <a id="6207" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="6212" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a><a id="6213" class="Symbol">)</a> <a id="6215" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="6217" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="6227" class="Symbol">{</a><a id="6228" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a><a id="6230" class="Symbol">}</a> <a id="6232" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="6234" class="Symbol">(λ</a> <a id="6237" href="1Lab.Univalence.SIP.html#6237" class="Bound">X</a> <a id="6239" class="Symbol">→</a> <a id="6241" href="1Lab.Univalence.SIP.html#6203" class="Bound">A</a><a id="6242" class="Symbol">)</a>
<a data-type="(A : Type ℓ) → Structure ℓ (λ X → A)" id="6244" href="1Lab.Univalence.SIP.html#6188" class="Function">constantStr</a> <a id="6256" href="1Lab.Univalence.SIP.html#6256" class="Bound">T</a> <a id="6258" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="6259" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="6266" class="Symbol">(</a><a id="6267" href="1Lab.Univalence.SIP.html#6267" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="6269" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="6271" href="1Lab.Univalence.SIP.html#6271" class="Bound">x</a><a id="6272" class="Symbol">)</a> <a id="6274" class="Symbol">(</a><a id="6275" href="1Lab.Univalence.SIP.html#6275" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="6277" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="6279" href="1Lab.Univalence.SIP.html#6279" class="Bound">y</a><a id="6280" class="Symbol">)</a> <a id="6282" href="1Lab.Univalence.SIP.html#6282" class="Bound">f</a> <a id="6284" class="Symbol">=</a> <a id="6286" href="1Lab.Univalence.SIP.html#6271" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="6288" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="6290" href="1Lab.Univalence.SIP.html#6279" class="Bound">y</a>

<a id="constantStr-univalent"></a><a data-type="isUnivalent (constantStr A)" id="6293" href="1Lab.Univalence.SIP.html#6293" class="Function">constantStr-univalent</a> <a id="6315" class="Symbol">:</a> <a id="6317" class="Symbol">{</a><a id="6318" href="1Lab.Univalence.SIP.html#6318" class="Bound">A</a> <a id="6320" class="Symbol">:</a> <a id="6322" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="6327" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a><a id="6328" class="Symbol">}</a> <a id="6330" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="6332" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="6344" class="Symbol">(</a><a data-type="(A : Type ℓ) → Structure ℓ (λ X → A)" id="6345" href="1Lab.Univalence.SIP.html#6188" class="Function">constantStr</a> <a id="6357" class="Symbol">{</a><a id="6358" class="Argument">ℓ₁</a> <a id="6361" class="Symbol">=</a> <a id="6363" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a><a id="6365" class="Symbol">}</a> <a id="6367" href="1Lab.Univalence.SIP.html#6318" class="Bound">A</a><a id="6368" class="Symbol">)</a>
<a data-type="isUnivalent (constantStr A)" id="6370" href="1Lab.Univalence.SIP.html#6293" class="Function">constantStr-univalent</a> <a id="6392" href="1Lab.Univalence.SIP.html#6392" class="Bound">f</a> <a id="6394" class="Symbol">=</a> <a id="6396" class="Symbol">_</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="6398" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="6400" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a>
</pre>
<p>The next simplest case is considering the identity function as a structure. In that case, the resulting structured type is that of a <em>pointed type</em>, whence the name <span class="Agda"><a data-type="Structure ℓ (λ X → X)" href="1Lab.Univalence.SIP.html#7039" class="Function">pointedStr</a></span>.</p>
<p>The name <span class="Agda"><a data-type="Structure ℓ (λ X → X)" href="1Lab.Univalence.SIP.html#7039" class="Function">pointedStr</a></span> breaks down when it is used with some of the other combinators: A type equipped with the <span class="Agda"><a data-type="Structure ℓ S₁ →
Structure ℓ₂ T → Structure (ℓ ⊔ ℓ₂) (λ X → S₁ X × T X)" href="1Lab.Univalence.SIP.html#7539" class="Function">product</a></span> of two <span class="Agda"><a data-type="Structure ℓ (λ X → X)" href="1Lab.Univalence.SIP.html#7039" class="Function">pointed structures</a></span> is indeed a “bipointed structure”, but a type equipped with <span class="Agda"><a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" href="1Lab.Univalence.SIP.html#16922" class="Function">maps between</a></span> two <span class="Agda"><a data-type="Structure ℓ (λ X → X)" href="1Lab.Univalence.SIP.html#7039" class="Function">pointed structures</a></span> is a type equipped with an endomorphism, which does not necessitate a point.</p>
<pre class="Agda"><a id="pointedStr"></a><a data-type="Structure ℓ (λ X → X)" id="7039" href="1Lab.Univalence.SIP.html#7039" class="Function">pointedStr</a> <a id="7050" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="7052" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="7062" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="7064" class="Symbol">(λ</a> <a id="7067" href="1Lab.Univalence.SIP.html#7067" class="Bound">X</a> <a id="7069" class="Symbol">→</a> <a id="7071" href="1Lab.Univalence.SIP.html#7067" class="Bound">X</a><a id="7072" class="Symbol">)</a>
<a data-type="Structure ℓ (λ X → X)" id="7074" href="1Lab.Univalence.SIP.html#7039" class="Function">pointedStr</a> <a id="7085" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="7086" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="7093" class="Symbol">(</a><a id="7094" href="1Lab.Univalence.SIP.html#7094" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="7096" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7098" href="1Lab.Univalence.SIP.html#7098" class="Bound">x</a><a id="7099" class="Symbol">)</a> <a id="7101" class="Symbol">(</a><a id="7102" href="1Lab.Univalence.SIP.html#7102" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="7104" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7106" href="1Lab.Univalence.SIP.html#7106" class="Bound">y</a><a id="7107" class="Symbol">)</a> <a id="7109" href="1Lab.Univalence.SIP.html#7109" class="Bound">f</a> <a id="7111" class="Symbol">=</a> <a id="7113" href="1Lab.Univalence.SIP.html#7109" class="Bound">f</a> <a id="7115" class="Symbol">.</a><a data-type="∑ A B → A" id="7116" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="7120" href="1Lab.Univalence.SIP.html#7098" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="7122" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="7124" href="1Lab.Univalence.SIP.html#7106" class="Bound">y</a>
</pre>
<p>This is univalent by <span class="Agda"><a data-type="(e : A ≃ B) → (e .fst x ≡ y) ≃ PathP (λ i → ua e i) x y" href="1Lab.Univalence.html#14275" class="Function">uaPathP≃Path</a></span>, which says <code>PathP (ua f) x y</code> is equivalent to <code>f .fst x ≡ y</code>.</p>
<pre class="Agda"><a id="pointedStr-univalent"></a><a data-type="isUnivalent pointedStr" id="7247" href="1Lab.Univalence.SIP.html#7247" class="Function">pointedStr-univalent</a> <a id="7268" class="Symbol">:</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="7270" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="7282" class="Symbol">(</a><a data-type="Structure ℓ (λ X → X)" id="7283" href="1Lab.Univalence.SIP.html#7039" class="Function">pointedStr</a> <a id="7294" class="Symbol">{</a><a id="7295" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a><a id="7296" class="Symbol">})</a>
<a data-type="isUnivalent pointedStr" id="7299" href="1Lab.Univalence.SIP.html#7247" class="Function">pointedStr-univalent</a> <a id="7320" href="1Lab.Univalence.SIP.html#7320" class="Bound">f</a> <a id="7322" class="Symbol">=</a> <a data-type="(e : A ≃ B) → (e .fst x ≡ y) ≃ PathP (λ i → ua e i) x y" id="7324" href="1Lab.Univalence.html#14275" class="Function">uaPathP≃Path</a> <a id="7337" class="Symbol">_</a>
</pre>
<p>If <code>S</code> and <code>T</code> are univalent structures, then so is their pointwise product. The notion of a <code>S × T</code>-homomorphism is that of a function homomorphic for both <code>S</code> and <code>T</code>, simultaneously:</p>
<pre class="Agda"><a id="productStr"></a><a data-type="Structure ℓ S₁ →
Structure ℓ₂ T → Structure (ℓ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="7539" href="1Lab.Univalence.SIP.html#7539" class="Function">productStr</a> <a id="7550" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="7552" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="7562" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="7564" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="7566" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="7568" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="7578" href="1Lab.Univalence.SIP.html#3455" class="Generalizable">ℓ₂</a> <a id="7581" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a> <a id="7583" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="7585" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="7595" class="Symbol">_</a> <a id="7597" class="Symbol">(λ</a> <a id="7600" href="1Lab.Univalence.SIP.html#7600" class="Bound">X</a> <a id="7602" class="Symbol">→</a> <a id="7604" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="7606" href="1Lab.Univalence.SIP.html#7600" class="Bound">X</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="7608" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="7610" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a> <a id="7612" href="1Lab.Univalence.SIP.html#7600" class="Bound">X</a><a id="7613" class="Symbol">)</a>
<a data-type="Structure ℓ S₁ →
Structure ℓ₂ T → Structure (ℓ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="7615" href="1Lab.Univalence.SIP.html#7539" class="Function">productStr</a> <a id="7626" href="1Lab.Univalence.SIP.html#7626" class="Bound">S</a> <a id="7628" href="1Lab.Univalence.SIP.html#7628" class="Bound">T</a> <a id="7630" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="7631" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="7638" class="Symbol">(</a><a id="7639" href="1Lab.Univalence.SIP.html#7639" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="7641" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7643" href="1Lab.Univalence.SIP.html#7643" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="7645" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7647" href="1Lab.Univalence.SIP.html#7647" class="Bound">y</a><a id="7648" class="Symbol">)</a> <a id="7650" class="Symbol">(</a><a id="7651" href="1Lab.Univalence.SIP.html#7651" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="7653" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7655" href="1Lab.Univalence.SIP.html#7655" class="Bound">x&#39;</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="7658" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7660" href="1Lab.Univalence.SIP.html#7660" class="Bound">y&#39;</a><a id="7662" class="Symbol">)</a> <a id="7664" href="1Lab.Univalence.SIP.html#7664" class="Bound">f</a> <a id="7666" class="Symbol">=</a>
  <a id="7670" href="1Lab.Univalence.SIP.html#7626" class="Bound">S</a> <a id="7672" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="7673" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="7680" class="Symbol">(</a><a id="7681" href="1Lab.Univalence.SIP.html#7639" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="7683" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7685" href="1Lab.Univalence.SIP.html#7643" class="Bound">x</a><a id="7686" class="Symbol">)</a> <a id="7688" class="Symbol">(</a><a id="7689" href="1Lab.Univalence.SIP.html#7651" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="7691" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7693" href="1Lab.Univalence.SIP.html#7655" class="Bound">x&#39;</a><a id="7695" class="Symbol">)</a> <a id="7697" href="1Lab.Univalence.SIP.html#7664" class="Bound">f</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="7699" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="7701" href="1Lab.Univalence.SIP.html#7628" class="Bound">T</a> <a id="7703" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="7704" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="7711" class="Symbol">(</a><a id="7712" href="1Lab.Univalence.SIP.html#7639" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="7714" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7716" href="1Lab.Univalence.SIP.html#7647" class="Bound">y</a><a id="7717" class="Symbol">)</a> <a id="7719" class="Symbol">(</a><a id="7720" href="1Lab.Univalence.SIP.html#7651" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="7722" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7724" href="1Lab.Univalence.SIP.html#7660" class="Bound">y&#39;</a><a id="7726" class="Symbol">)</a> <a id="7728" href="1Lab.Univalence.SIP.html#7664" class="Bound">f</a>

<a id="productStr-univalent"></a><a data-type="isUnivalent σ → isUnivalent τ → isUnivalent (productStr σ τ)" id="7731" href="1Lab.Univalence.SIP.html#7731" class="Function">productStr-univalent</a> <a id="7752" class="Symbol">:</a> <a id="7754" class="Symbol">{</a><a id="7755" href="1Lab.Univalence.SIP.html#7755" class="Bound">σ</a> <a id="7757" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="7759" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="7769" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a> <a id="7772" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="7773" class="Symbol">}</a> <a id="7775" class="Symbol">{</a><a id="7776" href="1Lab.Univalence.SIP.html#7776" class="Bound">τ</a> <a id="7778" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="7780" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="7790" href="1Lab.Univalence.SIP.html#3455" class="Generalizable">ℓ₂</a> <a id="7793" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a><a id="7794" class="Symbol">}</a>
                     <a id="7817" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="7819" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="7831" href="1Lab.Univalence.SIP.html#7755" class="Bound">σ</a> <a id="7833" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="7835" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="7847" href="1Lab.Univalence.SIP.html#7776" class="Bound">τ</a>
                     <a id="7870" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="7872" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="7884" class="Symbol">(</a><a data-type="Structure ℓ S₁ →
Structure ℓ₂ T → Structure (ℓ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="7885" href="1Lab.Univalence.SIP.html#7539" class="Function">productStr</a> <a id="7896" href="1Lab.Univalence.SIP.html#7755" class="Bound">σ</a> <a id="7898" href="1Lab.Univalence.SIP.html#7776" class="Bound">τ</a><a id="7899" class="Symbol">)</a>
<a data-type="isUnivalent σ → isUnivalent τ → isUnivalent (productStr σ τ)" id="7901" href="1Lab.Univalence.SIP.html#7731" class="Function">productStr-univalent</a> <a id="7922" class="Symbol">{</a><a id="7923" class="Argument">S</a> <a id="7925" class="Symbol">=</a> <a id="7927" href="1Lab.Univalence.SIP.html#7927" class="Bound">S</a><a id="7928" class="Symbol">}</a> <a id="7930" class="Symbol">{</a><a id="7931" class="Argument">T</a> <a id="7933" class="Symbol">=</a> <a id="7935" href="1Lab.Univalence.SIP.html#7935" class="Bound">T</a><a id="7936" class="Symbol">}</a> <a id="7938" class="Symbol">{</a><a id="7939" class="Argument">σ</a> <a id="7941" class="Symbol">=</a> <a id="7943" href="1Lab.Univalence.SIP.html#7943" class="Bound">σ</a><a id="7944" class="Symbol">}</a> <a id="7946" class="Symbol">{</a><a id="7947" href="1Lab.Univalence.SIP.html#7947" class="Bound">τ</a><a id="7948" class="Symbol">}</a> <a id="7950" href="1Lab.Univalence.SIP.html#7950" class="Bound">θ₁</a> <a id="7953" href="1Lab.Univalence.SIP.html#7953" class="Bound">θ₂</a> <a id="7956" class="Symbol">{</a><a id="7957" href="1Lab.Univalence.SIP.html#7957" class="Bound">X</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="7959" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7961" href="1Lab.Univalence.SIP.html#7961" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="7963" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7965" href="1Lab.Univalence.SIP.html#7965" class="Bound">y</a><a id="7966" class="Symbol">}</a> <a id="7968" class="Symbol">{</a><a id="7969" href="1Lab.Univalence.SIP.html#7969" class="Bound">Y</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="7971" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7973" href="1Lab.Univalence.SIP.html#7973" class="Bound">x&#39;</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="7976" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7978" href="1Lab.Univalence.SIP.html#7978" class="Bound">y&#39;</a><a id="7980" class="Symbol">}</a> <a id="7982" href="1Lab.Univalence.SIP.html#7982" class="Bound">f</a> <a id="7984" class="Symbol">=</a>
  <a id="7988" class="Symbol">(</a><a id="7989" href="1Lab.Univalence.SIP.html#7943" class="Bound">σ</a> <a id="7991" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="7992" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="7999" class="Symbol">(</a><a id="8000" href="1Lab.Univalence.SIP.html#7957" class="Bound">X</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="8002" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8004" href="1Lab.Univalence.SIP.html#7961" class="Bound">x</a><a id="8005" class="Symbol">)</a> <a id="8007" class="Symbol">(</a><a id="8008" href="1Lab.Univalence.SIP.html#7969" class="Bound">Y</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="8010" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8012" href="1Lab.Univalence.SIP.html#7973" class="Bound">x&#39;</a><a id="8014" class="Symbol">)</a> <a id="8016" class="Symbol">_</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="8018" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="8020" href="1Lab.Univalence.SIP.html#7947" class="Bound">τ</a> <a id="8022" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="8023" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="8030" class="Symbol">(</a><a id="8031" href="1Lab.Univalence.SIP.html#7957" class="Bound">X</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="8033" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8035" href="1Lab.Univalence.SIP.html#7965" class="Bound">y</a><a id="8036" class="Symbol">)</a> <a id="8038" class="Symbol">(</a><a id="8039" href="1Lab.Univalence.SIP.html#7969" class="Bound">Y</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="8041" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8043" href="1Lab.Univalence.SIP.html#7978" class="Bound">y&#39;</a><a id="8045" class="Symbol">)</a> <a id="8047" class="Symbol">_)</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="8050" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a data-type="(e : A ≃ A&#39;) → ((x : A) → P x ≃ Q (e .fst x)) → Σ P ≃ Σ Q" id="8053" href="1Lab.Type.Sigma.html#2110" class="Function">Σ-ap</a> <a id="8058" class="Symbol">(</a><a id="8059" href="1Lab.Univalence.SIP.html#7950" class="Bound">θ₁</a> <a id="8062" href="1Lab.Univalence.SIP.html#7982" class="Bound">f</a><a id="8063" class="Symbol">)</a> <a id="8065" class="Symbol">(λ</a> <a id="8068" href="1Lab.Univalence.SIP.html#8068" class="Bound">_</a> <a id="8070" class="Symbol">→</a> <a id="8072" href="1Lab.Univalence.SIP.html#7953" class="Bound">θ₂</a> <a id="8075" href="1Lab.Univalence.SIP.html#7982" class="Bound">f</a><a id="8076" class="Symbol">)</a> <a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="8078" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a id="8082" class="Symbol">(</a><a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="8083" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="8089" class="Symbol">_</a> <a id="8091" class="Symbol">_</a> <a id="8093" class="Symbol">_</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="8095" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="8097" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="8103" class="Symbol">_</a> <a id="8105" class="Symbol">_</a> <a id="8107" class="Symbol">_)</a>                                   <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="8144" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a data-type="Iso A B → A ≃ B" id="8147" href="1Lab.Equiv.html#20090" class="Function">Iso→Equiv</a> <a data-type="Iso (Σ (λ p → PathP (λ i → B i (p i)) (x .snd) (y .snd)))
(PathP (λ i → Σ (B i)) x y)" id="8157" href="1Lab.Type.Sigma.html#553" class="Function">Σ-PathP-iso</a> <a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="8169" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="8173" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="8179" class="Symbol">(λ</a> <a id="8182" href="1Lab.Univalence.SIP.html#8182" class="Bound">i</a> <a id="8184" class="Symbol">→</a> <a id="8186" href="1Lab.Univalence.SIP.html#7927" class="Bound">S</a> <a id="8188" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="8189" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="8192" href="1Lab.Univalence.SIP.html#7982" class="Bound">f</a> <a id="8194" href="1Lab.Univalence.SIP.html#8182" class="Bound">i</a><a id="8195" class="Symbol">)</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="8197" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="8199" href="1Lab.Univalence.SIP.html#7935" class="Bound">T</a> <a id="8201" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="8202" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="8205" href="1Lab.Univalence.SIP.html#7982" class="Bound">f</a> <a id="8207" href="1Lab.Univalence.SIP.html#8182" class="Bound">i</a><a id="8208" class="Symbol">))</a> <a id="8211" class="Symbol">(</a><a id="8212" href="1Lab.Univalence.SIP.html#7961" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="8214" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8216" href="1Lab.Univalence.SIP.html#7965" class="Bound">y</a><a id="8217" class="Symbol">)</a> <a id="8219" class="Symbol">(</a><a id="8220" href="1Lab.Univalence.SIP.html#7973" class="Bound">x&#39;</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="8223" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8225" href="1Lab.Univalence.SIP.html#7978" class="Bound">y&#39;</a><a id="8227" class="Symbol">)</a>       <a data-type="(A : Type ℓ) → A ≃ A" id="8235" href="1Lab.Equiv.html#23023" class="Function Operator">≃∎</a>
</pre>
<p>If <code>S</code> and <code>T</code> are univalent structures, then so are the families of functions between them. For reasons we’ll see below, this is called <span class="Agda"><a data-type="Structure ℓ₁ S₁ →
Structure ℓ₂ T → Structure (ℓ₁ ⊔ S.ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" href="1Lab.Univalence.SIP.html#8474" class="Function">Str-functionStr</a></span> (a rather redundant name!) instead of <span class="Agda"><a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" href="1Lab.Univalence.SIP.html#16922" class="Function">functionStr</a></span>.</p>
<pre class="Agda"><a id="Str-functionStr"></a><a data-type="Structure ℓ₁ S₁ →
Structure ℓ₂ T → Structure (ℓ₁ ⊔ S.ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="8474" href="1Lab.Univalence.SIP.html#8474" class="Function">Str-functionStr</a> <a id="8490" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="8492" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="8502" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a> <a id="8505" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="8507" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="8509" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="8519" href="1Lab.Univalence.SIP.html#3455" class="Generalizable">ℓ₂</a> <a id="8522" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a> <a id="8524" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="8526" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="8536" class="Symbol">_</a> <a id="8538" class="Symbol">(λ</a> <a id="8541" href="1Lab.Univalence.SIP.html#8541" class="Bound">X</a> <a id="8543" class="Symbol">→</a> <a id="8545" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="8547" href="1Lab.Univalence.SIP.html#8541" class="Bound">X</a> <a id="8549" class="Symbol">→</a> <a id="8551" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a> <a id="8553" href="1Lab.Univalence.SIP.html#8541" class="Bound">X</a><a id="8554" class="Symbol">)</a>
<a data-type="Structure ℓ₁ S₁ →
Structure ℓ₂ T → Structure (ℓ₁ ⊔ S.ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="8556" href="1Lab.Univalence.SIP.html#8474" class="Function">Str-functionStr</a> <a id="8572" class="Symbol">{</a><a id="8573" class="Argument">S</a> <a id="8575" class="Symbol">=</a> <a id="8577" href="1Lab.Univalence.SIP.html#8577" class="Bound">S</a><a id="8578" class="Symbol">}</a> <a id="8580" href="1Lab.Univalence.SIP.html#8580" class="Bound">σ</a> <a id="8582" href="1Lab.Univalence.SIP.html#8582" class="Bound">τ</a> <a id="8584" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="8585" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="8592" class="Symbol">(</a><a id="8593" href="1Lab.Univalence.SIP.html#8593" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="8595" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8597" href="1Lab.Univalence.SIP.html#8597" class="Bound">f</a><a id="8598" class="Symbol">)</a> <a id="8600" class="Symbol">(</a><a id="8601" href="1Lab.Univalence.SIP.html#8601" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="8603" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8605" href="1Lab.Univalence.SIP.html#8605" class="Bound">g</a><a id="8606" class="Symbol">)</a> <a id="8608" href="1Lab.Univalence.SIP.html#8608" class="Bound">h</a> <a id="8610" class="Symbol">=</a>
  <a id="8614" class="Symbol">{</a><a id="8615" href="1Lab.Univalence.SIP.html#8615" class="Bound">s</a> <a id="8617" class="Symbol">:</a> <a id="8619" href="1Lab.Univalence.SIP.html#8577" class="Bound">S</a> <a id="8621" href="1Lab.Univalence.SIP.html#8593" class="Bound">A</a><a id="8622" class="Symbol">}</a> <a id="8624" class="Symbol">{</a><a id="8625" href="1Lab.Univalence.SIP.html#8625" class="Bound">t</a> <a id="8627" class="Symbol">:</a> <a id="8629" href="1Lab.Univalence.SIP.html#8577" class="Bound">S</a> <a id="8631" href="1Lab.Univalence.SIP.html#8601" class="Bound">B</a><a id="8632" class="Symbol">}</a> <a id="8634" class="Symbol">→</a> <a id="8636" href="1Lab.Univalence.SIP.html#8580" class="Bound">σ</a> <a id="8638" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="8639" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="8646" class="Symbol">(</a><a id="8647" href="1Lab.Univalence.SIP.html#8593" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="8649" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8651" href="1Lab.Univalence.SIP.html#8615" class="Bound">s</a><a id="8652" class="Symbol">)</a> <a id="8654" class="Symbol">(</a><a id="8655" href="1Lab.Univalence.SIP.html#8601" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="8657" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8659" href="1Lab.Univalence.SIP.html#8625" class="Bound">t</a><a id="8660" class="Symbol">)</a> <a id="8662" href="1Lab.Univalence.SIP.html#8608" class="Bound">h</a>
                      <a id="8686" class="Symbol">→</a> <a id="8688" href="1Lab.Univalence.SIP.html#8582" class="Bound">τ</a> <a id="8690" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="8691" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="8698" class="Symbol">(</a><a id="8699" href="1Lab.Univalence.SIP.html#8593" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="8701" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8703" href="1Lab.Univalence.SIP.html#8597" class="Bound">f</a> <a id="8705" href="1Lab.Univalence.SIP.html#8615" class="Bound">s</a><a id="8706" class="Symbol">)</a> <a id="8708" class="Symbol">(</a><a id="8709" href="1Lab.Univalence.SIP.html#8601" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="8711" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8713" href="1Lab.Univalence.SIP.html#8605" class="Bound">g</a> <a id="8715" href="1Lab.Univalence.SIP.html#8625" class="Bound">t</a><a id="8716" class="Symbol">)</a> <a id="8718" href="1Lab.Univalence.SIP.html#8608" class="Bound">h</a>

<a id="Str-functionStr-univalent"></a><a data-type="isUnivalent σ → isUnivalent τ → isUnivalent (Str-functionStr σ τ)" id="8721" href="1Lab.Univalence.SIP.html#8721" class="Function">Str-functionStr-univalent</a> <a id="8747" class="Symbol">:</a> <a id="8749" class="Symbol">{</a><a id="8750" href="1Lab.Univalence.SIP.html#8750" class="Bound">σ</a> <a id="8752" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="8754" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="8764" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a> <a id="8767" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="8768" class="Symbol">}</a> <a id="8770" class="Symbol">{</a><a id="8771" href="1Lab.Univalence.SIP.html#8771" class="Bound">τ</a> <a id="8773" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="8775" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="8785" href="1Lab.Univalence.SIP.html#3455" class="Generalizable">ℓ₂</a> <a id="8788" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a><a id="8789" class="Symbol">}</a>
                          <a id="8817" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="8819" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="8831" href="1Lab.Univalence.SIP.html#8750" class="Bound">σ</a> <a id="8833" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="8835" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="8847" href="1Lab.Univalence.SIP.html#8771" class="Bound">τ</a>
                          <a id="8875" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="8877" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="8889" class="Symbol">(</a><a data-type="Structure ℓ₁ S₁ →
Structure ℓ₂ T → Structure (ℓ₁ ⊔ S.ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="8890" href="1Lab.Univalence.SIP.html#8474" class="Function">Str-functionStr</a> <a id="8906" href="1Lab.Univalence.SIP.html#8750" class="Bound">σ</a> <a id="8908" href="1Lab.Univalence.SIP.html#8771" class="Bound">τ</a><a id="8909" class="Symbol">)</a>
<a data-type="isUnivalent σ → isUnivalent τ → isUnivalent (Str-functionStr σ τ)" id="8911" href="1Lab.Univalence.SIP.html#8721" class="Function">Str-functionStr-univalent</a> <a id="8937" class="Symbol">{</a><a id="8938" class="Argument">S</a> <a id="8940" class="Symbol">=</a> <a id="8942" href="1Lab.Univalence.SIP.html#8942" class="Bound">S</a><a id="8943" class="Symbol">}</a> <a id="8945" class="Symbol">{</a><a id="8946" class="Argument">T</a> <a id="8948" class="Symbol">=</a> <a id="8950" href="1Lab.Univalence.SIP.html#8950" class="Bound">T</a><a id="8951" class="Symbol">}</a> <a id="8953" class="Symbol">{</a><a id="8954" class="Argument">σ</a> <a id="8956" class="Symbol">=</a> <a id="8958" href="1Lab.Univalence.SIP.html#8958" class="Bound">σ</a><a id="8959" class="Symbol">}</a> <a id="8961" class="Symbol">{</a><a id="8962" href="1Lab.Univalence.SIP.html#8962" class="Bound">τ</a><a id="8963" class="Symbol">}</a> <a id="8965" href="1Lab.Univalence.SIP.html#8965" class="Bound">θ₁</a> <a id="8968" href="1Lab.Univalence.SIP.html#8968" class="Bound">θ₂</a> <a id="8971" href="1Lab.Univalence.SIP.html#8971" class="Bound">eqv</a> <a id="8975" class="Symbol">=</a>
  <a data-type="((x : A) → P x ≃ Q x) → ({x : A} → P x) ≃ ({x : A} → Q x)" id="8979" href="1Lab.Type.Pi.html#1118" class="Function">Π-impl-cod≃</a> <a id="8991" class="Symbol">(λ</a> <a id="8994" href="1Lab.Univalence.SIP.html#8994" class="Bound">s</a> <a id="8996" class="Symbol">→</a> <a data-type="((x : A) → P x ≃ Q x) → ({x : A} → P x) ≃ ({x : A} → Q x)" id="8998" href="1Lab.Type.Pi.html#1118" class="Function">Π-impl-cod≃</a> <a id="9010" class="Symbol">λ</a> <a id="9012" href="1Lab.Univalence.SIP.html#9012" class="Bound">t</a> <a id="9014" class="Symbol">→</a> <a data-type="A ≃ B → C ≃ D → (A → C) ≃ (B → D)" id="9016" href="1Lab.Type.Pi.html#1721" class="Function">function≃</a> <a id="9026" class="Symbol">(</a><a id="9027" href="1Lab.Univalence.SIP.html#8965" class="Bound">θ₁</a> <a id="9030" href="1Lab.Univalence.SIP.html#8971" class="Bound">eqv</a><a id="9033" class="Symbol">)</a> <a id="9035" class="Symbol">(</a><a id="9036" href="1Lab.Univalence.SIP.html#8968" class="Bound">θ₂</a> <a id="9039" href="1Lab.Univalence.SIP.html#8971" class="Bound">eqv</a><a id="9042" class="Symbol">))</a> <a data-type="A ≃ B → B ≃ C → A ≃ C" id="9045" href="1Lab.Equiv.html#21156" class="Function Operator">∙e</a> <a data-type="({x₀ : A i0} {x₁ : A i1} (p : PathP A x₀ x₁) →
 PathP (λ i → B i (p i)) (f x₀) (g x₁))
≃ PathP (λ i → (x : A i) → B i x) f g" id="9048" href="1Lab.Type.Pi.html#3070" class="Function">funextDep≃</a>
</pre>
<h2 id="example-infty-magmas"><a href="#example-infty-magmas" class="header-link">Example: <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>-magmas</span><span class="header-link-emoji">🔗</span></a></h2>
<p>We provide an example of applying the SIP, and the structure combinators: <strong><span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>-magmas</span></strong>. Recall that a <a href="https://ncatlab.org/nlab/show/magma">magma</a> is a <a data-type="(ℓ : Level) → Type (lsuc ℓ)" href="1Lab.HLevel.html#3398">Set</a> equipped with a binary operation, with no further conditions imposed. In HoTT, we can relax this even further: An <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>-magma</span> is a <span class="Agda"><a href="1Lab.Type.html#394" class="Primitive">Type</a></span> - that is, an <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>-groupoid</span> - equipped with a binary operation.</p>
<pre class="Agda"><a id="9522" class="Keyword">private</a>
  <a id="binop"></a><a id="9532" href="1Lab.Univalence.SIP.html#9532" class="Function">binop</a> <a id="9538" class="Symbol">:</a> <a id="9540" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="9545" class="Symbol">→</a> <a id="9547" href="1Lab.Type.html#394" class="Primitive">Type</a>
  <a id="9554" href="1Lab.Univalence.SIP.html#9532" class="Function">binop</a> <a id="9560" href="1Lab.Univalence.SIP.html#9560" class="Bound">X</a> <a id="9562" class="Symbol">=</a> <a id="9564" href="1Lab.Univalence.SIP.html#9560" class="Bound">X</a> <a id="9566" class="Symbol">→</a> <a id="9568" href="1Lab.Univalence.SIP.html#9560" class="Bound">X</a> <a id="9570" class="Symbol">→</a> <a id="9572" href="1Lab.Univalence.SIP.html#9560" class="Bound">X</a>
</pre>
<p>We can impose a <span class="Agda"><a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a></span> on <span class="Agda"><a href="1Lab.Univalence.SIP.html#9532" class="Function">binop</a></span> by applying nested <span class="Agda"><a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" href="1Lab.Univalence.SIP.html#16922" class="Function">functionStr</a></span> and <span class="Agda"><a data-type="Structure ℓ (λ X → X)" href="1Lab.Univalence.SIP.html#7039" class="Function">pointedStr</a></span>. Since this structure is built out of structure combinators, it’s automatically univalent:</p>
<pre class="Agda">  <a id="∞-Magma"></a><a id="9798" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a> <a id="9806" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="9808" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a data-type="Level" id="9818" href="Agda.Primitive.html#764" class="Primitive">lzero</a> <a id="9824" href="1Lab.Univalence.SIP.html#9532" class="Function">binop</a>
  <a id="9832" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a> <a id="9840" class="Symbol">=</a> <a data-type="Structure ℓ₁ S₁ →
Structure ℓ₂ T → Structure (ℓ₁ ⊔ S.ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="9842" href="1Lab.Univalence.SIP.html#8474" class="Function">Str-functionStr</a> <a data-type="Structure ℓ (λ X → X)" id="9858" href="1Lab.Univalence.SIP.html#7039" class="Function">pointedStr</a> <a id="9869" class="Symbol">(</a><a data-type="Structure ℓ₁ S₁ →
Structure ℓ₂ T → Structure (ℓ₁ ⊔ S.ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="9870" href="1Lab.Univalence.SIP.html#8474" class="Function">Str-functionStr</a> <a data-type="Structure ℓ (λ X → X)" id="9886" href="1Lab.Univalence.SIP.html#7039" class="Function">pointedStr</a> <a data-type="Structure ℓ (λ X → X)" id="9897" href="1Lab.Univalence.SIP.html#7039" class="Function">pointedStr</a><a id="9907" class="Symbol">)</a>

  <a id="∞-Magma-univ"></a><a id="9912" href="1Lab.Univalence.SIP.html#9912" class="Function">∞-Magma-univ</a> <a id="9925" class="Symbol">:</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="9927" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="9939" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a>
  <a id="9949" href="1Lab.Univalence.SIP.html#9912" class="Function">∞-Magma-univ</a> <a id="9962" class="Symbol">=</a>
    <a data-type="isUnivalent σ → isUnivalent τ → isUnivalent (Str-functionStr σ τ)" id="9968" href="1Lab.Univalence.SIP.html#8721" class="Function">Str-functionStr-univalent</a> <a id="9994" class="Symbol">{</a><a id="9995" class="Argument">τ</a> <a id="9997" class="Symbol">=</a> <a data-type="Structure ℓ₁ S₁ →
Structure ℓ₂ T → Structure (ℓ₁ ⊔ S.ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="9999" href="1Lab.Univalence.SIP.html#8474" class="Function">Str-functionStr</a> <a data-type="Structure ℓ (λ X → X)" id="10015" href="1Lab.Univalence.SIP.html#7039" class="Function">pointedStr</a> <a data-type="Structure ℓ (λ X → X)" id="10026" href="1Lab.Univalence.SIP.html#7039" class="Function">pointedStr</a><a id="10036" class="Symbol">}</a>
      <a data-type="isUnivalent pointedStr" id="10044" href="1Lab.Univalence.SIP.html#7247" class="Function">pointedStr-univalent</a>
      <a id="10071" class="Symbol">(</a><a data-type="isUnivalent σ → isUnivalent τ → isUnivalent (Str-functionStr σ τ)" id="10072" href="1Lab.Univalence.SIP.html#8721" class="Function">Str-functionStr-univalent</a> <a id="10098" class="Symbol">{</a><a id="10099" class="Argument">τ</a> <a id="10101" class="Symbol">=</a> <a data-type="Structure ℓ (λ X → X)" id="10103" href="1Lab.Univalence.SIP.html#7039" class="Function">pointedStr</a><a id="10113" class="Symbol">}</a>
        <a data-type="isUnivalent pointedStr" id="10123" href="1Lab.Univalence.SIP.html#7247" class="Function">pointedStr-univalent</a>
        <a data-type="isUnivalent pointedStr" id="10152" href="1Lab.Univalence.SIP.html#7247" class="Function">pointedStr-univalent</a><a id="10172" class="Symbol">)</a>
</pre>
<p>The type of <span class="Agda"><a href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a></span> homomorphisms generated by this equivalence is slightly inconvenient: Instead of getting <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo>⋆</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mi>x</mi><mo>∗</mo><mi>f</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">f (x \star y) = f x * f y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋆</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>,</span> we get something that is parameterised over two paths:</p>
<pre class="Agda">  <a id="10392" href="1Lab.Univalence.SIP.html#10392" class="Function">_</a> <a id="10394" class="Symbol">:</a> <a id="10396" class="Symbol">{</a><a id="10397" href="1Lab.Univalence.SIP.html#10397" class="Bound">A</a> <a id="10399" href="1Lab.Univalence.SIP.html#10399" class="Bound">B</a> <a id="10401" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="10403" href="1Lab.Univalence.SIP.html#3316" class="Function">TypeWith</a> <a id="10412" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a><a id="10419" class="Symbol">}</a> <a id="10421" class="Symbol">{</a><a id="10422" href="1Lab.Univalence.SIP.html#10422" class="Bound">f</a> <a id="10424" class="Symbol">:</a> <a id="10426" href="1Lab.Univalence.SIP.html#10397" class="Bound">A</a> <a id="10428" class="Symbol">.</a><a data-type="∑ A B → A" id="10429" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="10433" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="10435" href="1Lab.Univalence.SIP.html#10399" class="Bound">B</a> <a id="10437" class="Symbol">.</a><a data-type="∑ A B → A" id="10438" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="10441" class="Symbol">}</a>
    <a id="10447" class="Symbol">→</a> <a id="10449" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a> <a id="10457" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="10458" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="10465" href="1Lab.Univalence.SIP.html#10397" class="Bound">A</a> <a id="10467" href="1Lab.Univalence.SIP.html#10399" class="Bound">B</a> <a id="10469" href="1Lab.Univalence.SIP.html#10422" class="Bound">f</a>
    <a data-type="A → A → Type ℓ" id="10475" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10477" class="Symbol">(</a> <a id="10479" class="Symbol">{</a><a id="10480" href="1Lab.Univalence.SIP.html#10480" class="Bound">s</a> <a id="10482" class="Symbol">:</a> <a id="10484" href="1Lab.Univalence.SIP.html#10397" class="Bound">A</a> <a id="10486" class="Symbol">.</a><a data-type="∑ A B → A" id="10487" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="10490" class="Symbol">}</a> <a id="10492" class="Symbol">{</a><a id="10493" href="1Lab.Univalence.SIP.html#10493" class="Bound">t</a> <a id="10495" class="Symbol">:</a> <a id="10497" href="1Lab.Univalence.SIP.html#10399" class="Bound">B</a> <a id="10499" class="Symbol">.</a><a data-type="∑ A B → A" id="10500" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="10503" class="Symbol">}</a> <a id="10505" class="Symbol">→</a> <a id="10507" href="1Lab.Univalence.SIP.html#10422" class="Bound">f</a> <a id="10509" class="Symbol">.</a><a data-type="∑ A B → A" id="10510" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10514" href="1Lab.Univalence.SIP.html#10480" class="Bound">s</a> <a data-type="A → A → Type ℓ" id="10516" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10518" href="1Lab.Univalence.SIP.html#10493" class="Bound">t</a>
      <a id="10526" class="Symbol">→</a> <a id="10528" class="Symbol">{</a><a id="10529" href="1Lab.Univalence.SIP.html#10529" class="Bound">x</a> <a id="10531" class="Symbol">:</a> <a id="10533" href="1Lab.Univalence.SIP.html#10397" class="Bound">A</a> <a id="10535" class="Symbol">.</a><a data-type="∑ A B → A" id="10536" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="10539" class="Symbol">}</a> <a id="10541" class="Symbol">{</a><a id="10542" href="1Lab.Univalence.SIP.html#10542" class="Bound">y</a> <a id="10544" class="Symbol">:</a> <a id="10546" href="1Lab.Univalence.SIP.html#10399" class="Bound">B</a> <a id="10548" class="Symbol">.</a><a data-type="∑ A B → A" id="10549" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="10552" class="Symbol">}</a> <a id="10554" class="Symbol">→</a> <a id="10556" href="1Lab.Univalence.SIP.html#10422" class="Bound">f</a> <a id="10558" class="Symbol">.</a><a data-type="∑ A B → A" id="10559" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10563" href="1Lab.Univalence.SIP.html#10529" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="10565" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10567" href="1Lab.Univalence.SIP.html#10542" class="Bound">y</a>
      <a id="10575" class="Symbol">→</a> <a id="10577" href="1Lab.Univalence.SIP.html#10422" class="Bound">f</a> <a id="10579" class="Symbol">.</a><a data-type="∑ A B → A" id="10580" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10584" class="Symbol">(</a><a id="10585" href="1Lab.Univalence.SIP.html#10397" class="Bound">A</a> <a id="10587" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="10588" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10592" href="1Lab.Univalence.SIP.html#10480" class="Bound">s</a> <a id="10594" href="1Lab.Univalence.SIP.html#10529" class="Bound">x</a><a id="10595" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="10597" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10599" href="1Lab.Univalence.SIP.html#10399" class="Bound">B</a> <a id="10601" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="10602" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10606" href="1Lab.Univalence.SIP.html#10493" class="Bound">t</a> <a id="10608" href="1Lab.Univalence.SIP.html#10542" class="Bound">y</a><a id="10609" class="Symbol">)</a>
  <a id="10613" class="Symbol">_</a> <a id="10615" class="Symbol">=</a> <a data-type="x ≡ x" id="10617" href="1Lab.Path.html#2137" class="Function">refl</a>
</pre>
<p>This condition, although it looks a lot more complicated, is essentially the same as the standard notion:</p>
<pre class="Agda">  <a id="fixup"></a><a id="10744" href="1Lab.Univalence.SIP.html#10744" class="Function">fixup</a> <a id="10750" class="Symbol">:</a> <a id="10752" class="Symbol">{</a><a id="10753" href="1Lab.Univalence.SIP.html#10753" class="Bound">A</a> <a id="10755" href="1Lab.Univalence.SIP.html#10755" class="Bound">B</a> <a id="10757" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="10759" href="1Lab.Univalence.SIP.html#3316" class="Function">TypeWith</a> <a id="10768" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a><a id="10775" class="Symbol">}</a> <a id="10777" class="Symbol">{</a><a id="10778" href="1Lab.Univalence.SIP.html#10778" class="Bound">f</a> <a id="10780" class="Symbol">:</a> <a id="10782" href="1Lab.Univalence.SIP.html#10753" class="Bound">A</a> <a id="10784" class="Symbol">.</a><a data-type="∑ A B → A" id="10785" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="10789" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="10791" href="1Lab.Univalence.SIP.html#10755" class="Bound">B</a> <a id="10793" class="Symbol">.</a><a data-type="∑ A B → A" id="10794" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="10797" class="Symbol">}</a>
        <a id="10807" class="Symbol">→</a> <a id="10809" class="Symbol">((</a><a id="10811" href="1Lab.Univalence.SIP.html#10811" class="Bound">x</a> <a id="10813" href="1Lab.Univalence.SIP.html#10813" class="Bound">y</a> <a id="10815" class="Symbol">:</a> <a id="10817" href="1Lab.Univalence.SIP.html#10753" class="Bound">A</a> <a id="10819" class="Symbol">.</a><a data-type="∑ A B → A" id="10820" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="10823" class="Symbol">)</a> <a id="10825" class="Symbol">→</a> <a id="10827" href="1Lab.Univalence.SIP.html#10778" class="Bound">f</a> <a id="10829" class="Symbol">.</a><a data-type="∑ A B → A" id="10830" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10834" class="Symbol">(</a><a id="10835" href="1Lab.Univalence.SIP.html#10753" class="Bound">A</a> <a id="10837" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="10838" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10842" href="1Lab.Univalence.SIP.html#10811" class="Bound">x</a> <a id="10844" href="1Lab.Univalence.SIP.html#10813" class="Bound">y</a><a id="10845" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="10847" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10849" href="1Lab.Univalence.SIP.html#10755" class="Bound">B</a> <a id="10851" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="10852" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10856" class="Symbol">(</a><a id="10857" href="1Lab.Univalence.SIP.html#10778" class="Bound">f</a> <a id="10859" class="Symbol">.</a><a data-type="∑ A B → A" id="10860" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10864" href="1Lab.Univalence.SIP.html#10811" class="Bound">x</a><a id="10865" class="Symbol">)</a> <a id="10867" class="Symbol">(</a><a id="10868" href="1Lab.Univalence.SIP.html#10778" class="Bound">f</a> <a id="10870" class="Symbol">.</a><a data-type="∑ A B → A" id="10871" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10875" href="1Lab.Univalence.SIP.html#10813" class="Bound">y</a><a id="10876" class="Symbol">))</a>
        <a id="10887" class="Symbol">→</a> <a id="10889" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a> <a id="10897" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="10898" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="10905" href="1Lab.Univalence.SIP.html#10753" class="Bound">A</a> <a id="10907" href="1Lab.Univalence.SIP.html#10755" class="Bound">B</a> <a id="10909" href="1Lab.Univalence.SIP.html#10778" class="Bound">f</a>
  <a id="10913" href="1Lab.Univalence.SIP.html#10744" class="Function">fixup</a> <a id="10919" class="Symbol">{</a><a id="10920" class="Argument">A</a> <a id="10922" class="Symbol">=</a> <a id="10924" href="1Lab.Univalence.SIP.html#10924" class="Bound">A</a><a id="10925" class="Symbol">}</a> <a id="10927" class="Symbol">{</a><a id="10928" href="1Lab.Univalence.SIP.html#10928" class="Bound">B</a><a id="10929" class="Symbol">}</a> <a id="10931" class="Symbol">{</a><a id="10932" href="1Lab.Univalence.SIP.html#10932" class="Bound">f</a><a id="10933" class="Symbol">}</a> <a id="10935" href="1Lab.Univalence.SIP.html#10935" class="Bound">path</a> <a id="10940" class="Symbol">{</a><a id="10941" href="1Lab.Univalence.SIP.html#10941" class="Bound">s</a><a id="10942" class="Symbol">}</a> <a id="10944" class="Symbol">{</a><a id="10945" href="1Lab.Univalence.SIP.html#10945" class="Bound">t</a><a id="10946" class="Symbol">}</a> <a id="10948" href="1Lab.Univalence.SIP.html#10948" class="Bound">p</a> <a id="10950" class="Symbol">{</a><a id="10951" href="1Lab.Univalence.SIP.html#10951" class="Bound">s₁</a><a id="10953" class="Symbol">}</a> <a id="10955" class="Symbol">{</a><a id="10956" href="1Lab.Univalence.SIP.html#10956" class="Bound">t₁</a><a id="10958" class="Symbol">}</a> <a id="10960" href="1Lab.Univalence.SIP.html#10960" class="Bound">q</a> <a id="10962" class="Symbol">=</a>
    <a id="10968" href="1Lab.Univalence.SIP.html#10932" class="Bound">f</a> <a id="10970" class="Symbol">.</a><a data-type="∑ A B → A" id="10971" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="10975" class="Symbol">(</a><a id="10976" href="1Lab.Univalence.SIP.html#10924" class="Bound">A</a> <a id="10978" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="10979" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10983" href="1Lab.Univalence.SIP.html#10941" class="Bound">s</a> <a id="10985" href="1Lab.Univalence.SIP.html#10951" class="Bound">s₁</a><a id="10987" class="Symbol">)</a>     <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="10993" href="1Lab.Path.html#45199" class="Function Operator">≡⟨</a> <a id="10996" href="1Lab.Univalence.SIP.html#10935" class="Bound">path</a> <a id="11001" class="Symbol">_</a> <a id="11003" class="Symbol">_</a> <a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="11005" href="1Lab.Path.html#45199" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡</span></span>
    <a id="11011" href="1Lab.Univalence.SIP.html#10928" class="Bound">B</a> <a id="11013" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11014" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11018" class="Symbol">(</a><a id="11019" href="1Lab.Univalence.SIP.html#10932" class="Bound">f</a> <a id="11021" class="Symbol">.</a><a data-type="∑ A B → A" id="11022" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="11026" href="1Lab.Univalence.SIP.html#10941" class="Bound">s</a><a id="11027" class="Symbol">)</a> <a id="11029" class="Symbol">(</a><a id="11030" href="1Lab.Univalence.SIP.html#10932" class="Bound">f</a> <a id="11032" class="Symbol">.</a><a data-type="∑ A B → A" id="11033" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="11037" href="1Lab.Univalence.SIP.html#10951" class="Bound">s₁</a><a id="11039" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="11041" href="1Lab.Path.html#45199" class="Function Operator">≡⟨</a> <a data-type="(f : (x : A) (y : B x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" id="11044" href="1Lab.Path.html#19695" class="Function">ap₂</a> <a id="11048" class="Symbol">(</a><a id="11049" href="1Lab.Univalence.SIP.html#10928" class="Bound">B</a> <a id="11051" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11052" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="11055" class="Symbol">)</a> <a id="11057" href="1Lab.Univalence.SIP.html#10948" class="Bound">p</a> <a id="11059" href="1Lab.Univalence.SIP.html#10960" class="Bound">q</a> <a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="11061" href="1Lab.Path.html#45199" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡</span></span>
    <a id="11067" href="1Lab.Univalence.SIP.html#10928" class="Bound">B</a> <a id="11069" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11070" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11074" href="1Lab.Univalence.SIP.html#10945" class="Bound">t</a>     <a id="11080" href="1Lab.Univalence.SIP.html#10956" class="Bound">t₁</a>     <a data-type="(x : A) → x ≡ x" id="11087" href="1Lab.Path.html#45365" class="Function Operator">∎</a>
</pre>
<p>As an example, we equip the type of booleans with two ∞-magma structures, one given by conjunction, one by disjunction, and prove that <span class="Agda"><a data-type="Bool → Bool" href="Data.Bool.html#1190" class="Function">not</a></span> makes them equal as ∞-magmas:</p>
<div class="mathpar">
<pre class="Agda">  <a id="11303" class="Keyword">open</a> <a id="11308" class="Keyword">import</a> <a id="11315" href="Data.Bool.html" class="Module">Data.Bool</a>
</pre>
</pre>
</div>
<div class="mathpar">
<pre class="Agda">  <a id="Conj"></a><a id="11373" href="1Lab.Univalence.SIP.html#11373" class="Function">Conj</a> <a id="11378" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="11380" href="1Lab.Univalence.SIP.html#3316" class="Function">TypeWith</a> <a id="11389" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a>
  <a id="11399" href="1Lab.Univalence.SIP.html#11373" class="Function">Conj</a> <a id="11404" class="Symbol">.</a><a data-type="∑ A B → A" id="11405" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="11409" class="Symbol">=</a> <a data-type="Type" id="11411" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="11418" href="1Lab.Univalence.SIP.html#11373" class="Function">Conj</a> <a id="11423" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11424" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="11428" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="11434" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="11440" class="Symbol">=</a> <a data-type="Bool" id="11442" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="11450" href="1Lab.Univalence.SIP.html#11373" class="Function">Conj</a> <a id="11455" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11456" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="11460" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="11466" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="11472" class="Symbol">=</a> <a data-type="Bool" id="11474" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="11482" href="1Lab.Univalence.SIP.html#11373" class="Function">Conj</a> <a id="11487" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11488" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="11492" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a data-type="Bool" id="11498" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="11504" class="Symbol">=</a> <a data-type="Bool" id="11506" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="11514" href="1Lab.Univalence.SIP.html#11373" class="Function">Conj</a> <a id="11519" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11520" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="11524" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a data-type="Bool" id="11530" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="11536" class="Symbol">=</a> <a data-type="Bool" id="11538" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
</pre>
<pre class="Agda">  <a id="Disj"></a><a id="11558" href="1Lab.Univalence.SIP.html#11558" class="Function">Disj</a> <a id="11563" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="11565" href="1Lab.Univalence.SIP.html#3316" class="Function">TypeWith</a> <a id="11574" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a>
  <a id="11584" href="1Lab.Univalence.SIP.html#11558" class="Function">Disj</a> <a id="11589" class="Symbol">.</a><a data-type="∑ A B → A" id="11590" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="11594" class="Symbol">=</a> <a data-type="Type" id="11596" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="11603" href="1Lab.Univalence.SIP.html#11558" class="Function">Disj</a> <a id="11608" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11609" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="11613" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="11619" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="11625" class="Symbol">=</a> <a data-type="Bool" id="11627" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="11635" href="1Lab.Univalence.SIP.html#11558" class="Function">Disj</a> <a id="11640" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11641" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="11645" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="11651" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="11657" class="Symbol">=</a> <a data-type="Bool" id="11659" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
  <a id="11666" href="1Lab.Univalence.SIP.html#11558" class="Function">Disj</a> <a id="11671" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11672" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="11676" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a data-type="Bool" id="11682" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="11688" class="Symbol">=</a> <a data-type="Bool" id="11690" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
  <a id="11697" href="1Lab.Univalence.SIP.html#11558" class="Function">Disj</a> <a id="11702" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11703" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="11707" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a data-type="Bool" id="11713" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="11719" class="Symbol">=</a> <a data-type="Bool" id="11721" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
</pre>
</div>
<p>I claim that <span class="Agda"><a data-type="Bool → Bool" href="Data.Bool.html#1190" class="Function">not</a></span> is a <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>-magma</span> isomorphism between <span class="Agda"><a href="1Lab.Univalence.SIP.html#11373" class="Function">Conj</a></span> and <span class="Agda"><a href="1Lab.Univalence.SIP.html#11558" class="Function">Disj</a></span>:</p>
<pre class="Agda">  <a id="not-iso"></a><a id="11848" href="1Lab.Univalence.SIP.html#11848" class="Function">not-iso</a> <a id="11856" class="Symbol">:</a> <a id="11858" href="1Lab.Univalence.SIP.html#11373" class="Function">Conj</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="11863" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">≃[</a> <a id="11866" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="11874" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">]</a> <a id="11876" href="1Lab.Univalence.SIP.html#11558" class="Function">Disj</a>
  <a id="11883" href="1Lab.Univalence.SIP.html#11848" class="Function">not-iso</a> <a id="11891" class="Symbol">.</a><a data-type="∑ A B → A" id="11892" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="11896" class="Symbol">=</a> <a data-type="Bool → Bool" id="11898" href="Data.Bool.html#1190" class="Function">not</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="11902" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv not" id="11904" href="Data.Bool.html#7030" class="Function">isEquiv-not</a>
  <a id="11918" href="1Lab.Univalence.SIP.html#11848" class="Function">not-iso</a> <a id="11926" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11927" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11931" class="Symbol">=</a> <a id="11933" href="1Lab.Univalence.SIP.html#10744" class="Function">fixup</a> <a id="11939" class="Symbol">{</a><a id="11940" class="Argument">A</a> <a id="11942" class="Symbol">=</a> <a id="11944" href="1Lab.Univalence.SIP.html#11373" class="Function">Conj</a><a id="11948" class="Symbol">}</a> <a id="11950" class="Symbol">{</a><a id="11951" class="Argument">B</a> <a id="11953" class="Symbol">=</a> <a id="11955" href="1Lab.Univalence.SIP.html#11558" class="Function">Disj</a><a id="11959" class="Symbol">}</a> <a id="11961" class="Symbol">{</a><a id="11962" class="Argument">f</a> <a id="11964" class="Symbol">=</a> <a id="11966" class="Symbol">_</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="11968" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv not" id="11970" href="Data.Bool.html#7030" class="Function">isEquiv-not</a><a id="11981" class="Symbol">}</a> <a id="11983" class="Symbol">λ</a> <a id="11985" class="Keyword">where</a>
    <a data-type="Bool" id="11995" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="12001" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="12007" class="Symbol">→</a> <a data-type="x ≡ x" id="12009" href="1Lab.Path.html#2137" class="Function">refl</a>
    <a data-type="Bool" id="12018" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="12024" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="12029" class="Symbol">→</a> <a data-type="x ≡ x" id="12031" href="1Lab.Path.html#2137" class="Function">refl</a>
    <a data-type="Bool" id="12040" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="Bool" id="12045" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="12051" class="Symbol">→</a> <a data-type="x ≡ x" id="12053" href="1Lab.Path.html#2137" class="Function">refl</a>
    <a data-type="Bool" id="12062" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="Bool" id="12067" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="12072" class="Symbol">→</a> <a data-type="x ≡ x" id="12074" href="1Lab.Path.html#2137" class="Function">refl</a>
</pre>
<p>It’s not clear that this should be the case, especially since the case analysis obfuscates the result further. However, writing <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∧</mo></mrow><annotation encoding="application/x-tex">\land</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∧</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∨</mo></mrow><annotation encoding="application/x-tex">\lor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">∨</span></span></span></span> for the actions of <span class="Agda"><a href="1Lab.Univalence.SIP.html#11373" class="Function">Conj</a></span> and <span class="Agda"><a href="1Lab.Univalence.SIP.html#11558" class="Function">Disj</a></span> (as one should!), then we see that <span class="Agda"><a href="1Lab.Univalence.SIP.html#11848" class="Function">not-iso</a></span> says exactly that</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">¬</mi><mo stretchy="false">(</mo><mi>x</mi><mo>∧</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">¬</mi><mi>x</mi><mo>∨</mo><mi mathvariant="normal">¬</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">\neg (x \land y) = \neg x \lor \neg y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5556em;"></span><span class="mord">¬</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord">¬</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></span></p>
<p>From this and the SIP we get that <span class="Agda"><a href="1Lab.Univalence.SIP.html#11373" class="Function">Conj</a></span> and <span class="Agda"><a href="1Lab.Univalence.SIP.html#11558" class="Function">Disj</a></span> are the same <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>-magma:</span></p>
<pre class="Agda">  <a id="Conj≡Disj"></a><a id="12504" href="1Lab.Univalence.SIP.html#12504" class="Function">Conj≡Disj</a> <a id="12514" class="Symbol">:</a> <a id="12516" href="1Lab.Univalence.SIP.html#11373" class="Function">Conj</a> <a data-type="A → A → Type ℓ" id="12521" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="12523" href="1Lab.Univalence.SIP.html#11558" class="Function">Disj</a>
  <a id="12530" href="1Lab.Univalence.SIP.html#12504" class="Function">Conj≡Disj</a> <a id="12540" class="Symbol">=</a> <a data-type="isUnivalent σ → X ≃[ σ ] Y → X ≡ Y" id="12542" href="1Lab.Univalence.SIP.html#5488" class="Function">sip</a> <a id="12546" href="1Lab.Univalence.SIP.html#9912" class="Function">∞-Magma-univ</a> <a id="12559" href="1Lab.Univalence.SIP.html#11848" class="Function">not-iso</a>
</pre>
<p>We have a similar phenomenon that happens with NAND and NOR:</p>
<div class="mathpar">
<pre class="Agda">  <a id="Nand"></a><a id="12664" href="1Lab.Univalence.SIP.html#12664" class="Function">Nand</a> <a id="12669" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="12671" href="1Lab.Univalence.SIP.html#3316" class="Function">TypeWith</a> <a id="12680" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a>
  <a id="12690" href="1Lab.Univalence.SIP.html#12664" class="Function">Nand</a> <a id="12695" class="Symbol">.</a><a data-type="∑ A B → A" id="12696" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="12700" class="Symbol">=</a> <a data-type="Type" id="12702" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="12709" href="1Lab.Univalence.SIP.html#12664" class="Function">Nand</a> <a id="12714" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="12715" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="12719" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="12725" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="12731" class="Symbol">=</a> <a data-type="Bool" id="12733" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
  <a id="12740" href="1Lab.Univalence.SIP.html#12664" class="Function">Nand</a> <a id="12745" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="12746" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="12750" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="12756" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="12762" class="Symbol">=</a> <a data-type="Bool" id="12764" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
  <a id="12771" href="1Lab.Univalence.SIP.html#12664" class="Function">Nand</a> <a id="12776" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="12777" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="12781" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a data-type="Bool" id="12787" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="12793" class="Symbol">=</a> <a data-type="Bool" id="12795" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
  <a id="12802" href="1Lab.Univalence.SIP.html#12664" class="Function">Nand</a> <a id="12807" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="12808" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="12812" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a data-type="Bool" id="12818" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="12824" class="Symbol">=</a> <a data-type="Bool" id="12826" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
</pre>
<pre class="Agda">  <a id="Nor"></a><a id="12847" href="1Lab.Univalence.SIP.html#12847" class="Function">Nor</a> <a id="12851" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="12853" href="1Lab.Univalence.SIP.html#3316" class="Function">TypeWith</a> <a id="12862" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a>
  <a id="12872" href="1Lab.Univalence.SIP.html#12847" class="Function">Nor</a> <a id="12876" class="Symbol">.</a><a data-type="∑ A B → A" id="12877" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="12881" class="Symbol">=</a> <a data-type="Type" id="12883" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
  <a id="12890" href="1Lab.Univalence.SIP.html#12847" class="Function">Nor</a> <a id="12894" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="12895" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="12899" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="12905" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="12911" class="Symbol">=</a> <a data-type="Bool" id="12913" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
  <a id="12920" href="1Lab.Univalence.SIP.html#12847" class="Function">Nor</a> <a id="12924" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="12925" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="12929" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="12935" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="12941" class="Symbol">=</a> <a data-type="Bool" id="12943" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="12951" href="1Lab.Univalence.SIP.html#12847" class="Function">Nor</a> <a id="12955" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="12956" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="12960" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a data-type="Bool" id="12966" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="12972" class="Symbol">=</a> <a data-type="Bool" id="12974" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="12982" href="1Lab.Univalence.SIP.html#12847" class="Function">Nor</a> <a id="12986" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="12987" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Bool" id="12991" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a data-type="Bool" id="12997" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="13003" class="Symbol">=</a> <a data-type="Bool" id="13005" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
</pre>
</div>
<pre class="Agda">  <a id="not-iso&#39;"></a><a id="13033" href="1Lab.Univalence.SIP.html#13033" class="Function">not-iso&#39;</a> <a id="13042" class="Symbol">:</a> <a id="13044" href="1Lab.Univalence.SIP.html#12664" class="Function">Nand</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="13049" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">≃[</a> <a id="13052" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="13060" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">]</a> <a id="13062" href="1Lab.Univalence.SIP.html#12847" class="Function">Nor</a>
  <a id="13068" href="1Lab.Univalence.SIP.html#13033" class="Function">not-iso&#39;</a> <a id="13077" class="Symbol">.</a><a data-type="∑ A B → A" id="13078" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="13082" class="Symbol">=</a> <a data-type="Bool → Bool" id="13084" href="Data.Bool.html#1190" class="Function">not</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="13088" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv not" id="13090" href="Data.Bool.html#7030" class="Function">isEquiv-not</a>
  <a id="13104" href="1Lab.Univalence.SIP.html#13033" class="Function">not-iso&#39;</a> <a id="13113" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="13114" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="13118" class="Symbol">=</a> <a id="13120" href="1Lab.Univalence.SIP.html#10744" class="Function">fixup</a> <a id="13126" class="Symbol">{</a><a id="13127" class="Argument">A</a> <a id="13129" class="Symbol">=</a> <a id="13131" href="1Lab.Univalence.SIP.html#12664" class="Function">Nand</a><a id="13135" class="Symbol">}</a> <a id="13137" class="Symbol">{</a><a id="13138" class="Argument">B</a> <a id="13140" class="Symbol">=</a> <a id="13142" href="1Lab.Univalence.SIP.html#12847" class="Function">Nor</a><a id="13145" class="Symbol">}</a> <a id="13147" class="Symbol">{</a><a id="13148" class="Argument">f</a> <a id="13150" class="Symbol">=</a> <a id="13152" class="Symbol">_</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="13154" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv not" id="13156" href="Data.Bool.html#7030" class="Function">isEquiv-not</a><a id="13167" class="Symbol">}</a> <a id="13169" class="Symbol">λ</a> <a id="13171" class="Keyword">where</a>
    <a data-type="Bool" id="13181" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="13187" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="13193" class="Symbol">→</a> <a data-type="x ≡ x" id="13195" href="1Lab.Path.html#2137" class="Function">refl</a>
    <a data-type="Bool" id="13204" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="13210" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="13215" class="Symbol">→</a> <a data-type="x ≡ x" id="13217" href="1Lab.Path.html#2137" class="Function">refl</a>
    <a data-type="Bool" id="13226" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="Bool" id="13231" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="13237" class="Symbol">→</a> <a data-type="x ≡ x" id="13239" href="1Lab.Path.html#2137" class="Function">refl</a>
    <a data-type="Bool" id="13248" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="Bool" id="13253" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="13258" class="Symbol">→</a> <a data-type="x ≡ x" id="13260" href="1Lab.Path.html#2137" class="Function">refl</a>
</pre>
<h1 id="transport-structures"><a href="#transport-structures" class="header-link">Transport Structures<span class="header-link-emoji">🔗</span></a></h1>
<p>As an alternative to equipping a type family <code>S : Type → Type</code> with a notion of S-homomorphism, we can equip it with a notion of <em>action</em>. Equipping a structure with a notion of action canonically equips it with a notion of homomorphism:</p>
<pre class="Agda"><a id="EqvAction"></a><a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="13541" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="13551" class="Symbol">:</a> <a id="13553" class="Symbol">(</a><a id="13554" href="1Lab.Univalence.SIP.html#13554" class="Bound">S</a> <a id="13556" class="Symbol">:</a> <a id="13558" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13563" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="13565" class="Symbol">→</a> <a id="13567" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13572" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a><a id="13574" class="Symbol">)</a> <a id="13576" class="Symbol">→</a> <a id="13578" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13583" class="Symbol">_</a>
<a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="13585" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="13595" class="Symbol">{</a><a id="13596" class="Argument">ℓ</a> <a id="13598" class="Symbol">=</a> <a id="13600" href="1Lab.Univalence.SIP.html#13600" class="Bound">ℓ</a><a id="13601" class="Symbol">}</a> <a id="13603" href="1Lab.Univalence.SIP.html#13603" class="Bound">S</a> <a id="13605" class="Symbol">=</a> <a id="13607" class="Symbol">{</a><a id="13608" href="1Lab.Univalence.SIP.html#13608" class="Bound">X</a> <a id="13610" href="1Lab.Univalence.SIP.html#13610" class="Bound">Y</a> <a id="13612" class="Symbol">:</a> <a id="13614" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13619" href="1Lab.Univalence.SIP.html#13600" class="Bound">ℓ</a><a id="13620" class="Symbol">}</a> <a id="13622" class="Symbol">→</a> <a id="13624" class="Symbol">(</a><a id="13625" href="1Lab.Univalence.SIP.html#13608" class="Bound">X</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="13627" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="13629" href="1Lab.Univalence.SIP.html#13610" class="Bound">Y</a><a id="13630" class="Symbol">)</a> <a id="13632" class="Symbol">→</a> <a id="13634" class="Symbol">(</a><a id="13635" href="1Lab.Univalence.SIP.html#13603" class="Bound">S</a> <a id="13637" href="1Lab.Univalence.SIP.html#13608" class="Bound">X</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="13639" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="13641" href="1Lab.Univalence.SIP.html#13603" class="Bound">S</a> <a id="13643" href="1Lab.Univalence.SIP.html#13610" class="Bound">Y</a><a id="13644" class="Symbol">)</a>

<a id="Action→Structure"></a><a data-type="EqvAction S₁ → Structure ℓ₁ S₁" id="13647" href="1Lab.Univalence.SIP.html#13647" class="Function">Action→Structure</a> <a id="13664" class="Symbol">:</a> <a id="13666" class="Symbol">{</a><a id="13667" href="1Lab.Univalence.SIP.html#13667" class="Bound">S</a> <a id="13669" class="Symbol">:</a> <a id="13671" href="1Lab.Type.html#394" class="Primitive">Type</a>  <a id="13677" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="13679" class="Symbol">→</a> <a id="13681" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13686" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a><a id="13688" class="Symbol">}</a> <a id="13690" class="Symbol">→</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="13692" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="13702" href="1Lab.Univalence.SIP.html#13667" class="Bound">S</a> <a id="13704" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="13706" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="13716" class="Symbol">_</a> <a id="13718" href="1Lab.Univalence.SIP.html#13667" class="Bound">S</a>
<a data-type="EqvAction S₁ → Structure ℓ₁ S₁" id="13720" href="1Lab.Univalence.SIP.html#13647" class="Function">Action→Structure</a> <a id="13737" href="1Lab.Univalence.SIP.html#13737" class="Bound">act</a> <a id="13741" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="13742" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="13749" class="Symbol">(</a><a id="13750" href="1Lab.Univalence.SIP.html#13750" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="13752" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="13754" href="1Lab.Univalence.SIP.html#13754" class="Bound">x</a><a id="13755" class="Symbol">)</a> <a id="13757" class="Symbol">(</a><a id="13758" href="1Lab.Univalence.SIP.html#13758" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="13760" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="13762" href="1Lab.Univalence.SIP.html#13762" class="Bound">y</a><a id="13763" class="Symbol">)</a> <a id="13765" href="1Lab.Univalence.SIP.html#13765" class="Bound">f</a> <a id="13767" class="Symbol">=</a> <a id="13769" href="1Lab.Univalence.SIP.html#13737" class="Bound">act</a> <a id="13773" href="1Lab.Univalence.SIP.html#13765" class="Bound">f</a> <a id="13775" class="Symbol">.</a><a data-type="∑ A B → A" id="13776" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="13780" href="1Lab.Univalence.SIP.html#13754" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="13782" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="13784" href="1Lab.Univalence.SIP.html#13762" class="Bound">y</a>
</pre>
<p>A <strong>transport structure</strong> is a structure <code>S : Type → Type</code> with a choice of equivalence action <code>α : EqvAction S</code> which agrees with the “intrinsic” notion of equivalence action that is induced by <a href="1Lab.Path.html#computation">the computation rules for transport</a>.</p>
<pre class="Agda"><a id="isTransportStr"></a><a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="14101" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a> <a id="14116" class="Symbol">:</a> <a id="14118" class="Symbol">{</a><a id="14119" href="1Lab.Univalence.SIP.html#14119" class="Bound">S</a> <a id="14121" class="Symbol">:</a> <a id="14123" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14128" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="14130" class="Symbol">→</a> <a id="14132" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14137" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a><a id="14139" class="Symbol">}</a> <a id="14141" class="Symbol">→</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="14143" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="14153" href="1Lab.Univalence.SIP.html#14119" class="Bound">S</a> <a id="14155" class="Symbol">→</a> <a id="14157" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14162" class="Symbol">_</a>
<a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="14164" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a> <a id="14179" class="Symbol">{</a><a id="14180" class="Argument">ℓ</a> <a id="14182" class="Symbol">=</a> <a id="14184" href="1Lab.Univalence.SIP.html#14184" class="Bound">ℓ</a><a id="14185" class="Symbol">}</a> <a id="14187" class="Symbol">{</a><a id="14188" class="Argument">S</a> <a id="14190" class="Symbol">=</a> <a id="14192" href="1Lab.Univalence.SIP.html#14192" class="Bound">S</a><a id="14193" class="Symbol">}</a> <a id="14195" href="1Lab.Univalence.SIP.html#14195" class="Bound">act</a> <a id="14199" class="Symbol">=</a>
  <a id="14203" class="Symbol">{</a><a id="14204" href="1Lab.Univalence.SIP.html#14204" class="Bound">X</a> <a id="14206" href="1Lab.Univalence.SIP.html#14206" class="Bound">Y</a> <a id="14208" class="Symbol">:</a> <a id="14210" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14215" href="1Lab.Univalence.SIP.html#14184" class="Bound">ℓ</a><a id="14216" class="Symbol">}</a> <a id="14218" class="Symbol">(</a><a id="14219" href="1Lab.Univalence.SIP.html#14219" class="Bound">e</a> <a id="14221" class="Symbol">:</a> <a id="14223" href="1Lab.Univalence.SIP.html#14204" class="Bound">X</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="14225" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="14227" href="1Lab.Univalence.SIP.html#14206" class="Bound">Y</a><a id="14228" class="Symbol">)</a> <a id="14230" class="Symbol">(</a><a id="14231" href="1Lab.Univalence.SIP.html#14231" class="Bound">s</a> <a id="14233" class="Symbol">:</a> <a id="14235" href="1Lab.Univalence.SIP.html#14192" class="Bound">S</a> <a id="14237" href="1Lab.Univalence.SIP.html#14204" class="Bound">X</a><a id="14238" class="Symbol">)</a> <a id="14240" class="Symbol">→</a> <a id="14242" href="1Lab.Univalence.SIP.html#14195" class="Bound">act</a> <a id="14246" href="1Lab.Univalence.SIP.html#14219" class="Bound">e</a> <a id="14248" class="Symbol">.</a><a data-type="∑ A B → A" id="14249" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="14253" href="1Lab.Univalence.SIP.html#14231" class="Bound">s</a> <a data-type="A → A → Type ℓ" id="14255" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="14257" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="14263" href="1Lab.Univalence.SIP.html#14192" class="Bound">S</a> <a id="14265" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="14266" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="14269" href="1Lab.Univalence.SIP.html#14219" class="Bound">e</a><a id="14270" class="Symbol">)</a> <a id="14272" href="1Lab.Univalence.SIP.html#14231" class="Bound">s</a>
</pre>
<p>While the above definition of <code class="sourceCode agda">transport structure</code> is natural, it can sometimes be unwieldy to work with. Using <span class="Agda"><a data-type="(P : (B : Type ℓ) → A ≃ B → Type ℓ&#39;) →
P A ((λ x → x) , idEquiv) → (e : A ≃ B) → P B e" href="1Lab.Univalence.html#19782" class="Function">univalence</a></span>, the condition for being a transport structure can be weakened to “preserves the identity equivalence”, with no loss of generality:</p>
<pre class="Agda"><a id="preservesId"></a><a data-type="EqvAction S₁ → Type (lsuc ℓ)" id="14573" href="1Lab.Univalence.SIP.html#14573" class="Function">preservesId</a> <a id="14585" class="Symbol">:</a> <a id="14587" class="Symbol">{</a><a id="14588" href="1Lab.Univalence.SIP.html#14588" class="Bound">S</a> <a id="14590" class="Symbol">:</a> <a id="14592" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14597" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="14599" class="Symbol">→</a> <a id="14601" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14606" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a><a id="14607" class="Symbol">}</a> <a id="14609" class="Symbol">→</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="14611" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="14621" href="1Lab.Univalence.SIP.html#14588" class="Bound">S</a> <a id="14623" class="Symbol">→</a> <a id="14625" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14630" class="Symbol">_</a>
<a data-type="EqvAction S₁ → Type (lsuc ℓ)" id="14632" href="1Lab.Univalence.SIP.html#14573" class="Function">preservesId</a> <a id="14644" class="Symbol">{</a><a id="14645" class="Argument">ℓ</a> <a id="14647" class="Symbol">=</a> <a id="14649" href="1Lab.Univalence.SIP.html#14649" class="Bound">ℓ</a><a id="14650" class="Symbol">}</a> <a id="14652" class="Symbol">{</a><a id="14653" class="Argument">S</a> <a id="14655" class="Symbol">=</a> <a id="14657" href="1Lab.Univalence.SIP.html#14657" class="Bound">S</a><a id="14658" class="Symbol">}</a> <a id="14660" href="1Lab.Univalence.SIP.html#14660" class="Bound">act</a> <a id="14664" class="Symbol">=</a>
  <a id="14668" class="Symbol">{</a><a id="14669" href="1Lab.Univalence.SIP.html#14669" class="Bound">X</a> <a id="14671" class="Symbol">:</a> <a id="14673" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14678" href="1Lab.Univalence.SIP.html#14649" class="Bound">ℓ</a><a id="14679" class="Symbol">}</a> <a id="14681" class="Symbol">(</a><a id="14682" href="1Lab.Univalence.SIP.html#14682" class="Bound">s</a> <a id="14684" class="Symbol">:</a> <a id="14686" href="1Lab.Univalence.SIP.html#14657" class="Bound">S</a> <a id="14688" href="1Lab.Univalence.SIP.html#14669" class="Bound">X</a><a id="14689" class="Symbol">)</a> <a id="14691" class="Symbol">→</a> <a id="14693" href="1Lab.Univalence.SIP.html#14660" class="Bound">act</a> <a id="14697" class="Symbol">(</a><a data-type="A → A" id="14698" href="1Lab.Type.html#2348" class="Function">id</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="14701" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="14703" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="14710" class="Symbol">)</a> <a id="14712" class="Symbol">.</a><a data-type="∑ A B → A" id="14713" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="14717" href="1Lab.Univalence.SIP.html#14682" class="Bound">s</a> <a data-type="A → A → Type ℓ" id="14719" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="14721" href="1Lab.Univalence.SIP.html#14682" class="Bound">s</a>
</pre>
<p>The proof is by equivalence induction: To show something about all <code>Y : Type, x : X ≃ Y</code> (with X fixed), it suffices to cover the case where <code>Y</code> is <code>X</code> and <code>e</code> is the identity equivalence. This case is by the assumption that <span class="Agda"><a data-type="EqvAction S₁ → Type (lsuc ℓ)" href="1Lab.Univalence.SIP.html#14573" class="Function">σ preserves id</a></span>.</p>
<pre class="Agda"><a id="preservesId→isTransportStr"></a><a data-type="(σ : EqvAction S₁) → preservesId σ → isTransportStr σ" id="15005" href="1Lab.Univalence.SIP.html#15005" class="Function">preservesId→isTransportStr</a> <a id="15032" class="Symbol">:</a> <a id="15034" class="Symbol">(</a><a id="15035" href="1Lab.Univalence.SIP.html#15035" class="Bound">σ</a> <a id="15037" class="Symbol">:</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="15039" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="15049" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="15050" class="Symbol">)</a> <a id="15052" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ)" id="15054" href="1Lab.Univalence.SIP.html#14573" class="Function">preservesId</a> <a id="15066" href="1Lab.Univalence.SIP.html#15035" class="Bound">σ</a> <a id="15068" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="15070" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a> <a id="15085" href="1Lab.Univalence.SIP.html#15035" class="Bound">σ</a>
<a data-type="(σ : EqvAction S₁) → preservesId σ → isTransportStr σ" id="15087" href="1Lab.Univalence.SIP.html#15005" class="Function">preservesId→isTransportStr</a> <a id="15114" class="Symbol">{</a><a id="15115" class="Argument">S</a> <a id="15117" class="Symbol">=</a> <a id="15119" href="1Lab.Univalence.SIP.html#15119" class="Bound">S</a><a id="15120" class="Symbol">}</a> <a id="15122" href="1Lab.Univalence.SIP.html#15122" class="Bound">σ</a> <a id="15124" href="1Lab.Univalence.SIP.html#15124" class="Bound">pres-id</a> <a id="15132" href="1Lab.Univalence.SIP.html#15132" class="Bound">e</a> <a id="15134" href="1Lab.Univalence.SIP.html#15134" class="Bound">s</a> <a id="15136" class="Symbol">=</a>
  <a data-type="(P : (B : Type ℓ) → A ≃ B → Type ℓ&#39;) →
P A ((λ x → x) , idEquiv) → (e : A ≃ B) → P B e" id="15140" href="1Lab.Univalence.html#19782" class="Function">EquivJ</a> <a id="15147" class="Symbol">(λ</a> <a id="15150" href="1Lab.Univalence.SIP.html#15150" class="Bound">_</a> <a id="15152" href="1Lab.Univalence.SIP.html#15152" class="Bound">e</a> <a id="15154" class="Symbol">→</a> <a id="15156" href="1Lab.Univalence.SIP.html#15122" class="Bound">σ</a> <a id="15158" href="1Lab.Univalence.SIP.html#15152" class="Bound">e</a> <a id="15160" class="Symbol">.</a><a data-type="∑ A B → A" id="15161" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="15165" href="1Lab.Univalence.SIP.html#15134" class="Bound">s</a> <a data-type="A → A → Type ℓ" id="15167" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="15169" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="15175" href="1Lab.Univalence.SIP.html#15119" class="Bound">S</a> <a id="15177" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="15178" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="15181" href="1Lab.Univalence.SIP.html#15152" class="Bound">e</a><a id="15182" class="Symbol">)</a> <a id="15184" href="1Lab.Univalence.SIP.html#15134" class="Bound">s</a><a id="15185" class="Symbol">)</a> <a id="15187" href="1Lab.Univalence.SIP.html#15381" class="Function">lemma&#39;</a> <a id="15194" href="1Lab.Univalence.SIP.html#15132" class="Bound">e</a>
  <a id="15198" class="Keyword">where</a>
</pre>
<p>Unfortunately we can not directly use the assumption that <code>σ</code> preserves <span class="Agda"><a data-type="A → A" href="1Lab.Type.html#2348" class="Function">id</a></span> in the proof, but it can be used as the final step in an equational proof:</p>
<pre class="Agda">    <a id="15381" href="1Lab.Univalence.SIP.html#15381" class="Function">lemma&#39;</a> <a id="15388" class="Symbol">:</a> <a id="15390" href="1Lab.Univalence.SIP.html#15122" class="Bound">σ</a> <a id="15392" class="Symbol">(</a><a data-type="A → A" id="15393" href="1Lab.Type.html#2348" class="Function">id</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="15396" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="15398" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="15405" class="Symbol">)</a> <a id="15407" class="Symbol">.</a><a data-type="∑ A B → A" id="15408" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="15412" href="1Lab.Univalence.SIP.html#15134" class="Bound">s</a> <a data-type="A → A → Type ℓ" id="15414" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="15416" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="15422" href="1Lab.Univalence.SIP.html#15119" class="Bound">S</a> <a id="15424" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="15425" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="15428" class="Symbol">(</a><a data-type="A → A" id="15429" href="1Lab.Type.html#2348" class="Function">id</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="15432" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="15434" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="15441" class="Symbol">))</a> <a id="15444" href="1Lab.Univalence.SIP.html#15134" class="Bound">s</a>
    <a id="15450" href="1Lab.Univalence.SIP.html#15381" class="Function">lemma&#39;</a> <a id="15457" class="Symbol">=</a>
      <a data-type="x ≡ y → y ≡ x" id="15465" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="15469" class="Symbol">(</a>
        <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="15479" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="15485" href="1Lab.Univalence.SIP.html#15119" class="Bound">S</a> <a id="15487" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="15488" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="15491" class="Symbol">(</a><a data-type="A → A" id="15492" href="1Lab.Type.html#2348" class="Function">id</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="15495" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="15497" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="15504" class="Symbol">))</a> <a id="15507" href="1Lab.Univalence.SIP.html#15134" class="Bound">s</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="15509" href="1Lab.Path.html#45199" class="Function Operator">≡⟨</a> <a data-type="(f : (x : A) → B x) (p : x ≡ y) → PathP (λ i → B (p i)) (f x) (f y)" id="15512" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="15515" class="Symbol">(λ</a> <a id="15518" href="1Lab.Univalence.SIP.html#15518" class="Bound">p</a> <a id="15520" class="Symbol">→</a> <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="15522" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="15528" href="1Lab.Univalence.SIP.html#15119" class="Bound">S</a> <a id="15530" href="1Lab.Univalence.SIP.html#15518" class="Bound">p</a> <a id="15532" href="1Lab.Univalence.SIP.html#15134" class="Bound">s</a><a id="15533" class="Symbol">)</a> <a data-type="ua ((λ x → x) , idEquiv) ≡ refl" id="15535" href="1Lab.Univalence.html#16245" class="Function">uaIdEquiv</a> <a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="15545" href="1Lab.Path.html#45199" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡</span></span>
        <a data-type="A ≡ B → A → B" id="15555" href="1Lab.Path.html#10335" class="Function">transport</a> <a data-type="x ≡ x" id="15565" href="1Lab.Path.html#2137" class="Function">refl</a> <a id="15570" href="1Lab.Univalence.SIP.html#15134" class="Bound">s</a>              <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="15585" href="1Lab.Path.html#45199" class="Function Operator">≡⟨</a> <a data-type="(x : A) → transport (λ i → A) x ≡ x" id="15588" href="1Lab.Path.html#12012" class="Function">transport-refl</a> <a id="15603" class="Symbol">_</a> <a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="15605" href="1Lab.Path.html#45199" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡</span></span>
        <a id="15615" href="1Lab.Univalence.SIP.html#15134" class="Bound">s</a>                             <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="15645" href="1Lab.Path.html#45199" class="Function Operator">≡⟨</a> <a data-type="x ≡ y → y ≡ x" id="15648" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="15652" class="Symbol">(</a><a id="15653" href="1Lab.Univalence.SIP.html#15124" class="Bound">pres-id</a> <a id="15661" href="1Lab.Univalence.SIP.html#15134" class="Bound">s</a><a id="15662" class="Symbol">)</a> <a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="15664" href="1Lab.Path.html#45199" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡</span></span> 
        <a id="15675" href="1Lab.Univalence.SIP.html#15122" class="Bound">σ</a> <a id="15677" class="Symbol">(</a><a data-type="A → A" id="15678" href="1Lab.Type.html#2348" class="Function">id</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="15681" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="15683" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="15690" class="Symbol">)</a> <a id="15692" class="Symbol">.</a><a data-type="∑ A B → A" id="15693" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="15697" href="1Lab.Univalence.SIP.html#15134" class="Bound">s</a>       <a data-type="(x : A) → x ≡ x" id="15705" href="1Lab.Path.html#45365" class="Function Operator">∎</a>
      <a id="15713" class="Symbol">)</a>
</pre>
<!--
<pre class="Agda"><a id="transportStr⁻¹"></a><a id="15733" href="1Lab.Univalence.SIP.html#15733" class="Function">transportStr⁻¹</a> <a id="15748" class="Symbol">:</a>
  <a id="15752" class="Symbol">{</a><a id="15753" href="1Lab.Univalence.SIP.html#15753" class="Bound">S</a> <a id="15755" class="Symbol">:</a> <a id="15757" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="15762" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="15764" class="Symbol">→</a> <a id="15766" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="15771" href="1Lab.Univalence.SIP.html#3455" class="Generalizable">ℓ₂</a><a id="15773" class="Symbol">}</a> <a id="15775" class="Symbol">(</a><a id="15776" href="1Lab.Univalence.SIP.html#15776" class="Bound">α</a> <a id="15778" class="Symbol">:</a> <a id="15780" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="15790" href="1Lab.Univalence.SIP.html#15753" class="Bound">S</a><a id="15791" class="Symbol">)</a> <a id="15793" class="Symbol">(</a><a id="15794" href="1Lab.Univalence.SIP.html#15794" class="Bound">τ</a> <a id="15796" class="Symbol">:</a> <a id="15798" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a> <a id="15813" href="1Lab.Univalence.SIP.html#15776" class="Bound">α</a><a id="15814" class="Symbol">)</a>
  <a id="15818" class="Symbol">{</a><a id="15819" href="1Lab.Univalence.SIP.html#15819" class="Bound">X</a> <a id="15821" href="1Lab.Univalence.SIP.html#15821" class="Bound">Y</a> <a id="15823" class="Symbol">:</a> <a id="15825" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="15830" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a><a id="15831" class="Symbol">}</a> <a id="15833" class="Symbol">(</a><a id="15834" href="1Lab.Univalence.SIP.html#15834" class="Bound">e</a> <a id="15836" class="Symbol">:</a> <a id="15838" href="1Lab.Univalence.SIP.html#15819" class="Bound">X</a> <a id="15840" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="15842" href="1Lab.Univalence.SIP.html#15821" class="Bound">Y</a><a id="15843" class="Symbol">)</a> <a id="15845" class="Symbol">(</a><a id="15846" href="1Lab.Univalence.SIP.html#15846" class="Bound">t</a> <a id="15848" class="Symbol">:</a> <a id="15850" href="1Lab.Univalence.SIP.html#15753" class="Bound">S</a> <a id="15852" href="1Lab.Univalence.SIP.html#15821" class="Bound">Y</a><a id="15853" class="Symbol">)</a>
  <a id="15857" class="Symbol">→</a> <a id="15859" href="1Lab.Equiv.html#6391" class="Function">equiv→inverse</a> <a id="15873" class="Symbol">(</a><a id="15874" href="1Lab.Univalence.SIP.html#15776" class="Bound">α</a> <a id="15876" href="1Lab.Univalence.SIP.html#15834" class="Bound">e</a> <a id="15878" class="Symbol">.</a><a id="15879" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="15882" class="Symbol">)</a> <a id="15884" href="1Lab.Univalence.SIP.html#15846" class="Bound">t</a> <a id="15886" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="15888" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="15894" href="1Lab.Univalence.SIP.html#15753" class="Bound">S</a> <a id="15896" class="Symbol">(</a><a id="15897" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="15901" class="Symbol">(</a><a id="15902" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="15905" href="1Lab.Univalence.SIP.html#15834" class="Bound">e</a><a id="15906" class="Symbol">))</a> <a id="15909" href="1Lab.Univalence.SIP.html#15846" class="Bound">t</a>
<a id="15911" href="1Lab.Univalence.SIP.html#15733" class="Function">transportStr⁻¹</a> <a id="15926" class="Symbol">{</a><a id="15927" class="Argument">S</a> <a id="15929" class="Symbol">=</a> <a id="15931" href="1Lab.Univalence.SIP.html#15931" class="Bound">S</a><a id="15932" class="Symbol">}</a> <a id="15934" href="1Lab.Univalence.SIP.html#15934" class="Bound">α</a> <a id="15936" href="1Lab.Univalence.SIP.html#15936" class="Bound">τ</a> <a id="15938" href="1Lab.Univalence.SIP.html#15938" class="Bound">e</a> <a id="15940" href="1Lab.Univalence.SIP.html#15940" class="Bound">t</a> <a id="15942" class="Symbol">=</a>
     <a id="15949" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="15953" class="Symbol">(</a><a id="15954" href="1Lab.Path.html#13290" class="Function">transport⁻Transport</a> <a id="15974" class="Symbol">(</a><a id="15975" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="15978" href="1Lab.Univalence.SIP.html#15931" class="Bound">S</a> <a id="15980" class="Symbol">(</a><a id="15981" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="15984" href="1Lab.Univalence.SIP.html#15938" class="Bound">e</a><a id="15985" class="Symbol">))</a> <a id="15988" class="Symbol">(</a><a id="15989" href="1Lab.Equiv.html#6391" class="Function">equiv→inverse</a> <a id="16003" class="Symbol">(</a><a id="16004" href="1Lab.Univalence.SIP.html#15934" class="Bound">α</a> <a id="16006" href="1Lab.Univalence.SIP.html#15938" class="Bound">e</a> <a id="16008" class="Symbol">.</a><a id="16009" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="16012" class="Symbol">)</a> <a id="16014" href="1Lab.Univalence.SIP.html#15940" class="Bound">t</a><a id="16015" class="Symbol">))</a>
  <a id="16020" href="1Lab.Path.html#36860" class="Function Operator">··</a> <a id="16023" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="16027" class="Symbol">(</a><a id="16028" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="16031" class="Symbol">(</a><a id="16032" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="16038" href="1Lab.Univalence.SIP.html#15931" class="Bound">S</a> <a id="16040" class="Symbol">(</a><a id="16041" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="16045" class="Symbol">(</a><a id="16046" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="16049" href="1Lab.Univalence.SIP.html#15938" class="Bound">e</a><a id="16050" class="Symbol">)))</a> <a id="16054" class="Symbol">(</a><a id="16055" href="1Lab.Univalence.SIP.html#15936" class="Bound">τ</a> <a id="16057" href="1Lab.Univalence.SIP.html#15938" class="Bound">e</a> <a id="16059" class="Symbol">(</a><a id="16060" href="1Lab.Equiv.html#6391" class="Function">equiv→inverse</a> <a id="16074" class="Symbol">(</a><a id="16075" href="1Lab.Univalence.SIP.html#15934" class="Bound">α</a> <a id="16077" href="1Lab.Univalence.SIP.html#15938" class="Bound">e</a> <a id="16079" class="Symbol">.</a><a id="16080" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="16083" class="Symbol">)</a> <a id="16085" href="1Lab.Univalence.SIP.html#15940" class="Bound">t</a><a id="16086" class="Symbol">)))</a>
  <a id="16092" href="1Lab.Path.html#36860" class="Function Operator">··</a> <a id="16095" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="16098" class="Symbol">(</a><a id="16099" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="16105" href="1Lab.Univalence.SIP.html#15931" class="Bound">S</a> <a id="16107" class="Symbol">(</a><a id="16108" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="16112" class="Symbol">(</a><a id="16113" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="16116" href="1Lab.Univalence.SIP.html#15938" class="Bound">e</a><a id="16117" class="Symbol">)))</a> <a id="16121" class="Symbol">(</a><a id="16122" href="1Lab.Equiv.html#6488" class="Function">equiv→section</a> <a id="16136" class="Symbol">(</a><a id="16137" href="1Lab.Univalence.SIP.html#15934" class="Bound">α</a> <a id="16139" href="1Lab.Univalence.SIP.html#15938" class="Bound">e</a> <a id="16141" class="Symbol">.</a><a id="16142" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="16145" class="Symbol">)</a> <a id="16147" href="1Lab.Univalence.SIP.html#15940" class="Bound">t</a><a id="16148" class="Symbol">)</a>
</pre>-->
<p>If <code>S</code> is a <code class="sourceCode agda" id="isTransportStr">transport structure</code>, then its canonical equipment as a <span class="Agda"><a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a></span> is univalent:</p>
<pre class="Agda"><a id="isTransp→isUnivalent"></a><a data-type="(a : EqvAction S₁) →
isTransportStr a → isUnivalent (Action→Structure a)" id="16295" href="1Lab.Univalence.SIP.html#16295" class="Function">isTransp→isUnivalent</a> <a id="16316" class="Symbol">:</a> <a id="16318" class="Symbol">{</a><a id="16319" href="1Lab.Univalence.SIP.html#16319" class="Bound">S</a> <a id="16321" class="Symbol">:</a> <a id="16323" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="16328" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="16330" class="Symbol">→</a> <a id="16332" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="16337" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a><a id="16339" class="Symbol">}</a> <a id="16341" class="Symbol">(</a><a id="16342" href="1Lab.Univalence.SIP.html#16342" class="Bound">a</a> <a id="16344" class="Symbol">:</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="16346" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="16356" href="1Lab.Univalence.SIP.html#16319" class="Bound">S</a><a id="16357" class="Symbol">)</a>
                     <a id="16380" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="16382" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a> <a id="16397" href="1Lab.Univalence.SIP.html#16342" class="Bound">a</a>
                     <a id="16420" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="16422" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="16434" class="Symbol">(</a><a data-type="EqvAction S₁ → Structure ℓ₁ S₁" id="16435" href="1Lab.Univalence.SIP.html#13647" class="Function">Action→Structure</a> <a id="16452" href="1Lab.Univalence.SIP.html#16342" class="Bound">a</a><a id="16453" class="Symbol">)</a>
<a data-type="(a : EqvAction S₁) →
isTransportStr a → isUnivalent (Action→Structure a)" id="16455" href="1Lab.Univalence.SIP.html#16295" class="Function">isTransp→isUnivalent</a> <a id="16476" class="Symbol">{</a><a id="16477" class="Argument">S</a> <a id="16479" class="Symbol">=</a> <a id="16481" href="1Lab.Univalence.SIP.html#16481" class="Bound">S</a><a id="16482" class="Symbol">}</a> <a id="16484" href="1Lab.Univalence.SIP.html#16484" class="Bound">act</a> <a id="16488" href="1Lab.Univalence.SIP.html#16488" class="Bound">is-tr</a> <a id="16494" class="Symbol">{</a><a id="16495" href="1Lab.Univalence.SIP.html#16495" class="Bound">X</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="16497" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="16499" href="1Lab.Univalence.SIP.html#16499" class="Bound">s</a><a id="16500" class="Symbol">}</a> <a id="16502" class="Symbol">{</a><a id="16503" href="1Lab.Univalence.SIP.html#16503" class="Bound">Y</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="16505" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="16507" href="1Lab.Univalence.SIP.html#16507" class="Bound">t</a><a id="16508" class="Symbol">}</a> <a id="16510" href="1Lab.Univalence.SIP.html#16510" class="Bound">eqv</a> <a id="16514" class="Symbol">=</a>
  <a id="16518" href="1Lab.Univalence.SIP.html#16484" class="Bound">act</a> <a id="16522" href="1Lab.Univalence.SIP.html#16510" class="Bound">eqv</a> <a id="16526" class="Symbol">.</a><a data-type="∑ A B → A" id="16527" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="16531" href="1Lab.Univalence.SIP.html#16499" class="Bound">s</a> <a data-type="A → A → Type ℓ" id="16533" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="16535" href="1Lab.Univalence.SIP.html#16507" class="Bound">t</a>              <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="16550" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a data-type="A ≡ B → A ≃ B" id="16553" href="1Lab.Univalence.html#15463" class="Function">pathToEquiv</a> <a id="16565" class="Symbol">(</a><a data-type="(f : (x : A) → B x) (p : x ≡ y) → PathP (λ i → B (p i)) (f x) (f y)" id="16566" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="16569" class="Symbol">(</a><a data-type="A → A → Type ℓ" id="16570" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">_≡</a> <a id="16573" href="1Lab.Univalence.SIP.html#16507" class="Bound">t</a><a id="16574" class="Symbol">)</a> <a id="16576" class="Symbol">(</a><a id="16577" href="1Lab.Univalence.SIP.html#16488" class="Bound">is-tr</a> <a id="16583" href="1Lab.Univalence.SIP.html#16510" class="Bound">eqv</a> <a id="16587" href="1Lab.Univalence.SIP.html#16499" class="Bound">s</a><a id="16588" class="Symbol">))</a> <a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="16591" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="16595" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="16601" href="1Lab.Univalence.SIP.html#16481" class="Bound">S</a> <a id="16603" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="16604" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="16607" href="1Lab.Univalence.SIP.html#16510" class="Bound">eqv</a><a id="16610" class="Symbol">)</a> <a id="16612" href="1Lab.Univalence.SIP.html#16499" class="Bound">s</a> <a data-type="A → A → Type ℓ" id="16614" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="16616" href="1Lab.Univalence.SIP.html#16507" class="Bound">t</a>          <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="16627" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a data-type="A ≡ B → A ≃ B" id="16630" href="1Lab.Univalence.html#15463" class="Function">pathToEquiv</a> <a id="16642" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="16643" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="16647" class="Symbol">(</a><a data-type="(P : I → Type ℓ) (p : P i0) (q : P i1) →
PathP P p q ≡ Path (P i1) (transport P p) q" id="16648" href="1Lab.Path.html#47534" class="Function">PathP≡Path</a> <a id="16659" class="Symbol">(λ</a> <a id="16662" href="1Lab.Univalence.SIP.html#16662" class="Bound">i</a> <a id="16664" class="Symbol">→</a> <a id="16666" href="1Lab.Univalence.SIP.html#16481" class="Bound">S</a> <a id="16668" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="16669" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="16672" href="1Lab.Univalence.SIP.html#16510" class="Bound">eqv</a> <a id="16676" href="1Lab.Univalence.SIP.html#16662" class="Bound">i</a><a id="16677" class="Symbol">))</a> <a id="16680" href="1Lab.Univalence.SIP.html#16499" class="Bound">s</a> <a id="16682" href="1Lab.Univalence.SIP.html#16507" class="Bound">t</a><a id="16683" class="Symbol">))</a> <a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="16686" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="16690" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="16696" class="Symbol">(λ</a> <a id="16699" href="1Lab.Univalence.SIP.html#16699" class="Bound">i</a> <a id="16701" class="Symbol">→</a> <a id="16703" href="1Lab.Univalence.SIP.html#16481" class="Bound">S</a> <a id="16705" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="16706" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="16709" href="1Lab.Univalence.SIP.html#16510" class="Bound">eqv</a> <a id="16713" href="1Lab.Univalence.SIP.html#16699" class="Bound">i</a><a id="16714" class="Symbol">))</a> <a id="16717" href="1Lab.Univalence.SIP.html#16499" class="Bound">s</a> <a id="16719" href="1Lab.Univalence.SIP.html#16507" class="Bound">t</a>  <a data-type="(A : Type ℓ) → A ≃ A" id="16722" href="1Lab.Equiv.html#23023" class="Function Operator">≃∎</a>
</pre>
<p>We can mix and match these different notions of structure at will. For example, a more convenient definition of function univalent structure uses an equivalence action on the domain:</p>
<pre class="Agda"><a id="functionStr"></a><a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" id="16922" href="1Lab.Univalence.SIP.html#16922" class="Function">functionStr</a> <a id="16934" class="Symbol">:</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="16936" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="16946" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="16948" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="16950" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="16960" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="16962" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a> <a id="16964" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="16966" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="16976" class="Symbol">_</a> <a id="16978" class="Symbol">(λ</a> <a id="16981" href="1Lab.Univalence.SIP.html#16981" class="Bound">X</a> <a id="16983" class="Symbol">→</a> <a id="16985" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="16987" href="1Lab.Univalence.SIP.html#16981" class="Bound">X</a> <a id="16989" class="Symbol">→</a> <a id="16991" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a> <a id="16993" href="1Lab.Univalence.SIP.html#16981" class="Bound">X</a><a id="16994" class="Symbol">)</a>
<a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" id="16996" href="1Lab.Univalence.SIP.html#16922" class="Function">functionStr</a> <a id="17008" class="Symbol">{</a><a id="17009" class="Argument">S</a> <a id="17011" class="Symbol">=</a> <a id="17013" href="1Lab.Univalence.SIP.html#17013" class="Bound">S</a><a id="17014" class="Symbol">}</a> <a id="17016" href="1Lab.Univalence.SIP.html#17016" class="Bound">act</a> <a id="17020" href="1Lab.Univalence.SIP.html#17020" class="Bound">str</a> <a id="17024" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="17025" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="17032" class="Symbol">(</a><a id="17033" href="1Lab.Univalence.SIP.html#17033" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="17035" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17037" href="1Lab.Univalence.SIP.html#17037" class="Bound">f</a><a id="17038" class="Symbol">)</a> <a id="17040" class="Symbol">(</a><a id="17041" href="1Lab.Univalence.SIP.html#17041" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="17043" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17045" href="1Lab.Univalence.SIP.html#17045" class="Bound">g</a><a id="17046" class="Symbol">)</a> <a id="17048" href="1Lab.Univalence.SIP.html#17048" class="Bound">e</a> <a id="17050" class="Symbol">=</a>
  <a id="17054" class="Symbol">(</a><a id="17055" href="1Lab.Univalence.SIP.html#17055" class="Bound">s</a> <a id="17057" class="Symbol">:</a> <a id="17059" href="1Lab.Univalence.SIP.html#17013" class="Bound">S</a> <a id="17061" href="1Lab.Univalence.SIP.html#17033" class="Bound">A</a><a id="17062" class="Symbol">)</a> <a id="17064" class="Symbol">→</a> <a id="17066" href="1Lab.Univalence.SIP.html#17020" class="Bound">str</a> <a id="17070" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="17071" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="17078" class="Symbol">(</a><a id="17079" href="1Lab.Univalence.SIP.html#17033" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="17081" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17083" href="1Lab.Univalence.SIP.html#17037" class="Bound">f</a> <a id="17085" href="1Lab.Univalence.SIP.html#17055" class="Bound">s</a><a id="17086" class="Symbol">)</a> <a id="17088" class="Symbol">(</a><a id="17089" href="1Lab.Univalence.SIP.html#17041" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="17091" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17093" href="1Lab.Univalence.SIP.html#17045" class="Bound">g</a> <a id="17095" class="Symbol">(</a><a id="17096" href="1Lab.Univalence.SIP.html#17016" class="Bound">act</a> <a id="17100" href="1Lab.Univalence.SIP.html#17048" class="Bound">e</a> <a id="17102" class="Symbol">.</a><a data-type="∑ A B → A" id="17103" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="17107" href="1Lab.Univalence.SIP.html#17055" class="Bound">s</a><a id="17108" class="Symbol">))</a> <a id="17111" href="1Lab.Univalence.SIP.html#17048" class="Bound">e</a>
</pre>
<p>This alternative definition of structure is univalent when <code>T</code> is a univalent structure and <code>S</code> is a transport structure:</p>
<pre class="Agda"><a id="functionStr-univalent"></a><a data-type="(α : EqvAction S₁) →
isTransportStr α →
(τ : Structure ℓ T) → isUnivalent τ → isUnivalent (functionStr α τ)" id="17249" href="1Lab.Univalence.SIP.html#17249" class="Function">functionStr-univalent</a> <a id="17271" class="Symbol">:</a> <a id="17273" class="Symbol">(</a><a id="17274" href="1Lab.Univalence.SIP.html#17274" class="Bound">α</a> <a id="17276" class="Symbol">:</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="17278" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="17288" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="17289" class="Symbol">)</a> <a id="17291" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="17293" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a> <a id="17308" href="1Lab.Univalence.SIP.html#17274" class="Bound">α</a>
                      <a id="17332" class="Symbol">→</a> <a id="17334" class="Symbol">(</a><a id="17335" href="1Lab.Univalence.SIP.html#17335" class="Bound">τ</a> <a id="17337" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="17339" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="17349" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="17351" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a><a id="17352" class="Symbol">)</a> <a id="17354" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="17356" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="17368" href="1Lab.Univalence.SIP.html#17335" class="Bound">τ</a>
                      <a id="17392" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="17394" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="17406" class="Symbol">(</a><a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" id="17407" href="1Lab.Univalence.SIP.html#16922" class="Function">functionStr</a> <a id="17419" href="1Lab.Univalence.SIP.html#17274" class="Bound">α</a> <a id="17421" href="1Lab.Univalence.SIP.html#17335" class="Bound">τ</a><a id="17422" class="Symbol">)</a>
<a data-type="(α : EqvAction S₁) →
isTransportStr α →
(τ : Structure ℓ T) → isUnivalent τ → isUnivalent (functionStr α τ)" id="17424" href="1Lab.Univalence.SIP.html#17249" class="Function">functionStr-univalent</a> <a id="17446" class="Symbol">{</a><a id="17447" class="Argument">S</a> <a id="17449" class="Symbol">=</a> <a id="17451" href="1Lab.Univalence.SIP.html#17451" class="Bound">S</a><a id="17452" class="Symbol">}</a> <a id="17454" class="Symbol">{</a><a id="17455" class="Argument">T</a> <a id="17457" class="Symbol">=</a> <a id="17459" href="1Lab.Univalence.SIP.html#17459" class="Bound">T</a><a id="17460" class="Symbol">}</a> <a id="17462" href="1Lab.Univalence.SIP.html#17462" class="Bound">α</a> <a id="17464" href="1Lab.Univalence.SIP.html#17464" class="Bound">α-tr</a> <a id="17469" href="1Lab.Univalence.SIP.html#17469" class="Bound">τ</a> <a id="17471" href="1Lab.Univalence.SIP.html#17471" class="Bound">τ-univ</a> <a id="17478" class="Symbol">{</a><a id="17479" href="1Lab.Univalence.SIP.html#17479" class="Bound">X</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="17481" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17483" href="1Lab.Univalence.SIP.html#17483" class="Bound">f</a><a id="17484" class="Symbol">}</a> <a id="17486" class="Symbol">{</a><a id="17487" href="1Lab.Univalence.SIP.html#17487" class="Bound">Y</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="17489" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17491" href="1Lab.Univalence.SIP.html#17491" class="Bound">g</a><a id="17492" class="Symbol">}</a> <a id="17494" href="1Lab.Univalence.SIP.html#17494" class="Bound">eqv</a> <a id="17498" class="Symbol">=</a>
  <a id="17502" class="Symbol">((</a><a id="17504" href="1Lab.Univalence.SIP.html#17504" class="Bound">s</a> <a id="17506" class="Symbol">:</a> <a id="17508" href="1Lab.Univalence.SIP.html#17451" class="Bound">S</a> <a id="17510" href="1Lab.Univalence.SIP.html#17479" class="Bound">X</a><a id="17511" class="Symbol">)</a> <a id="17513" class="Symbol">→</a> <a id="17515" href="1Lab.Univalence.SIP.html#17469" class="Bound">τ</a> <a id="17517" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="17518" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="17525" class="Symbol">(</a><a id="17526" href="1Lab.Univalence.SIP.html#17479" class="Bound">X</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="17528" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17530" href="1Lab.Univalence.SIP.html#17483" class="Bound">f</a> <a id="17532" href="1Lab.Univalence.SIP.html#17504" class="Bound">s</a><a id="17533" class="Symbol">)</a> <a id="17535" class="Symbol">(</a><a id="17536" href="1Lab.Univalence.SIP.html#17487" class="Bound">Y</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="17538" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17540" class="Symbol">_)</a> <a id="17543" href="1Lab.Univalence.SIP.html#17494" class="Bound">eqv</a><a id="17546" class="Symbol">)</a>     <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="17552" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a data-type="((x : A) → P x ≃ Q x) → ((x : A) → P x) ≃ ((x : A) → Q x)" id="17555" href="1Lab.Type.Pi.html#663" class="Function">Π-cod≃</a> <a id="17562" class="Symbol">(λ</a> <a id="17565" href="1Lab.Univalence.SIP.html#17565" class="Bound">s</a> <a id="17567" class="Symbol">→</a> <a id="17569" href="1Lab.Univalence.SIP.html#17471" class="Bound">τ-univ</a> <a id="17576" href="1Lab.Univalence.SIP.html#17494" class="Bound">eqv</a> <a data-type="A ≃ B → B ≃ C → A ≃ C" id="17580" href="1Lab.Equiv.html#21156" class="Function Operator">∙e</a> <a data-type="A ≡ B → A ≃ B" id="17583" href="1Lab.Univalence.html#15463" class="Function">pathToEquiv</a> <a id="17595" class="Symbol">(</a><a data-type="(f : (x : A) → B x) (p : x ≡ y) → PathP (λ i → B (p i)) (f x) (f y)" id="17596" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="17599" class="Symbol">(</a><a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="17600" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="17606" class="Symbol">(λ</a> <a id="17609" href="1Lab.Univalence.SIP.html#17609" class="Bound">i</a> <a id="17611" class="Symbol">→</a> <a id="17613" href="1Lab.Univalence.SIP.html#17459" class="Bound">T</a> <a id="17615" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="17616" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="17619" href="1Lab.Univalence.SIP.html#17494" class="Bound">eqv</a> <a id="17623" href="1Lab.Univalence.SIP.html#17609" class="Bound">i</a><a id="17624" class="Symbol">))</a> <a id="17627" class="Symbol">(</a><a id="17628" href="1Lab.Univalence.SIP.html#17483" class="Bound">f</a> <a id="17630" href="1Lab.Univalence.SIP.html#17565" class="Bound">s</a><a id="17631" class="Symbol">)</a> <a data-type="(B → C) → (A → B) → A → C" id="17633" href="1Lab.Type.html#2217" class="Function Operator">∘</a> <a id="17635" href="1Lab.Univalence.SIP.html#17491" class="Bound">g</a><a id="17636" class="Symbol">)</a> <a id="17638" class="Symbol">(</a><a id="17639" href="1Lab.Univalence.SIP.html#17464" class="Bound">α-tr</a> <a id="17644" class="Symbol">_</a> <a id="17646" class="Symbol">_)))</a> <a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="17651" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a id="17655" class="Symbol">((</a><a id="17657" href="1Lab.Univalence.SIP.html#17657" class="Bound">s</a> <a id="17659" class="Symbol">:</a> <a id="17661" href="1Lab.Univalence.SIP.html#17451" class="Bound">S</a> <a id="17663" href="1Lab.Univalence.SIP.html#17479" class="Bound">X</a><a id="17664" class="Symbol">)</a> <a id="17666" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="17668" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="17674" class="Symbol">(λ</a> <a id="17677" href="1Lab.Univalence.SIP.html#17677" class="Bound">i</a> <a id="17679" class="Symbol">→</a> <a id="17681" href="1Lab.Univalence.SIP.html#17459" class="Bound">T</a> <a id="17683" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="17684" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="17687" href="1Lab.Univalence.SIP.html#17494" class="Bound">eqv</a> <a id="17691" href="1Lab.Univalence.SIP.html#17677" class="Bound">i</a><a id="17692" class="Symbol">))</a> <a id="17695" class="Symbol">(</a><a id="17696" href="1Lab.Univalence.SIP.html#17483" class="Bound">f</a> <a id="17698" href="1Lab.Univalence.SIP.html#17657" class="Bound">s</a><a id="17699" class="Symbol">)</a> <a id="17701" class="Symbol">_)</a>  <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="17705" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a id="17708" class="Symbol">(</a><a data-type="({x₀ : A i0} {x₁ : A i1} → PathP A x₀ x₁ → PathP B (f x₀) (g x₁)) ≃
((x₀ : A i0) → PathP B (f x₀) (g (coe0→1 A x₀)))" id="17709" href="1Lab.Type.Pi.html#4266" class="Function">heteroHomotopy≃Homotopy</a> <a data-type="A ≃ B → B ≃ A" id="17733" href="1Lab.Equiv.html#21246" class="Function Operator">e⁻¹</a><a id="17736" class="Symbol">)</a> <a data-type="A ≃ B → B ≃ C → A ≃ C" id="17738" href="1Lab.Equiv.html#21156" class="Function Operator">∙e</a> <a data-type="({x₀ : A i0} {x₁ : A i1} (p : PathP A x₀ x₁) →
 PathP (λ i → B i (p i)) (f x₀) (g x₁))
≃ PathP (λ i → (x : A i) → B i x) f g" id="17741" href="1Lab.Type.Pi.html#3070" class="Function">funextDep≃</a> <a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="17752" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a id="17756" class="Symbol">_</a>                                                 <a data-type="(A : Type ℓ) → A ≃ A" id="17806" href="1Lab.Equiv.html#23023" class="Function Operator">≃∎</a>
</pre>
<p>To see why <span class="Agda"><a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" href="1Lab.Univalence.SIP.html#16922" class="Function">functionStr</a></span> is more convenient than <span class="Agda"><a data-type="Structure ℓ₁ S₁ →
Structure ℓ₂ T → Structure (ℓ₁ ⊔ S.ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" href="1Lab.Univalence.SIP.html#8474" class="Function">the previous definition</a></span> - which is why it gets the shorter name - it’s convenient to consider how the <span class="Agda"><a data-type="Structure ℓ (λ X → X)" href="1Lab.Univalence.SIP.html#7039" class="Function">pointed structure</a></span> acts on equivvalences: <em>not at all</em>. Recall the definition of ∞-magma equivalence generated by <span class="Agda"><a data-type="Structure ℓ₁ S₁ →
Structure ℓ₂ T → Structure (ℓ₁ ⊔ S.ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" href="1Lab.Univalence.SIP.html#8474" class="Function">Str-functionStr</a></span>:</p>
<pre class="Agda"><a id="18195" class="Keyword">private</a>
  <a id="18205" href="1Lab.Univalence.SIP.html#18205" class="Function">_</a> <a id="18207" class="Symbol">:</a> <a id="18209" class="Symbol">{</a><a id="18210" href="1Lab.Univalence.SIP.html#18210" class="Bound">A</a> <a id="18212" href="1Lab.Univalence.SIP.html#18212" class="Bound">B</a> <a id="18214" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="18216" href="1Lab.Univalence.SIP.html#3316" class="Function">TypeWith</a> <a id="18225" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a><a id="18232" class="Symbol">}</a> <a id="18234" class="Symbol">{</a><a id="18235" href="1Lab.Univalence.SIP.html#18235" class="Bound">f</a> <a id="18237" class="Symbol">:</a> <a id="18239" href="1Lab.Univalence.SIP.html#18210" class="Bound">A</a> <a id="18241" class="Symbol">.</a><a data-type="∑ A B → A" id="18242" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="18246" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="18248" href="1Lab.Univalence.SIP.html#18212" class="Bound">B</a> <a id="18250" class="Symbol">.</a><a data-type="∑ A B → A" id="18251" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="18254" class="Symbol">}</a>
    <a id="18260" class="Symbol">→</a> <a id="18262" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a> <a id="18270" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="18271" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="18278" href="1Lab.Univalence.SIP.html#18210" class="Bound">A</a> <a id="18280" href="1Lab.Univalence.SIP.html#18212" class="Bound">B</a> <a id="18282" href="1Lab.Univalence.SIP.html#18235" class="Bound">f</a>
    <a data-type="A → A → Type ℓ" id="18288" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="18290" class="Symbol">(</a> <a id="18292" class="Symbol">{</a><a id="18293" href="1Lab.Univalence.SIP.html#18293" class="Bound">s</a> <a id="18295" class="Symbol">:</a> <a id="18297" href="1Lab.Univalence.SIP.html#18210" class="Bound">A</a> <a id="18299" class="Symbol">.</a><a data-type="∑ A B → A" id="18300" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="18303" class="Symbol">}</a> <a id="18305" class="Symbol">{</a><a id="18306" href="1Lab.Univalence.SIP.html#18306" class="Bound">t</a> <a id="18308" class="Symbol">:</a> <a id="18310" href="1Lab.Univalence.SIP.html#18212" class="Bound">B</a> <a id="18312" class="Symbol">.</a><a data-type="∑ A B → A" id="18313" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="18316" class="Symbol">}</a> <a id="18318" class="Symbol">→</a> <a id="18320" href="1Lab.Univalence.SIP.html#18235" class="Bound">f</a> <a id="18322" class="Symbol">.</a><a data-type="∑ A B → A" id="18323" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="18327" href="1Lab.Univalence.SIP.html#18293" class="Bound">s</a> <a data-type="A → A → Type ℓ" id="18329" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="18331" href="1Lab.Univalence.SIP.html#18306" class="Bound">t</a>
      <a id="18339" class="Symbol">→</a> <a id="18341" class="Symbol">{</a><a id="18342" href="1Lab.Univalence.SIP.html#18342" class="Bound">x</a> <a id="18344" class="Symbol">:</a> <a id="18346" href="1Lab.Univalence.SIP.html#18210" class="Bound">A</a> <a id="18348" class="Symbol">.</a><a data-type="∑ A B → A" id="18349" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="18352" class="Symbol">}</a> <a id="18354" class="Symbol">{</a><a id="18355" href="1Lab.Univalence.SIP.html#18355" class="Bound">y</a> <a id="18357" class="Symbol">:</a> <a id="18359" href="1Lab.Univalence.SIP.html#18212" class="Bound">B</a> <a id="18361" class="Symbol">.</a><a data-type="∑ A B → A" id="18362" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="18365" class="Symbol">}</a> <a id="18367" class="Symbol">→</a> <a id="18369" href="1Lab.Univalence.SIP.html#18235" class="Bound">f</a> <a id="18371" class="Symbol">.</a><a data-type="∑ A B → A" id="18372" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="18376" href="1Lab.Univalence.SIP.html#18342" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="18378" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="18380" href="1Lab.Univalence.SIP.html#18355" class="Bound">y</a>
      <a id="18388" class="Symbol">→</a> <a id="18390" href="1Lab.Univalence.SIP.html#18235" class="Bound">f</a> <a id="18392" class="Symbol">.</a><a data-type="∑ A B → A" id="18393" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="18397" class="Symbol">(</a><a id="18398" href="1Lab.Univalence.SIP.html#18210" class="Bound">A</a> <a id="18400" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="18401" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="18405" href="1Lab.Univalence.SIP.html#18293" class="Bound">s</a> <a id="18407" href="1Lab.Univalence.SIP.html#18342" class="Bound">x</a><a id="18408" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="18410" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="18412" href="1Lab.Univalence.SIP.html#18212" class="Bound">B</a> <a id="18414" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="18415" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="18419" href="1Lab.Univalence.SIP.html#18306" class="Bound">t</a> <a id="18421" href="1Lab.Univalence.SIP.html#18355" class="Bound">y</a><a id="18422" class="Symbol">)</a>
  <a id="18426" class="Symbol">_</a> <a id="18428" class="Symbol">=</a> <a data-type="x ≡ x" id="18430" href="1Lab.Path.html#2137" class="Function">refl</a>
</pre>
<p>Let’s rewrite <span class="Agda"><a href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a></span> using <span class="Agda"><a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" href="1Lab.Univalence.SIP.html#16922" class="Function">functionStr</a></span> to see how it compares:</p>
<pre class="Agda">  <a id="∞-Magma′"></a><a id="18533" href="1Lab.Univalence.SIP.html#18533" class="Function">∞-Magma′</a> <a id="18542" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="18544" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a data-type="Level" id="18554" href="Agda.Primitive.html#764" class="Primitive">lzero</a> <a id="18560" href="1Lab.Univalence.SIP.html#9532" class="Function">binop</a>
  <a id="18568" href="1Lab.Univalence.SIP.html#18533" class="Function">∞-Magma′</a> <a id="18577" class="Symbol">=</a> <a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" id="18579" href="1Lab.Univalence.SIP.html#16922" class="Function">functionStr</a> <a data-type="A → A" id="18591" href="1Lab.Type.html#2348" class="Function">id</a> <a id="18594" class="Symbol">(</a><a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" id="18595" href="1Lab.Univalence.SIP.html#16922" class="Function">functionStr</a> <a data-type="A → A" id="18607" href="1Lab.Type.html#2348" class="Function">id</a> <a data-type="Structure ℓ (λ X → X)" id="18610" href="1Lab.Univalence.SIP.html#7039" class="Function">pointedStr</a><a id="18620" class="Symbol">)</a>

  <a id="18625" href="1Lab.Univalence.SIP.html#18625" class="Function">_</a> <a id="18627" class="Symbol">:</a> <a id="18629" class="Symbol">{</a><a id="18630" href="1Lab.Univalence.SIP.html#18630" class="Bound">A</a> <a id="18632" href="1Lab.Univalence.SIP.html#18632" class="Bound">B</a> <a id="18634" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="18636" href="1Lab.Univalence.SIP.html#3316" class="Function">TypeWith</a> <a id="18645" href="1Lab.Univalence.SIP.html#9798" class="Function">∞-Magma</a><a id="18652" class="Symbol">}</a> <a id="18654" class="Symbol">{</a><a id="18655" href="1Lab.Univalence.SIP.html#18655" class="Bound">f</a> <a id="18657" class="Symbol">:</a> <a id="18659" href="1Lab.Univalence.SIP.html#18630" class="Bound">A</a> <a id="18661" class="Symbol">.</a><a data-type="∑ A B → A" id="18662" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="18666" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="18668" href="1Lab.Univalence.SIP.html#18632" class="Bound">B</a> <a id="18670" class="Symbol">.</a><a data-type="∑ A B → A" id="18671" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="18674" class="Symbol">}</a>
    <a id="18680" class="Symbol">→</a> <a id="18682" href="1Lab.Univalence.SIP.html#18533" class="Function">∞-Magma′</a> <a id="18691" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="18692" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="18699" href="1Lab.Univalence.SIP.html#18630" class="Bound">A</a> <a id="18701" href="1Lab.Univalence.SIP.html#18632" class="Bound">B</a> <a id="18703" href="1Lab.Univalence.SIP.html#18655" class="Bound">f</a>
    <a data-type="A → A → Type ℓ" id="18709" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="18711" class="Symbol">(</a> <a id="18713" class="Symbol">(</a><a id="18714" href="1Lab.Univalence.SIP.html#18714" class="Bound">x</a> <a id="18716" href="1Lab.Univalence.SIP.html#18716" class="Bound">y</a> <a id="18718" class="Symbol">:</a> <a id="18720" href="1Lab.Univalence.SIP.html#18630" class="Bound">A</a> <a id="18722" class="Symbol">.</a><a data-type="∑ A B → A" id="18723" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="18726" class="Symbol">)</a> <a id="18728" class="Symbol">→</a> <a id="18730" href="1Lab.Univalence.SIP.html#18655" class="Bound">f</a> <a id="18732" class="Symbol">.</a><a data-type="∑ A B → A" id="18733" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="18737" class="Symbol">(</a><a id="18738" href="1Lab.Univalence.SIP.html#18630" class="Bound">A</a> <a id="18740" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="18741" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="18745" href="1Lab.Univalence.SIP.html#18714" class="Bound">x</a> <a id="18747" href="1Lab.Univalence.SIP.html#18716" class="Bound">y</a><a id="18748" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="18750" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="18752" href="1Lab.Univalence.SIP.html#18632" class="Bound">B</a> <a id="18754" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="18755" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="18759" class="Symbol">(</a><a id="18760" href="1Lab.Univalence.SIP.html#18655" class="Bound">f</a> <a id="18762" class="Symbol">.</a><a data-type="∑ A B → A" id="18763" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="18767" href="1Lab.Univalence.SIP.html#18714" class="Bound">x</a><a id="18768" class="Symbol">)</a> <a id="18770" class="Symbol">(</a><a id="18771" href="1Lab.Univalence.SIP.html#18655" class="Bound">f</a> <a id="18773" class="Symbol">.</a><a data-type="∑ A B → A" id="18774" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="18778" href="1Lab.Univalence.SIP.html#18716" class="Bound">y</a><a id="18779" class="Symbol">))</a>
  <a id="18784" class="Symbol">_</a> <a id="18786" class="Symbol">=</a> <a data-type="x ≡ x" id="18788" href="1Lab.Path.html#2137" class="Function">refl</a>
</pre>
<p>Much better! This gets rid of all those redundant paths that were previously present, using the fact that <code>λ X → X</code> <em>does not need to act on equivalences</em>.</p>
<p>In general, transport structures are closed under all of the same operations as univalent structures, which begs the question: Why mention univalent structures at all? The reason is that a definition of structure homomorphism is very often needed, and the data of a univalent structure is perfect to use in the definition of <span class="Agda"><a data-type="isUnivalent σ → (X ≃[ σ ] Y) ≃ (X ≡ Y)" href="1Lab.Univalence.SIP.html#4629" class="Function">SIP</a></span>.</p>
<details>
<summary>
The closure properties of transport structures are in this <code>&lt;details&gt;</code> tag to keep the length of the page shorter
</summary>
<pre class="Agda"><a id="constantAction"></a><a data-type="(A : Type ℓ) → EqvAction (λ X → A)" id="19448" href="1Lab.Univalence.SIP.html#19448" class="Function">constantAction</a> <a id="19463" class="Symbol">:</a> <a id="19465" class="Symbol">(</a><a id="19466" href="1Lab.Univalence.SIP.html#19466" class="Bound">A</a> <a id="19468" class="Symbol">:</a> <a id="19470" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="19475" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a><a id="19476" class="Symbol">)</a> <a id="19478" class="Symbol">→</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="19480" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="19490" class="Symbol">{</a><a id="19491" class="Argument">ℓ</a> <a id="19493" class="Symbol">=</a> <a id="19495" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a><a id="19497" class="Symbol">}</a> <a id="19499" class="Symbol">(λ</a> <a id="19502" href="1Lab.Univalence.SIP.html#19502" class="Bound">X</a> <a id="19504" class="Symbol">→</a> <a id="19506" href="1Lab.Univalence.SIP.html#19466" class="Bound">A</a><a id="19507" class="Symbol">)</a>
<a data-type="(A : Type ℓ) → EqvAction (λ X → A)" id="19509" href="1Lab.Univalence.SIP.html#19448" class="Function">constantAction</a> <a id="19524" href="1Lab.Univalence.SIP.html#19524" class="Bound">A</a> <a id="19526" href="1Lab.Univalence.SIP.html#19526" class="Bound">eqv</a> <a id="19530" class="Symbol">=</a> <a id="19532" class="Symbol">_</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="19534" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="19536" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a>

<a id="constantAction-isTransp"></a><a data-type="isTransportStr (constantAction A)" id="19545" href="1Lab.Univalence.SIP.html#19545" class="Function">constantAction-isTransp</a> <a id="19569" class="Symbol">:</a> <a id="19571" class="Symbol">{</a><a id="19572" href="1Lab.Univalence.SIP.html#19572" class="Bound">A</a> <a id="19574" class="Symbol">:</a> <a id="19576" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="19581" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a><a id="19582" class="Symbol">}</a> <a id="19584" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="19586" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a> <a id="19601" class="Symbol">{</a><a id="19602" class="Argument">ℓ</a> <a id="19604" class="Symbol">=</a> <a id="19606" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a><a id="19608" class="Symbol">}</a> <a id="19610" class="Symbol">(</a><a data-type="(A : Type ℓ) → EqvAction (λ X → A)" id="19611" href="1Lab.Univalence.SIP.html#19448" class="Function">constantAction</a> <a id="19626" href="1Lab.Univalence.SIP.html#19572" class="Bound">A</a><a id="19627" class="Symbol">)</a>
<a data-type="isTransportStr (constantAction A)" id="19629" href="1Lab.Univalence.SIP.html#19545" class="Function">constantAction-isTransp</a> <a id="19653" href="1Lab.Univalence.SIP.html#19653" class="Bound">f</a> <a id="19655" href="1Lab.Univalence.SIP.html#19655" class="Bound">s</a> <a id="19657" class="Symbol">=</a> <a data-type="x ≡ y → y ≡ x" id="19659" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="19663" class="Symbol">(</a><a data-type="(x : A) → transport (λ i → A) x ≡ x" id="19664" href="1Lab.Path.html#12012" class="Function">transport-refl</a> <a id="19679" class="Symbol">_)</a>

<a id="idAction-isTransp"></a><a data-type="isTransportStr id" id="19683" href="1Lab.Univalence.SIP.html#19683" class="Function">idAction-isTransp</a> <a id="19701" class="Symbol">:</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="19703" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a> <a id="19718" class="Symbol">{</a><a id="19719" class="Argument">ℓ</a> <a id="19721" class="Symbol">=</a> <a id="19723" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a><a id="19724" class="Symbol">}</a> <a id="19726" class="Symbol">{</a><a id="19727" class="Argument">ℓ₁</a> <a id="19730" class="Symbol">=</a> <a id="19732" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a><a id="19733" class="Symbol">}</a> <a data-type="A → A" id="19735" href="1Lab.Type.html#2348" class="Function">id</a>
<a data-type="isTransportStr id" id="19738" href="1Lab.Univalence.SIP.html#19683" class="Function">idAction-isTransp</a> <a id="19756" href="1Lab.Univalence.SIP.html#19756" class="Bound">f</a> <a id="19758" href="1Lab.Univalence.SIP.html#19758" class="Bound">s</a> <a id="19760" class="Symbol">=</a> <a data-type="x ≡ y → y ≡ x" id="19762" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="19766" class="Symbol">(</a><a data-type="(x : A) → transport (λ i → A) x ≡ x" id="19767" href="1Lab.Path.html#12012" class="Function">transport-refl</a> <a id="19782" class="Symbol">_)</a>

<a id="productAction"></a><a data-type="EqvAction S₁ → EqvAction T → EqvAction (λ X → S₁ X × T X)" id="19786" href="1Lab.Univalence.SIP.html#19786" class="Function">productAction</a> <a id="19800" class="Symbol">:</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="19802" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="19812" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="19814" class="Symbol">→</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="19816" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="19826" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a> <a id="19828" class="Symbol">→</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="19830" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="19840" class="Symbol">(λ</a> <a id="19843" href="1Lab.Univalence.SIP.html#19843" class="Bound">X</a> <a id="19845" class="Symbol">→</a> <a id="19847" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="19849" href="1Lab.Univalence.SIP.html#19843" class="Bound">X</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="19851" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="19853" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a> <a id="19855" href="1Lab.Univalence.SIP.html#19843" class="Bound">X</a><a id="19856" class="Symbol">)</a>
<a data-type="EqvAction S₁ → EqvAction T → EqvAction (λ X → S₁ X × T X)" id="19858" href="1Lab.Univalence.SIP.html#19786" class="Function">productAction</a> <a id="19872" href="1Lab.Univalence.SIP.html#19872" class="Bound">actx</a> <a id="19877" href="1Lab.Univalence.SIP.html#19877" class="Bound">acty</a> <a id="19882" href="1Lab.Univalence.SIP.html#19882" class="Bound">eqv</a> <a id="19886" class="Symbol">=</a> <a data-type="(e : A ≃ A&#39;) → ((x : A) → P x ≃ Q (e .fst x)) → Σ P ≃ Σ Q" id="19888" href="1Lab.Type.Sigma.html#2110" class="Function">Σ-ap</a> <a id="19893" class="Symbol">(</a><a id="19894" href="1Lab.Univalence.SIP.html#19872" class="Bound">actx</a> <a id="19899" href="1Lab.Univalence.SIP.html#19882" class="Bound">eqv</a><a id="19902" class="Symbol">)</a> <a id="19904" class="Symbol">λ</a> <a id="19906" href="1Lab.Univalence.SIP.html#19906" class="Bound">x</a> <a id="19908" class="Symbol">→</a> <a id="19910" href="1Lab.Univalence.SIP.html#19877" class="Bound">acty</a> <a id="19915" href="1Lab.Univalence.SIP.html#19882" class="Bound">eqv</a>

<a id="productAction-isTransp"></a><a data-type="isTransportStr α →
isTransportStr β → isTransportStr (productAction α β)" id="19920" href="1Lab.Univalence.SIP.html#19920" class="Function">productAction-isTransp</a> <a id="19943" class="Symbol">:</a> <a id="19945" class="Symbol">{</a><a id="19946" href="1Lab.Univalence.SIP.html#19946" class="Bound">α</a> <a id="19948" class="Symbol">:</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="19950" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="19960" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="19961" class="Symbol">}</a> <a id="19963" class="Symbol">{</a><a id="19964" href="1Lab.Univalence.SIP.html#19964" class="Bound">β</a> <a id="19966" class="Symbol">:</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="19968" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="19978" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a><a id="19979" class="Symbol">}</a>
                       <a id="20004" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="20006" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a> <a id="20021" href="1Lab.Univalence.SIP.html#19946" class="Bound">α</a> <a id="20023" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="20025" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a> <a id="20040" href="1Lab.Univalence.SIP.html#19964" class="Bound">β</a>
                       <a id="20065" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="20067" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a> <a id="20082" class="Symbol">(</a><a data-type="EqvAction S₁ → EqvAction T → EqvAction (λ X → S₁ X × T X)" id="20083" href="1Lab.Univalence.SIP.html#19786" class="Function">productAction</a> <a id="20097" href="1Lab.Univalence.SIP.html#19946" class="Bound">α</a> <a id="20099" href="1Lab.Univalence.SIP.html#19964" class="Bound">β</a><a id="20100" class="Symbol">)</a>
<a data-type="isTransportStr α →
isTransportStr β → isTransportStr (productAction α β)" id="20102" href="1Lab.Univalence.SIP.html#19920" class="Function">productAction-isTransp</a> <a id="20125" href="1Lab.Univalence.SIP.html#20125" class="Bound">α-tr</a> <a id="20130" href="1Lab.Univalence.SIP.html#20130" class="Bound">β-tr</a> <a id="20135" href="1Lab.Univalence.SIP.html#20135" class="Bound">e</a> <a id="20137" href="1Lab.Univalence.SIP.html#20137" class="Bound">s</a> <a id="20139" class="Symbol">=</a> <a data-type="(p : x .fst ≡ y .fst) →
PathP (λ i → B (p i)) (x .snd) (y .snd) → x ≡ y" id="20141" href="1Lab.Path.html#55212" class="Function">Σ-PathP</a> <a id="20149" class="Symbol">(</a><a id="20150" href="1Lab.Univalence.SIP.html#20125" class="Bound">α-tr</a> <a id="20155" href="1Lab.Univalence.SIP.html#20135" class="Bound">e</a> <a id="20157" class="Symbol">(</a><a id="20158" href="1Lab.Univalence.SIP.html#20137" class="Bound">s</a> <a id="20160" class="Symbol">.</a><a data-type="∑ A B → A" id="20161" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="20164" class="Symbol">))</a> <a id="20167" class="Symbol">(</a><a id="20168" href="1Lab.Univalence.SIP.html#20130" class="Bound">β-tr</a> <a id="20173" href="1Lab.Univalence.SIP.html#20135" class="Bound">e</a> <a id="20175" class="Symbol">(</a><a id="20176" href="1Lab.Univalence.SIP.html#20137" class="Bound">s</a> <a id="20178" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="20179" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="20182" class="Symbol">))</a>

<a id="functionAction"></a><a data-type="EqvAction S₁ → EqvAction T → EqvAction (λ X → S₁ X → T X)" id="20186" href="1Lab.Univalence.SIP.html#20186" class="Function">functionAction</a> <a id="20201" class="Symbol">:</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="20203" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="20213" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="20215" class="Symbol">→</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="20217" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="20227" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a> <a id="20229" class="Symbol">→</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="20231" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="20241" class="Symbol">(λ</a> <a id="20244" href="1Lab.Univalence.SIP.html#20244" class="Bound">X</a> <a id="20246" class="Symbol">→</a> <a id="20248" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="20250" href="1Lab.Univalence.SIP.html#20244" class="Bound">X</a> <a id="20252" class="Symbol">→</a> <a id="20254" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a> <a id="20256" href="1Lab.Univalence.SIP.html#20244" class="Bound">X</a><a id="20257" class="Symbol">)</a>
<a data-type="EqvAction S₁ → EqvAction T → EqvAction (λ X → S₁ X → T X)" id="20259" href="1Lab.Univalence.SIP.html#20186" class="Function">functionAction</a> <a id="20274" href="1Lab.Univalence.SIP.html#20274" class="Bound">actx</a> <a id="20279" href="1Lab.Univalence.SIP.html#20279" class="Bound">acty</a> <a id="20284" href="1Lab.Univalence.SIP.html#20284" class="Bound">eqv</a> <a id="20288" class="Symbol">=</a> <a data-type="A ≃ B → C ≃ D → (A → C) ≃ (B → D)" id="20290" href="1Lab.Type.Pi.html#1721" class="Function">function≃</a> <a id="20300" class="Symbol">(</a><a id="20301" href="1Lab.Univalence.SIP.html#20274" class="Bound">actx</a> <a id="20306" href="1Lab.Univalence.SIP.html#20284" class="Bound">eqv</a><a id="20309" class="Symbol">)</a> <a id="20311" class="Symbol">(</a><a id="20312" href="1Lab.Univalence.SIP.html#20279" class="Bound">acty</a> <a id="20317" href="1Lab.Univalence.SIP.html#20284" class="Bound">eqv</a><a id="20320" class="Symbol">)</a>

<a id="functionAction-isTransp"></a><a data-type="isTransportStr α →
isTransportStr β → isTransportStr (functionAction α β)" id="20323" href="1Lab.Univalence.SIP.html#20323" class="Function">functionAction-isTransp</a> <a id="20347" class="Symbol">:</a> <a id="20349" class="Symbol">{</a><a id="20350" href="1Lab.Univalence.SIP.html#20350" class="Bound">α</a> <a id="20352" class="Symbol">:</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="20354" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="20364" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="20365" class="Symbol">}</a> <a id="20367" class="Symbol">{</a><a id="20368" href="1Lab.Univalence.SIP.html#20368" class="Bound">β</a> <a id="20370" class="Symbol">:</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="20372" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="20382" href="1Lab.Univalence.SIP.html#3486" class="Generalizable">T</a><a id="20383" class="Symbol">}</a>
                        <a id="20409" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="20411" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a> <a id="20426" href="1Lab.Univalence.SIP.html#20350" class="Bound">α</a> <a id="20428" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="20430" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a> <a id="20445" href="1Lab.Univalence.SIP.html#20368" class="Bound">β</a>
                        <a id="20471" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="20473" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a> <a id="20488" class="Symbol">(</a><a data-type="EqvAction S₁ → EqvAction T → EqvAction (λ X → S₁ X → T X)" id="20489" href="1Lab.Univalence.SIP.html#20186" class="Function">functionAction</a> <a id="20504" href="1Lab.Univalence.SIP.html#20350" class="Bound">α</a> <a id="20506" href="1Lab.Univalence.SIP.html#20368" class="Bound">β</a><a id="20507" class="Symbol">)</a>
<a data-type="isTransportStr α →
isTransportStr β → isTransportStr (functionAction α β)" id="20509" href="1Lab.Univalence.SIP.html#20323" class="Function">functionAction-isTransp</a> <a id="20533" class="Symbol">{</a><a id="20534" class="Argument">S</a> <a id="20536" class="Symbol">=</a> <a id="20538" href="1Lab.Univalence.SIP.html#20538" class="Bound">S</a><a id="20539" class="Symbol">}</a> <a id="20541" class="Symbol">{</a><a id="20542" class="Argument">α</a> <a id="20544" class="Symbol">=</a> <a id="20546" href="1Lab.Univalence.SIP.html#20546" class="Bound">α</a><a id="20547" class="Symbol">}</a> <a id="20549" class="Symbol">{</a><a id="20550" class="Argument">β</a> <a id="20552" class="Symbol">=</a> <a id="20554" href="1Lab.Univalence.SIP.html#20554" class="Bound">β</a><a id="20555" class="Symbol">}</a> <a id="20557" href="1Lab.Univalence.SIP.html#20557" class="Bound">α-tr</a> <a id="20562" href="1Lab.Univalence.SIP.html#20562" class="Bound">β-tr</a> <a id="20567" href="1Lab.Univalence.SIP.html#20567" class="Bound">eqv</a> <a id="20571" href="1Lab.Univalence.SIP.html#20571" class="Bound">f</a> <a id="20573" class="Symbol">=</a>
  <a data-type="((x : A) → f x ≡ g x) → f ≡ g" id="20577" href="1Lab.Path.html#56413" class="Function">funext</a> <a id="20584" class="Symbol">λ</a> <a id="20586" href="1Lab.Univalence.SIP.html#20586" class="Bound">x</a> <a id="20588" class="Symbol">→</a> <a data-type="(f : (x : A) → B x) (p : x ≡ y) → PathP (λ i → B (p i)) (f x) (f y)" id="20590" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="20593" class="Symbol">(</a><a id="20594" href="1Lab.Univalence.SIP.html#20554" class="Bound">β</a> <a id="20596" href="1Lab.Univalence.SIP.html#20567" class="Bound">eqv</a> <a id="20600" class="Symbol">.</a><a data-type="∑ A B → A" id="20601" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="(B → C) → (A → B) → A → C" id="20605" href="1Lab.Type.html#2217" class="Function Operator">∘</a> <a id="20607" href="1Lab.Univalence.SIP.html#20571" class="Bound">f</a><a id="20608" class="Symbol">)</a> <a id="20610" class="Symbol">(</a><a id="20611" href="1Lab.Univalence.SIP.html#15733" class="Function">transportStr⁻¹</a> <a id="20626" href="1Lab.Univalence.SIP.html#20546" class="Bound">α</a> <a id="20628" href="1Lab.Univalence.SIP.html#20557" class="Bound">α-tr</a> <a id="20633" href="1Lab.Univalence.SIP.html#20567" class="Bound">eqv</a> <a id="20637" href="1Lab.Univalence.SIP.html#20586" class="Bound">x</a><a id="20638" class="Symbol">)</a>
             <a data-type="x ≡ y → y ≡ z → x ≡ z" id="20653" href="1Lab.Path.html#38031" class="Function Operator">∙</a> <a id="20655" href="1Lab.Univalence.SIP.html#20562" class="Bound">β-tr</a> <a id="20660" href="1Lab.Univalence.SIP.html#20567" class="Bound">eqv</a> <a id="20664" class="Symbol">(</a><a id="20665" href="1Lab.Univalence.SIP.html#20571" class="Bound">f</a> <a id="20667" class="Symbol">(</a><a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="20668" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="20674" href="1Lab.Univalence.SIP.html#20538" class="Bound">S</a> <a id="20676" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="20677" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="20681" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="20682" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="20685" href="1Lab.Univalence.SIP.html#20567" class="Bound">eqv</a><a id="20688" class="Symbol">))</a> <a id="20691" href="1Lab.Univalence.SIP.html#20586" class="Bound">x</a><a id="20692" class="Symbol">))</a>
</pre>
</details>
<h1 id="adding-axioms"><a href="#adding-axioms" class="header-link">Adding Axioms<span class="header-link-emoji">🔗</span></a></h1>
<p>Most mathematical objects of interest aren’t merely sets with structure. More often, the objects we’re interested in have <em>stuff</em> (the underlying type), <em>structure</em> (such as a <code class="sourceCode agda">SNS</code>), and <em>properties</em> - for instance, equations imposed on the structure. A concrete example may help:</p>
<ul class="incremental">
<li><p>A <strong>pointed <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>-magma</span></strong> is a pointed type equipped with a binary operation;</p></li>
<li><p>A <strong>monoid</strong> is a pointed <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord">∞</span></span></span></span>-magma</span> with additional data witnessing that a) the type is a set; b) the operation is associative; and c) the point acts as a left- and right- identity for the operation.</p></li>
</ul>
<p>Fortunately, the SIP again applies here: If you augment a standard notion of structure with <em>axioms</em>, then equality of structures with axioms is still isomorphism of the underlying structures. For this, we require that the axioms be <a data-type="Type ℓ → Type ℓ" href="1Lab.HLevel.html#2594">valued in propositions</a>.</p>
<pre class="Agda"><a id="21605" class="Keyword">module</a> <a id="21612" href="1Lab.Univalence.SIP.html#21612" class="Module">_</a>
  <a id="21616" class="Symbol">(</a><a id="21617" href="1Lab.Univalence.SIP.html#21617" class="Bound">σ</a> <a id="21619" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="21621" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="21631" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="21633" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="21634" class="Symbol">)</a>
  <a id="21638" class="Symbol">(</a><a id="21639" href="1Lab.Univalence.SIP.html#21639" class="Bound">axioms</a> <a id="21646" class="Symbol">:</a> <a id="21648" class="Symbol">(</a><a id="21649" href="1Lab.Univalence.SIP.html#21649" class="Bound">X</a> <a id="21651" class="Symbol">:</a> <a id="21653" class="Symbol">_)</a> <a id="21656" class="Symbol">→</a> <a id="21658" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="21660" href="1Lab.Univalence.SIP.html#21649" class="Bound">X</a> <a id="21662" class="Symbol">→</a> <a id="21664" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="21669" href="1Lab.Univalence.SIP.html#3458" class="Generalizable">ℓ₃</a><a id="21671" class="Symbol">)</a>
  <a id="21675" class="Keyword">where</a>
</pre>
<p>First, the notion of structure that you get is just a lifting of the underlying structure <code>σ</code> to ignore the witnesses for the axioms:</p>
<pre class="Agda">  <a data-type="(σ : Structure ℓ S₁) (axioms : (X : Type S.ℓ) → S₁ X → Type ℓ₃) →
Structure ℓ (λ X → Σ (axioms X))" id="21831" href="1Lab.Univalence.SIP.html#21831" class="Function">axiomsStr</a> <a id="21841" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="21843" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="21853" href="1Lab.Univalence.SIP.html#21631" class="Bound">ℓ</a> <a id="21855" class="Symbol">(λ</a> <a id="21858" href="1Lab.Univalence.SIP.html#21858" class="Bound">X</a> <a id="21860" class="Symbol">→</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="21862" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="21865" href="1Lab.Univalence.SIP.html#21865" class="Bound">s</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="21867" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="21869" href="1Lab.Univalence.SIP.html#21633" class="Bound">S</a> <a id="21871" href="1Lab.Univalence.SIP.html#21858" class="Bound">X</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="21873" href="1Lab.Type.html#1563" class="Function">]</a> <a id="21875" class="Symbol">(</a><a id="21876" href="1Lab.Univalence.SIP.html#21639" class="Bound">axioms</a> <a id="21883" href="1Lab.Univalence.SIP.html#21858" class="Bound">X</a> <a id="21885" href="1Lab.Univalence.SIP.html#21865" class="Bound">s</a><a id="21886" class="Symbol">))</a>
  <a data-type="(σ : Structure ℓ S₁) (axioms : (X : Type S.ℓ) → S₁ X → Type ℓ₃) →
Structure ℓ (λ X → Σ (axioms X))" id="21891" href="1Lab.Univalence.SIP.html#21831" class="Function">axiomsStr</a> <a id="21901" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="21902" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="21909" class="Symbol">(</a><a id="21910" href="1Lab.Univalence.SIP.html#21910" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="21912" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="21914" href="1Lab.Univalence.SIP.html#21914" class="Bound">s</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="21916" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="21918" href="1Lab.Univalence.SIP.html#21918" class="Bound">a</a><a id="21919" class="Symbol">)</a> <a id="21921" class="Symbol">(</a><a id="21922" href="1Lab.Univalence.SIP.html#21922" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="21924" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="21926" href="1Lab.Univalence.SIP.html#21926" class="Bound">t</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="21928" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="21930" href="1Lab.Univalence.SIP.html#21930" class="Bound">b</a><a id="21931" class="Symbol">)</a> <a id="21933" href="1Lab.Univalence.SIP.html#21933" class="Bound">f</a> <a id="21935" class="Symbol">=</a>
    <a id="21941" href="1Lab.Univalence.SIP.html#21617" class="Bound">σ</a> <a id="21943" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="21944" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="21951" class="Symbol">(</a><a id="21952" href="1Lab.Univalence.SIP.html#21910" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="21954" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="21956" href="1Lab.Univalence.SIP.html#21914" class="Bound">s</a><a id="21957" class="Symbol">)</a> <a id="21959" class="Symbol">(</a><a id="21960" href="1Lab.Univalence.SIP.html#21922" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="21962" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="21964" href="1Lab.Univalence.SIP.html#21926" class="Bound">t</a><a id="21965" class="Symbol">)</a> <a id="21967" href="1Lab.Univalence.SIP.html#21933" class="Bound">f</a>
</pre>
<p>Then, if the axioms are propositional, a calculation by equivalence reasoning concludes what we wanted: <span class="Agda"><a data-type="(σ : Structure ℓ S₁) (axioms : (X : Type S.ℓ) → S₁ X → Type ℓ₃) →
Structure ℓ (λ X → Σ (axioms X))" href="1Lab.Univalence.SIP.html#21831" class="Function">axiomsStr</a></span> is univalent.</p>
<pre class="Agda">  <a id="22122" class="Keyword">module</a> <a id="22129" href="1Lab.Univalence.SIP.html#22129" class="Module">_</a>
    <a id="22135" class="Symbol">(</a><a id="22136" href="1Lab.Univalence.SIP.html#22136" class="Bound">univ</a> <a id="22141" class="Symbol">:</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="22143" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="22155" href="1Lab.Univalence.SIP.html#21617" class="Bound">σ</a><a id="22156" class="Symbol">)</a>
    <a id="22162" class="Symbol">(</a><a id="22163" href="1Lab.Univalence.SIP.html#22163" class="Bound">axioms-prop</a> <a id="22175" class="Symbol">:</a> <a id="22177" class="Symbol">∀</a> <a id="22179" class="Symbol">{</a><a id="22180" href="1Lab.Univalence.SIP.html#22180" class="Bound">X</a><a id="22181" class="Symbol">}</a> <a id="22183" class="Symbol">{</a><a id="22184" href="1Lab.Univalence.SIP.html#22184" class="Bound">s</a><a id="22185" class="Symbol">}</a> <a id="22187" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="22189" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="22196" class="Symbol">(</a><a id="22197" href="1Lab.Univalence.SIP.html#21639" class="Bound">axioms</a> <a id="22204" href="1Lab.Univalence.SIP.html#22180" class="Bound">X</a> <a id="22206" href="1Lab.Univalence.SIP.html#22184" class="Bound">s</a><a id="22207" class="Symbol">))</a> <a id="22210" class="Keyword">where</a>
    <a data-type="(σ : Structure ℓ S₁) (axioms : (X : Type S.ℓ) → S₁ X → Type ℓ₃)
(univ : isUnivalent σ) (axioms-prop : isProp (axioms X s)) →
isUnivalent (axiomsStr σ axioms)" id="22220" href="1Lab.Univalence.SIP.html#22220" class="Function">axiomsStr-univalent</a> <a id="22240" class="Symbol">:</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="22242" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a data-type="(σ : Structure ℓ S₁) (axioms : (X : Type S.ℓ) → S₁ X → Type ℓ₃) →
Structure ℓ (λ X → Σ (axioms X))" id="22254" href="1Lab.Univalence.SIP.html#21831" class="Function">axiomsStr</a>
    <a data-type="(σ : Structure ℓ S₁) (axioms : (X : Type S.ℓ) → S₁ X → Type ℓ₃)
(univ : isUnivalent σ) (axioms-prop : isProp (axioms X s)) →
isUnivalent (axiomsStr σ axioms)" id="22268" href="1Lab.Univalence.SIP.html#22220" class="Function">axiomsStr-univalent</a> <a id="22288" class="Symbol">{</a><a id="22289" class="Argument">X</a> <a id="22291" class="Symbol">=</a> <a id="22293" href="1Lab.Univalence.SIP.html#22293" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="22295" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="22297" href="1Lab.Univalence.SIP.html#22297" class="Bound">s</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="22299" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="22301" href="1Lab.Univalence.SIP.html#22301" class="Bound">a</a><a id="22302" class="Symbol">}</a> <a id="22304" class="Symbol">{</a><a id="22305" class="Argument">Y</a> <a id="22307" class="Symbol">=</a> <a id="22309" href="1Lab.Univalence.SIP.html#22309" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="22311" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="22313" href="1Lab.Univalence.SIP.html#22313" class="Bound">t</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="22315" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="22317" href="1Lab.Univalence.SIP.html#22317" class="Bound">b</a><a id="22318" class="Symbol">}</a> <a id="22320" href="1Lab.Univalence.SIP.html#22320" class="Bound">f</a> <a id="22322" class="Symbol">=</a>
      <a id="22330" href="1Lab.Univalence.SIP.html#21617" class="Bound">σ</a> <a id="22332" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="22333" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="22340" class="Symbol">(</a><a id="22341" href="1Lab.Univalence.SIP.html#22293" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="22343" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="22345" href="1Lab.Univalence.SIP.html#22297" class="Bound">s</a><a id="22346" class="Symbol">)</a> <a id="22348" class="Symbol">(</a><a id="22349" href="1Lab.Univalence.SIP.html#22309" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="22351" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="22353" href="1Lab.Univalence.SIP.html#22313" class="Bound">t</a><a id="22354" class="Symbol">)</a> <a id="22356" href="1Lab.Univalence.SIP.html#22320" class="Bound">f</a>
        <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="22366" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a id="22369" href="1Lab.Univalence.SIP.html#22136" class="Bound">univ</a> <a id="22374" href="1Lab.Univalence.SIP.html#22320" class="Bound">f</a> <a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="22376" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
      <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="22384" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="22390" class="Symbol">(λ</a> <a id="22393" href="1Lab.Univalence.SIP.html#22393" class="Bound">i</a> <a id="22395" class="Symbol">→</a> <a id="22397" href="1Lab.Univalence.SIP.html#21633" class="Bound">S</a> <a id="22399" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="22400" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="22403" href="1Lab.Univalence.SIP.html#22320" class="Bound">f</a> <a id="22405" href="1Lab.Univalence.SIP.html#22393" class="Bound">i</a><a id="22406" class="Symbol">))</a> <a id="22409" href="1Lab.Univalence.SIP.html#22297" class="Bound">s</a> <a id="22411" href="1Lab.Univalence.SIP.html#22313" class="Bound">t</a> 
        <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="22422" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a data-type="((x : A) → isContr (B x)) → Σ B ≃ A" id="22425" href="1Lab.Type.Sigma.html#6996" class="Function">Σ-contract</a> <a id="22436" class="Symbol">(λ</a> <a id="22439" href="1Lab.Univalence.SIP.html#22439" class="Bound">x</a> <a id="22441" class="Symbol">→</a> <a data-type="(n : Nat) → isHLevel (A i1) n → isHLevel (PathP A x y) n" id="22443" href="1Lab.HLevel.html#9918" class="Function">isHLevelPathP</a> <a id="22457" class="Number">0</a> <a id="22459" class="Symbol">(</a><a data-type="(centre₁ : A) (paths₁ : (x : A) → centre₁ ≡ x) → isContr A" id="22460" href="1Lab.HLevel.html#1382" class="InductiveConstructor">contr</a> <a id="22466" href="1Lab.Univalence.SIP.html#22317" class="Bound">b</a> <a id="22468" class="Symbol">(</a><a id="22469" href="1Lab.Univalence.SIP.html#22163" class="Bound">axioms-prop</a> <a id="22481" href="1Lab.Univalence.SIP.html#22317" class="Bound">b</a><a id="22482" class="Symbol">)))</a> <a data-type="A ≃ B → B ≃ A" id="22486" href="1Lab.Equiv.html#21246" class="Function Operator">e⁻¹</a> <a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="22490" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
      <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="22498" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="22501" href="1Lab.Univalence.SIP.html#22501" class="Bound">p</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="22503" href="1Lab.Type.html#1563" class="Function">∈</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="22505" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="22511" class="Symbol">(λ</a> <a id="22514" href="1Lab.Univalence.SIP.html#22514" class="Bound">i</a> <a id="22516" class="Symbol">→</a> <a id="22518" href="1Lab.Univalence.SIP.html#21633" class="Bound">S</a> <a id="22520" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="22521" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="22524" href="1Lab.Univalence.SIP.html#22320" class="Bound">f</a> <a id="22526" href="1Lab.Univalence.SIP.html#22514" class="Bound">i</a><a id="22527" class="Symbol">))</a> <a id="22530" href="1Lab.Univalence.SIP.html#22297" class="Bound">s</a> <a id="22532" href="1Lab.Univalence.SIP.html#22313" class="Bound">t</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="22534" href="1Lab.Type.html#1563" class="Function">]</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="22536" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="22542" class="Symbol">(λ</a> <a id="22545" href="1Lab.Univalence.SIP.html#22545" class="Bound">i</a> <a id="22547" class="Symbol">→</a> <a id="22549" href="1Lab.Univalence.SIP.html#21639" class="Bound">axioms</a> <a id="22556" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="22557" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="22560" href="1Lab.Univalence.SIP.html#22320" class="Bound">f</a> <a id="22562" href="1Lab.Univalence.SIP.html#22545" class="Bound">i</a><a id="22563" class="Symbol">)</a> <a id="22565" class="Symbol">(</a><a id="22566" href="1Lab.Univalence.SIP.html#22501" class="Bound">p</a> <a id="22568" href="1Lab.Univalence.SIP.html#22545" class="Bound">i</a><a id="22569" class="Symbol">))</a> <a id="22572" href="1Lab.Univalence.SIP.html#22301" class="Bound">a</a> <a id="22574" href="1Lab.Univalence.SIP.html#22317" class="Bound">b</a>
        <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="22584" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a data-type="Iso A B → A ≃ B" id="22587" href="1Lab.Equiv.html#20090" class="Function">Iso→Equiv</a> <a data-type="Iso (Σ (λ p → PathP (λ i → B i (p i)) (x .snd) (y .snd)))
(PathP (λ i → Σ (B i)) x y)" id="22597" href="1Lab.Type.Sigma.html#553" class="Function">Σ-PathP-iso</a> <a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="22609" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
      <a id="22617" class="Symbol">_</a>
        <a data-type="(A : Type ℓ) → A ≃ A" id="22627" href="1Lab.Equiv.html#23023" class="Function Operator">≃∎</a>
</pre>
<p>Here, another facet of the trade-offs between transport and univalent structures make themselves clear: It’s possible (albeit less than straightforward) to add axioms to a <em>univalent</em> structure, but without imposing further structure on the axioms themselves, it is not clear how to add axioms to a <em>transport</em> structure.</p>
<p>Regardless, a very useful consequence of the SIP is that axioms can be lifted from equivalent underlying structures. For instance: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\mathbb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">N</span></span></span></span> can be defined as both unary numbers (the construction of <code class="sourceCode agda">Nat</code>), or as binary numbers. If you prove that <code class="sourceCode agda">Nat</code> is a monoid, and <code>Nat ≃ Bin</code> as pointed ∞-magmas, then <code>Bin</code> inherits the monoid structure.</p>
<pre class="Agda"><a id="transferAxioms"></a><a data-type="(A : TypeWith (axiomsStr σ axioms)) (B : TypeWith σ) →
(A .fst , A .snd .fst) ≃[ σ ] B → axioms (B .fst) (B .snd)" id="23329" href="1Lab.Univalence.SIP.html#23329" class="Function">transferAxioms</a> 
  <a id="23347" class="Symbol">:</a> <a id="23349" class="Symbol">{</a><a id="23350" href="1Lab.Univalence.SIP.html#23350" class="Bound">σ</a> <a id="23352" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="23354" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="23364" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="23366" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="23367" class="Symbol">}</a> <a id="23369" class="Symbol">{</a><a id="23370" href="1Lab.Univalence.SIP.html#23370" class="Bound">univ</a> <a id="23375" class="Symbol">:</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="23377" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="23389" href="1Lab.Univalence.SIP.html#23350" class="Bound">σ</a><a id="23390" class="Symbol">}</a>
    <a id="23396" class="Symbol">{</a><a id="23397" href="1Lab.Univalence.SIP.html#23397" class="Bound">axioms</a> <a id="23404" class="Symbol">:</a> <a id="23406" class="Symbol">(</a><a id="23407" href="1Lab.Univalence.SIP.html#23407" class="Bound">X</a> <a id="23409" class="Symbol">:</a> <a id="23411" class="Symbol">_)</a> <a id="23414" class="Symbol">→</a> <a id="23416" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="23418" href="1Lab.Univalence.SIP.html#23407" class="Bound">X</a> <a id="23420" class="Symbol">→</a> <a id="23422" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="23427" href="1Lab.Univalence.SIP.html#3458" class="Generalizable">ℓ₃</a><a id="23429" class="Symbol">}</a>
  <a id="23433" class="Symbol">→</a> <a id="23435" class="Symbol">(</a><a id="23436" href="1Lab.Univalence.SIP.html#23436" class="Bound">A</a> <a id="23438" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="23440" href="1Lab.Univalence.SIP.html#3316" class="Function">TypeWith</a> <a id="23449" class="Symbol">(</a><a data-type="(σ : Structure ℓ S₁) (axioms : (X : Type S.ℓ) → S₁ X → Type ℓ₃) →
Structure ℓ (λ X → Σ (axioms X))" id="23450" href="1Lab.Univalence.SIP.html#21831" class="Function">axiomsStr</a> <a id="23460" href="1Lab.Univalence.SIP.html#23350" class="Bound">σ</a> <a id="23462" href="1Lab.Univalence.SIP.html#23397" class="Bound">axioms</a><a id="23468" class="Symbol">))</a> <a id="23471" class="Symbol">(</a><a id="23472" href="1Lab.Univalence.SIP.html#23472" class="Bound">B</a> <a id="23474" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="23476" href="1Lab.Univalence.SIP.html#3316" class="Function">TypeWith</a> <a id="23485" href="1Lab.Univalence.SIP.html#23350" class="Bound">σ</a><a id="23486" class="Symbol">)</a>
  <a id="23490" class="Symbol">→</a> <a id="23492" class="Symbol">(</a><a id="23493" href="1Lab.Univalence.SIP.html#23436" class="Bound">A</a> <a id="23495" class="Symbol">.</a><a data-type="∑ A B → A" id="23496" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="23500" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23502" href="1Lab.Univalence.SIP.html#23436" class="Bound">A</a> <a id="23504" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="23505" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="23509" class="Symbol">.</a><a data-type="∑ A B → A" id="23510" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="23513" class="Symbol">)</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="23515" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">≃[</a> <a id="23518" href="1Lab.Univalence.SIP.html#23350" class="Bound">σ</a> <a data-type="Σ S₁ → Structure ℓ S₁ → Σ S₁ → Type (S.ℓ ⊔ ℓ)" id="23520" href="1Lab.Univalence.SIP.html#4204" class="Function Operator">]</a> <a id="23522" href="1Lab.Univalence.SIP.html#23472" class="Bound">B</a>
  <a id="23526" class="Symbol">→</a> <a id="23528" href="1Lab.Univalence.SIP.html#23397" class="Bound">axioms</a> <a id="23535" class="Symbol">(</a><a id="23536" href="1Lab.Univalence.SIP.html#23472" class="Bound">B</a> <a id="23538" class="Symbol">.</a><a data-type="∑ A B → A" id="23539" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="23542" class="Symbol">)</a> <a id="23544" class="Symbol">(</a><a id="23545" href="1Lab.Univalence.SIP.html#23472" class="Bound">B</a> <a id="23547" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="23548" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="23551" class="Symbol">)</a>
<a data-type="(A : TypeWith (axiomsStr σ axioms)) (B : TypeWith σ) →
(A .fst , A .snd .fst) ≃[ σ ] B → axioms (B .fst) (B .snd)" id="23553" href="1Lab.Univalence.SIP.html#23329" class="Function">transferAxioms</a> <a id="23568" class="Symbol">{</a><a id="23569" class="Argument">univ</a> <a id="23574" class="Symbol">=</a> <a id="23576" href="1Lab.Univalence.SIP.html#23576" class="Bound">univ</a><a id="23580" class="Symbol">}</a> <a id="23582" class="Symbol">{</a><a id="23583" class="Argument">axioms</a> <a id="23590" class="Symbol">=</a> <a id="23592" href="1Lab.Univalence.SIP.html#23592" class="Bound">axioms</a><a id="23598" class="Symbol">}</a> <a id="23600" href="1Lab.Univalence.SIP.html#23600" class="Bound">A</a> <a id="23602" href="1Lab.Univalence.SIP.html#23602" class="Bound">B</a> <a id="23604" href="1Lab.Univalence.SIP.html#23604" class="Bound">eqv</a> <a id="23608" class="Symbol">=</a>
  <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="23612" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="23618" class="Symbol">(λ</a> <a id="23621" class="Symbol">{</a> <a id="23623" class="Symbol">(</a><a id="23624" href="1Lab.Univalence.SIP.html#23624" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="23626" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23628" href="1Lab.Univalence.SIP.html#23628" class="Bound">y</a><a id="23629" class="Symbol">)</a> <a id="23631" class="Symbol">→</a> <a id="23633" href="1Lab.Univalence.SIP.html#23592" class="Bound">axioms</a> <a id="23640" href="1Lab.Univalence.SIP.html#23624" class="Bound">x</a> <a id="23642" href="1Lab.Univalence.SIP.html#23628" class="Bound">y</a> <a id="23644" class="Symbol">})</a> <a id="23647" class="Symbol">(</a><a data-type="isUnivalent σ → X ≃[ σ ] Y → X ≡ Y" id="23648" href="1Lab.Univalence.SIP.html#5488" class="Function">sip</a> <a id="23652" href="1Lab.Univalence.SIP.html#23576" class="Bound">univ</a> <a id="23657" href="1Lab.Univalence.SIP.html#23604" class="Bound">eqv</a><a id="23660" class="Symbol">)</a> <a id="23662" class="Symbol">(</a><a id="23663" href="1Lab.Univalence.SIP.html#23600" class="Bound">A</a> <a id="23665" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="23666" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="23670" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="23671" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="23674" class="Symbol">)</a>
</pre>
<h1 id="a-language-for-structures"><a href="#a-language-for-structures" class="header-link">A Language for Structures<span class="header-link-emoji">🔗</span></a></h1>
<p>The structure combinators can be abstracted away into a <em>language</em> for defining structures. A <span class="Agda"><a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" href="1Lab.Univalence.SIP.html#23979" class="Datatype">StrTm</a></span> describes a structure, that may be <code class="sourceCode agda" data-ident="interp">interpreted</code> into a family of types, and defines both transport and univalent structures.</p>
<pre class="Agda"><a id="23974" class="Keyword">data</a> <a id="StrTm"></a><a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="23979" href="1Lab.Univalence.SIP.html#23979" class="Datatype">StrTm</a> <a id="23985" href="1Lab.Univalence.SIP.html#23985" class="Bound">ℓ</a> <a id="23987" class="Symbol">:</a> <a id="23989" class="Symbol">(</a><a id="23990" href="1Lab.Univalence.SIP.html#23990" class="Bound">ℓ₁</a> <a id="23993" class="Symbol">:</a> <a data-type="Type" id="23995" href="Agda.Primitive.html#597" class="Postulate">Level</a><a id="24000" class="Symbol">)</a> <a id="24002" class="Symbol">→</a> <a id="24004" class="Symbol">(</a><a id="24005" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="24010" href="1Lab.Univalence.SIP.html#23985" class="Bound">ℓ</a> <a id="24012" class="Symbol">→</a> <a id="24014" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="24019" href="1Lab.Univalence.SIP.html#23990" class="Bound">ℓ₁</a><a id="24021" class="Symbol">)</a> <a id="24023" class="Symbol">→</a> <a id="24025" href="1Lab.Type.html#409" class="Primitive">Typeω</a> <a id="24031" class="Keyword">where</a>
  <a id="StrTm.s-const"></a><a data-type="(A : Type ℓ₁) → StrTm ℓ ℓ₁ (λ X → A)" id="24039" href="1Lab.Univalence.SIP.html#24039" class="InductiveConstructor">s-const</a> <a id="24047" class="Symbol">:</a> <a id="24049" class="Symbol">∀</a> <a id="24051" class="Symbol">{</a><a id="24052" href="1Lab.Univalence.SIP.html#24052" class="Bound">ℓ₁</a><a id="24054" class="Symbol">}</a> <a id="24056" class="Symbol">(</a><a id="24057" href="1Lab.Univalence.SIP.html#24057" class="Bound">A</a> <a id="24059" class="Symbol">:</a> <a id="24061" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="24066" href="1Lab.Univalence.SIP.html#24052" class="Bound">ℓ₁</a><a id="24068" class="Symbol">)</a> <a id="24070" class="Symbol">→</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="24072" href="1Lab.Univalence.SIP.html#23979" class="Datatype">StrTm</a> <a id="24078" href="1Lab.Univalence.SIP.html#23985" class="Bound">ℓ</a> <a id="24080" href="1Lab.Univalence.SIP.html#24052" class="Bound">ℓ₁</a> <a id="24083" class="Symbol">(λ</a> <a id="24086" href="1Lab.Univalence.SIP.html#24086" class="Bound">X</a> <a id="24088" class="Symbol">→</a> <a id="24090" href="1Lab.Univalence.SIP.html#24057" class="Bound">A</a><a id="24091" class="Symbol">)</a>
  <a id="StrTm.s∙"></a><a data-type="StrTm ℓ ℓ (λ X → X)" id="24095" href="1Lab.Univalence.SIP.html#24095" class="InductiveConstructor">s∙</a>      <a id="24103" class="Symbol">:</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="24105" href="1Lab.Univalence.SIP.html#23979" class="Datatype">StrTm</a> <a id="24111" href="1Lab.Univalence.SIP.html#23985" class="Bound">ℓ</a> <a id="24113" href="1Lab.Univalence.SIP.html#23985" class="Bound">ℓ</a> <a id="24115" class="Symbol">(λ</a> <a id="24118" href="1Lab.Univalence.SIP.html#24118" class="Bound">X</a> <a id="24120" class="Symbol">→</a> <a id="24122" href="1Lab.Univalence.SIP.html#24118" class="Bound">X</a><a id="24123" class="Symbol">)</a>
  <a id="StrTm._s→_"></a><a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="24127" href="1Lab.Univalence.SIP.html#24127" class="InductiveConstructor Operator">_s→_</a>    <a id="24135" class="Symbol">:</a> <a id="24137" class="Symbol">∀</a> <a id="24139" class="Symbol">{</a><a id="24140" href="1Lab.Univalence.SIP.html#24140" class="Bound">ℓ₁</a> <a id="24143" href="1Lab.Univalence.SIP.html#24143" class="Bound">ℓ₂</a><a id="24145" class="Symbol">}</a> <a id="24147" class="Symbol">{</a><a id="24148" href="1Lab.Univalence.SIP.html#24148" class="Bound">S</a><a id="24149" class="Symbol">}</a> <a id="24151" class="Symbol">{</a><a id="24152" href="1Lab.Univalence.SIP.html#24152" class="Bound">T</a><a id="24153" class="Symbol">}</a> <a id="24155" class="Symbol">→</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="24157" href="1Lab.Univalence.SIP.html#23979" class="Datatype">StrTm</a> <a id="24163" href="1Lab.Univalence.SIP.html#23985" class="Bound">ℓ</a> <a id="24165" href="1Lab.Univalence.SIP.html#24140" class="Bound">ℓ₁</a> <a id="24168" href="1Lab.Univalence.SIP.html#24148" class="Bound">S</a> <a id="24170" class="Symbol">→</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="24172" href="1Lab.Univalence.SIP.html#23979" class="Datatype">StrTm</a> <a id="24178" href="1Lab.Univalence.SIP.html#23985" class="Bound">ℓ</a> <a id="24180" href="1Lab.Univalence.SIP.html#24143" class="Bound">ℓ₂</a> <a id="24183" href="1Lab.Univalence.SIP.html#24152" class="Bound">T</a> <a id="24185" class="Symbol">→</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="24187" href="1Lab.Univalence.SIP.html#23979" class="Datatype">StrTm</a> <a id="24193" href="1Lab.Univalence.SIP.html#23985" class="Bound">ℓ</a> <a id="24195" class="Symbol">(</a><a id="24196" href="1Lab.Univalence.SIP.html#24140" class="Bound">ℓ₁</a> <a data-type="Level → Level → Level" id="24199" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="24201" href="1Lab.Univalence.SIP.html#24143" class="Bound">ℓ₂</a><a id="24203" class="Symbol">)</a> <a id="24205" class="Symbol">(λ</a> <a id="24208" href="1Lab.Univalence.SIP.html#24208" class="Bound">X</a> <a id="24210" class="Symbol">→</a> <a id="24212" href="1Lab.Univalence.SIP.html#24148" class="Bound">S</a> <a id="24214" href="1Lab.Univalence.SIP.html#24208" class="Bound">X</a> <a id="24216" class="Symbol">→</a> <a id="24218" href="1Lab.Univalence.SIP.html#24152" class="Bound">T</a> <a id="24220" href="1Lab.Univalence.SIP.html#24208" class="Bound">X</a><a id="24221" class="Symbol">)</a>
  <a id="StrTm._s×_"></a><a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="24225" href="1Lab.Univalence.SIP.html#24225" class="InductiveConstructor Operator">_s×_</a>    <a id="24233" class="Symbol">:</a> <a id="24235" class="Symbol">∀</a> <a id="24237" class="Symbol">{</a><a id="24238" href="1Lab.Univalence.SIP.html#24238" class="Bound">ℓ₁</a> <a id="24241" href="1Lab.Univalence.SIP.html#24241" class="Bound">ℓ₂</a><a id="24243" class="Symbol">}</a> <a id="24245" class="Symbol">{</a><a id="24246" href="1Lab.Univalence.SIP.html#24246" class="Bound">S</a><a id="24247" class="Symbol">}</a> <a id="24249" class="Symbol">{</a><a id="24250" href="1Lab.Univalence.SIP.html#24250" class="Bound">T</a><a id="24251" class="Symbol">}</a> <a id="24253" class="Symbol">→</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="24255" href="1Lab.Univalence.SIP.html#23979" class="Datatype">StrTm</a> <a id="24261" href="1Lab.Univalence.SIP.html#23985" class="Bound">ℓ</a> <a id="24263" href="1Lab.Univalence.SIP.html#24238" class="Bound">ℓ₁</a> <a id="24266" href="1Lab.Univalence.SIP.html#24246" class="Bound">S</a> <a id="24268" class="Symbol">→</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="24270" href="1Lab.Univalence.SIP.html#23979" class="Datatype">StrTm</a> <a id="24276" href="1Lab.Univalence.SIP.html#23985" class="Bound">ℓ</a> <a id="24278" href="1Lab.Univalence.SIP.html#24241" class="Bound">ℓ₂</a> <a id="24281" href="1Lab.Univalence.SIP.html#24250" class="Bound">T</a> <a id="24283" class="Symbol">→</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="24285" href="1Lab.Univalence.SIP.html#23979" class="Datatype">StrTm</a> <a id="24291" href="1Lab.Univalence.SIP.html#23985" class="Bound">ℓ</a> <a id="24293" class="Symbol">(</a><a id="24294" href="1Lab.Univalence.SIP.html#24238" class="Bound">ℓ₁</a> <a data-type="Level → Level → Level" id="24297" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="24299" href="1Lab.Univalence.SIP.html#24241" class="Bound">ℓ₂</a><a id="24301" class="Symbol">)</a> <a id="24303" class="Symbol">(λ</a> <a id="24306" href="1Lab.Univalence.SIP.html#24306" class="Bound">X</a> <a id="24308" class="Symbol">→</a> <a id="24310" href="1Lab.Univalence.SIP.html#24246" class="Bound">S</a> <a id="24312" href="1Lab.Univalence.SIP.html#24306" class="Bound">X</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="24314" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="24316" href="1Lab.Univalence.SIP.html#24250" class="Bound">T</a> <a id="24318" href="1Lab.Univalence.SIP.html#24306" class="Bound">X</a><a id="24319" class="Symbol">)</a>

<a id="24322" class="Keyword">infixr</a> <a id="24329" class="Number">30</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="24332" href="1Lab.Univalence.SIP.html#24127" class="InductiveConstructor Operator">_s→_</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="24337" href="1Lab.Univalence.SIP.html#24225" class="InductiveConstructor Operator">_s×_</a>
</pre>
<p>Since each term of the language corresponds to one of the combinators for building univalent structures, a pair of <em>mutually recursive</em> functions lets us derive a <span class="Agda"><a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a></span> and an <span class="Agda"><a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" href="1Lab.Univalence.SIP.html#13541" class="Function">action on equivalences</a></span> from a term, at the same time.</p>
<pre class="Agda"><a id="tm→Structure"></a><a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="24624" href="1Lab.Univalence.SIP.html#24624" class="Function">tm→Structure</a> <a id="24637" class="Symbol">:</a> <a id="24639" class="Symbol">(</a><a id="24640" href="1Lab.Univalence.SIP.html#24640" class="Bound">s</a> <a id="24642" class="Symbol">:</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="24644" href="1Lab.Univalence.SIP.html#23979" class="Datatype">StrTm</a> <a id="24650" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="24652" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a> <a id="24655" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="24656" class="Symbol">)</a> <a id="24658" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="24660" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="24670" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a> <a id="24673" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a>
<a id="tm→Action"></a><a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="24675" href="1Lab.Univalence.SIP.html#24675" class="Function">tm→Action</a> <a id="24685" class="Symbol">:</a> <a id="24687" class="Symbol">(</a><a id="24688" href="1Lab.Univalence.SIP.html#24688" class="Bound">s</a> <a id="24690" class="Symbol">:</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="24692" href="1Lab.Univalence.SIP.html#23979" class="Datatype">StrTm</a> <a id="24698" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="24700" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a> <a id="24703" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="24704" class="Symbol">)</a> <a id="24706" class="Symbol">→</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="24708" href="1Lab.Univalence.SIP.html#13541" class="Function">EqvAction</a> <a id="24718" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a>

<a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="24721" href="1Lab.Univalence.SIP.html#24624" class="Function">tm→Structure</a> <a id="24734" class="Symbol">(</a><a data-type="(A : Type ℓ₁) → StrTm ℓ ℓ₁ (λ X → A)" id="24735" href="1Lab.Univalence.SIP.html#24039" class="InductiveConstructor">s-const</a> <a id="24743" href="1Lab.Univalence.SIP.html#24743" class="Bound">x</a><a id="24744" class="Symbol">)</a> <a id="24746" class="Symbol">=</a> <a data-type="(A : Type ℓ) → Structure ℓ (λ X → A)" id="24748" href="1Lab.Univalence.SIP.html#6188" class="Function">constantStr</a> <a id="24760" href="1Lab.Univalence.SIP.html#24743" class="Bound">x</a>
<a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="24762" href="1Lab.Univalence.SIP.html#24624" class="Function">tm→Structure</a> <a data-type="StrTm ℓ ℓ (λ X → X)" id="24775" href="1Lab.Univalence.SIP.html#24095" class="InductiveConstructor">s∙</a> <a id="24778" class="Symbol">=</a> <a data-type="Structure ℓ (λ X → X)" id="24780" href="1Lab.Univalence.SIP.html#7039" class="Function">pointedStr</a>
<a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="24791" href="1Lab.Univalence.SIP.html#24624" class="Function">tm→Structure</a> <a id="24804" class="Symbol">(</a><a id="24805" href="1Lab.Univalence.SIP.html#24805" class="Bound">s</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="24807" href="1Lab.Univalence.SIP.html#24127" class="InductiveConstructor Operator">s→</a> <a id="24810" href="1Lab.Univalence.SIP.html#24810" class="Bound">s₁</a><a id="24812" class="Symbol">)</a> <a id="24814" class="Symbol">=</a> <a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" id="24816" href="1Lab.Univalence.SIP.html#16922" class="Function">functionStr</a> <a id="24828" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="24829" href="1Lab.Univalence.SIP.html#24675" class="Function">tm→Action</a> <a id="24839" href="1Lab.Univalence.SIP.html#24805" class="Bound">s</a><a id="24840" class="Symbol">)</a> <a id="24842" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="24843" href="1Lab.Univalence.SIP.html#24624" class="Function">tm→Structure</a> <a id="24856" href="1Lab.Univalence.SIP.html#24810" class="Bound">s₁</a><a id="24858" class="Symbol">)</a>
<a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="24860" href="1Lab.Univalence.SIP.html#24624" class="Function">tm→Structure</a> <a id="24873" class="Symbol">(</a><a id="24874" href="1Lab.Univalence.SIP.html#24874" class="Bound">s</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="24876" href="1Lab.Univalence.SIP.html#24225" class="InductiveConstructor Operator">s×</a> <a id="24879" href="1Lab.Univalence.SIP.html#24879" class="Bound">s₁</a><a id="24881" class="Symbol">)</a> <a id="24883" class="Symbol">=</a> <a data-type="Structure ℓ S₁ →
Structure ℓ₂ T → Structure (ℓ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="24885" href="1Lab.Univalence.SIP.html#7539" class="Function">productStr</a> <a id="24896" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="24897" href="1Lab.Univalence.SIP.html#24624" class="Function">tm→Structure</a> <a id="24910" href="1Lab.Univalence.SIP.html#24874" class="Bound">s</a><a id="24911" class="Symbol">)</a> <a id="24913" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="24914" href="1Lab.Univalence.SIP.html#24624" class="Function">tm→Structure</a> <a id="24927" href="1Lab.Univalence.SIP.html#24879" class="Bound">s₁</a><a id="24929" class="Symbol">)</a>

<a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="24932" href="1Lab.Univalence.SIP.html#24675" class="Function">tm→Action</a> <a id="24942" class="Symbol">(</a><a data-type="(A : Type ℓ₁) → StrTm ℓ ℓ₁ (λ X → A)" id="24943" href="1Lab.Univalence.SIP.html#24039" class="InductiveConstructor">s-const</a> <a id="24951" href="1Lab.Univalence.SIP.html#24951" class="Bound">x₁</a><a id="24953" class="Symbol">)</a> <a id="24955" href="1Lab.Univalence.SIP.html#24955" class="Bound">x</a> <a id="24957" class="Symbol">=</a> <a id="24959" class="Symbol">_</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="24961" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="24963" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a>
<a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="24971" href="1Lab.Univalence.SIP.html#24675" class="Function">tm→Action</a> <a data-type="StrTm ℓ ℓ (λ X → X)" id="24981" href="1Lab.Univalence.SIP.html#24095" class="InductiveConstructor">s∙</a> <a id="24984" href="1Lab.Univalence.SIP.html#24984" class="Bound">x</a> <a id="24986" class="Symbol">=</a> <a id="24988" href="1Lab.Univalence.SIP.html#24984" class="Bound">x</a>
<a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="24990" href="1Lab.Univalence.SIP.html#24675" class="Function">tm→Action</a> <a id="25000" class="Symbol">(</a><a id="25001" href="1Lab.Univalence.SIP.html#25001" class="Bound">s</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="25003" href="1Lab.Univalence.SIP.html#24127" class="InductiveConstructor Operator">s→</a> <a id="25006" href="1Lab.Univalence.SIP.html#25006" class="Bound">s₁</a><a id="25008" class="Symbol">)</a> <a id="25010" class="Symbol">=</a> <a data-type="EqvAction S₁ → EqvAction T → EqvAction (λ X → S₁ X → T X)" id="25012" href="1Lab.Univalence.SIP.html#20186" class="Function">functionAction</a> <a id="25027" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="25028" href="1Lab.Univalence.SIP.html#24675" class="Function">tm→Action</a> <a id="25038" href="1Lab.Univalence.SIP.html#25001" class="Bound">s</a><a id="25039" class="Symbol">)</a> <a id="25041" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="25042" href="1Lab.Univalence.SIP.html#24675" class="Function">tm→Action</a> <a id="25052" href="1Lab.Univalence.SIP.html#25006" class="Bound">s₁</a><a id="25054" class="Symbol">)</a>
<a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="25056" href="1Lab.Univalence.SIP.html#24675" class="Function">tm→Action</a> <a id="25066" class="Symbol">(</a><a id="25067" href="1Lab.Univalence.SIP.html#25067" class="Bound">s</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="25069" href="1Lab.Univalence.SIP.html#24225" class="InductiveConstructor Operator">s×</a> <a id="25072" href="1Lab.Univalence.SIP.html#25072" class="Bound">s₁</a><a id="25074" class="Symbol">)</a> <a id="25076" class="Symbol">=</a> <a data-type="EqvAction S₁ → EqvAction T → EqvAction (λ X → S₁ X × T X)" id="25078" href="1Lab.Univalence.SIP.html#19786" class="Function">productAction</a> <a id="25092" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="25093" href="1Lab.Univalence.SIP.html#24675" class="Function">tm→Action</a> <a id="25103" href="1Lab.Univalence.SIP.html#25067" class="Bound">s</a><a id="25104" class="Symbol">)</a> <a id="25106" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="25107" href="1Lab.Univalence.SIP.html#24675" class="Function">tm→Action</a> <a id="25117" href="1Lab.Univalence.SIP.html#25072" class="Bound">s₁</a><a id="25119" class="Symbol">)</a>
</pre>
<p>The reason for this mutual recursion is the same reason that transport structures are considered in the first place: <span class="Agda"><a data-type="EqvAction S₁ →
Structure ℓ T → Structure (S.ℓ₁ ⊔ ℓ) (λ X → S₁ X → T X)" href="1Lab.Univalence.SIP.html#16922" class="Function">functionStr</a></span> gives much better results for the definition of homomorphism than can be gotten directly using <span class="Agda"><a data-type="Structure ℓ₁ S₁ →
Structure ℓ₂ T → Structure (ℓ₁ ⊔ S.ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" href="1Lab.Univalence.SIP.html#8474" class="Function">Str-functionStr</a></span>. As an example of using the language, and the generated definition of homomorphism, consider pointed ∞-magmas:</p>
<pre class="Agda"><a id="25504" class="Keyword">private</a>
  <a id="Pointed∞Magma"></a><a id="25514" href="1Lab.Univalence.SIP.html#25514" class="Function">Pointed∞Magma</a> <a id="25528" class="Symbol">:</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="25530" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a data-type="Level" id="25540" href="Agda.Primitive.html#764" class="Primitive">lzero</a> <a id="25546" class="Symbol">_</a>
  <a id="25550" href="1Lab.Univalence.SIP.html#25514" class="Function">Pointed∞Magma</a> <a id="25564" class="Symbol">=</a> <a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="25566" href="1Lab.Univalence.SIP.html#24624" class="Function">tm→Structure</a> <a id="25579" class="Symbol">(</a><a data-type="StrTm ℓ ℓ (λ X → X)" id="25580" href="1Lab.Univalence.SIP.html#24095" class="InductiveConstructor">s∙</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="25583" href="1Lab.Univalence.SIP.html#24225" class="InductiveConstructor Operator">s×</a> <a id="25586" class="Symbol">(</a><a data-type="StrTm ℓ ℓ (λ X → X)" id="25587" href="1Lab.Univalence.SIP.html#24095" class="InductiveConstructor">s∙</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="25590" href="1Lab.Univalence.SIP.html#24127" class="InductiveConstructor Operator">s→</a> <a id="25593" class="Symbol">(</a><a data-type="StrTm ℓ ℓ (λ X → X)" id="25594" href="1Lab.Univalence.SIP.html#24095" class="InductiveConstructor">s∙</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="25597" href="1Lab.Univalence.SIP.html#24127" class="InductiveConstructor Operator">s→</a> <a data-type="StrTm ℓ ℓ (λ X → X)" id="25600" href="1Lab.Univalence.SIP.html#24095" class="InductiveConstructor">s∙</a><a id="25602" class="Symbol">)))</a>

  <a id="25609" href="1Lab.Univalence.SIP.html#25609" class="Function">_</a> <a id="25611" class="Symbol">:</a> <a id="25613" class="Symbol">{</a><a id="25614" href="1Lab.Univalence.SIP.html#25614" class="Bound">A</a> <a id="25616" href="1Lab.Univalence.SIP.html#25616" class="Bound">B</a> <a id="25618" class="Symbol">:</a> <a data-type="Structure ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="25620" href="1Lab.Univalence.SIP.html#3316" class="Function">TypeWith</a> <a id="25629" href="1Lab.Univalence.SIP.html#25514" class="Function">Pointed∞Magma</a><a id="25642" class="Symbol">}</a> <a id="25644" class="Symbol">{</a><a id="25645" href="1Lab.Univalence.SIP.html#25645" class="Bound">f</a> <a id="25647" class="Symbol">:</a> <a id="25649" href="1Lab.Univalence.SIP.html#25614" class="Bound">A</a> <a id="25651" class="Symbol">.</a><a data-type="∑ A B → A" id="25652" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="25656" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="25658" href="1Lab.Univalence.SIP.html#25616" class="Bound">B</a> <a id="25660" class="Symbol">.</a><a data-type="∑ A B → A" id="25661" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="25664" class="Symbol">}</a>
    <a id="25670" class="Symbol">→</a> <a id="25672" href="1Lab.Univalence.SIP.html#25514" class="Function">Pointed∞Magma</a> <a id="25686" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="25687" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a> <a id="25694" href="1Lab.Univalence.SIP.html#25614" class="Bound">A</a> <a id="25696" href="1Lab.Univalence.SIP.html#25616" class="Bound">B</a> <a id="25698" href="1Lab.Univalence.SIP.html#25645" class="Bound">f</a>
    <a data-type="A → A → Type ℓ" id="25704" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="25706" class="Symbol">(</a> <a id="25708" class="Symbol">(</a><a id="25709" href="1Lab.Univalence.SIP.html#25645" class="Bound">f</a> <a id="25711" class="Symbol">.</a><a data-type="∑ A B → A" id="25712" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="25716" class="Symbol">(</a><a id="25717" href="1Lab.Univalence.SIP.html#25614" class="Bound">A</a> <a id="25719" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="25720" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="25724" class="Symbol">.</a><a data-type="∑ A B → A" id="25725" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="25728" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="25730" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="25732" href="1Lab.Univalence.SIP.html#25616" class="Bound">B</a> <a id="25734" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="25735" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="25739" class="Symbol">.</a><a data-type="∑ A B → A" id="25740" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="25743" class="Symbol">)</a>
      <a data-type="Type a → Type b → Type (a ⊔ b)" id="25751" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="25753" class="Symbol">((</a><a id="25755" href="1Lab.Univalence.SIP.html#25755" class="Bound">x</a> <a id="25757" href="1Lab.Univalence.SIP.html#25757" class="Bound">y</a> <a id="25759" class="Symbol">:</a> <a id="25761" href="1Lab.Univalence.SIP.html#25614" class="Bound">A</a> <a id="25763" class="Symbol">.</a><a data-type="∑ A B → A" id="25764" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="25767" class="Symbol">)</a> <a id="25769" class="Symbol">→</a> <a id="25771" href="1Lab.Univalence.SIP.html#25645" class="Bound">f</a> <a id="25773" class="Symbol">.</a><a data-type="∑ A B → A" id="25774" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="25778" class="Symbol">(</a><a id="25779" href="1Lab.Univalence.SIP.html#25614" class="Bound">A</a> <a id="25781" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="25782" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="25786" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="25787" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="25791" href="1Lab.Univalence.SIP.html#25755" class="Bound">x</a> <a id="25793" href="1Lab.Univalence.SIP.html#25757" class="Bound">y</a><a id="25794" class="Symbol">)</a>
                        <a data-type="A → A → Type ℓ" id="25820" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="25822" href="1Lab.Univalence.SIP.html#25616" class="Bound">B</a> <a id="25824" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="25825" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="25829" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="25830" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="25834" class="Symbol">(</a><a id="25835" href="1Lab.Univalence.SIP.html#25645" class="Bound">f</a> <a id="25837" class="Symbol">.</a><a data-type="∑ A B → A" id="25838" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="25842" href="1Lab.Univalence.SIP.html#25755" class="Bound">x</a><a id="25843" class="Symbol">)</a> <a id="25845" class="Symbol">(</a><a id="25846" href="1Lab.Univalence.SIP.html#25645" class="Bound">f</a> <a id="25848" class="Symbol">.</a><a data-type="∑ A B → A" id="25849" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="25853" href="1Lab.Univalence.SIP.html#25757" class="Bound">y</a><a id="25854" class="Symbol">)))</a>
  <a id="25860" class="Symbol">_</a> <a id="25862" class="Symbol">=</a> <a data-type="x ≡ x" id="25864" href="1Lab.Path.html#2137" class="Function">refl</a>
</pre>
<p>A homomorphic equivalence of pointed ∞-magmas is an equivalence of their underlying types that preserves the basepoint and is homomorphic over the operation. The use of <span class="Agda"><a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" href="1Lab.Univalence.SIP.html#24675" class="Function">tm→Action</a></span> in contravariant positions is responsible for making sure the computed <span class="Agda"><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" href="1Lab.Univalence.SIP.html#2872" class="Field">is-hom</a></span> doesn’t have any redundant paths in argument positions.</p>
<p>A mutually <em>inductive</em> argument proves that <span class="Agda"><a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" href="1Lab.Univalence.SIP.html#24675" class="Function">tm→Action</a></span> produces transport structures, and that <span class="Agda"><a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" href="1Lab.Univalence.SIP.html#24624" class="Function">tm→Structure</a></span> produces univalent structures. At every case, the proof is by appeal to a lemma that was proved above.</p>
<pre class="Agda"><a id="tm→Structure-univalent"></a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isUnivalent (tm→Structure s)" id="26443" href="1Lab.Univalence.SIP.html#26443" class="Function">tm→Structure-univalent</a> <a id="26466" class="Symbol">:</a> <a id="26468" class="Symbol">(</a><a id="26469" href="1Lab.Univalence.SIP.html#26469" class="Bound">s</a> <a id="26471" class="Symbol">:</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="26473" href="1Lab.Univalence.SIP.html#23979" class="Datatype">StrTm</a> <a id="26479" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="26481" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a> <a id="26484" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="26485" class="Symbol">)</a> <a id="26487" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="26489" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="26501" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="26502" href="1Lab.Univalence.SIP.html#24624" class="Function">tm→Structure</a> <a id="26515" href="1Lab.Univalence.SIP.html#26469" class="Bound">s</a><a id="26516" class="Symbol">)</a>
<a id="tm→Action-isTransp"></a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isTransportStr (tm→Action s)" id="26518" href="1Lab.Univalence.SIP.html#26518" class="Function">tm→Action-isTransp</a> <a id="26537" class="Symbol">:</a> <a id="26539" class="Symbol">(</a><a id="26540" href="1Lab.Univalence.SIP.html#26540" class="Bound">s</a> <a id="26542" class="Symbol">:</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="26544" href="1Lab.Univalence.SIP.html#23979" class="Datatype">StrTm</a> <a id="26550" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="26552" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a> <a id="26555" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a><a id="26556" class="Symbol">)</a> <a id="26558" class="Symbol">→</a> <a data-type="EqvAction S₁ → Type (lsuc ℓ ⊔ ℓ₁)" id="26560" href="1Lab.Univalence.SIP.html#14101" class="Function">isTransportStr</a> <a id="26575" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="26576" href="1Lab.Univalence.SIP.html#24675" class="Function">tm→Action</a> <a id="26586" href="1Lab.Univalence.SIP.html#26540" class="Bound">s</a><a id="26587" class="Symbol">)</a>

<a data-type="(s : StrTm ℓ ℓ₁ S₁) → isUnivalent (tm→Structure s)" id="26590" href="1Lab.Univalence.SIP.html#26443" class="Function">tm→Structure-univalent</a> <a id="26613" class="Symbol">(</a><a data-type="(A : Type ℓ₁) → StrTm ℓ ℓ₁ (λ X → A)" id="26614" href="1Lab.Univalence.SIP.html#24039" class="InductiveConstructor">s-const</a> <a id="26622" href="1Lab.Univalence.SIP.html#26622" class="Bound">x</a><a id="26623" class="Symbol">)</a> <a id="26625" class="Symbol">=</a> <a data-type="isUnivalent (constantStr A)" id="26627" href="1Lab.Univalence.SIP.html#6293" class="Function">constantStr-univalent</a>
<a data-type="(s : StrTm ℓ ℓ₁ S₁) → isUnivalent (tm→Structure s)" id="26649" href="1Lab.Univalence.SIP.html#26443" class="Function">tm→Structure-univalent</a> <a data-type="StrTm ℓ ℓ (λ X → X)" id="26672" href="1Lab.Univalence.SIP.html#24095" class="InductiveConstructor">s∙</a> <a id="26675" class="Symbol">=</a> <a data-type="isUnivalent pointedStr" id="26677" href="1Lab.Univalence.SIP.html#7247" class="Function">pointedStr-univalent</a>
<a data-type="(s : StrTm ℓ ℓ₁ S₁) → isUnivalent (tm→Structure s)" id="26698" href="1Lab.Univalence.SIP.html#26443" class="Function">tm→Structure-univalent</a> <a id="26721" class="Symbol">(</a><a id="26722" href="1Lab.Univalence.SIP.html#26722" class="Bound">s</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="26724" href="1Lab.Univalence.SIP.html#24127" class="InductiveConstructor Operator">s→</a> <a id="26727" href="1Lab.Univalence.SIP.html#26727" class="Bound">s₁</a><a id="26729" class="Symbol">)</a> <a id="26731" class="Symbol">=</a>
  <a data-type="(α : EqvAction S₁) →
isTransportStr α →
(τ : Structure ℓ T) → isUnivalent τ → isUnivalent (functionStr α τ)" id="26735" href="1Lab.Univalence.SIP.html#17249" class="Function">functionStr-univalent</a>
    <a id="26761" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="26762" href="1Lab.Univalence.SIP.html#24675" class="Function">tm→Action</a> <a id="26772" href="1Lab.Univalence.SIP.html#26722" class="Bound">s</a><a id="26773" class="Symbol">)</a> <a id="26775" class="Symbol">(</a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isTransportStr (tm→Action s)" id="26776" href="1Lab.Univalence.SIP.html#26518" class="Function">tm→Action-isTransp</a> <a id="26795" href="1Lab.Univalence.SIP.html#26722" class="Bound">s</a><a id="26796" class="Symbol">)</a>
    <a id="26802" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="26803" href="1Lab.Univalence.SIP.html#24624" class="Function">tm→Structure</a> <a id="26816" href="1Lab.Univalence.SIP.html#26727" class="Bound">s₁</a><a id="26818" class="Symbol">)</a> <a id="26820" class="Symbol">(</a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isUnivalent (tm→Structure s)" id="26821" href="1Lab.Univalence.SIP.html#26443" class="Function">tm→Structure-univalent</a> <a id="26844" href="1Lab.Univalence.SIP.html#26727" class="Bound">s₁</a><a id="26846" class="Symbol">)</a>
<a data-type="(s : StrTm ℓ ℓ₁ S₁) → isUnivalent (tm→Structure s)" id="26848" href="1Lab.Univalence.SIP.html#26443" class="Function">tm→Structure-univalent</a> <a id="26871" class="Symbol">(</a><a id="26872" href="1Lab.Univalence.SIP.html#26872" class="Bound">s</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="26874" href="1Lab.Univalence.SIP.html#24225" class="InductiveConstructor Operator">s×</a> <a id="26877" href="1Lab.Univalence.SIP.html#26877" class="Bound">s₁</a><a id="26879" class="Symbol">)</a> <a id="26881" class="Symbol">=</a>
  <a data-type="isUnivalent σ → isUnivalent τ → isUnivalent (productStr σ τ)" id="26885" href="1Lab.Univalence.SIP.html#7731" class="Function">productStr-univalent</a> <a id="26906" class="Symbol">{</a><a id="26907" class="Argument">σ</a> <a id="26909" class="Symbol">=</a> <a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="26911" href="1Lab.Univalence.SIP.html#24624" class="Function">tm→Structure</a> <a id="26924" href="1Lab.Univalence.SIP.html#26872" class="Bound">s</a><a id="26925" class="Symbol">}</a> <a id="26927" class="Symbol">{</a><a id="26928" class="Argument">τ</a> <a id="26930" class="Symbol">=</a> <a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="26932" href="1Lab.Univalence.SIP.html#24624" class="Function">tm→Structure</a> <a id="26945" href="1Lab.Univalence.SIP.html#26877" class="Bound">s₁</a><a id="26947" class="Symbol">}</a>
    <a id="26953" class="Symbol">(</a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isUnivalent (tm→Structure s)" id="26954" href="1Lab.Univalence.SIP.html#26443" class="Function">tm→Structure-univalent</a> <a id="26977" href="1Lab.Univalence.SIP.html#26872" class="Bound">s</a><a id="26978" class="Symbol">)</a> <a id="26980" class="Symbol">(</a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isUnivalent (tm→Structure s)" id="26981" href="1Lab.Univalence.SIP.html#26443" class="Function">tm→Structure-univalent</a> <a id="27004" href="1Lab.Univalence.SIP.html#26877" class="Bound">s₁</a><a id="27006" class="Symbol">)</a>

<a data-type="(s : StrTm ℓ ℓ₁ S₁) → isTransportStr (tm→Action s)" id="27009" href="1Lab.Univalence.SIP.html#26518" class="Function">tm→Action-isTransp</a> <a id="27028" class="Symbol">(</a><a data-type="(A : Type ℓ₁) → StrTm ℓ ℓ₁ (λ X → A)" id="27029" href="1Lab.Univalence.SIP.html#24039" class="InductiveConstructor">s-const</a> <a id="27037" href="1Lab.Univalence.SIP.html#27037" class="Bound">x</a><a id="27038" class="Symbol">)</a> <a id="27040" class="Symbol">=</a> <a data-type="isTransportStr (constantAction A)" id="27042" href="1Lab.Univalence.SIP.html#19545" class="Function">constantAction-isTransp</a>
<a data-type="(s : StrTm ℓ ℓ₁ S₁) → isTransportStr (tm→Action s)" id="27066" href="1Lab.Univalence.SIP.html#26518" class="Function">tm→Action-isTransp</a> <a data-type="StrTm ℓ ℓ (λ X → X)" id="27085" href="1Lab.Univalence.SIP.html#24095" class="InductiveConstructor">s∙</a> <a id="27088" class="Symbol">=</a> <a data-type="isTransportStr id" id="27090" href="1Lab.Univalence.SIP.html#19683" class="Function">idAction-isTransp</a>
<a data-type="(s : StrTm ℓ ℓ₁ S₁) → isTransportStr (tm→Action s)" id="27108" href="1Lab.Univalence.SIP.html#26518" class="Function">tm→Action-isTransp</a> <a id="27127" class="Symbol">(</a><a id="27128" href="1Lab.Univalence.SIP.html#27128" class="Bound">s</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X → T X)" id="27130" href="1Lab.Univalence.SIP.html#24127" class="InductiveConstructor Operator">s→</a> <a id="27133" href="1Lab.Univalence.SIP.html#27133" class="Bound">s₁</a><a id="27135" class="Symbol">)</a> <a id="27137" class="Symbol">=</a>
  <a data-type="isTransportStr α →
isTransportStr β → isTransportStr (functionAction α β)" id="27141" href="1Lab.Univalence.SIP.html#20323" class="Function">functionAction-isTransp</a> <a id="27165" class="Symbol">{</a><a id="27166" class="Argument">α</a> <a id="27168" class="Symbol">=</a> <a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="27170" href="1Lab.Univalence.SIP.html#24675" class="Function">tm→Action</a> <a id="27180" href="1Lab.Univalence.SIP.html#27128" class="Bound">s</a><a id="27181" class="Symbol">}</a> <a id="27183" class="Symbol">{</a><a id="27184" class="Argument">β</a> <a id="27186" class="Symbol">=</a> <a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="27188" href="1Lab.Univalence.SIP.html#24675" class="Function">tm→Action</a> <a id="27198" href="1Lab.Univalence.SIP.html#27133" class="Bound">s₁</a><a id="27200" class="Symbol">}</a>
    <a id="27206" class="Symbol">(</a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isTransportStr (tm→Action s)" id="27207" href="1Lab.Univalence.SIP.html#26518" class="Function">tm→Action-isTransp</a> <a id="27226" href="1Lab.Univalence.SIP.html#27128" class="Bound">s</a><a id="27227" class="Symbol">)</a> <a id="27229" class="Symbol">(</a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isTransportStr (tm→Action s)" id="27230" href="1Lab.Univalence.SIP.html#26518" class="Function">tm→Action-isTransp</a> <a id="27249" href="1Lab.Univalence.SIP.html#27133" class="Bound">s₁</a><a id="27251" class="Symbol">)</a>
<a data-type="(s : StrTm ℓ ℓ₁ S₁) → isTransportStr (tm→Action s)" id="27253" href="1Lab.Univalence.SIP.html#26518" class="Function">tm→Action-isTransp</a> <a id="27272" class="Symbol">(</a><a id="27273" href="1Lab.Univalence.SIP.html#27273" class="Bound">s</a> <a data-type="StrTm ℓ ℓ₁ S₁ → StrTm ℓ ℓ₂ T → StrTm ℓ (ℓ₁ ⊔ ℓ₂) (λ X → S₁ X × T X)" id="27275" href="1Lab.Univalence.SIP.html#24225" class="InductiveConstructor Operator">s×</a> <a id="27278" href="1Lab.Univalence.SIP.html#27278" class="Bound">s₁</a><a id="27280" class="Symbol">)</a> <a id="27282" class="Symbol">=</a>
  <a data-type="isTransportStr α →
isTransportStr β → isTransportStr (productAction α β)" id="27286" href="1Lab.Univalence.SIP.html#19920" class="Function">productAction-isTransp</a> <a id="27309" class="Symbol">{</a><a id="27310" class="Argument">α</a> <a id="27312" class="Symbol">=</a> <a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="27314" href="1Lab.Univalence.SIP.html#24675" class="Function">tm→Action</a> <a id="27324" href="1Lab.Univalence.SIP.html#27273" class="Bound">s</a><a id="27325" class="Symbol">}</a> <a id="27327" class="Symbol">{</a><a id="27328" class="Argument">β</a> <a id="27330" class="Symbol">=</a> <a data-type="StrTm ℓ ℓ₁ S₁ → EqvAction S₁" id="27332" href="1Lab.Univalence.SIP.html#24675" class="Function">tm→Action</a> <a id="27342" href="1Lab.Univalence.SIP.html#27278" class="Bound">s₁</a><a id="27344" class="Symbol">}</a>
    <a id="27350" class="Symbol">(</a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isTransportStr (tm→Action s)" id="27351" href="1Lab.Univalence.SIP.html#26518" class="Function">tm→Action-isTransp</a> <a id="27370" href="1Lab.Univalence.SIP.html#27273" class="Bound">s</a><a id="27371" class="Symbol">)</a> <a id="27373" class="Symbol">(</a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isTransportStr (tm→Action s)" id="27374" href="1Lab.Univalence.SIP.html#26518" class="Function">tm→Action-isTransp</a> <a id="27393" href="1Lab.Univalence.SIP.html#27278" class="Bound">s₁</a><a id="27395" class="Symbol">)</a>
</pre>
<h2 id="descriptions-of-structures"><a href="#descriptions-of-structures" class="header-link">Descriptions of Structures<span class="header-link-emoji">🔗</span></a></h2>
<p>To make convenient descriptions of structures-with-axioms, we introduce a record type, <span class="Agda"><a data-type="(ℓ ℓ₁ : Level) (S₁ : Type ℓ → Type ℓ₁) (ax : Level) → Typeω" href="1Lab.Univalence.SIP.html#27634" class="Record">StrDesc</a></span>, which packages together the structure term and the properties that are imposed:</p>
<pre class="Agda"><a id="27627" class="Keyword">record</a> <a id="StrDesc"></a><a data-type="(ℓ ℓ₁ : Level) (S₁ : Type ℓ → Type ℓ₁) (ax : Level) → Typeω" id="27634" href="1Lab.Univalence.SIP.html#27634" class="Record">StrDesc</a> <a id="27642" href="1Lab.Univalence.SIP.html#27642" class="Bound">ℓ</a> <a id="27644" href="1Lab.Univalence.SIP.html#27644" class="Bound">ℓ₁</a> <a id="27647" href="1Lab.Univalence.SIP.html#27647" class="Bound">S</a> <a id="27649" href="1Lab.Univalence.SIP.html#27649" class="Bound">ax</a> <a id="27652" class="Symbol">:</a> <a id="27654" href="1Lab.Type.html#409" class="Primitive">Typeω</a> <a id="27660" class="Keyword">where</a>
  <a id="27668" class="Keyword">field</a>
    <a id="StrDesc.descriptor"></a><a id="27678" href="1Lab.Univalence.SIP.html#27678" class="Field">descriptor</a> <a id="27689" class="Symbol">:</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="27691" href="1Lab.Univalence.SIP.html#23979" class="Datatype">StrTm</a> <a id="27697" href="1Lab.Univalence.SIP.html#27642" class="Bound">ℓ</a> <a id="27699" href="1Lab.Univalence.SIP.html#27644" class="Bound">ℓ₁</a> <a id="27702" href="1Lab.Univalence.SIP.html#27647" class="Bound">S</a>

    <a id="StrDesc.axioms"></a><a id="27709" href="1Lab.Univalence.SIP.html#27709" class="Field">axioms</a> <a id="27716" class="Symbol">:</a> <a id="27718" class="Symbol">∀</a> <a id="27720" href="1Lab.Univalence.SIP.html#27720" class="Bound">X</a> <a id="27722" class="Symbol">→</a> <a id="27724" href="1Lab.Univalence.SIP.html#27647" class="Bound">S</a> <a id="27726" href="1Lab.Univalence.SIP.html#27720" class="Bound">X</a> <a id="27728" class="Symbol">→</a> <a id="27730" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="27735" href="1Lab.Univalence.SIP.html#27649" class="Bound">ax</a>
    <a id="StrDesc.axioms-prop"></a><a id="27742" href="1Lab.Univalence.SIP.html#27742" class="Field">axioms-prop</a> <a id="27754" class="Symbol">:</a> <a id="27756" class="Symbol">∀</a> <a id="27758" href="1Lab.Univalence.SIP.html#27758" class="Bound">X</a> <a id="27760" href="1Lab.Univalence.SIP.html#27760" class="Bound">s</a> <a id="27762" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="27764" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="27771" class="Symbol">(</a><a id="27772" href="1Lab.Univalence.SIP.html#27709" class="Field">axioms</a> <a id="27779" href="1Lab.Univalence.SIP.html#27758" class="Bound">X</a> <a id="27781" href="1Lab.Univalence.SIP.html#27760" class="Bound">s</a><a id="27782" class="Symbol">)</a>

<a id="Desc→Fam"></a><a data-type="StrDesc ℓ ℓ₁ S₁ ax → Type ℓ → Type (ℓ₁ ⊔ ax)" id="27785" href="1Lab.Univalence.SIP.html#27785" class="Function">Desc→Fam</a> <a id="27794" class="Symbol">:</a> <a id="27796" class="Symbol">∀</a> <a id="27798" class="Symbol">{</a><a id="27799" href="1Lab.Univalence.SIP.html#27799" class="Bound">ax</a><a id="27801" class="Symbol">}</a> <a id="27803" class="Symbol">→</a> <a data-type="(ℓ ℓ₁ : Level) (S₁ : Type ℓ → Type ℓ₁) (ax : Level) → Typeω" id="27805" href="1Lab.Univalence.SIP.html#27634" class="Record">StrDesc</a> <a id="27813" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="27815" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a> <a id="27818" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="27820" href="1Lab.Univalence.SIP.html#27799" class="Bound">ax</a> <a id="27823" class="Symbol">→</a> <a id="27825" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="27830" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="27832" class="Symbol">→</a> <a id="27834" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="27839" class="Symbol">(</a><a id="27840" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a> <a data-type="Level → Level → Level" id="27843" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="27845" href="1Lab.Univalence.SIP.html#27799" class="Bound">ax</a><a id="27847" class="Symbol">)</a>
<a data-type="StrDesc ℓ ℓ₁ S₁ ax → Type ℓ → Type (ℓ₁ ⊔ ax)" id="27849" href="1Lab.Univalence.SIP.html#27785" class="Function">Desc→Fam</a> <a id="27858" class="Symbol">{</a><a id="27859" class="Argument">S</a> <a id="27861" class="Symbol">=</a> <a id="27863" href="1Lab.Univalence.SIP.html#27863" class="Bound">S</a><a id="27864" class="Symbol">}</a> <a id="27866" href="1Lab.Univalence.SIP.html#27866" class="Bound">desc</a> <a id="27871" href="1Lab.Univalence.SIP.html#27871" class="Bound">X</a> <a id="27873" class="Symbol">=</a>
  <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="27877" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="27880" href="1Lab.Univalence.SIP.html#27880" class="Bound">S</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="27882" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="27884" href="1Lab.Univalence.SIP.html#27863" class="Bound">S</a> <a id="27886" href="1Lab.Univalence.SIP.html#27871" class="Bound">X</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="27888" href="1Lab.Type.html#1563" class="Function">]</a>
    <a id="27894" class="Symbol">(</a><a id="27895" href="1Lab.Univalence.SIP.html#27866" class="Bound">desc</a> <a id="27900" class="Symbol">.</a><a id="27901" href="1Lab.Univalence.SIP.html#27709" class="Field">StrDesc.axioms</a> <a id="27916" class="Symbol">_</a> <a id="27918" href="1Lab.Univalence.SIP.html#27880" class="Bound">S</a><a id="27919" class="Symbol">)</a>

<a id="Desc→Str"></a><a data-type="(S₂ : StrDesc ℓ ℓ₁ S₁ ax) → Structure ℓ₁ (Desc→Fam S₂)" id="27922" href="1Lab.Univalence.SIP.html#27922" class="Function">Desc→Str</a> <a id="27931" class="Symbol">:</a> <a id="27933" class="Symbol">∀</a> <a id="27935" class="Symbol">{</a><a id="27936" href="1Lab.Univalence.SIP.html#27936" class="Bound">ax</a><a id="27938" class="Symbol">}</a> <a id="27940" class="Symbol">→</a> <a id="27942" class="Symbol">(</a><a id="27943" href="1Lab.Univalence.SIP.html#27943" class="Bound">S</a> <a id="27945" class="Symbol">:</a> <a data-type="(ℓ ℓ₁ : Level) (S₁ : Type ℓ → Type ℓ₁) (ax : Level) → Typeω" id="27947" href="1Lab.Univalence.SIP.html#27634" class="Record">StrDesc</a> <a id="27955" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="27957" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a> <a id="27960" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="27962" href="1Lab.Univalence.SIP.html#27936" class="Bound">ax</a><a id="27964" class="Symbol">)</a> <a id="27966" class="Symbol">→</a> <a data-type="(ℓ₃ : Level) (S₁ : Type ℓ₁ → Type ℓ₂) →
Type (lsuc ℓ₁ ⊔ ℓ₂ ⊔ lsuc ℓ₃)" id="27968" href="1Lab.Univalence.SIP.html#1944" class="Record">Structure</a> <a id="27978" class="Symbol">_</a> <a id="27980" class="Symbol">(</a><a data-type="StrDesc ℓ ℓ₁ S₁ ax → Type ℓ → Type (ℓ₁ ⊔ ax)" id="27981" href="1Lab.Univalence.SIP.html#27785" class="Function">Desc→Fam</a> <a id="27990" href="1Lab.Univalence.SIP.html#27943" class="Bound">S</a><a id="27991" class="Symbol">)</a>
<a data-type="(S₂ : StrDesc ℓ ℓ₁ S₁ ax) → Structure ℓ₁ (Desc→Fam S₂)" id="27993" href="1Lab.Univalence.SIP.html#27922" class="Function">Desc→Str</a> <a id="28002" href="1Lab.Univalence.SIP.html#28002" class="Bound">desc</a> <a id="28007" class="Symbol">=</a> <a data-type="(σ : Structure ℓ S₁) (axioms : (X : Type S.ℓ) → S₁ X → Type ℓ₃) →
Structure ℓ (λ X → Σ (axioms X))" id="28009" href="1Lab.Univalence.SIP.html#21831" class="Function">axiomsStr</a> <a id="28019" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="28020" href="1Lab.Univalence.SIP.html#24624" class="Function">tm→Structure</a> <a id="28033" href="1Lab.Univalence.SIP.html#27678" class="Field">descriptor</a><a id="28043" class="Symbol">)</a> <a id="28045" href="1Lab.Univalence.SIP.html#27709" class="Field">axioms</a>
  <a id="28054" class="Keyword">where</a> <a id="28060" class="Keyword">open</a> <a data-type="(ℓ ℓ₁ : Level) (S₁ : Type ℓ → Type ℓ₁) (ax : Level) → Typeω" id="28065" href="1Lab.Univalence.SIP.html#27634" class="Module">StrDesc</a> <a id="28073" href="1Lab.Univalence.SIP.html#28002" class="Bound">desc</a>

<a id="Desc→isUnivalent"></a><a data-type="(S₂ : StrDesc ℓ ℓ₁ S₁ ax) → isUnivalent (Desc→Str S₂)" id="28079" href="1Lab.Univalence.SIP.html#28079" class="Function">Desc→isUnivalent</a> <a id="28096" class="Symbol">:</a> <a id="28098" class="Symbol">∀</a> <a id="28100" class="Symbol">{</a><a id="28101" href="1Lab.Univalence.SIP.html#28101" class="Bound">ax</a><a id="28103" class="Symbol">}</a> <a id="28105" class="Symbol">→</a> <a id="28107" class="Symbol">(</a><a id="28108" href="1Lab.Univalence.SIP.html#28108" class="Bound">S</a> <a id="28110" class="Symbol">:</a> <a data-type="(ℓ ℓ₁ : Level) (S₁ : Type ℓ → Type ℓ₁) (ax : Level) → Typeω" id="28112" href="1Lab.Univalence.SIP.html#27634" class="Record">StrDesc</a> <a id="28120" href="1Lab.Univalence.SIP.html#3450" class="Generalizable">ℓ</a> <a id="28122" href="1Lab.Univalence.SIP.html#3452" class="Generalizable">ℓ₁</a> <a id="28125" href="1Lab.Univalence.SIP.html#3484" class="Generalizable">S</a> <a id="28127" href="1Lab.Univalence.SIP.html#28101" class="Bound">ax</a><a id="28129" class="Symbol">)</a> <a id="28131" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="28133" href="1Lab.Univalence.SIP.html#3831" class="Function">isUnivalent</a> <a id="28145" class="Symbol">(</a><a data-type="(S₂ : StrDesc ℓ ℓ₁ S₁ ax) → Structure ℓ₁ (Desc→Fam S₂)" id="28146" href="1Lab.Univalence.SIP.html#27922" class="Function">Desc→Str</a> <a id="28155" href="1Lab.Univalence.SIP.html#28108" class="Bound">S</a><a id="28156" class="Symbol">)</a>
<a data-type="(S₂ : StrDesc ℓ ℓ₁ S₁ ax) → isUnivalent (Desc→Str S₂)" id="28158" href="1Lab.Univalence.SIP.html#28079" class="Function">Desc→isUnivalent</a> <a id="28175" href="1Lab.Univalence.SIP.html#28175" class="Bound">desc</a> <a id="28180" class="Symbol">=</a>
  <a data-type="(σ : Structure ℓ S₁) (axioms : (X : Type S.ℓ) → S₁ X → Type ℓ₃)
(univ : isUnivalent σ) (axioms-prop : isProp (axioms X s)) →
isUnivalent (axiomsStr σ axioms)" id="28184" href="1Lab.Univalence.SIP.html#22220" class="Function">axiomsStr-univalent</a>
    <a id="28208" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="28209" href="1Lab.Univalence.SIP.html#24624" class="Function">tm→Structure</a> <a id="28222" href="1Lab.Univalence.SIP.html#27678" class="Function">descriptor</a><a id="28232" class="Symbol">)</a> <a id="28234" href="1Lab.Univalence.SIP.html#27709" class="Function">axioms</a>
    <a id="28245" class="Symbol">(</a><a data-type="(s : StrTm ℓ ℓ₁ S₁) → isUnivalent (tm→Structure s)" id="28246" href="1Lab.Univalence.SIP.html#26443" class="Function">tm→Structure-univalent</a> <a id="28269" href="1Lab.Univalence.SIP.html#27678" class="Function">descriptor</a><a id="28279" class="Symbol">)</a> <a id="28281" class="Symbol">(λ</a> <a id="28284" class="Symbol">{</a><a id="28285" href="1Lab.Univalence.SIP.html#28285" class="Bound">X</a><a id="28286" class="Symbol">}</a> <a id="28288" class="Symbol">{</a><a id="28289" href="1Lab.Univalence.SIP.html#28289" class="Bound">s</a><a id="28290" class="Symbol">}</a> <a id="28292" class="Symbol">→</a> <a id="28294" href="1Lab.Univalence.SIP.html#27742" class="Function">axioms-prop</a> <a id="28306" href="1Lab.Univalence.SIP.html#28285" class="Bound">X</a> <a id="28308" href="1Lab.Univalence.SIP.html#28289" class="Bound">s</a><a id="28309" class="Symbol">)</a>
  <a id="28313" class="Keyword">where</a> <a id="28319" class="Keyword">open</a> <a data-type="(ℓ ℓ₁ : Level) (S₁ : Type ℓ → Type ℓ₁) (ax : Level) → Typeω" id="28324" href="1Lab.Univalence.SIP.html#27634" class="Module">StrDesc</a> <a id="28332" href="1Lab.Univalence.SIP.html#28175" class="Bound">desc</a>
</pre>
  </article>
</div>

</main>
</body>
</html>