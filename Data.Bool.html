<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8"></meta>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"></meta>
  <meta name="keywords" content="Agda,categories,topos"></meta>

  <title>Data.Bool - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css"></link>
  <link rel="stylesheet" href="/css/katex.min.css"></link>
  <link rel="stylesheet" href="/css/agda-cats.css"></link>

  <meta name="twitter:card" content="summary"></meta>
  <meta name="twitter:title" content="Data.Bool - 1Lab"></meta>
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png"></meta>

  <meta name="og:title" content="Data.Bool - 1Lab"></meta>
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png"></meta>
  <meta name="og:site-name" content="1Lab"></meta>
  <meta name="og:type" content="website"></meta>

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory."></meta>
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory."></meta>
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory."></meta>
  
  <script src="/equations.js" type="text/javascript"></script> 
  <script src="/highlight-hover.js" type="text/javascript"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>
</head>

<body>
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0;">
                <a class="Module">Data.Bool</a>
              </h3>

      <!-- Cube logo -->
      <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px"></img>
      
      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr></hr>
      <ul>
      <li><a href="#the-booleans"><a href="#the-booleans" class="header-link">The Booleans<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#basic-algebraic-properties"><a href="#basic-algebraic-properties" class="header-link">Basic algebraic properties<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#discreteness"><a href="#discreteness" class="header-link">Discreteness<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#the-not-equivalence"><a href="#the-not-equivalence" class="header-link">The “not” equivalence<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#autbool"><a href="#autbool" class="header-link">Aut(Bool)<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      </ul>
      <hr></hr>

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>
      </div>

      <hr></hr>

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
              <a href="index.html">️back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/066a87e8c57395f5419592e9fd714ff2224cd7ea/src/Data/Bool.lagda.md">link to source</a> <br />
      </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="index.html">️back to index</a>
      </div>
      
      <!-- Font toggle checkbox -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="1Lab.HLevel.Sets.html" class="Module">1Lab.HLevel.Sets</a>
<a id="38" class="Keyword">open</a> <a id="43" class="Keyword">import</a> <a id="50" href="1Lab.Univalence.html" class="Module">1Lab.Univalence</a>
<a id="66" class="Keyword">open</a> <a id="71" class="Keyword">import</a> <a id="78" href="1Lab.Type.Dec.html" class="Module">1Lab.Type.Dec</a>
<a id="92" class="Keyword">open</a> <a id="97" class="Keyword">import</a> <a id="104" href="1Lab.HLevel.html" class="Module">1Lab.HLevel</a>
<a id="116" class="Keyword">open</a> <a id="121" class="Keyword">import</a> <a id="128" href="1Lab.Equiv.html" class="Module">1Lab.Equiv</a>
<a id="139" class="Keyword">open</a> <a id="144" class="Keyword">import</a> <a id="151" href="1Lab.Path.html" class="Module">1Lab.Path</a>
<a id="161" class="Keyword">open</a> <a id="166" class="Keyword">import</a> <a id="173" href="1Lab.Type.html" class="Module">1Lab.Type</a>

<a id="184" class="Keyword">open</a> <a id="189" class="Keyword">import</a> <a id="196" href="Agda.Builtin.Bool.html" class="Module">Agda.Builtin.Bool</a>

<a id="215" class="Keyword">open</a> <a data-type="(f : A → B) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="220" href="1Lab.Equiv.html#2293" class="Module">isEquiv</a>
<a id="228" class="Keyword">open</a> <a data-type="(A : Type ℓ) → Type ℓ" id="233" href="1Lab.HLevel.html#1328" class="Module">isContr</a>
<a id="241" class="Keyword">open</a> <a data-type="(f : A → B) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="246" href="1Lab.Equiv.html#5975" class="Module">isIso</a>

<a id="253" class="Keyword">module</a> <a id="260" href="Data.Bool.html" class="Module">Data.Bool</a> <a id="270" class="Keyword">where</a>

<a id="277" class="Keyword">open</a> <a id="282" href="Agda.Builtin.Bool.html" class="Module">Agda.Builtin.Bool</a> <a id="300" class="Keyword">public</a>
</pre>
<h1 id="the-booleans"><a href="#the-booleans" class="header-link">The Booleans<span class="header-link-emoji">🔗</span></a></h1>
<p>The type of booleans is interesting in homotopy type theory because it is the simplest type where its automorphisms in <span class="Agda"><a href="1Lab.Type.html#394" class="Primitive">Type</a></span> are non-trivial. In particular, there are two: negation, and the identity.</p>
<p>But first, true isn’t false.</p>
<pre class="Agda"><a id="true≠false"></a><a data-type="true ≡ false → ⊥" id="575" href="Data.Bool.html#575" class="Function">true≠false</a> <a id="586" class="Symbol">:</a> <a data-type="Bool" id="588" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="A → A → Type ℓ" id="593" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Bool" id="595" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="601" class="Symbol">→</a> <a data-type="Type" id="603" href="1Lab.Type.html#1326" class="Datatype">⊥</a>
<a data-type="true ≡ false → ⊥" id="605" href="Data.Bool.html#575" class="Function">true≠false</a> <a id="616" href="Data.Bool.html#616" class="Bound">p</a> <a id="618" class="Symbol">=</a> <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="620" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="626" href="Data.Bool.html#641" class="Function">P</a> <a id="628" href="Data.Bool.html#616" class="Bound">p</a> <a data-type="⊤" id="630" href="Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a> <a id="633" class="Keyword">where</a>
  <a id="641" href="Data.Bool.html#641" class="Function">P</a> <a id="643" class="Symbol">:</a> <a data-type="Type" id="645" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a> <a id="650" class="Symbol">→</a> <a id="652" href="1Lab.Type.html#394" class="Primitive">Type</a>
  <a id="659" href="Data.Bool.html#641" class="Function">P</a> <a data-type="Bool" id="661" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="667" class="Symbol">=</a> <a data-type="Type" id="669" href="1Lab.Type.html#1326" class="Datatype">⊥</a>
  <a id="673" href="Data.Bool.html#641" class="Function">P</a> <a data-type="Bool" id="675" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="680" class="Symbol">=</a> <a data-type="Type" id="682" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
</pre>
<p>It’s worth noting how to prove two things are <strong>not</strong> equal. We write a predicate that distinguishes them by mapping one to <span class="Agda"><a data-type="Type" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a></span>, and one to <span class="Agda"><a data-type="Type" href="1Lab.Type.html#1326" class="Datatype">⊥</a></span>. Then we can substitute under P along the claimed equality to get an element of <span class="Agda"><a data-type="Type" href="1Lab.Type.html#1326" class="Datatype">⊥</a></span> - a contradiction.</p>
<h2 id="basic-algebraic-properties"><a href="#basic-algebraic-properties" class="header-link">Basic algebraic properties<span class="header-link-emoji">🔗</span></a></h2>
<p>The booleans form a <a href="https://en.wikipedia.org/wiki/Boolean_algebra_(structure)" title="Boolean algebra">Boolean algebra</a>, as one might already expect, given its name. The operations required to define such a structure are straightforward to define using pattern matching:</p>
<pre class="Agda"><a id="not"></a><a data-type="Bool → Bool" id="1190" href="Data.Bool.html#1190" class="Function">not</a> <a id="1194" class="Symbol">:</a> <a data-type="Type" id="1196" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a> <a id="1201" class="Symbol">→</a> <a data-type="Type" id="1203" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
<a data-type="Bool → Bool" id="1208" href="Data.Bool.html#1190" class="Function">not</a> <a data-type="Bool" id="1212" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="1217" class="Symbol">=</a> <a data-type="Bool" id="1219" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
<a data-type="Bool → Bool" id="1225" href="Data.Bool.html#1190" class="Function">not</a> <a data-type="Bool" id="1229" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="1235" class="Symbol">=</a> <a data-type="Bool" id="1237" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>

<a id="and"></a><a data-type="Bool → Bool → Bool" id="1243" href="Data.Bool.html#1243" class="Function">and</a> <a id="or"></a><a data-type="Bool → Bool → Bool" id="1247" href="Data.Bool.html#1247" class="Function">or</a> <a id="1250" class="Symbol">:</a> <a data-type="Type" id="1252" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a> <a id="1257" class="Symbol">→</a> <a data-type="Type" id="1259" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a> <a id="1264" class="Symbol">→</a> <a data-type="Type" id="1266" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
<a data-type="Bool → Bool → Bool" id="1271" href="Data.Bool.html#1243" class="Function">and</a> <a data-type="Bool" id="1275" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="1281" href="Data.Bool.html#1281" class="Bound">y</a> <a id="1283" class="Symbol">=</a> <a data-type="Bool" id="1285" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
<a data-type="Bool → Bool → Bool" id="1291" href="Data.Bool.html#1243" class="Function">and</a> <a data-type="Bool" id="1295" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="1300" href="Data.Bool.html#1300" class="Bound">y</a> <a id="1302" class="Symbol">=</a> <a id="1304" href="Data.Bool.html#1300" class="Bound">y</a>

<a data-type="Bool → Bool → Bool" id="1307" href="Data.Bool.html#1247" class="Function">or</a> <a data-type="Bool" id="1310" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="1316" href="Data.Bool.html#1316" class="Bound">y</a> <a id="1318" class="Symbol">=</a> <a id="1320" href="Data.Bool.html#1316" class="Bound">y</a>
<a data-type="Bool → Bool → Bool" id="1322" href="Data.Bool.html#1247" class="Function">or</a> <a data-type="Bool" id="1325" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="1330" href="Data.Bool.html#1330" class="Bound">y</a> <a id="1332" class="Symbol">=</a> <a data-type="Bool" id="1334" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
</pre>
<p>Pattern matching on only the first argument might seem like a somewhat inpractical choice due to its asymmetry - however, it shortens a lot of proofs since we get a lot of judgemental equalities for free. For example, see the following statements:</p>
<pre class="Agda"><a id="and-associative"></a><a data-type="(x y z : Bool) → and x (and y z) ≡ and (and x y) z" id="1601" href="Data.Bool.html#1601" class="Function">and-associative</a> <a id="1617" class="Symbol">:</a> <a id="1619" class="Symbol">(</a><a id="1620" href="Data.Bool.html#1620" class="Bound">x</a> <a id="1622" href="Data.Bool.html#1622" class="Bound">y</a> <a id="1624" href="Data.Bool.html#1624" class="Bound">z</a> <a id="1626" class="Symbol">:</a> <a data-type="Type" id="1628" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="1632" class="Symbol">)</a> <a id="1634" class="Symbol">→</a> <a data-type="Bool → Bool → Bool" id="1636" href="Data.Bool.html#1243" class="Function">and</a> <a id="1640" href="Data.Bool.html#1620" class="Bound">x</a> <a id="1642" class="Symbol">(</a><a data-type="Bool → Bool → Bool" id="1643" href="Data.Bool.html#1243" class="Function">and</a> <a id="1647" href="Data.Bool.html#1622" class="Bound">y</a> <a id="1649" href="Data.Bool.html#1624" class="Bound">z</a><a id="1650" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="1652" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Bool → Bool → Bool" id="1654" href="Data.Bool.html#1243" class="Function">and</a> <a id="1658" class="Symbol">(</a><a data-type="Bool → Bool → Bool" id="1659" href="Data.Bool.html#1243" class="Function">and</a> <a id="1663" href="Data.Bool.html#1620" class="Bound">x</a> <a id="1665" href="Data.Bool.html#1622" class="Bound">y</a><a id="1666" class="Symbol">)</a> <a id="1668" href="Data.Bool.html#1624" class="Bound">z</a>
<a data-type="(x y z : Bool) → and x (and y z) ≡ and (and x y) z" id="1670" href="Data.Bool.html#1601" class="Function">and-associative</a> <a data-type="Bool" id="1686" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="1692" href="Data.Bool.html#1692" class="Bound">y</a> <a id="1694" href="Data.Bool.html#1694" class="Bound">z</a> <a id="1696" class="Symbol">=</a> <a data-type="x ≡ x" id="1698" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x y z : Bool) → and x (and y z) ≡ and (and x y) z" id="1703" href="Data.Bool.html#1601" class="Function">and-associative</a> <a data-type="Bool" id="1719" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="1724" href="Data.Bool.html#1724" class="Bound">y</a> <a id="1726" href="Data.Bool.html#1726" class="Bound">z</a> <a id="1728" class="Symbol">=</a> <a data-type="x ≡ x" id="1730" href="1Lab.Path.html#2137" class="Function">refl</a>

<a id="or-associative"></a><a data-type="(x y z : Bool) → or x (or y z) ≡ or (or x y) z" id="1736" href="Data.Bool.html#1736" class="Function">or-associative</a> <a id="1751" class="Symbol">:</a> <a id="1753" class="Symbol">(</a><a id="1754" href="Data.Bool.html#1754" class="Bound">x</a> <a id="1756" href="Data.Bool.html#1756" class="Bound">y</a> <a id="1758" href="Data.Bool.html#1758" class="Bound">z</a> <a id="1760" class="Symbol">:</a> <a data-type="Type" id="1762" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="1766" class="Symbol">)</a> <a id="1768" class="Symbol">→</a> <a data-type="Bool → Bool → Bool" id="1770" href="Data.Bool.html#1247" class="Function">or</a> <a id="1773" href="Data.Bool.html#1754" class="Bound">x</a> <a id="1775" class="Symbol">(</a><a data-type="Bool → Bool → Bool" id="1776" href="Data.Bool.html#1247" class="Function">or</a> <a id="1779" href="Data.Bool.html#1756" class="Bound">y</a> <a id="1781" href="Data.Bool.html#1758" class="Bound">z</a><a id="1782" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="1784" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Bool → Bool → Bool" id="1786" href="Data.Bool.html#1247" class="Function">or</a> <a id="1789" class="Symbol">(</a><a data-type="Bool → Bool → Bool" id="1790" href="Data.Bool.html#1247" class="Function">or</a> <a id="1793" href="Data.Bool.html#1754" class="Bound">x</a> <a id="1795" href="Data.Bool.html#1756" class="Bound">y</a><a id="1796" class="Symbol">)</a> <a id="1798" href="Data.Bool.html#1758" class="Bound">z</a>
<a data-type="(x y z : Bool) → or x (or y z) ≡ or (or x y) z" id="1800" href="Data.Bool.html#1736" class="Function">or-associative</a> <a data-type="Bool" id="1815" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="1821" href="Data.Bool.html#1821" class="Bound">y</a> <a id="1823" href="Data.Bool.html#1823" class="Bound">z</a> <a id="1825" class="Symbol">=</a> <a data-type="x ≡ x" id="1827" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x y z : Bool) → or x (or y z) ≡ or (or x y) z" id="1832" href="Data.Bool.html#1736" class="Function">or-associative</a> <a data-type="Bool" id="1847" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="1852" href="Data.Bool.html#1852" class="Bound">y</a> <a id="1854" href="Data.Bool.html#1854" class="Bound">z</a> <a id="1856" class="Symbol">=</a> <a data-type="x ≡ x" id="1858" href="1Lab.Path.html#2137" class="Function">refl</a>

<a id="and-commutative"></a><a data-type="(x y : Bool) → and x y ≡ and y x" id="1864" href="Data.Bool.html#1864" class="Function">and-commutative</a> <a id="1880" class="Symbol">:</a> <a id="1882" class="Symbol">(</a><a id="1883" href="Data.Bool.html#1883" class="Bound">x</a> <a id="1885" href="Data.Bool.html#1885" class="Bound">y</a> <a id="1887" class="Symbol">:</a> <a data-type="Type" id="1889" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="1893" class="Symbol">)</a> <a id="1895" class="Symbol">→</a> <a data-type="Bool → Bool → Bool" id="1897" href="Data.Bool.html#1243" class="Function">and</a> <a id="1901" href="Data.Bool.html#1883" class="Bound">x</a> <a id="1903" href="Data.Bool.html#1885" class="Bound">y</a> <a data-type="A → A → Type ℓ" id="1905" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Bool → Bool → Bool" id="1907" href="Data.Bool.html#1243" class="Function">and</a> <a id="1911" href="Data.Bool.html#1885" class="Bound">y</a> <a id="1913" href="Data.Bool.html#1883" class="Bound">x</a>
<a data-type="(x y : Bool) → and x y ≡ and y x" id="1915" href="Data.Bool.html#1864" class="Function">and-commutative</a> <a data-type="Bool" id="1931" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="1937" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="1943" class="Symbol">=</a> <a data-type="x ≡ x" id="1945" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x y : Bool) → and x y ≡ and y x" id="1950" href="Data.Bool.html#1864" class="Function">and-commutative</a> <a data-type="Bool" id="1966" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="1972" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="1977" class="Symbol">=</a> <a data-type="x ≡ x" id="1979" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x y : Bool) → and x y ≡ and y x" id="1984" href="Data.Bool.html#1864" class="Function">and-commutative</a> <a data-type="Bool" id="2000" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="Bool" id="2005" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="2011" class="Symbol">=</a> <a data-type="x ≡ x" id="2013" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x y : Bool) → and x y ≡ and y x" id="2018" href="Data.Bool.html#1864" class="Function">and-commutative</a> <a data-type="Bool" id="2034" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="Bool" id="2039" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="2044" class="Symbol">=</a> <a data-type="x ≡ x" id="2046" href="1Lab.Path.html#2137" class="Function">refl</a>

<a id="or-commutative"></a><a data-type="(x y : Bool) → or x y ≡ or y x" id="2052" href="Data.Bool.html#2052" class="Function">or-commutative</a> <a id="2067" class="Symbol">:</a> <a id="2069" class="Symbol">(</a><a id="2070" href="Data.Bool.html#2070" class="Bound">x</a> <a id="2072" href="Data.Bool.html#2072" class="Bound">y</a> <a id="2074" class="Symbol">:</a> <a data-type="Type" id="2076" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="2080" class="Symbol">)</a> <a id="2082" class="Symbol">→</a> <a data-type="Bool → Bool → Bool" id="2084" href="Data.Bool.html#1247" class="Function">or</a> <a id="2087" href="Data.Bool.html#2070" class="Bound">x</a> <a id="2089" href="Data.Bool.html#2072" class="Bound">y</a> <a data-type="A → A → Type ℓ" id="2091" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Bool → Bool → Bool" id="2093" href="Data.Bool.html#1247" class="Function">or</a> <a id="2096" href="Data.Bool.html#2072" class="Bound">y</a> <a id="2098" href="Data.Bool.html#2070" class="Bound">x</a>
<a data-type="(x y : Bool) → or x y ≡ or y x" id="2100" href="Data.Bool.html#2052" class="Function">or-commutative</a> <a data-type="Bool" id="2115" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="2121" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="2127" class="Symbol">=</a> <a data-type="x ≡ x" id="2129" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x y : Bool) → or x y ≡ or y x" id="2134" href="Data.Bool.html#2052" class="Function">or-commutative</a> <a data-type="Bool" id="2149" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="2155" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="2160" class="Symbol">=</a> <a data-type="x ≡ x" id="2162" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x y : Bool) → or x y ≡ or y x" id="2167" href="Data.Bool.html#2052" class="Function">or-commutative</a> <a data-type="Bool" id="2182" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="Bool" id="2187" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="2193" class="Symbol">=</a> <a data-type="x ≡ x" id="2195" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x y : Bool) → or x y ≡ or y x" id="2200" href="Data.Bool.html#2052" class="Function">or-commutative</a> <a data-type="Bool" id="2215" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="Bool" id="2220" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="2225" class="Symbol">=</a> <a data-type="x ≡ x" id="2227" href="1Lab.Path.html#2137" class="Function">refl</a>

<a id="and-trueʳ"></a><a data-type="(x : Bool) → and x true ≡ x" id="2233" href="Data.Bool.html#2233" class="Function">and-trueʳ</a> <a id="2243" class="Symbol">:</a> <a id="2245" class="Symbol">(</a><a id="2246" href="Data.Bool.html#2246" class="Bound">x</a> <a id="2248" class="Symbol">:</a> <a data-type="Type" id="2250" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="2254" class="Symbol">)</a> <a id="2256" class="Symbol">→</a> <a data-type="Bool → Bool → Bool" id="2258" href="Data.Bool.html#1243" class="Function">and</a> <a id="2262" href="Data.Bool.html#2246" class="Bound">x</a> <a data-type="Bool" id="2264" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="A → A → Type ℓ" id="2269" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="2271" href="Data.Bool.html#2246" class="Bound">x</a>
<a data-type="(x : Bool) → and x true ≡ x" id="2273" href="Data.Bool.html#2233" class="Function">and-trueʳ</a> <a data-type="Bool" id="2283" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="2289" class="Symbol">=</a> <a data-type="x ≡ x" id="2291" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x : Bool) → and x true ≡ x" id="2296" href="Data.Bool.html#2233" class="Function">and-trueʳ</a> <a data-type="Bool" id="2306" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="2311" class="Symbol">=</a> <a data-type="x ≡ x" id="2313" href="1Lab.Path.html#2137" class="Function">refl</a>

<a id="and-falseʳ"></a><a data-type="(x : Bool) → and x false ≡ false" id="2319" href="Data.Bool.html#2319" class="Function">and-falseʳ</a> <a id="2330" class="Symbol">:</a> <a id="2332" class="Symbol">(</a><a id="2333" href="Data.Bool.html#2333" class="Bound">x</a> <a id="2335" class="Symbol">:</a> <a data-type="Type" id="2337" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="2341" class="Symbol">)</a> <a id="2343" class="Symbol">→</a> <a data-type="Bool → Bool → Bool" id="2345" href="Data.Bool.html#1243" class="Function">and</a> <a id="2349" href="Data.Bool.html#2333" class="Bound">x</a> <a data-type="Bool" id="2351" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="A → A → Type ℓ" id="2357" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Bool" id="2359" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
<a data-type="(x : Bool) → and x false ≡ false" id="2365" href="Data.Bool.html#2319" class="Function">and-falseʳ</a> <a data-type="Bool" id="2376" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="2382" class="Symbol">=</a> <a data-type="x ≡ x" id="2384" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x : Bool) → and x false ≡ false" id="2389" href="Data.Bool.html#2319" class="Function">and-falseʳ</a> <a data-type="Bool" id="2400" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="2405" class="Symbol">=</a> <a data-type="x ≡ x" id="2407" href="1Lab.Path.html#2137" class="Function">refl</a>

<a id="and-trueˡ"></a><a data-type="(x : Bool) → and true x ≡ x" id="2413" href="Data.Bool.html#2413" class="Function">and-trueˡ</a> <a id="2423" class="Symbol">:</a> <a id="2425" class="Symbol">(</a><a id="2426" href="Data.Bool.html#2426" class="Bound">x</a> <a id="2428" class="Symbol">:</a> <a data-type="Type" id="2430" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="2434" class="Symbol">)</a> <a id="2436" class="Symbol">→</a> <a data-type="Bool → Bool → Bool" id="2438" href="Data.Bool.html#1243" class="Function">and</a> <a data-type="Bool" id="2442" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="2447" href="Data.Bool.html#2426" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="2449" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="2451" href="Data.Bool.html#2426" class="Bound">x</a>
<a data-type="(x : Bool) → and true x ≡ x" id="2453" href="Data.Bool.html#2413" class="Function">and-trueˡ</a> <a id="2463" href="Data.Bool.html#2463" class="Bound">x</a> <a id="2465" class="Symbol">=</a> <a data-type="x ≡ x" id="2467" href="1Lab.Path.html#2137" class="Function">refl</a>

<a id="or-falseʳ"></a><a data-type="(x : Bool) → or x false ≡ x" id="2473" href="Data.Bool.html#2473" class="Function">or-falseʳ</a> <a id="2483" class="Symbol">:</a> <a id="2485" class="Symbol">(</a><a id="2486" href="Data.Bool.html#2486" class="Bound">x</a> <a id="2488" class="Symbol">:</a> <a data-type="Type" id="2490" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="2494" class="Symbol">)</a> <a id="2496" class="Symbol">→</a> <a data-type="Bool → Bool → Bool" id="2498" href="Data.Bool.html#1247" class="Function">or</a> <a id="2501" href="Data.Bool.html#2486" class="Bound">x</a> <a data-type="Bool" id="2503" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="A → A → Type ℓ" id="2509" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="2511" href="Data.Bool.html#2486" class="Bound">x</a>
<a data-type="(x : Bool) → or x false ≡ x" id="2513" href="Data.Bool.html#2473" class="Function">or-falseʳ</a> <a data-type="Bool" id="2523" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="2529" class="Symbol">=</a> <a data-type="x ≡ x" id="2531" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x : Bool) → or x false ≡ x" id="2536" href="Data.Bool.html#2473" class="Function">or-falseʳ</a> <a data-type="Bool" id="2546" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="2551" class="Symbol">=</a> <a data-type="x ≡ x" id="2553" href="1Lab.Path.html#2137" class="Function">refl</a>

<a id="or-trueʳ"></a><a data-type="(x : Bool) → or x true ≡ true" id="2559" href="Data.Bool.html#2559" class="Function">or-trueʳ</a> <a id="2568" class="Symbol">:</a> <a id="2570" class="Symbol">(</a><a id="2571" href="Data.Bool.html#2571" class="Bound">x</a> <a id="2573" class="Symbol">:</a> <a data-type="Type" id="2575" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="2579" class="Symbol">)</a> <a id="2581" class="Symbol">→</a> <a data-type="Bool → Bool → Bool" id="2583" href="Data.Bool.html#1247" class="Function">or</a> <a id="2586" href="Data.Bool.html#2571" class="Bound">x</a> <a data-type="Bool" id="2588" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="A → A → Type ℓ" id="2593" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Bool" id="2595" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
<a data-type="(x : Bool) → or x true ≡ true" id="2600" href="Data.Bool.html#2559" class="Function">or-trueʳ</a> <a data-type="Bool" id="2609" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="2615" class="Symbol">=</a> <a data-type="x ≡ x" id="2617" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x : Bool) → or x true ≡ true" id="2622" href="Data.Bool.html#2559" class="Function">or-trueʳ</a> <a data-type="Bool" id="2631" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="2636" class="Symbol">=</a> <a data-type="x ≡ x" id="2638" href="1Lab.Path.html#2137" class="Function">refl</a>

<a id="or-falseˡ"></a><a data-type="(x : Bool) → or false x ≡ x" id="2644" href="Data.Bool.html#2644" class="Function">or-falseˡ</a> <a id="2654" class="Symbol">:</a> <a id="2656" class="Symbol">(</a><a id="2657" href="Data.Bool.html#2657" class="Bound">x</a> <a id="2659" class="Symbol">:</a> <a data-type="Type" id="2661" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="2665" class="Symbol">)</a> <a id="2667" class="Symbol">→</a> <a data-type="Bool → Bool → Bool" id="2669" href="Data.Bool.html#1247" class="Function">or</a> <a data-type="Bool" id="2672" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="2678" href="Data.Bool.html#2657" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="2680" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="2682" href="Data.Bool.html#2657" class="Bound">x</a>
<a data-type="(x : Bool) → or false x ≡ x" id="2684" href="Data.Bool.html#2644" class="Function">or-falseˡ</a> <a id="2694" href="Data.Bool.html#2694" class="Bound">x</a> <a id="2696" class="Symbol">=</a> <a data-type="x ≡ x" id="2698" href="1Lab.Path.html#2137" class="Function">refl</a>

<a id="and-absorbs-orʳ"></a><a data-type="(x y : Bool) → and x (or x y) ≡ x" id="2704" href="Data.Bool.html#2704" class="Function">and-absorbs-orʳ</a> <a id="2720" class="Symbol">:</a> <a id="2722" class="Symbol">(</a><a id="2723" href="Data.Bool.html#2723" class="Bound">x</a> <a id="2725" href="Data.Bool.html#2725" class="Bound">y</a> <a id="2727" class="Symbol">:</a> <a data-type="Type" id="2729" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="2733" class="Symbol">)</a> <a id="2735" class="Symbol">→</a> <a data-type="Bool → Bool → Bool" id="2737" href="Data.Bool.html#1243" class="Function">and</a> <a id="2741" href="Data.Bool.html#2723" class="Bound">x</a> <a id="2743" class="Symbol">(</a><a data-type="Bool → Bool → Bool" id="2744" href="Data.Bool.html#1247" class="Function">or</a> <a id="2747" href="Data.Bool.html#2723" class="Bound">x</a> <a id="2749" href="Data.Bool.html#2725" class="Bound">y</a><a id="2750" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="2752" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="2754" href="Data.Bool.html#2723" class="Bound">x</a>
<a data-type="(x y : Bool) → and x (or x y) ≡ x" id="2756" href="Data.Bool.html#2704" class="Function">and-absorbs-orʳ</a> <a data-type="Bool" id="2772" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="2778" href="Data.Bool.html#2778" class="Bound">y</a> <a id="2780" class="Symbol">=</a> <a data-type="x ≡ x" id="2782" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x y : Bool) → and x (or x y) ≡ x" id="2787" href="Data.Bool.html#2704" class="Function">and-absorbs-orʳ</a> <a data-type="Bool" id="2803" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="2808" href="Data.Bool.html#2808" class="Bound">y</a> <a id="2810" class="Symbol">=</a> <a data-type="x ≡ x" id="2812" href="1Lab.Path.html#2137" class="Function">refl</a>

<a id="or-absorbs-andʳ"></a><a data-type="(x y : Bool) → or x (and x y) ≡ x" id="2818" href="Data.Bool.html#2818" class="Function">or-absorbs-andʳ</a> <a id="2834" class="Symbol">:</a> <a id="2836" class="Symbol">(</a><a id="2837" href="Data.Bool.html#2837" class="Bound">x</a> <a id="2839" href="Data.Bool.html#2839" class="Bound">y</a> <a id="2841" class="Symbol">:</a> <a data-type="Type" id="2843" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="2847" class="Symbol">)</a> <a id="2849" class="Symbol">→</a> <a data-type="Bool → Bool → Bool" id="2851" href="Data.Bool.html#1247" class="Function">or</a> <a id="2854" href="Data.Bool.html#2837" class="Bound">x</a> <a id="2856" class="Symbol">(</a><a data-type="Bool → Bool → Bool" id="2857" href="Data.Bool.html#1243" class="Function">and</a> <a id="2861" href="Data.Bool.html#2837" class="Bound">x</a> <a id="2863" href="Data.Bool.html#2839" class="Bound">y</a><a id="2864" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="2866" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="2868" href="Data.Bool.html#2837" class="Bound">x</a>
<a data-type="(x y : Bool) → or x (and x y) ≡ x" id="2870" href="Data.Bool.html#2818" class="Function">or-absorbs-andʳ</a> <a data-type="Bool" id="2886" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="2892" href="Data.Bool.html#2892" class="Bound">y</a> <a id="2894" class="Symbol">=</a> <a data-type="x ≡ x" id="2896" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x y : Bool) → or x (and x y) ≡ x" id="2901" href="Data.Bool.html#2818" class="Function">or-absorbs-andʳ</a> <a data-type="Bool" id="2917" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="2922" href="Data.Bool.html#2922" class="Bound">y</a> <a id="2924" class="Symbol">=</a> <a data-type="x ≡ x" id="2926" href="1Lab.Path.html#2137" class="Function">refl</a>

<a id="and-distrib-orˡ"></a><a data-type="(x y z : Bool) → and x (or y z) ≡ or (and x y) (and x z)" id="2932" href="Data.Bool.html#2932" class="Function">and-distrib-orˡ</a> <a id="2948" class="Symbol">:</a> <a id="2950" class="Symbol">(</a><a id="2951" href="Data.Bool.html#2951" class="Bound">x</a> <a id="2953" href="Data.Bool.html#2953" class="Bound">y</a> <a id="2955" href="Data.Bool.html#2955" class="Bound">z</a> <a id="2957" class="Symbol">:</a> <a data-type="Type" id="2959" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="2963" class="Symbol">)</a> <a id="2965" class="Symbol">→</a> <a data-type="Bool → Bool → Bool" id="2967" href="Data.Bool.html#1243" class="Function">and</a> <a id="2971" href="Data.Bool.html#2951" class="Bound">x</a> <a id="2973" class="Symbol">(</a><a data-type="Bool → Bool → Bool" id="2974" href="Data.Bool.html#1247" class="Function">or</a> <a id="2977" href="Data.Bool.html#2953" class="Bound">y</a> <a id="2979" href="Data.Bool.html#2955" class="Bound">z</a><a id="2980" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="2982" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Bool → Bool → Bool" id="2984" href="Data.Bool.html#1247" class="Function">or</a> <a id="2987" class="Symbol">(</a><a data-type="Bool → Bool → Bool" id="2988" href="Data.Bool.html#1243" class="Function">and</a> <a id="2992" href="Data.Bool.html#2951" class="Bound">x</a> <a id="2994" href="Data.Bool.html#2953" class="Bound">y</a><a id="2995" class="Symbol">)</a> <a id="2997" class="Symbol">(</a><a data-type="Bool → Bool → Bool" id="2998" href="Data.Bool.html#1243" class="Function">and</a> <a id="3002" href="Data.Bool.html#2951" class="Bound">x</a> <a id="3004" href="Data.Bool.html#2955" class="Bound">z</a><a id="3005" class="Symbol">)</a>
<a data-type="(x y z : Bool) → and x (or y z) ≡ or (and x y) (and x z)" id="3007" href="Data.Bool.html#2932" class="Function">and-distrib-orˡ</a> <a data-type="Bool" id="3023" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="3029" href="Data.Bool.html#3029" class="Bound">y</a> <a id="3031" href="Data.Bool.html#3031" class="Bound">z</a> <a id="3033" class="Symbol">=</a> <a data-type="x ≡ x" id="3035" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x y z : Bool) → and x (or y z) ≡ or (and x y) (and x z)" id="3040" href="Data.Bool.html#2932" class="Function">and-distrib-orˡ</a> <a data-type="Bool" id="3056" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="3061" href="Data.Bool.html#3061" class="Bound">y</a> <a id="3063" href="Data.Bool.html#3063" class="Bound">z</a> <a id="3065" class="Symbol">=</a> <a data-type="x ≡ x" id="3067" href="1Lab.Path.html#2137" class="Function">refl</a>

<a id="or-distrib-andˡ"></a><a data-type="(x y z : Bool) → or x (and y z) ≡ and (or x y) (or x z)" id="3073" href="Data.Bool.html#3073" class="Function">or-distrib-andˡ</a> <a id="3089" class="Symbol">:</a> <a id="3091" class="Symbol">(</a><a id="3092" href="Data.Bool.html#3092" class="Bound">x</a> <a id="3094" href="Data.Bool.html#3094" class="Bound">y</a> <a id="3096" href="Data.Bool.html#3096" class="Bound">z</a> <a id="3098" class="Symbol">:</a> <a data-type="Type" id="3100" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="3104" class="Symbol">)</a> <a id="3106" class="Symbol">→</a> <a data-type="Bool → Bool → Bool" id="3108" href="Data.Bool.html#1247" class="Function">or</a> <a id="3111" href="Data.Bool.html#3092" class="Bound">x</a> <a id="3113" class="Symbol">(</a><a data-type="Bool → Bool → Bool" id="3114" href="Data.Bool.html#1243" class="Function">and</a> <a id="3118" href="Data.Bool.html#3094" class="Bound">y</a> <a id="3120" href="Data.Bool.html#3096" class="Bound">z</a><a id="3121" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="3123" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Bool → Bool → Bool" id="3125" href="Data.Bool.html#1243" class="Function">and</a> <a id="3129" class="Symbol">(</a><a data-type="Bool → Bool → Bool" id="3130" href="Data.Bool.html#1247" class="Function">or</a> <a id="3133" href="Data.Bool.html#3092" class="Bound">x</a> <a id="3135" href="Data.Bool.html#3094" class="Bound">y</a><a id="3136" class="Symbol">)</a> <a id="3138" class="Symbol">(</a><a data-type="Bool → Bool → Bool" id="3139" href="Data.Bool.html#1247" class="Function">or</a> <a id="3142" href="Data.Bool.html#3092" class="Bound">x</a> <a id="3144" href="Data.Bool.html#3096" class="Bound">z</a><a id="3145" class="Symbol">)</a>
<a data-type="(x y z : Bool) → or x (and y z) ≡ and (or x y) (or x z)" id="3147" href="Data.Bool.html#3073" class="Function">or-distrib-andˡ</a> <a data-type="Bool" id="3163" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="3169" href="Data.Bool.html#3169" class="Bound">y</a> <a id="3171" href="Data.Bool.html#3171" class="Bound">z</a> <a id="3173" class="Symbol">=</a> <a data-type="x ≡ x" id="3175" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x y z : Bool) → or x (and y z) ≡ and (or x y) (or x z)" id="3180" href="Data.Bool.html#3073" class="Function">or-distrib-andˡ</a> <a data-type="Bool" id="3196" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="3201" href="Data.Bool.html#3201" class="Bound">y</a> <a id="3203" href="Data.Bool.html#3203" class="Bound">z</a> <a id="3205" class="Symbol">=</a> <a data-type="x ≡ x" id="3207" href="1Lab.Path.html#2137" class="Function">refl</a>

<a id="and-idempotent"></a><a data-type="(x : Bool) → and x x ≡ x" id="3213" href="Data.Bool.html#3213" class="Function">and-idempotent</a> <a id="3228" class="Symbol">:</a> <a id="3230" class="Symbol">(</a><a id="3231" href="Data.Bool.html#3231" class="Bound">x</a> <a id="3233" class="Symbol">:</a> <a data-type="Type" id="3235" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="3239" class="Symbol">)</a> <a id="3241" class="Symbol">→</a> <a data-type="Bool → Bool → Bool" id="3243" href="Data.Bool.html#1243" class="Function">and</a> <a id="3247" href="Data.Bool.html#3231" class="Bound">x</a> <a id="3249" href="Data.Bool.html#3231" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="3251" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="3253" href="Data.Bool.html#3231" class="Bound">x</a>
<a data-type="(x : Bool) → and x x ≡ x" id="3255" href="Data.Bool.html#3213" class="Function">and-idempotent</a> <a data-type="Bool" id="3270" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="3276" class="Symbol">=</a> <a data-type="x ≡ x" id="3278" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x : Bool) → and x x ≡ x" id="3283" href="Data.Bool.html#3213" class="Function">and-idempotent</a> <a data-type="Bool" id="3298" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="3303" class="Symbol">=</a> <a data-type="x ≡ x" id="3305" href="1Lab.Path.html#2137" class="Function">refl</a>

<a id="or-idempotent"></a><a data-type="(x : Bool) → or x x ≡ x" id="3311" href="Data.Bool.html#3311" class="Function">or-idempotent</a> <a id="3325" class="Symbol">:</a> <a id="3327" class="Symbol">(</a><a id="3328" href="Data.Bool.html#3328" class="Bound">x</a> <a id="3330" class="Symbol">:</a> <a data-type="Type" id="3332" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="3336" class="Symbol">)</a> <a id="3338" class="Symbol">→</a> <a data-type="Bool → Bool → Bool" id="3340" href="Data.Bool.html#1247" class="Function">or</a> <a id="3343" href="Data.Bool.html#3328" class="Bound">x</a> <a id="3345" href="Data.Bool.html#3328" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="3347" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="3349" href="Data.Bool.html#3328" class="Bound">x</a>
<a data-type="(x : Bool) → or x x ≡ x" id="3351" href="Data.Bool.html#3311" class="Function">or-idempotent</a> <a data-type="Bool" id="3365" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="3371" class="Symbol">=</a> <a data-type="x ≡ x" id="3373" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x : Bool) → or x x ≡ x" id="3378" href="Data.Bool.html#3311" class="Function">or-idempotent</a> <a data-type="Bool" id="3392" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="3397" class="Symbol">=</a> <a data-type="x ≡ x" id="3399" href="1Lab.Path.html#2137" class="Function">refl</a>
</pre>
<p>All the properties above hold both in classical and constructive mathematics, even in <em><a href="https://en.wikipedia.org/wiki/Minimal_logic" title="Minimal logic">minimal logic</a></em> that fails to validate both the law of the excluded middle as well as the law of noncontradiction. However, the boolean operations satisfy both of these laws:</p>
<pre class="Agda"><a id="not-involutive"></a><a data-type="(x : Bool) → not (not x) ≡ x" id="3684" href="Data.Bool.html#3684" class="Function">not-involutive</a> <a id="3699" class="Symbol">:</a> <a id="3701" class="Symbol">(</a><a id="3702" href="Data.Bool.html#3702" class="Bound">x</a> <a id="3704" class="Symbol">:</a> <a data-type="Type" id="3706" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="3710" class="Symbol">)</a> <a id="3712" class="Symbol">→</a> <a data-type="Bool → Bool" id="3714" href="Data.Bool.html#1190" class="Function">not</a> <a id="3718" class="Symbol">(</a><a data-type="Bool → Bool" id="3719" href="Data.Bool.html#1190" class="Function">not</a> <a id="3723" href="Data.Bool.html#3702" class="Bound">x</a><a id="3724" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="3726" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="3728" href="Data.Bool.html#3702" class="Bound">x</a>
<a data-type="(x : Bool) → not (not x) ≡ x" id="3730" href="Data.Bool.html#3684" class="Function">not-involutive</a> <a data-type="Bool" id="3745" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="3751" href="Data.Bool.html#3751" class="Bound">i</a> <a id="3753" class="Symbol">=</a> <a data-type="Bool" id="3755" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
<a data-type="(x : Bool) → not (not x) ≡ x" id="3761" href="Data.Bool.html#3684" class="Function">not-involutive</a> <a data-type="Bool" id="3776" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="3781" href="Data.Bool.html#3781" class="Bound">i</a> <a id="3783" class="Symbol">=</a> <a data-type="Bool" id="3785" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>

<a id="not-and≡or-not"></a><a data-type="(x y : Bool) → not (and x y) ≡ or (not x) (not y)" id="3791" href="Data.Bool.html#3791" class="Function">not-and≡or-not</a> <a id="3806" class="Symbol">:</a> <a id="3808" class="Symbol">(</a><a id="3809" href="Data.Bool.html#3809" class="Bound">x</a> <a id="3811" href="Data.Bool.html#3811" class="Bound">y</a> <a id="3813" class="Symbol">:</a> <a data-type="Type" id="3815" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="3819" class="Symbol">)</a> <a id="3821" class="Symbol">→</a> <a data-type="Bool → Bool" id="3823" href="Data.Bool.html#1190" class="Function">not</a> <a id="3827" class="Symbol">(</a><a data-type="Bool → Bool → Bool" id="3828" href="Data.Bool.html#1243" class="Function">and</a> <a id="3832" href="Data.Bool.html#3809" class="Bound">x</a> <a id="3834" href="Data.Bool.html#3811" class="Bound">y</a><a id="3835" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="3837" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Bool → Bool → Bool" id="3839" href="Data.Bool.html#1247" class="Function">or</a> <a id="3842" class="Symbol">(</a><a data-type="Bool → Bool" id="3843" href="Data.Bool.html#1190" class="Function">not</a> <a id="3847" href="Data.Bool.html#3809" class="Bound">x</a><a id="3848" class="Symbol">)</a> <a id="3850" class="Symbol">(</a><a data-type="Bool → Bool" id="3851" href="Data.Bool.html#1190" class="Function">not</a> <a id="3855" href="Data.Bool.html#3811" class="Bound">y</a><a id="3856" class="Symbol">)</a>
<a data-type="(x y : Bool) → not (and x y) ≡ or (not x) (not y)" id="3858" href="Data.Bool.html#3791" class="Function">not-and≡or-not</a> <a data-type="Bool" id="3873" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="3879" href="Data.Bool.html#3879" class="Bound">y</a> <a id="3881" class="Symbol">=</a> <a data-type="x ≡ x" id="3883" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x y : Bool) → not (and x y) ≡ or (not x) (not y)" id="3888" href="Data.Bool.html#3791" class="Function">not-and≡or-not</a> <a data-type="Bool" id="3903" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="3908" href="Data.Bool.html#3908" class="Bound">y</a> <a id="3910" class="Symbol">=</a> <a data-type="x ≡ x" id="3912" href="1Lab.Path.html#2137" class="Function">refl</a>

<a id="not-or≡and-not"></a><a data-type="(x y : Bool) → not (or x y) ≡ and (not x) (not y)" id="3918" href="Data.Bool.html#3918" class="Function">not-or≡and-not</a> <a id="3933" class="Symbol">:</a> <a id="3935" class="Symbol">(</a><a id="3936" href="Data.Bool.html#3936" class="Bound">x</a> <a id="3938" href="Data.Bool.html#3938" class="Bound">y</a> <a id="3940" class="Symbol">:</a> <a data-type="Type" id="3942" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="3946" class="Symbol">)</a> <a id="3948" class="Symbol">→</a> <a data-type="Bool → Bool" id="3950" href="Data.Bool.html#1190" class="Function">not</a> <a id="3954" class="Symbol">(</a><a data-type="Bool → Bool → Bool" id="3955" href="Data.Bool.html#1247" class="Function">or</a> <a id="3958" href="Data.Bool.html#3936" class="Bound">x</a> <a id="3960" href="Data.Bool.html#3938" class="Bound">y</a><a id="3961" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="3963" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Bool → Bool → Bool" id="3965" href="Data.Bool.html#1243" class="Function">and</a> <a id="3969" class="Symbol">(</a><a data-type="Bool → Bool" id="3970" href="Data.Bool.html#1190" class="Function">not</a> <a id="3974" href="Data.Bool.html#3936" class="Bound">x</a><a id="3975" class="Symbol">)</a> <a id="3977" class="Symbol">(</a><a data-type="Bool → Bool" id="3978" href="Data.Bool.html#1190" class="Function">not</a> <a id="3982" href="Data.Bool.html#3938" class="Bound">y</a><a id="3983" class="Symbol">)</a>
<a data-type="(x y : Bool) → not (or x y) ≡ and (not x) (not y)" id="3985" href="Data.Bool.html#3918" class="Function">not-or≡and-not</a> <a data-type="Bool" id="4000" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="4006" href="Data.Bool.html#4006" class="Bound">y</a> <a id="4008" class="Symbol">=</a> <a data-type="x ≡ x" id="4010" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x y : Bool) → not (or x y) ≡ and (not x) (not y)" id="4015" href="Data.Bool.html#3918" class="Function">not-or≡and-not</a> <a data-type="Bool" id="4030" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="4035" href="Data.Bool.html#4035" class="Bound">y</a> <a id="4037" class="Symbol">=</a> <a data-type="x ≡ x" id="4039" href="1Lab.Path.html#2137" class="Function">refl</a>

<a id="or-complementˡ"></a><a data-type="(x : Bool) → or (not x) x ≡ true" id="4045" href="Data.Bool.html#4045" class="Function">or-complementˡ</a> <a id="4060" class="Symbol">:</a> <a id="4062" class="Symbol">(</a><a id="4063" href="Data.Bool.html#4063" class="Bound">x</a> <a id="4065" class="Symbol">:</a> <a data-type="Type" id="4067" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="4071" class="Symbol">)</a> <a id="4073" class="Symbol">→</a> <a data-type="Bool → Bool → Bool" id="4075" href="Data.Bool.html#1247" class="Function">or</a> <a id="4078" class="Symbol">(</a><a data-type="Bool → Bool" id="4079" href="Data.Bool.html#1190" class="Function">not</a> <a id="4083" href="Data.Bool.html#4063" class="Bound">x</a><a id="4084" class="Symbol">)</a> <a id="4086" href="Data.Bool.html#4063" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="4088" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Bool" id="4090" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
<a data-type="(x : Bool) → or (not x) x ≡ true" id="4095" href="Data.Bool.html#4045" class="Function">or-complementˡ</a> <a data-type="Bool" id="4110" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="4116" class="Symbol">=</a> <a data-type="x ≡ x" id="4118" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x : Bool) → or (not x) x ≡ true" id="4123" href="Data.Bool.html#4045" class="Function">or-complementˡ</a> <a data-type="Bool" id="4138" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="4143" class="Symbol">=</a> <a data-type="x ≡ x" id="4145" href="1Lab.Path.html#2137" class="Function">refl</a>

<a id="and-complementˡ"></a><a data-type="(x : Bool) → and (not x) x ≡ false" id="4151" href="Data.Bool.html#4151" class="Function">and-complementˡ</a> <a id="4167" class="Symbol">:</a> <a id="4169" class="Symbol">(</a><a id="4170" href="Data.Bool.html#4170" class="Bound">x</a> <a id="4172" class="Symbol">:</a> <a data-type="Type" id="4174" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="4178" class="Symbol">)</a> <a id="4180" class="Symbol">→</a> <a data-type="Bool → Bool → Bool" id="4182" href="Data.Bool.html#1243" class="Function">and</a> <a id="4186" class="Symbol">(</a><a data-type="Bool → Bool" id="4187" href="Data.Bool.html#1190" class="Function">not</a> <a id="4191" href="Data.Bool.html#4170" class="Bound">x</a><a id="4192" class="Symbol">)</a> <a id="4194" href="Data.Bool.html#4170" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="4196" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Bool" id="4198" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
<a data-type="(x : Bool) → and (not x) x ≡ false" id="4204" href="Data.Bool.html#4151" class="Function">and-complementˡ</a> <a data-type="Bool" id="4220" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="4226" class="Symbol">=</a> <a data-type="x ≡ x" id="4228" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x : Bool) → and (not x) x ≡ false" id="4233" href="Data.Bool.html#4151" class="Function">and-complementˡ</a> <a data-type="Bool" id="4249" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="4254" class="Symbol">=</a> <a data-type="x ≡ x" id="4256" href="1Lab.Path.html#2137" class="Function">refl</a>
</pre>
<p>Exclusive disjunction (usually known as <em>XOR</em>) also yields additional structure - in particular, it can be viewed as an addition operator in a ring whose multiplication is defined by conjunction:</p>
<pre class="Agda"><a id="xor"></a><a data-type="Bool → Bool → Bool" id="4622" href="Data.Bool.html#4622" class="Function">xor</a> <a id="4626" class="Symbol">:</a> <a data-type="Type" id="4628" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a> <a id="4633" class="Symbol">→</a> <a data-type="Type" id="4635" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a> <a id="4640" class="Symbol">→</a> <a data-type="Type" id="4642" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
<a data-type="Bool → Bool → Bool" id="4647" href="Data.Bool.html#4622" class="Function">xor</a> <a data-type="Bool" id="4651" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="4657" href="Data.Bool.html#4657" class="Bound">y</a> <a id="4659" class="Symbol">=</a> <a id="4661" href="Data.Bool.html#4657" class="Bound">y</a>
<a data-type="Bool → Bool → Bool" id="4663" href="Data.Bool.html#4622" class="Function">xor</a> <a data-type="Bool" id="4667" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="4672" href="Data.Bool.html#4672" class="Bound">y</a> <a id="4674" class="Symbol">=</a> <a data-type="Bool → Bool" id="4676" href="Data.Bool.html#1190" class="Function">not</a> <a id="4680" href="Data.Bool.html#4672" class="Bound">y</a>

<a id="xor-associative"></a><a data-type="(x y z : Bool) → xor x (xor y z) ≡ xor (xor x y) z" id="4683" href="Data.Bool.html#4683" class="Function">xor-associative</a> <a id="4699" class="Symbol">:</a> <a id="4701" class="Symbol">(</a><a id="4702" href="Data.Bool.html#4702" class="Bound">x</a> <a id="4704" href="Data.Bool.html#4704" class="Bound">y</a> <a id="4706" href="Data.Bool.html#4706" class="Bound">z</a> <a id="4708" class="Symbol">:</a> <a data-type="Type" id="4710" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="4714" class="Symbol">)</a> <a id="4716" class="Symbol">→</a> <a data-type="Bool → Bool → Bool" id="4718" href="Data.Bool.html#4622" class="Function">xor</a> <a id="4722" href="Data.Bool.html#4702" class="Bound">x</a> <a id="4724" class="Symbol">(</a><a data-type="Bool → Bool → Bool" id="4725" href="Data.Bool.html#4622" class="Function">xor</a> <a id="4729" href="Data.Bool.html#4704" class="Bound">y</a> <a id="4731" href="Data.Bool.html#4706" class="Bound">z</a><a id="4732" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="4734" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Bool → Bool → Bool" id="4736" href="Data.Bool.html#4622" class="Function">xor</a> <a id="4740" class="Symbol">(</a><a data-type="Bool → Bool → Bool" id="4741" href="Data.Bool.html#4622" class="Function">xor</a> <a id="4745" href="Data.Bool.html#4702" class="Bound">x</a> <a id="4747" href="Data.Bool.html#4704" class="Bound">y</a><a id="4748" class="Symbol">)</a> <a id="4750" href="Data.Bool.html#4706" class="Bound">z</a>
<a data-type="(x y z : Bool) → xor x (xor y z) ≡ xor (xor x y) z" id="4752" href="Data.Bool.html#4683" class="Function">xor-associative</a> <a data-type="Bool" id="4768" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="4774" href="Data.Bool.html#4774" class="Bound">y</a> <a id="4776" href="Data.Bool.html#4776" class="Bound">z</a> <a id="4778" class="Symbol">=</a> <a data-type="x ≡ x" id="4780" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x y z : Bool) → xor x (xor y z) ≡ xor (xor x y) z" id="4785" href="Data.Bool.html#4683" class="Function">xor-associative</a> <a data-type="Bool" id="4801" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="Bool" id="4806" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="4812" href="Data.Bool.html#4812" class="Bound">z</a> <a id="4814" class="Symbol">=</a> <a data-type="x ≡ x" id="4816" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x y z : Bool) → xor x (xor y z) ≡ xor (xor x y) z" id="4821" href="Data.Bool.html#4683" class="Function">xor-associative</a> <a data-type="Bool" id="4837" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="Bool" id="4842" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="4847" href="Data.Bool.html#4847" class="Bound">z</a> <a id="4849" class="Symbol">=</a> <a data-type="(x : Bool) → not (not x) ≡ x" id="4851" href="Data.Bool.html#3684" class="Function">not-involutive</a> <a id="4866" href="Data.Bool.html#4847" class="Bound">z</a>

<a id="xor-commutative"></a><a data-type="(x y : Bool) → xor x y ≡ xor y x" id="4869" href="Data.Bool.html#4869" class="Function">xor-commutative</a> <a id="4885" class="Symbol">:</a> <a id="4887" class="Symbol">(</a><a id="4888" href="Data.Bool.html#4888" class="Bound">x</a> <a id="4890" href="Data.Bool.html#4890" class="Bound">y</a> <a id="4892" class="Symbol">:</a> <a data-type="Type" id="4894" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="4898" class="Symbol">)</a> <a id="4900" class="Symbol">→</a> <a data-type="Bool → Bool → Bool" id="4902" href="Data.Bool.html#4622" class="Function">xor</a> <a id="4906" href="Data.Bool.html#4888" class="Bound">x</a> <a id="4908" href="Data.Bool.html#4890" class="Bound">y</a> <a data-type="A → A → Type ℓ" id="4910" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Bool → Bool → Bool" id="4912" href="Data.Bool.html#4622" class="Function">xor</a> <a id="4916" href="Data.Bool.html#4890" class="Bound">y</a> <a id="4918" href="Data.Bool.html#4888" class="Bound">x</a>
<a data-type="(x y : Bool) → xor x y ≡ xor y x" id="4920" href="Data.Bool.html#4869" class="Function">xor-commutative</a> <a data-type="Bool" id="4936" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="4942" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="4948" class="Symbol">=</a> <a data-type="x ≡ x" id="4950" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x y : Bool) → xor x y ≡ xor y x" id="4955" href="Data.Bool.html#4869" class="Function">xor-commutative</a> <a data-type="Bool" id="4971" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="4977" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="4982" class="Symbol">=</a> <a data-type="x ≡ x" id="4984" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x y : Bool) → xor x y ≡ xor y x" id="4989" href="Data.Bool.html#4869" class="Function">xor-commutative</a> <a data-type="Bool" id="5005" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="Bool" id="5010" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="5016" class="Symbol">=</a> <a data-type="x ≡ x" id="5018" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x y : Bool) → xor x y ≡ xor y x" id="5023" href="Data.Bool.html#4869" class="Function">xor-commutative</a> <a data-type="Bool" id="5039" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="Bool" id="5044" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="5049" class="Symbol">=</a> <a data-type="x ≡ x" id="5051" href="1Lab.Path.html#2137" class="Function">refl</a>

<a id="xor-falseʳ"></a><a data-type="(x : Bool) → xor x false ≡ x" id="5057" href="Data.Bool.html#5057" class="Function">xor-falseʳ</a> <a id="5068" class="Symbol">:</a> <a id="5070" class="Symbol">(</a><a id="5071" href="Data.Bool.html#5071" class="Bound">x</a> <a id="5073" class="Symbol">:</a> <a data-type="Type" id="5075" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="5079" class="Symbol">)</a> <a id="5081" class="Symbol">→</a> <a data-type="Bool → Bool → Bool" id="5083" href="Data.Bool.html#4622" class="Function">xor</a> <a id="5087" href="Data.Bool.html#5071" class="Bound">x</a> <a data-type="Bool" id="5089" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="A → A → Type ℓ" id="5095" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="5097" href="Data.Bool.html#5071" class="Bound">x</a>
<a data-type="(x : Bool) → xor x false ≡ x" id="5099" href="Data.Bool.html#5057" class="Function">xor-falseʳ</a> <a data-type="Bool" id="5110" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="5116" class="Symbol">=</a> <a data-type="x ≡ x" id="5118" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x : Bool) → xor x false ≡ x" id="5123" href="Data.Bool.html#5057" class="Function">xor-falseʳ</a> <a data-type="Bool" id="5134" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="5139" class="Symbol">=</a> <a data-type="x ≡ x" id="5141" href="1Lab.Path.html#2137" class="Function">refl</a>

<a id="xor-trueʳ"></a><a data-type="(x : Bool) → xor x true ≡ not x" id="5147" href="Data.Bool.html#5147" class="Function">xor-trueʳ</a> <a id="5157" class="Symbol">:</a> <a id="5159" class="Symbol">(</a><a id="5160" href="Data.Bool.html#5160" class="Bound">x</a> <a id="5162" class="Symbol">:</a> <a data-type="Type" id="5164" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="5168" class="Symbol">)</a> <a id="5170" class="Symbol">→</a> <a data-type="Bool → Bool → Bool" id="5172" href="Data.Bool.html#4622" class="Function">xor</a> <a id="5176" href="Data.Bool.html#5160" class="Bound">x</a> <a data-type="Bool" id="5178" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="A → A → Type ℓ" id="5183" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Bool → Bool" id="5185" href="Data.Bool.html#1190" class="Function">not</a> <a id="5189" href="Data.Bool.html#5160" class="Bound">x</a>
<a data-type="(x : Bool) → xor x true ≡ not x" id="5191" href="Data.Bool.html#5147" class="Function">xor-trueʳ</a> <a data-type="Bool" id="5201" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="5207" class="Symbol">=</a> <a data-type="x ≡ x" id="5209" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x : Bool) → xor x true ≡ not x" id="5214" href="Data.Bool.html#5147" class="Function">xor-trueʳ</a> <a data-type="Bool" id="5224" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="5229" class="Symbol">=</a> <a data-type="x ≡ x" id="5231" href="1Lab.Path.html#2137" class="Function">refl</a>

<a id="xor-inverse-self"></a><a data-type="(x : Bool) → xor x x ≡ false" id="5237" href="Data.Bool.html#5237" class="Function">xor-inverse-self</a> <a id="5254" class="Symbol">:</a> <a id="5256" class="Symbol">(</a><a id="5257" href="Data.Bool.html#5257" class="Bound">x</a> <a id="5259" class="Symbol">:</a> <a data-type="Type" id="5261" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="5265" class="Symbol">)</a> <a id="5267" class="Symbol">→</a> <a data-type="Bool → Bool → Bool" id="5269" href="Data.Bool.html#4622" class="Function">xor</a> <a id="5273" href="Data.Bool.html#5257" class="Bound">x</a> <a id="5275" href="Data.Bool.html#5257" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="5277" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Bool" id="5279" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
<a data-type="(x : Bool) → xor x x ≡ false" id="5285" href="Data.Bool.html#5237" class="Function">xor-inverse-self</a> <a data-type="Bool" id="5302" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="5308" class="Symbol">=</a> <a data-type="x ≡ x" id="5310" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x : Bool) → xor x x ≡ false" id="5315" href="Data.Bool.html#5237" class="Function">xor-inverse-self</a> <a data-type="Bool" id="5332" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="5337" class="Symbol">=</a> <a data-type="x ≡ x" id="5339" href="1Lab.Path.html#2137" class="Function">refl</a>

<a id="and-distrib-xorʳ"></a><a data-type="(x y z : Bool) → and (xor x y) z ≡ xor (and x z) (and y z)" id="5345" href="Data.Bool.html#5345" class="Function">and-distrib-xorʳ</a> <a id="5362" class="Symbol">:</a> <a id="5364" class="Symbol">(</a><a id="5365" href="Data.Bool.html#5365" class="Bound">x</a> <a id="5367" href="Data.Bool.html#5367" class="Bound">y</a> <a id="5369" href="Data.Bool.html#5369" class="Bound">z</a> <a id="5371" class="Symbol">:</a> <a data-type="Type" id="5373" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="5377" class="Symbol">)</a> <a id="5379" class="Symbol">→</a> <a data-type="Bool → Bool → Bool" id="5381" href="Data.Bool.html#1243" class="Function">and</a> <a id="5385" class="Symbol">(</a><a data-type="Bool → Bool → Bool" id="5386" href="Data.Bool.html#4622" class="Function">xor</a> <a id="5390" href="Data.Bool.html#5365" class="Bound">x</a> <a id="5392" href="Data.Bool.html#5367" class="Bound">y</a><a id="5393" class="Symbol">)</a> <a id="5395" href="Data.Bool.html#5369" class="Bound">z</a> <a data-type="A → A → Type ℓ" id="5397" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Bool → Bool → Bool" id="5399" href="Data.Bool.html#4622" class="Function">xor</a> <a id="5403" class="Symbol">(</a><a data-type="Bool → Bool → Bool" id="5404" href="Data.Bool.html#1243" class="Function">and</a> <a id="5408" href="Data.Bool.html#5365" class="Bound">x</a> <a id="5410" href="Data.Bool.html#5369" class="Bound">z</a><a id="5411" class="Symbol">)</a> <a id="5413" class="Symbol">(</a><a data-type="Bool → Bool → Bool" id="5414" href="Data.Bool.html#1243" class="Function">and</a> <a id="5418" href="Data.Bool.html#5367" class="Bound">y</a> <a id="5420" href="Data.Bool.html#5369" class="Bound">z</a><a id="5421" class="Symbol">)</a>
<a data-type="(x y z : Bool) → and (xor x y) z ≡ xor (and x z) (and y z)" id="5423" href="Data.Bool.html#5345" class="Function">and-distrib-xorʳ</a> <a data-type="Bool" id="5440" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="5446" href="Data.Bool.html#5446" class="Bound">y</a> <a id="5448" href="Data.Bool.html#5448" class="Bound">z</a> <a id="5450" class="Symbol">=</a> <a data-type="x ≡ x" id="5452" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x y z : Bool) → and (xor x y) z ≡ xor (and x z) (and y z)" id="5457" href="Data.Bool.html#5345" class="Function">and-distrib-xorʳ</a> <a data-type="Bool" id="5474" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="5479" href="Data.Bool.html#5479" class="Bound">y</a> <a data-type="Bool" id="5481" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="5487" class="Symbol">=</a> <a data-type="(x : Bool) → and x false ≡ false" id="5489" href="Data.Bool.html#2319" class="Function">and-falseʳ</a> <a id="5500" class="Symbol">(</a><a data-type="Bool → Bool" id="5501" href="Data.Bool.html#1190" class="Function">not</a> <a id="5505" href="Data.Bool.html#5479" class="Bound">y</a><a id="5506" class="Symbol">)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="5508" href="1Lab.Path.html#38031" class="Function Operator">∙</a> <a data-type="x ≡ y → y ≡ x" id="5510" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="5514" class="Symbol">(</a><a data-type="(x : Bool) → and x false ≡ false" id="5515" href="Data.Bool.html#2319" class="Function">and-falseʳ</a> <a id="5526" href="Data.Bool.html#5479" class="Bound">y</a><a id="5527" class="Symbol">)</a>
<a data-type="(x y z : Bool) → and (xor x y) z ≡ xor (and x z) (and y z)" id="5529" href="Data.Bool.html#5345" class="Function">and-distrib-xorʳ</a> <a data-type="Bool" id="5546" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="5551" href="Data.Bool.html#5551" class="Bound">y</a> <a data-type="Bool" id="5553" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="5558" class="Symbol">=</a> <a id="5560" class="Symbol">(</a><a data-type="(x : Bool) → and x true ≡ x" id="5561" href="Data.Bool.html#2233" class="Function">and-trueʳ</a> <a id="5571" class="Symbol">(</a><a data-type="Bool → Bool" id="5572" href="Data.Bool.html#1190" class="Function">not</a> <a id="5576" href="Data.Bool.html#5551" class="Bound">y</a><a id="5577" class="Symbol">))</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="5580" href="1Lab.Path.html#38031" class="Function Operator">∙</a> <a data-type="(f : (x : A) → B x) (p : x ≡ y) → PathP (λ i → B (p i)) (f x) (f y)" id="5582" href="1Lab.Path.html#19262" class="Function">ap</a> <a data-type="Bool → Bool" id="5585" href="Data.Bool.html#1190" class="Function">not</a> <a id="5589" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="5590" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="5594" class="Symbol">(</a><a data-type="(x : Bool) → and x true ≡ x" id="5595" href="Data.Bool.html#2233" class="Function">and-trueʳ</a> <a id="5605" href="Data.Bool.html#5551" class="Bound">y</a><a id="5606" class="Symbol">))</a>
</pre>
<p>Material implication between booleans also interacts nicely with many of the other operations:</p>
<pre class="Agda"><a id="imp"></a><a data-type="Bool → Bool → Bool" id="5718" href="Data.Bool.html#5718" class="Function">imp</a> <a id="5722" class="Symbol">:</a> <a data-type="Type" id="5724" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a> <a id="5729" class="Symbol">→</a> <a data-type="Type" id="5731" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a> <a id="5736" class="Symbol">→</a> <a data-type="Type" id="5738" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
<a data-type="Bool → Bool → Bool" id="5743" href="Data.Bool.html#5718" class="Function">imp</a> <a data-type="Bool" id="5747" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="5753" href="Data.Bool.html#5753" class="Bound">y</a> <a id="5755" class="Symbol">=</a> <a data-type="Bool" id="5757" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
<a data-type="Bool → Bool → Bool" id="5762" href="Data.Bool.html#5718" class="Function">imp</a> <a data-type="Bool" id="5766" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="5771" href="Data.Bool.html#5771" class="Bound">y</a> <a id="5773" class="Symbol">=</a> <a id="5775" href="Data.Bool.html#5771" class="Bound">y</a>

<a id="imp-trueʳ"></a><a data-type="(x : Bool) → imp x true ≡ true" id="5778" href="Data.Bool.html#5778" class="Function">imp-trueʳ</a> <a id="5788" class="Symbol">:</a> <a id="5790" class="Symbol">(</a><a id="5791" href="Data.Bool.html#5791" class="Bound">x</a> <a id="5793" class="Symbol">:</a> <a data-type="Type" id="5795" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="5799" class="Symbol">)</a> <a id="5801" class="Symbol">→</a> <a data-type="Bool → Bool → Bool" id="5803" href="Data.Bool.html#5718" class="Function">imp</a> <a id="5807" href="Data.Bool.html#5791" class="Bound">x</a> <a data-type="Bool" id="5809" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="A → A → Type ℓ" id="5814" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Bool" id="5816" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
<a data-type="(x : Bool) → imp x true ≡ true" id="5821" href="Data.Bool.html#5778" class="Function">imp-trueʳ</a> <a data-type="Bool" id="5831" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="5837" class="Symbol">=</a> <a data-type="x ≡ x" id="5839" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x : Bool) → imp x true ≡ true" id="5844" href="Data.Bool.html#5778" class="Function">imp-trueʳ</a> <a data-type="Bool" id="5854" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="5859" class="Symbol">=</a> <a data-type="x ≡ x" id="5861" href="1Lab.Path.html#2137" class="Function">refl</a>
</pre>
<h2 id="discreteness"><a href="#discreteness" class="header-link">Discreteness<span class="header-link-emoji">🔗</span></a></h2>
<p>Using pattern matching, and the fact that <span class="Agda"><a data-type="true ≡ false → ⊥" href="Data.Bool.html#575" class="Function">true isn&#39;t false</a></span>, one can write an algorithm to tell whether or not two booleans are the same:</p>
<pre class="Agda"><a id="Discrete-Bool"></a><a data-type="Discrete Bool" id="6061" href="Data.Bool.html#6061" class="Function">Discrete-Bool</a> <a id="6075" class="Symbol">:</a> <a data-type="Type ℓ → Type ℓ" id="6077" href="1Lab.Type.Dec.html#528" class="Function">Discrete</a> <a data-type="Type" id="6086" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
<a data-type="Discrete Bool" id="6091" href="Data.Bool.html#6061" class="Function">Discrete-Bool</a> <a data-type="Bool" id="6105" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="6111" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="6117" class="Symbol">=</a> <a data-type="A → Dec A" id="6119" href="1Lab.Type.Dec.html#235" class="InductiveConstructor">yes</a> <a data-type="x ≡ x" id="6123" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="Discrete Bool" id="6128" href="Data.Bool.html#6061" class="Function">Discrete-Bool</a> <a data-type="Bool" id="6142" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="Bool" id="6148" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="6153" class="Symbol">=</a> <a data-type="(A → ⊥) → Dec A" id="6155" href="1Lab.Type.Dec.html#253" class="InductiveConstructor">no</a> <a id="6158" class="Symbol">(λ</a> <a id="6161" href="Data.Bool.html#6161" class="Bound">p</a> <a id="6163" class="Symbol">→</a> <a data-type="true ≡ false → ⊥" id="6165" href="Data.Bool.html#575" class="Function">true≠false</a> <a id="6176" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="6177" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="6181" href="Data.Bool.html#6161" class="Bound">p</a><a id="6182" class="Symbol">))</a>
<a data-type="Discrete Bool" id="6185" href="Data.Bool.html#6061" class="Function">Discrete-Bool</a> <a data-type="Bool" id="6199" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="Bool" id="6204" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="6210" class="Symbol">=</a> <a data-type="(A → ⊥) → Dec A" id="6212" href="1Lab.Type.Dec.html#253" class="InductiveConstructor">no</a> <a data-type="true ≡ false → ⊥" id="6215" href="Data.Bool.html#575" class="Function">true≠false</a>
<a data-type="Discrete Bool" id="6226" href="Data.Bool.html#6061" class="Function">Discrete-Bool</a> <a data-type="Bool" id="6240" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="Bool" id="6245" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="6250" class="Symbol">=</a> <a data-type="A → Dec A" id="6252" href="1Lab.Type.Dec.html#235" class="InductiveConstructor">yes</a> <a data-type="x ≡ x" id="6256" href="1Lab.Path.html#2137" class="Function">refl</a>

<a id="isSet-Bool"></a><a data-type="isSet Bool" id="6262" href="Data.Bool.html#6262" class="Function">isSet-Bool</a> <a id="6273" class="Symbol">:</a> <a data-type="Type ℓ → Type ℓ" id="6275" href="1Lab.HLevel.html#3342" class="Function">isSet</a> <a data-type="Type" id="6281" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
<a data-type="isSet Bool" id="6286" href="Data.Bool.html#6262" class="Function">isSet-Bool</a> <a id="6297" class="Symbol">=</a> <a data-type="Discrete A → isSet A" id="6299" href="1Lab.HLevel.Sets.html#3101" class="Function">Discrete→isSet</a> <a data-type="Discrete Bool" id="6314" href="Data.Bool.html#6061" class="Function">Discrete-Bool</a>
</pre>
<p>Furthermore, if we know we’re not looking at true, then we must be looking at false, and vice-versa:</p>
<pre class="Agda"><a id="x≠true→x≡false"></a><a data-type="(x : Bool) → (x ≡ true → ⊥) → x ≡ false" id="6443" href="Data.Bool.html#6443" class="Function">x≠true→x≡false</a> <a id="6458" class="Symbol">:</a> <a id="6460" class="Symbol">(</a><a id="6461" href="Data.Bool.html#6461" class="Bound">x</a> <a id="6463" class="Symbol">:</a> <a data-type="Type" id="6465" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="6469" class="Symbol">)</a> <a id="6471" class="Symbol">→</a> <a id="6473" class="Symbol">(</a><a id="6474" href="Data.Bool.html#6461" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="6476" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Bool" id="6478" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="6483" class="Symbol">→</a> <a data-type="Type" id="6485" href="1Lab.Type.html#1326" class="Datatype">⊥</a><a id="6486" class="Symbol">)</a> <a id="6488" class="Symbol">→</a> <a id="6490" href="Data.Bool.html#6461" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="6492" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Bool" id="6494" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
<a data-type="(x : Bool) → (x ≡ true → ⊥) → x ≡ false" id="6500" href="Data.Bool.html#6443" class="Function">x≠true→x≡false</a> <a data-type="Bool" id="6515" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="6521" href="Data.Bool.html#6521" class="Bound">p</a> <a id="6523" class="Symbol">=</a> <a data-type="x ≡ x" id="6525" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="(x : Bool) → (x ≡ true → ⊥) → x ≡ false" id="6530" href="Data.Bool.html#6443" class="Function">x≠true→x≡false</a> <a data-type="Bool" id="6545" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="6550" href="Data.Bool.html#6550" class="Bound">p</a> <a id="6552" class="Symbol">=</a> <a data-type="⊥ → A" id="6554" href="1Lab.Type.html#1342" class="Function">absurd</a> <a id="6561" class="Symbol">(</a><a id="6562" href="Data.Bool.html#6550" class="Bound">p</a> <a data-type="x ≡ x" id="6564" href="1Lab.Path.html#2137" class="Function">refl</a><a id="6568" class="Symbol">)</a>

<a id="x≠false→x≡true"></a><a data-type="(x : Bool) → (x ≡ false → ⊥) → x ≡ true" id="6571" href="Data.Bool.html#6571" class="Function">x≠false→x≡true</a> <a id="6586" class="Symbol">:</a> <a id="6588" class="Symbol">(</a><a id="6589" href="Data.Bool.html#6589" class="Bound">x</a> <a id="6591" class="Symbol">:</a> <a data-type="Type" id="6593" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="6597" class="Symbol">)</a> <a id="6599" class="Symbol">→</a> <a id="6601" class="Symbol">(</a><a id="6602" href="Data.Bool.html#6589" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="6604" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Bool" id="6606" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="6612" class="Symbol">→</a> <a data-type="Type" id="6614" href="1Lab.Type.html#1326" class="Datatype">⊥</a><a id="6615" class="Symbol">)</a> <a id="6617" class="Symbol">→</a> <a id="6619" href="Data.Bool.html#6589" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="6621" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Bool" id="6623" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
<a data-type="(x : Bool) → (x ≡ false → ⊥) → x ≡ true" id="6628" href="Data.Bool.html#6571" class="Function">x≠false→x≡true</a> <a data-type="Bool" id="6643" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="6649" href="Data.Bool.html#6649" class="Bound">p</a> <a id="6651" class="Symbol">=</a> <a data-type="⊥ → A" id="6653" href="1Lab.Type.html#1342" class="Function">absurd</a> <a id="6660" class="Symbol">(</a><a id="6661" href="Data.Bool.html#6649" class="Bound">p</a> <a data-type="x ≡ x" id="6663" href="1Lab.Path.html#2137" class="Function">refl</a><a id="6667" class="Symbol">)</a>
<a data-type="(x : Bool) → (x ≡ false → ⊥) → x ≡ true" id="6669" href="Data.Bool.html#6571" class="Function">x≠false→x≡true</a> <a data-type="Bool" id="6684" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="6689" href="Data.Bool.html#6689" class="Bound">p</a> <a id="6691" class="Symbol">=</a> <a data-type="x ≡ x" id="6693" href="1Lab.Path.html#2137" class="Function">refl</a>
</pre>
<h2 id="the-not-equivalence"><a href="#the-not-equivalence" class="header-link">The “not” equivalence<span class="header-link-emoji">🔗</span></a></h2>
<p>The construction of <span class="Agda"><a data-type="Bool → Bool" href="Data.Bool.html#1190" class="Function">not</a></span> as an equivalence factors through showing that <code>not</code> is an isomorphism. In particular, <span class="Agda"><a data-type="Bool → Bool" href="Data.Bool.html#1190" class="Function">not</a></span> is its own inverse, so we need a proof that it’s involutive, as is proven in <span class="Agda"><a data-type="(x : Bool) → not (not x) ≡ x" href="Data.Bool.html#3684" class="Function">not-involutive</a></span>. With this, we can get a proof that it’s an equivalence:</p>
<pre class="Agda"><a id="isEquiv-not"></a><a data-type="isEquiv not" id="7030" href="Data.Bool.html#7030" class="Function">isEquiv-not</a> <a id="7042" class="Symbol">:</a> <a data-type="(f : A → B) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="7044" href="1Lab.Equiv.html#2293" class="Record">isEquiv</a> <a data-type="Bool → Bool" id="7052" href="Data.Bool.html#1190" class="Function">not</a>
<a data-type="isEquiv not" id="7056" href="Data.Bool.html#7030" class="Function">isEquiv-not</a> <a id="7068" class="Symbol">=</a> <a data-type="(i : isIso f) → isEquiv f" id="7070" href="1Lab.Equiv.html#19765" class="Function">isIso→isEquiv</a> <a id="7084" class="Symbol">(</a><a data-type="(inv₁ : B → A) (rinv₁ : isRightInverse inv₁ f)
(linv₁ : isLeftInverse inv₁ f) →
isIso f" id="7085" href="1Lab.Equiv.html#6064" class="InductiveConstructor">iso</a> <a data-type="Bool → Bool" id="7089" href="Data.Bool.html#1190" class="Function">not</a> <a data-type="(x : Bool) → not (not x) ≡ x" id="7093" href="Data.Bool.html#3684" class="Function">not-involutive</a> <a data-type="(x : Bool) → not (not x) ≡ x" id="7108" href="Data.Bool.html#3684" class="Function">not-involutive</a><a id="7122" class="Symbol">)</a>
</pre>
<h2 id="autbool"><a href="#autbool" class="header-link">Aut(Bool)<span class="header-link-emoji">🔗</span></a></h2>
<p>We characterise the type <code>Bool ≡ Bool</code>. There are exactly two paths, and we can decide which path we’re looking at by seeing how it acts on the element <span class="Agda"><a data-type="Bool" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a></span>.</p>
<p>First, two small lemmas: we can tell whether we’re looking at the identity equivalence or the “not” equivalence by seeing how it acts on the constructors.</p>
<pre class="Agda"><a id="7475" class="Keyword">private</a>
  <a id="idLemma"></a><a id="7485" href="Data.Bool.html#7485" class="Function">idLemma</a> <a id="7493" class="Symbol">:</a> <a id="7495" class="Symbol">(</a><a id="7496" href="Data.Bool.html#7496" class="Bound">p</a> <a id="7498" class="Symbol">:</a> <a data-type="Type" id="7500" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="7505" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a data-type="Type" id="7507" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="7511" class="Symbol">)</a>
          <a id="7523" class="Symbol">→</a> <a id="7525" href="Data.Bool.html#7496" class="Bound">p</a> <a id="7527" class="Symbol">.</a><a data-type="∑ A B → A" id="7528" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Bool" id="7532" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="A → A → Type ℓ" id="7537" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Bool" id="7539" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
          <a id="7554" class="Symbol">→</a> <a id="7556" href="Data.Bool.html#7496" class="Bound">p</a> <a id="7558" class="Symbol">.</a><a data-type="∑ A B → A" id="7559" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Bool" id="7563" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="A → A → Type ℓ" id="7569" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Bool" id="7571" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
          <a id="7587" class="Symbol">→</a> <a id="7589" href="Data.Bool.html#7496" class="Bound">p</a> <a data-type="A → A → Type ℓ" id="7591" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="7593" class="Symbol">(_</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="7596" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="7598" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="7605" class="Symbol">)</a>
  <a id="7609" href="Data.Bool.html#7485" class="Function">idLemma</a> <a id="7617" href="Data.Bool.html#7617" class="Bound">p</a> <a id="7619" href="Data.Bool.html#7619" class="Bound">p1</a> <a id="7622" href="Data.Bool.html#7622" class="Bound">p2</a> <a id="7625" class="Symbol">=</a> <a data-type="(p : x .fst ≡ y .fst) → subst B p (x .snd) ≡ y .snd → x ≡ y" id="7627" href="1Lab.Path.html#55595" class="Function">Σ-Path</a> <a id="7634" class="Symbol">(</a><a data-type="((x : A) → f x ≡ g x) → f ≡ g" id="7635" href="1Lab.Path.html#56413" class="Function">funext</a> <a id="7642" href="Data.Bool.html#7682" class="Function">lemma</a><a id="7647" class="Symbol">)</a> <a id="7649" class="Symbol">(</a><a data-type="(f : A → B) → isProp (isEquiv f)" id="7650" href="1Lab.Equiv.html#4883" class="Function">isProp-isEquiv</a> <a id="7665" class="Symbol">_</a> <a id="7667" class="Symbol">_</a> <a id="7669" class="Symbol">_)</a> <a id="7672" class="Keyword">where</a>
    <a id="7682" href="Data.Bool.html#7682" class="Function">lemma</a> <a id="7688" class="Symbol">:</a> <a id="7690" class="Symbol">(</a><a id="7691" href="Data.Bool.html#7691" class="Bound">x</a> <a id="7693" class="Symbol">:</a> <a data-type="Type" id="7695" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="7699" class="Symbol">)</a> <a id="7701" class="Symbol">→</a> <a id="7703" class="Symbol">_</a>
    <a id="7709" href="Data.Bool.html#7682" class="Function">lemma</a> <a data-type="Bool" id="7715" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="7721" class="Symbol">=</a> <a id="7723" href="Data.Bool.html#7622" class="Bound">p2</a>
    <a id="7730" href="Data.Bool.html#7682" class="Function">lemma</a> <a data-type="Bool" id="7736" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="7741" class="Symbol">=</a> <a id="7743" href="Data.Bool.html#7619" class="Bound">p1</a>
</pre>
<p>If it quacks like the identity equivalence, then it must be. Otherwise we’re looking at the <span class="Agda"><a data-type="Bool → Bool" href="Data.Bool.html#1190" class="Function">not</a></span> equivalence.</p>
<pre class="Agda">  <a id="notLemma"></a><a id="7880" href="Data.Bool.html#7880" class="Function">notLemma</a> <a id="7889" class="Symbol">:</a> <a id="7891" class="Symbol">(</a><a id="7892" href="Data.Bool.html#7892" class="Bound">p</a> <a id="7894" class="Symbol">:</a> <a data-type="Type" id="7896" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="7901" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a data-type="Type" id="7903" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="7907" class="Symbol">)</a>
           <a id="7920" class="Symbol">→</a> <a id="7922" href="Data.Bool.html#7892" class="Bound">p</a> <a id="7924" class="Symbol">.</a><a data-type="∑ A B → A" id="7925" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Bool" id="7929" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="A → A → Type ℓ" id="7934" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Bool" id="7936" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
           <a id="7953" class="Symbol">→</a> <a id="7955" href="Data.Bool.html#7892" class="Bound">p</a> <a id="7957" class="Symbol">.</a><a data-type="∑ A B → A" id="7958" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Bool" id="7962" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="A → A → Type ℓ" id="7968" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Bool" id="7970" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
           <a id="7986" class="Symbol">→</a> <a id="7988" href="Data.Bool.html#7892" class="Bound">p</a> <a data-type="A → A → Type ℓ" id="7990" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="7992" class="Symbol">(</a><a data-type="Bool → Bool" id="7993" href="Data.Bool.html#1190" class="Function">not</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="7997" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv not" id="7999" href="Data.Bool.html#7030" class="Function">isEquiv-not</a><a id="8010" class="Symbol">)</a>
  <a id="8014" href="Data.Bool.html#7880" class="Function">notLemma</a> <a id="8023" href="Data.Bool.html#8023" class="Bound">p</a> <a id="8025" href="Data.Bool.html#8025" class="Bound">p1</a> <a id="8028" href="Data.Bool.html#8028" class="Bound">p2</a> <a id="8031" class="Symbol">=</a> <a data-type="(p : x .fst ≡ y .fst) → subst B p (x .snd) ≡ y .snd → x ≡ y" id="8033" href="1Lab.Path.html#55595" class="Function">Σ-Path</a> <a id="8040" class="Symbol">(</a><a data-type="((x : A) → f x ≡ g x) → f ≡ g" id="8041" href="1Lab.Path.html#56413" class="Function">funext</a> <a id="8048" href="Data.Bool.html#8088" class="Function">lemma</a><a id="8053" class="Symbol">)</a> <a id="8055" class="Symbol">(</a><a data-type="(f : A → B) → isProp (isEquiv f)" id="8056" href="1Lab.Equiv.html#4883" class="Function">isProp-isEquiv</a> <a id="8071" class="Symbol">_</a> <a id="8073" class="Symbol">_</a> <a id="8075" class="Symbol">_)</a> <a id="8078" class="Keyword">where</a>
    <a id="8088" href="Data.Bool.html#8088" class="Function">lemma</a> <a id="8094" class="Symbol">:</a> <a id="8096" class="Symbol">(</a><a id="8097" href="Data.Bool.html#8097" class="Bound">x</a> <a id="8099" class="Symbol">:</a> <a data-type="Type" id="8101" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="8105" class="Symbol">)</a> <a id="8107" class="Symbol">→</a> <a id="8109" class="Symbol">_</a>
    <a id="8115" href="Data.Bool.html#8088" class="Function">lemma</a> <a data-type="Bool" id="8121" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="8127" class="Symbol">=</a> <a id="8129" href="Data.Bool.html#8028" class="Bound">p2</a>
    <a id="8136" href="Data.Bool.html#8088" class="Function">lemma</a> <a data-type="Bool" id="8142" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="8147" class="Symbol">=</a> <a id="8149" href="Data.Bool.html#8025" class="Bound">p1</a>
</pre>
<p>With these two lemmas, we can proceed to classify the automorphisms of <span class="Agda"><a data-type="Type" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a></span>. For this, we’ll need another lemma: If a function <code>Bool → Bool</code> <em>doesn’t</em> map <code>f x ≡ x</code>, then it maps <code>f x ≡ not x</code>.</p>
<pre class="Agda"><a id="AutBool≡2"></a><a data-type="(Bool ≡ Bool) ≡ Lift (lsuc lzero) Bool" id="8369" href="Data.Bool.html#8369" class="Function">AutBool≡2</a> <a id="8379" class="Symbol">:</a> <a id="8381" class="Symbol">(</a><a data-type="Type" id="8382" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a> <a data-type="A → A → Type ℓ" id="8387" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Type" id="8389" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="8393" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="8395" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(ℓ : Level) (A : Type a) → Type (a ⊔ ℓ)" id="8397" href="1Lab.Type.html#2006" class="Record">Lift</a> <a id="8402" class="Symbol">_</a> <a data-type="Type" id="8404" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>
<a data-type="(Bool ≡ Bool) ≡ Lift (lsuc lzero) Bool" id="8409" href="Data.Bool.html#8369" class="Function">AutBool≡2</a> <a id="8419" class="Symbol">=</a> <a data-type="Iso A B → A ≡ B" id="8421" href="1Lab.Univalence.html#11339" class="Function">Iso→path</a> <a id="8430" href="Data.Bool.html#9118" class="Function">the-iso</a> <a id="8438" class="Keyword">where</a>
  <a id="8446" href="Data.Bool.html#8446" class="Function">lemma</a> <a id="8452" class="Symbol">:</a> <a id="8454" class="Symbol">(</a><a id="8455" href="Data.Bool.html#8455" class="Bound">f</a> <a id="8457" class="Symbol">:</a> <a data-type="Type" id="8459" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a> <a id="8464" class="Symbol">→</a> <a data-type="Type" id="8466" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="8470" class="Symbol">)</a> <a id="8472" class="Symbol">{</a><a id="8473" href="Data.Bool.html#8473" class="Bound">x</a> <a id="8475" class="Symbol">:</a> <a data-type="Type" id="8477" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="8481" class="Symbol">}</a> <a id="8483" class="Symbol">→</a> <a id="8485" class="Symbol">(</a><a id="8486" href="Data.Bool.html#8455" class="Bound">f</a> <a id="8488" href="Data.Bool.html#8473" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="8490" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="8492" href="Data.Bool.html#8473" class="Bound">x</a> <a id="8494" class="Symbol">→</a> <a data-type="Type" id="8496" href="1Lab.Type.html#1326" class="Datatype">⊥</a><a id="8497" class="Symbol">)</a> <a id="8499" class="Symbol">→</a> <a id="8501" href="Data.Bool.html#8455" class="Bound">f</a> <a id="8503" href="Data.Bool.html#8473" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="8505" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Bool → Bool" id="8507" href="Data.Bool.html#1190" class="Function">not</a> <a id="8511" href="Data.Bool.html#8473" class="Bound">x</a>
  <a id="8515" href="Data.Bool.html#8446" class="Function">lemma</a> <a id="8521" href="Data.Bool.html#8521" class="Bound">f</a> <a id="8523" class="Symbol">{</a><a data-type="Bool" id="8524" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a><a id="8529" class="Symbol">}</a> <a id="8531" href="Data.Bool.html#8531" class="Bound">x</a> <a id="8533" class="Keyword">with</a> <a data-type="Discrete Bool" id="8538" href="Data.Bool.html#6061" class="Function">Discrete-Bool</a> <a id="8552" class="Symbol">(</a><a id="8553" href="Data.Bool.html#8521" class="Bound">f</a> <a data-type="Bool" id="8555" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a><a id="8560" class="Symbol">)</a> <a data-type="Bool" id="8562" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
  <a id="8569" href="Data.Bool.html#8446" class="Function">lemma</a> <a id="8575" href="Data.Bool.html#8575" class="Bound">f</a> <a id="8577" class="Symbol">{</a><a data-type="Bool" id="8578" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a><a id="8583" class="Symbol">}</a> <a id="8585" href="Data.Bool.html#8585" class="Bound">x</a> <a id="8587" class="Symbol">|</a> <a data-type="A → Dec A" id="8589" href="1Lab.Type.Dec.html#235" class="InductiveConstructor">yes</a> <a id="8593" href="Data.Bool.html#8593" class="Bound">p</a> <a id="8595" class="Symbol">=</a> <a id="8597" href="Data.Bool.html#8593" class="Bound">p</a>
  <a id="8601" href="Data.Bool.html#8446" class="Function">lemma</a> <a id="8607" href="Data.Bool.html#8607" class="Bound">f</a> <a id="8609" class="Symbol">{</a><a data-type="Bool" id="8610" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a><a id="8615" class="Symbol">}</a> <a id="8617" href="Data.Bool.html#8617" class="Bound">x</a> <a id="8619" class="Symbol">|</a> <a data-type="(A → ⊥) → Dec A" id="8621" href="1Lab.Type.Dec.html#253" class="InductiveConstructor">no</a> <a id="8624" href="Data.Bool.html#8624" class="Bound">¬p</a> <a id="8627" class="Symbol">=</a> <a data-type="⊥ → A" id="8629" href="1Lab.Type.html#1342" class="Function">absurd</a> <a id="8636" class="Symbol">(</a><a id="8637" href="Data.Bool.html#8624" class="Bound">¬p</a> <a id="8640" class="Symbol">(</a><a data-type="(x : Bool) → (x ≡ false → ⊥) → x ≡ true" id="8641" href="Data.Bool.html#6571" class="Function">x≠false→x≡true</a> <a id="8656" class="Symbol">_</a> <a id="8658" href="Data.Bool.html#8617" class="Bound">x</a><a id="8659" class="Symbol">))</a>

  <a id="8665" href="Data.Bool.html#8446" class="Function">lemma</a> <a id="8671" href="Data.Bool.html#8671" class="Bound">f</a> <a id="8673" class="Symbol">{</a><a data-type="Bool" id="8674" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a><a id="8678" class="Symbol">}</a> <a id="8680" href="Data.Bool.html#8680" class="Bound">x</a> <a id="8682" class="Keyword">with</a> <a data-type="Discrete Bool" id="8687" href="Data.Bool.html#6061" class="Function">Discrete-Bool</a> <a id="8701" class="Symbol">(</a><a id="8702" href="Data.Bool.html#8671" class="Bound">f</a> <a data-type="Bool" id="8704" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a><a id="8708" class="Symbol">)</a> <a data-type="Bool" id="8710" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="8718" href="Data.Bool.html#8446" class="Function">lemma</a> <a id="8724" href="Data.Bool.html#8724" class="Bound">f</a> <a id="8726" class="Symbol">{</a><a data-type="Bool" id="8727" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a><a id="8731" class="Symbol">}</a> <a id="8733" href="Data.Bool.html#8733" class="Bound">x</a> <a id="8735" class="Symbol">|</a> <a data-type="A → Dec A" id="8737" href="1Lab.Type.Dec.html#235" class="InductiveConstructor">yes</a> <a id="8741" href="Data.Bool.html#8741" class="Bound">p</a> <a id="8743" class="Symbol">=</a> <a id="8745" href="Data.Bool.html#8741" class="Bound">p</a>
  <a id="8749" href="Data.Bool.html#8446" class="Function">lemma</a> <a id="8755" href="Data.Bool.html#8755" class="Bound">f</a> <a id="8757" class="Symbol">{</a><a data-type="Bool" id="8758" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a><a id="8762" class="Symbol">}</a> <a id="8764" href="Data.Bool.html#8764" class="Bound">x</a> <a id="8766" class="Symbol">|</a> <a data-type="(A → ⊥) → Dec A" id="8768" href="1Lab.Type.Dec.html#253" class="InductiveConstructor">no</a> <a id="8771" href="Data.Bool.html#8771" class="Bound">¬p</a> <a id="8774" class="Symbol">=</a> <a data-type="⊥ → A" id="8776" href="1Lab.Type.html#1342" class="Function">absurd</a> <a id="8783" class="Symbol">(</a><a id="8784" href="Data.Bool.html#8771" class="Bound">¬p</a> <a id="8787" class="Symbol">(</a><a data-type="(x : Bool) → (x ≡ true → ⊥) → x ≡ false" id="8788" href="Data.Bool.html#6443" class="Function">x≠true→x≡false</a> <a id="8803" class="Symbol">_</a> <a id="8805" href="Data.Bool.html#8764" class="Bound">x</a><a id="8806" class="Symbol">))</a>
</pre>
<p>This lemma is slightly annoying to prove, but it’s not too complicated. It’s essentially two case splits: first on the boolean, and second on whether we’re looking at <code>f x ≡ not x</code>. If we are, then it’s fine (those are the <code>yes p = p</code> cases) - otherwise that contradicts what we’ve been told.</p>
<pre class="Agda">  <a id="9118" href="Data.Bool.html#9118" class="Function">the-iso</a> <a id="9126" class="Symbol">:</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="9128" href="1Lab.Equiv.html#6241" class="Function">Iso</a> <a id="9132" class="Symbol">(</a><a data-type="Type" id="9133" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a> <a data-type="A → A → Type ℓ" id="9138" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Type" id="9140" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="9144" class="Symbol">)</a> <a id="9146" class="Symbol">(</a><a data-type="(ℓ : Level) (A : Type a) → Type (a ⊔ ℓ)" id="9147" href="1Lab.Type.html#2006" class="Record">Lift</a> <a id="9152" class="Symbol">_</a> <a data-type="Type" id="9154" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="9158" class="Symbol">)</a>

  <a data-type="∑ A B → A" id="9163" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="9167" href="Data.Bool.html#9118" class="Function">the-iso</a> <a id="9175" href="Data.Bool.html#9175" class="Bound">path</a> <a id="9180" class="Keyword">with</a> <a data-type="Discrete Bool" id="9185" href="Data.Bool.html#6061" class="Function">Discrete-Bool</a> <a id="9199" class="Symbol">(</a><a data-type="A ≡ B → A → B" id="9200" href="1Lab.Path.html#10335" class="Function">transport</a> <a id="9210" href="Data.Bool.html#9175" class="Bound">path</a> <a data-type="Bool" id="9215" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a><a id="9219" class="Symbol">)</a> <a data-type="Bool" id="9221" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
  <a id="9228" class="Symbol">...</a> <a id="9232" class="Symbol">|</a> <a data-type="A → Dec A" id="9234" href="1Lab.Type.Dec.html#235" class="InductiveConstructor">yes</a> <a id="9238" href="Data.Bool.html#9238" class="Bound">path</a> <a id="9243" class="Symbol">=</a> <a data-type="(lower : A) → Lift ℓ A" id="9245" href="1Lab.Type.html#2065" class="InductiveConstructor">lift</a> <a data-type="Bool" id="9250" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="9258" class="Symbol">...</a> <a id="9262" class="Symbol">|</a> <a data-type="(A → ⊥) → Dec A" id="9264" href="1Lab.Type.Dec.html#253" class="InductiveConstructor">no</a> <a id="9267" href="Data.Bool.html#9267" class="Bound">¬path</a> <a id="9273" class="Symbol">=</a> <a data-type="(lower : A) → Lift ℓ A" id="9275" href="1Lab.Type.html#2065" class="InductiveConstructor">lift</a> <a data-type="Bool" id="9280" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
</pre>
<p>Now we classify the isomorphism by looking at what it does to <span class="Agda"><a data-type="Bool" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a></span>. We arbitrarily map <span class="Agda"><a data-type="x ≡ x" href="1Lab.Path.html#2137" class="Function">refl</a></span> to <span class="Agda"><a data-type="Bool" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a></span> and <span class="Agda"><a data-type="Bool → Bool" href="Data.Bool.html#1190" class="Function">not</a></span> to <span class="Agda"><a data-type="Bool" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a></span>.</p>
<pre class="Agda">  <a id="9464" href="Data.Bool.html#9118" class="Function">the-iso</a> <a id="9472" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="9473" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="9477" class="Symbol">.</a><a data-type="isIso f → B → A" id="9478" href="1Lab.Equiv.html#6080" class="Field">isIso.inv</a> <a id="9488" class="Symbol">(</a><a data-type="(lower : A) → Lift ℓ A" id="9489" href="1Lab.Type.html#2065" class="InductiveConstructor">lift</a> <a data-type="Bool" id="9494" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a><a id="9499" class="Symbol">)</a> <a id="9501" class="Symbol">=</a> <a data-type="x ≡ x" id="9503" href="1Lab.Path.html#2137" class="Function">refl</a>
  <a id="9510" href="Data.Bool.html#9118" class="Function">the-iso</a> <a id="9518" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="9519" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="9523" class="Symbol">.</a><a data-type="isIso f → B → A" id="9524" href="1Lab.Equiv.html#6080" class="Field">isIso.inv</a> <a id="9534" class="Symbol">(</a><a data-type="(lower : A) → Lift ℓ A" id="9535" href="1Lab.Type.html#2065" class="InductiveConstructor">lift</a> <a data-type="Bool" id="9540" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a><a id="9544" class="Symbol">)</a>  <a id="9547" class="Symbol">=</a> <a data-type="A ≃ B → A ≡ B" id="9549" href="1Lab.Univalence.html#8827" class="Function">ua</a> <a id="9552" class="Symbol">(</a><a data-type="Bool → Bool" id="9553" href="Data.Bool.html#1190" class="Function">not</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="9557" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv not" id="9559" href="Data.Bool.html#7030" class="Function">isEquiv-not</a><a id="9570" class="Symbol">)</a>
</pre>
<p>The inverse is determined by the same rule, but backwards. That’s why it’s an inverse! Everything computes in a way that lines up to this function being a <span class="Agda"><a data-type="(r : isIso f) → isRightInverse (r .inv) f" href="1Lab.Equiv.html#6096" class="Field">right inverse</a></span> on the nose.</p>
<pre class="Agda">  <a id="9796" href="Data.Bool.html#9118" class="Function">the-iso</a> <a id="9804" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="9805" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="9809" class="Symbol">.</a><a data-type="(r : isIso f) → isRightInverse (r .inv) f" id="9810" href="1Lab.Equiv.html#6096" class="Field">isIso.rinv</a> <a id="9821" class="Symbol">(</a><a data-type="(lower : A) → Lift ℓ A" id="9822" href="1Lab.Type.html#2065" class="InductiveConstructor">lift</a> <a data-type="Bool" id="9827" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a><a id="9832" class="Symbol">)</a> <a id="9834" class="Symbol">=</a> <a data-type="x ≡ x" id="9836" href="1Lab.Path.html#2137" class="Function">refl</a>
  <a id="9843" href="Data.Bool.html#9118" class="Function">the-iso</a> <a id="9851" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="9852" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="9856" class="Symbol">.</a><a data-type="(r : isIso f) → isRightInverse (r .inv) f" id="9857" href="1Lab.Equiv.html#6096" class="Field">isIso.rinv</a> <a id="9868" class="Symbol">(</a><a data-type="(lower : A) → Lift ℓ A" id="9869" href="1Lab.Type.html#2065" class="InductiveConstructor">lift</a> <a data-type="Bool" id="9874" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a><a id="9878" class="Symbol">)</a> <a id="9880" class="Symbol">=</a> <a data-type="x ≡ x" id="9882" href="1Lab.Path.html#2137" class="Function">refl</a>
</pre>
<p>The left inverse is a lot more complicated to prove. We examine how the path acts on both <code>true</code> and <code>false</code>. There are four cases:</p>
<pre class="Agda">  <a id="10035" href="Data.Bool.html#9118" class="Function">the-iso</a> <a id="10043" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="10044" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10048" class="Symbol">.</a><a data-type="(r : isIso f) → isLeftInverse (r .inv) f" id="10049" href="1Lab.Equiv.html#6128" class="Field">isIso.linv</a> <a id="10060" href="Data.Bool.html#10060" class="Bound">path</a> <a id="10065" class="Keyword">with</a> <a data-type="Discrete Bool" id="10070" href="Data.Bool.html#6061" class="Function">Discrete-Bool</a> <a id="10084" class="Symbol">(</a><a data-type="A ≡ B → A → B" id="10085" href="1Lab.Path.html#10335" class="Function">transport</a> <a id="10095" href="Data.Bool.html#10060" class="Bound">path</a> <a data-type="Bool" id="10100" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a><a id="10104" class="Symbol">)</a> <a data-type="Bool" id="10106" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>
                                     <a id="10148" class="Symbol">|</a> <a data-type="Discrete Bool" id="10150" href="Data.Bool.html#6061" class="Function">Discrete-Bool</a> <a id="10164" class="Symbol">(</a><a data-type="A ≡ B → A → B" id="10165" href="1Lab.Path.html#10335" class="Function">transport</a> <a id="10175" href="Data.Bool.html#10060" class="Bound">path</a> <a data-type="Bool" id="10180" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a><a id="10185" class="Symbol">)</a> <a data-type="Bool" id="10187" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a>
  <a id="10195" class="Symbol">...</a> <a id="10199" class="Symbol">|</a> <a data-type="A → Dec A" id="10201" href="1Lab.Type.Dec.html#235" class="InductiveConstructor">yes</a> <a id="10205" href="Data.Bool.html#10205" class="Bound">true→true</a> <a id="10215" class="Symbol">|</a> <a data-type="A → Dec A" id="10217" href="1Lab.Type.Dec.html#235" class="InductiveConstructor">yes</a> <a id="10221" href="Data.Bool.html#10221" class="Bound">false→false</a> <a id="10233" class="Symbol">=</a>
    <a data-type="x ≡ x" id="10239" href="1Lab.Path.html#2137" class="Function">refl</a>                  <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="10261" href="1Lab.Path.html#45199" class="Function Operator">≡⟨</a> <a data-type="x ≡ y → y ≡ x" id="10264" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="10268" class="Symbol">(</a><a data-type="Iso (A ≡ B) (A ≃ B)" id="10269" href="1Lab.Univalence.html#16729" class="Function">univalence-Iso</a> <a id="10284" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="10285" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10289" class="Symbol">.</a><a data-type="(r : isIso f) → isLeftInverse (r .inv) f" id="10290" href="1Lab.Equiv.html#6128" class="Field">linv</a> <a id="10295" class="Symbol">_)</a> <a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="10298" href="1Lab.Path.html#45199" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡</span></span>
    <a data-type="A ≃ B → A ≡ B" id="10304" href="1Lab.Univalence.html#8827" class="Function">ua</a> <a id="10307" class="Symbol">(</a><a data-type="A ≡ B → A ≃ B" id="10308" href="1Lab.Univalence.html#15494" class="Function">pathToEquiv</a> <a data-type="x ≡ x" id="10320" href="1Lab.Path.html#2137" class="Function">refl</a><a id="10324" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="10326" href="1Lab.Path.html#45199" class="Function Operator">≡⟨</a> <a data-type="(f : (x : A) → B x) (p : x ≡ y) → PathP (λ i → B (p i)) (f x) (f y)" id="10329" href="1Lab.Path.html#19262" class="Function">ap</a> <a data-type="A ≃ B → A ≡ B" id="10332" href="1Lab.Univalence.html#8827" class="Function">ua</a> <a data-type="pathToEquiv refl ≡ (id , idEquiv)" id="10335" href="1Lab.Univalence.html#15849" class="Function">pathToEquiv-refl</a> <a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="10352" href="1Lab.Path.html#45199" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡</span></span>
    <a data-type="A ≃ B → A ≡ B" id="10358" href="1Lab.Univalence.html#8827" class="Function">ua</a> <a id="10361" class="Symbol">(_</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="10364" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="10366" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="10373" class="Symbol">)</a>      <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="10380" href="1Lab.Path.html#45199" class="Function Operator">≡⟨</a> <a data-type="(f : (x : A) → B x) (p : x ≡ y) → PathP (λ i → B (p i)) (f x) (f y)" id="10383" href="1Lab.Path.html#19262" class="Function">ap</a> <a data-type="A ≃ B → A ≡ B" id="10386" href="1Lab.Univalence.html#8827" class="Function">ua</a> <a id="10389" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="10390" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="10394" class="Symbol">(</a><a id="10395" href="Data.Bool.html#7485" class="Function">idLemma</a> <a id="10403" class="Symbol">_</a> <a id="10405" href="Data.Bool.html#10205" class="Bound">true→true</a> <a id="10415" href="Data.Bool.html#10221" class="Bound">false→false</a><a id="10426" class="Symbol">))</a> <a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="10429" href="1Lab.Path.html#45199" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡</span></span>
    <a data-type="A ≃ B → A ≡ B" id="10435" href="1Lab.Univalence.html#8827" class="Function">ua</a> <a id="10438" class="Symbol">(</a><a data-type="A ≡ B → A ≃ B" id="10439" href="1Lab.Univalence.html#15494" class="Function">pathToEquiv</a> <a id="10451" class="Bound">path</a><a id="10455" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="10457" href="1Lab.Path.html#45199" class="Function Operator">≡⟨</a> <a data-type="Iso (A ≡ B) (A ≃ B)" id="10460" href="1Lab.Univalence.html#16729" class="Function">univalence-Iso</a> <a id="10475" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="10476" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10480" class="Symbol">.</a><a data-type="(r : isIso f) → isLeftInverse (r .inv) f" id="10481" href="1Lab.Equiv.html#6128" class="Field">linv</a> <a id="10486" class="Symbol">_</a> <a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="10488" href="1Lab.Path.html#45199" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡</span></span>
    <a id="10494" class="Bound">path</a>                  <a data-type="(x : A) → x ≡ x" id="10516" href="1Lab.Path.html#45365" class="Function Operator">∎</a>
</pre>
<p>In the case where the path quacks like reflexivity, we use the univalence axiom to show that we must be looking at the reflexivity path. For this, we use <code>idLemma</code> to show that <code>pathToEquiv path</code> must be the identity equivalence.</p>
<pre class="Agda">  <a id="10764" class="Symbol">...</a> <a id="10768" class="Symbol">|</a> <a data-type="A → Dec A" id="10770" href="1Lab.Type.Dec.html#235" class="InductiveConstructor">yes</a> <a id="10774" href="Data.Bool.html#10774" class="Bound">true→true</a> <a id="10784" class="Symbol">|</a> <a data-type="(A → ⊥) → Dec A" id="10786" href="1Lab.Type.Dec.html#253" class="InductiveConstructor">no</a> <a id="10789" href="Data.Bool.html#10789" class="Bound">false→true&#39;</a> <a id="10801" class="Symbol">=</a>
    <a id="10807" class="Keyword">let</a>
      <a id="10817" href="Data.Bool.html#10817" class="Bound">false→true</a> <a id="10828" class="Symbol">=</a> <a id="10830" href="Data.Bool.html#8446" class="Function">lemma</a> <a id="10836" class="Symbol">(</a><a data-type="A ≡ B → A → B" id="10837" href="1Lab.Path.html#10335" class="Function">transport</a> <a id="10847" class="Bound">path</a><a id="10851" class="Symbol">)</a> <a id="10853" href="Data.Bool.html#10789" class="Bound">false→true&#39;</a>
      <a id="10871" href="Data.Bool.html#10871" class="Bound">fibres</a> <a id="10878" class="Symbol">=</a> <a data-type="isContr A → isProp A" id="10880" href="1Lab.HLevel.html#3944" class="Function">isContr→isProp</a> <a id="10895" class="Symbol">(</a><a data-type="A ≡ B → A ≃ B" id="10896" href="1Lab.Univalence.html#15494" class="Function">pathToEquiv</a> <a id="10908" class="Bound">path</a> <a id="10913" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="10914" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="10918" class="Symbol">.</a><a data-type="isEquiv f → (y : B) → isContr (fibre f y)" id="10919" href="1Lab.Equiv.html#2382" class="Field">isEqv</a> <a data-type="Bool" id="10925" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a><a id="10929" class="Symbol">)</a>
                              <a id="10961" class="Symbol">(</a><a data-type="Bool" id="10962" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="10967" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="10969" href="Data.Bool.html#10774" class="Bound">true→true</a><a id="10978" class="Symbol">)</a> <a id="10980" class="Symbol">(</a><a data-type="Bool" id="10981" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="10987" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="10989" href="Data.Bool.html#10817" class="Bound">false→true</a><a id="10999" class="Symbol">)</a>
    <a id="11005" class="Keyword">in</a> <a data-type="⊥ → A" id="11008" href="1Lab.Type.html#1342" class="Function">absurd</a> <a id="11015" class="Symbol">(</a><a data-type="true ≡ false → ⊥" id="11016" href="Data.Bool.html#575" class="Function">true≠false</a> <a id="11027" class="Symbol">(</a><a data-type="(f : (x : A) → B x) (p : x ≡ y) → PathP (λ i → B (p i)) (f x) (f y)" id="11028" href="1Lab.Path.html#19262" class="Function">ap</a> <a data-type="∑ A B → A" id="11031" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="11035" href="Data.Bool.html#10871" class="Bound">fibres</a><a id="11041" class="Symbol">))</a>
</pre>
<p>The second case is when both booleans map to <span class="Agda"><a data-type="Bool" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a></span>. This is a contradiction - transport along a path is an equivalence, and equivalences have contractible fibres; Since we have two fibres over <span class="Agda"><a data-type="Bool" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a></span>, that means we must have <code>true ≡ false</code>.</p>
<pre class="Agda">  <a id="11316" class="Symbol">...</a> <a id="11320" class="Symbol">|</a> <a data-type="(A → ⊥) → Dec A" id="11322" href="1Lab.Type.Dec.html#253" class="InductiveConstructor">no</a> <a id="11325" href="Data.Bool.html#11325" class="Bound">true→false&#39;</a> <a id="11337" class="Symbol">|</a> <a data-type="A → Dec A" id="11339" href="1Lab.Type.Dec.html#235" class="InductiveConstructor">yes</a> <a id="11343" href="Data.Bool.html#11343" class="Bound">false→false</a> <a id="11355" class="Symbol">=</a>
    <a id="11361" class="Keyword">let</a>
      <a id="11371" href="Data.Bool.html#11371" class="Bound">true→false</a> <a id="11382" class="Symbol">=</a> <a id="11384" href="Data.Bool.html#8446" class="Function">lemma</a> <a id="11390" class="Symbol">(</a><a data-type="A ≡ B → A → B" id="11391" href="1Lab.Path.html#10335" class="Function">transport</a> <a id="11401" class="Bound">path</a><a id="11405" class="Symbol">)</a> <a id="11407" href="Data.Bool.html#11325" class="Bound">true→false&#39;</a>
      <a id="11425" href="Data.Bool.html#11425" class="Bound">fibres</a> <a id="11432" class="Symbol">=</a> <a data-type="isContr A → isProp A" id="11434" href="1Lab.HLevel.html#3944" class="Function">isContr→isProp</a> <a id="11449" class="Symbol">(</a><a data-type="A ≡ B → A ≃ B" id="11450" href="1Lab.Univalence.html#15494" class="Function">pathToEquiv</a> <a id="11462" class="Bound">path</a> <a id="11467" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11468" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11472" class="Symbol">.</a><a data-type="isEquiv f → (y : B) → isContr (fibre f y)" id="11473" href="1Lab.Equiv.html#2382" class="Field">isEqv</a> <a data-type="Bool" id="11479" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a><a id="11484" class="Symbol">)</a>
                              <a id="11516" class="Symbol">(</a><a data-type="Bool" id="11517" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="11522" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="11524" href="Data.Bool.html#11371" class="Bound">true→false</a><a id="11534" class="Symbol">)</a> <a id="11536" class="Symbol">(</a><a data-type="Bool" id="11537" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="11543" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="11545" href="Data.Bool.html#11343" class="Bound">false→false</a><a id="11556" class="Symbol">)</a>
    <a id="11562" class="Keyword">in</a> <a data-type="⊥ → A" id="11565" href="1Lab.Type.html#1342" class="Function">absurd</a> <a id="11572" class="Symbol">(</a><a data-type="true ≡ false → ⊥" id="11573" href="Data.Bool.html#575" class="Function">true≠false</a> <a id="11584" class="Symbol">(</a><a data-type="(f : (x : A) → B x) (p : x ≡ y) → PathP (λ i → B (p i)) (f x) (f y)" id="11585" href="1Lab.Path.html#19262" class="Function">ap</a> <a data-type="∑ A B → A" id="11588" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="11592" href="Data.Bool.html#11425" class="Bound">fibres</a><a id="11598" class="Symbol">))</a>
</pre>
<p>The other case is analogous.</p>
<pre class="Agda">  <a id="11646" class="Symbol">...</a> <a id="11650" class="Symbol">|</a> <a data-type="(A → ⊥) → Dec A" id="11652" href="1Lab.Type.Dec.html#253" class="InductiveConstructor">no</a> <a id="11655" href="Data.Bool.html#11655" class="Bound">true→false&#39;</a> <a id="11667" class="Symbol">|</a> <a data-type="(A → ⊥) → Dec A" id="11669" href="1Lab.Type.Dec.html#253" class="InductiveConstructor">no</a> <a id="11672" href="Data.Bool.html#11672" class="Bound">false→true&#39;</a> <a id="11684" class="Symbol">=</a>
    <a data-type="A ≃ B → A ≡ B" id="11690" href="1Lab.Univalence.html#8827" class="Function">ua</a> <a id="11693" class="Symbol">(</a><a data-type="Bool → Bool" id="11694" href="Data.Bool.html#1190" class="Function">not</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="11698" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv not" id="11700" href="Data.Bool.html#7030" class="Function">isEquiv-not</a><a id="11711" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="11713" href="1Lab.Path.html#45199" class="Function Operator">≡⟨</a> <a data-type="(f : (x : A) → B x) (p : x ≡ y) → PathP (λ i → B (p i)) (f x) (f y)" id="11716" href="1Lab.Path.html#19262" class="Function">ap</a> <a data-type="A ≃ B → A ≡ B" id="11719" href="1Lab.Univalence.html#8827" class="Function">ua</a> <a id="11722" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="11723" href="1Lab.Path.html#9128" class="Function">sym</a> <a id="11727" class="Symbol">(</a><a id="11728" href="Data.Bool.html#7880" class="Function">notLemma</a> <a id="11737" class="Symbol">_</a>
                                            <a id="11783" class="Symbol">(</a><a id="11784" href="Data.Bool.html#8446" class="Function">lemma</a> <a id="11790" class="Symbol">(</a><a data-type="A ≡ B → A → B" id="11791" href="1Lab.Path.html#10335" class="Function">transport</a> <a id="11801" class="Bound">path</a><a id="11805" class="Symbol">)</a> <a id="11807" href="Data.Bool.html#11655" class="Bound">true→false&#39;</a><a id="11818" class="Symbol">)</a>
                                            <a id="11864" class="Symbol">(</a><a id="11865" href="Data.Bool.html#8446" class="Function">lemma</a> <a id="11871" class="Symbol">(</a><a data-type="A ≡ B → A → B" id="11872" href="1Lab.Path.html#10335" class="Function">transport</a> <a id="11882" class="Bound">path</a><a id="11886" class="Symbol">)</a> <a id="11888" href="Data.Bool.html#11672" class="Bound">false→true&#39;</a><a id="11899" class="Symbol">)))</a>
                            <a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="11931" href="1Lab.Path.html#45199" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡</span></span>
    <a data-type="A ≃ B → A ≡ B" id="11937" href="1Lab.Univalence.html#8827" class="Function">ua</a> <a id="11940" class="Symbol">(</a><a data-type="A ≡ B → A ≃ B" id="11941" href="1Lab.Univalence.html#15494" class="Function">pathToEquiv</a> <a id="11953" class="Bound">path</a><a id="11957" class="Symbol">)</a>  <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="11960" href="1Lab.Path.html#45199" class="Function Operator">≡⟨</a> <a data-type="Iso (A ≡ B) (A ≃ B)" id="11963" href="1Lab.Univalence.html#16729" class="Function">univalence-Iso</a> <a id="11978" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="11979" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="11983" class="Symbol">.</a><a data-type="(r : isIso f) → isLeftInverse (r .inv) f" id="11984" href="1Lab.Equiv.html#6128" class="Field">linv</a> <a id="11989" class="Symbol">_</a> <a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="11991" href="1Lab.Path.html#45199" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡</span></span>
    <a id="11997" class="Bound">path</a>                   <a data-type="(x : A) → x ≡ x" id="12020" href="1Lab.Path.html#45365" class="Function Operator">∎</a>
</pre>
<p>The last case is when the path quacks like <code>ua (not, _)</code> - in that case, we use the <span class="Agda"><a href="Data.Bool.html#7880" class="Function">notLemma</a></span> to show it <em>must</em> be <code>ua (not, _)</code>, and the univalence axiom finishes the job.</p>
  </article>
</div>

</main>
</body>
</html>