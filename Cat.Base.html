<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8"></meta>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"></meta>
  <meta name="keywords" content="Agda,categories,topos"></meta>

  <title>Cat.Base - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css"></link>
  <link rel="stylesheet" href="/css/katex.min.css"></link>
  <link rel="stylesheet" href="/css/agda-cats.css"></link>

  <meta name="twitter:card" content="summary"></meta>
  <meta name="twitter:title" content="Cat.Base - 1Lab"></meta>
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png"></meta>

  <meta name="og:title" content="Cat.Base - 1Lab"></meta>
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png"></meta>
  <meta name="og:site-name" content="1Lab"></meta>
  <meta name="og:type" content="website"></meta>

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory."></meta>
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory."></meta>
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory."></meta>
  
  <script src="/equations.js" type="text/javascript"></script>
  <script src="/highlight-hover.js" type="text/javascript"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>
</head>

<body>
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0;">
                <a class="Module">Cat.Base</a>
              </h3>

      <!-- Cube logo -->
      <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px"></img>

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr></hr>
      <ul>
      <li><a href="#precategories"><a href="#precategories" class="header-link">Precategories<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#opposites"><a href="#opposites" class="header-link">Opposites<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#categories"><a href="#categories" class="header-link">Categories<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#the-category-of-sets"><a href="#the-category-of-sets" class="header-link">The category of Sets<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#functors"><a href="#functors" class="header-link">Functors<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#composition"><a href="#composition" class="header-link">Composition<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#natural-transformations"><a href="#natural-transformations" class="header-link">Natural Transformations<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#natural-isomorphism"><a href="#natural-isomorphism" class="header-link">Natural Isomorphism<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      </ul>
      <hr></hr>

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>
      </div>

      <hr></hr>

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
              <a href="index.html">️back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/3bd4b75cf587e33e84cb52dd2818c4e19c0fe1b5/src/Cat/Base.lagda.md">link to source</a> <br />
                <hr></hr> <div class="author-list">Written by Amélia Liao</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="index.html">️back to index</a>
      </div>
      
      <!-- Font toggle checkbox -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="1Lab.Equiv.Fibrewise.html" class="Module">1Lab.Equiv.Fibrewise</a>
<a id="42" class="Keyword">open</a> <a id="47" class="Keyword">import</a> <a id="54" href="1Lab.HLevel.Retracts.html" class="Module">1Lab.HLevel.Retracts</a>
<a id="75" class="Keyword">open</a> <a id="80" class="Keyword">import</a> <a id="87" href="1Lab.Univalence.html" class="Module">1Lab.Univalence</a>
<a id="103" class="Keyword">open</a> <a id="108" class="Keyword">import</a> <a id="115" href="1Lab.HLevel.html" class="Module">1Lab.HLevel</a>
<a id="127" class="Keyword">open</a> <a id="132" class="Keyword">import</a> <a id="139" href="1Lab.Equiv.html" class="Module">1Lab.Equiv</a>
<a id="150" class="Keyword">open</a> <a id="155" class="Keyword">import</a> <a id="162" href="1Lab.Path.html" class="Module">1Lab.Path</a>
<a id="172" class="Keyword">open</a> <a id="177" class="Keyword">import</a> <a id="184" href="1Lab.Type.html" class="Module">1Lab.Type</a> <a id="194" class="Keyword">hiding</a> <a id="201" class="Symbol">(</a><a data-type="A → A" id="202" href="1Lab.Type.html#2348" class="Function">id</a> <a id="205" class="Symbol">;</a> <a data-type="(B₁ → C) → (A → B₁) → A → C" id="207" href="1Lab.Type.html#2217" class="Function Operator">_∘_</a><a id="210" class="Symbol">)</a>

<a id="213" class="Keyword">module</a> <a id="220" href="Cat.Base.html" class="Module">Cat.Base</a> <a id="229" class="Keyword">where</a>
</pre>
<h1 id="precategories"><a href="#precategories" class="header-link">Precategories<span class="header-link-emoji">🔗</span></a></h1>
<p>In univalent mathematics, it makes sense to distinguish two stages in the construction of categories: A <strong>precategory</strong> is the object that directly corresponds to the definition of precategory as it is traditionally formalised, whereas a <strong>category</strong> (or univalent category) has an extra condition: Isomorphic objects must be identified.</p>
<pre class="Agda"><a id="604" class="Keyword">record</a> <a id="Precategory"></a><a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="611" href="Cat.Base.html#611" class="Record">Precategory</a> <a id="623" class="Symbol">(</a><a id="624" href="Cat.Base.html#624" class="Bound">o</a> <a id="626" href="Cat.Base.html#626" class="Bound">h</a> <a id="628" class="Symbol">:</a> <a data-type="Type" id="630" href="Agda.Primitive.html#597" class="Postulate">Level</a><a id="635" class="Symbol">)</a> <a id="637" class="Symbol">:</a> <a id="639" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="644" class="Symbol">(</a><a data-type="Level → Level" id="645" href="Agda.Primitive.html#780" class="Primitive">lsuc</a> <a id="650" class="Symbol">(</a><a id="651" href="Cat.Base.html#624" class="Bound">o</a> <a data-type="Level → Level → Level" id="653" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="655" href="Cat.Base.html#626" class="Bound">h</a><a id="656" class="Symbol">))</a> <a id="659" class="Keyword">where</a>
</pre>
<p>A <em>precategory</em> is a “proof-relevant preorder”. In a preordered set <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mo>≤</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A, \le)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span></span></span></span>,</span> the inhabitants of a set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> are related by a <em>proposition</em> <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \le b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>,</span> which is</p>
<ul>
<li><em>reflexive</em>: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a \le a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span></li>
<li><em>transitive</em>: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi><mo>∧</mo><mi>b</mi><mo>≤</mo><mi>c</mi><mo>→</mo><mi>a</mi><mo>≤</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a \le b \land b \le c \to a \le c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span></li>
</ul>
<p>In a precategory, the condition that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \le b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> be a proposition is relaxed: A precategory has a <span class="Agda"><a data-type="Precategory o h → Type o" href="Cat.Base.html#1312" class="Field">type of objects</a></span> and, between each <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x, y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>,</span> a <strong>set</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">H</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi></mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{Hom}(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">Hom</span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> of relations (or maps). The name Hom is historical and it betrays the original context in which categories where employed: algebra(ic topology), where the maps in question are <strong>hom</strong>omorphisms.</p>
<pre class="Agda">  <a id="1302" class="Keyword">field</a>
    <a id="Precategory.Ob"></a><a data-type="Precategory o h → Type o" id="1312" href="Cat.Base.html#1312" class="Field">Ob</a>  <a id="1316" class="Symbol">:</a> <a id="1318" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="1323" href="Cat.Base.html#624" class="Bound">o</a>
    <a id="Precategory.Hom"></a><a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1329" href="Cat.Base.html#1329" class="Field">Hom</a> <a id="1333" class="Symbol">:</a> <a data-type="Precategory o h → Type o" id="1335" href="Cat.Base.html#1312" class="Field">Ob</a> <a id="1338" class="Symbol">→</a> <a data-type="Precategory o h → Type o" id="1340" href="Cat.Base.html#1312" class="Field">Ob</a> <a id="1343" class="Symbol">→</a> <a id="1345" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="1350" href="Cat.Base.html#626" class="Bound">h</a>
</pre>
<p>Whereas reading a classical definition into a type theory where equality is a proposition, the word <strong>set</strong> may be read to mean <a href="1Lab.Type.html">inhabitant of a universe</a>. But in HoTT, if we want categories to be well-behaved, we do actually mean <em>set</em>: A type of <a href="1Lab.HLevel.html">h-level</a> 2.</p>
<pre class="Agda">  <a id="1667" class="Keyword">field</a>
    <a id="Precategory.Hom-set"></a><a data-type="(r : Precategory o h) (x y : r .Ob) → isSet (r .Hom x y)" id="1677" href="Cat.Base.html#1677" class="Field">Hom-set</a> <a id="1685" class="Symbol">:</a> <a id="1687" class="Symbol">(</a><a id="1688" href="Cat.Base.html#1688" class="Bound">x</a> <a id="1690" href="Cat.Base.html#1690" class="Bound">y</a> <a id="1692" class="Symbol">:</a> <a data-type="Precategory o h → Type o" id="1694" href="Cat.Base.html#1312" class="Field">Ob</a><a id="1696" class="Symbol">)</a> <a id="1698" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="1700" href="1Lab.HLevel.html#3342" class="Function">isSet</a> <a id="1706" class="Symbol">(</a><a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="1707" href="Cat.Base.html#1329" class="Field">Hom</a> <a id="1711" href="Cat.Base.html#1688" class="Bound">x</a> <a id="1713" href="Cat.Base.html#1690" class="Bound">y</a><a id="1714" class="Symbol">)</a>
</pre>
<p>If you are already familiar with the definition of precategory there are two things to note here:</p>
<p>First is that out formalization has a <em>family</em> of <span class="Agda"><a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" href="Cat.Base.html#1329" class="Field">Hom</a></span>-sets rather than a single <span class="Agda"><a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" href="Cat.Base.html#1329" class="Field">Hom</a></span>-set and source/target maps. This formulation is not unique to precategory theory done internally to type theory, but it is the most reasonable way to formulate things in this context.</p>
<p>Second is that the word “set” in the definition of Hom-set has nothing to do with “size”. Indeed, the “set”/“not a set” (alternatively “small”/“large”) distinction makes no sense in type theory (some may argue it makes no sense in general).</p>
<p>Instead, the <span class="Agda"><a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" href="Cat.Base.html#611" class="Record">Precategory</a></span> record is parametrised by two levels: <code>o</code>, and <code>h</code>. The type of objects has to fit in the universe <code>Type o</code>, and the family of Hom-sets is <code>Type h</code> valued. As an example, the thin precategory corresponding to the natural numbers with their usual ordering would live in <code>Precategory lzero lzero</code>.</p>
<p>This means, for instance, that there is no single “category of sets” - there is a <em>family</em> of categories of sets, parametrised by the level in which its objects live.</p>
<pre class="Agda">  <a id="2858" class="Keyword">field</a>
    <a id="Precategory.id"></a><a data-type="(r : Precategory o h) → r .Hom x x" id="2868" href="Cat.Base.html#2868" class="Field">id</a>  <a id="2872" class="Symbol">:</a> <a id="2874" class="Symbol">∀</a> <a id="2876" class="Symbol">{</a><a id="2877" href="Cat.Base.html#2877" class="Bound">x</a><a id="2878" class="Symbol">}</a>     <a id="2884" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="2886" href="Cat.Base.html#1329" class="Field">Hom</a> <a id="2890" href="Cat.Base.html#2877" class="Bound">x</a> <a id="2892" href="Cat.Base.html#2877" class="Bound">x</a>
    <a id="Precategory._∘_"></a><a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2898" href="Cat.Base.html#2898" class="Field Operator">_∘_</a> <a id="2902" class="Symbol">:</a> <a id="2904" class="Symbol">∀</a> <a id="2906" class="Symbol">{</a><a id="2907" href="Cat.Base.html#2907" class="Bound">x</a> <a id="2909" href="Cat.Base.html#2909" class="Bound">y</a> <a id="2911" href="Cat.Base.html#2911" class="Bound">z</a><a id="2912" class="Symbol">}</a> <a id="2914" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="2916" href="Cat.Base.html#1329" class="Field">Hom</a> <a id="2920" href="Cat.Base.html#2909" class="Bound">y</a> <a id="2922" href="Cat.Base.html#2911" class="Bound">z</a> <a id="2924" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="2926" href="Cat.Base.html#1329" class="Field">Hom</a> <a id="2930" href="Cat.Base.html#2907" class="Bound">x</a> <a id="2932" href="Cat.Base.html#2909" class="Bound">y</a> <a id="2934" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="2936" href="Cat.Base.html#1329" class="Field">Hom</a> <a id="2940" href="Cat.Base.html#2907" class="Bound">x</a> <a id="2942" href="Cat.Base.html#2911" class="Bound">z</a>

  <a id="2947" class="Keyword">infixr</a> <a id="2954" class="Number">40</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="2957" href="Cat.Base.html#2898" class="Function Operator">_∘_</a>
</pre>
<p>The “proof-relevant” version of the reflexivity and transitivity laws are, respectively, the <code class="sourceCode agda">identity morphisms</code> and <span class="Agda"><a data-type="(B₁ → C) → (A → B₁) → A → C" href="1Lab.Type.html#2217" class="Function Operator">composition of morphisms</a></span>. Unlike in the proof-irrelevant case, in which an inhabitant of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≤</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \le y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> merely witnesses that two things are related, these operations <em>matter</em>, and thus must satisfy laws:</p>
<pre class="Agda">  <a id="3321" class="Keyword">field</a>
    <a id="Precategory.idr"></a><a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" id="3331" href="Cat.Base.html#3331" class="Field">idr</a> <a id="3335" class="Symbol">:</a> <a id="3337" class="Symbol">∀</a> <a id="3339" class="Symbol">{</a><a id="3340" href="Cat.Base.html#3340" class="Bound">x</a> <a id="3342" href="Cat.Base.html#3342" class="Bound">y</a><a id="3343" class="Symbol">}</a> <a id="3345" class="Symbol">(</a><a id="3346" href="Cat.Base.html#3346" class="Bound">f</a> <a id="3348" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="3350" href="Cat.Base.html#1329" class="Field">Hom</a> <a id="3354" href="Cat.Base.html#3340" class="Bound">x</a> <a id="3356" href="Cat.Base.html#3342" class="Bound">y</a><a id="3357" class="Symbol">)</a> <a id="3359" class="Symbol">→</a> <a id="3361" href="Cat.Base.html#3346" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3363" href="Cat.Base.html#2898" class="Field Operator">∘</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="3365" href="Cat.Base.html#2868" class="Field">id</a> <a data-type="A → A → Type ℓ" id="3368" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="3370" href="Cat.Base.html#3346" class="Bound">f</a>
    <a id="Precategory.idl"></a><a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" id="3376" href="Cat.Base.html#3376" class="Field">idl</a> <a id="3380" class="Symbol">:</a> <a id="3382" class="Symbol">∀</a> <a id="3384" class="Symbol">{</a><a id="3385" href="Cat.Base.html#3385" class="Bound">x</a> <a id="3387" href="Cat.Base.html#3387" class="Bound">y</a><a id="3388" class="Symbol">}</a> <a id="3390" class="Symbol">(</a><a id="3391" href="Cat.Base.html#3391" class="Bound">f</a> <a id="3393" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="3395" href="Cat.Base.html#1329" class="Field">Hom</a> <a id="3399" href="Cat.Base.html#3385" class="Bound">x</a> <a id="3401" href="Cat.Base.html#3387" class="Bound">y</a><a id="3402" class="Symbol">)</a> <a id="3404" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="3406" href="Cat.Base.html#2868" class="Field">id</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3409" href="Cat.Base.html#2898" class="Field Operator">∘</a> <a id="3411" href="Cat.Base.html#3391" class="Bound">f</a> <a data-type="A → A → Type ℓ" id="3413" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="3415" href="Cat.Base.html#3391" class="Bound">f</a>
</pre>
<p>The two identity laws say that the identity morphisms serve as neutral elements for the composition operation, both on the left and on the right. The “two” associativity laws (below) say that both ways of writing parentheses around a composition of three morphisms is equal: <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>f</mi><mo>∘</mo><mi>g</mi><mo stretchy="false">)</mo><mo>∘</mo><mi>h</mi><mo>=</mo><mi>f</mi><mo>∘</mo><mo stretchy="false">(</mo><mi>g</mi><mo>∘</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(f \circ g) \circ h = f \circ (g \circ h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mclose">)</span></span></span></span>.</span></p>
<pre class="Agda">    <a id="Precategory.assoc"></a><a data-type="(r : Precategory o h) (f : r .Hom y z) (g : r .Hom x y)
(h : r .Hom w x) →
r ._∘_ f (r ._∘_ g h) ≡ r ._∘_ (r ._∘_ f g) h" id="3755" href="Cat.Base.html#3755" class="Field">assoc</a> <a id="3761" class="Symbol">:</a> <a id="3763" class="Symbol">∀</a> <a id="3765" class="Symbol">{</a><a id="3766" href="Cat.Base.html#3766" class="Bound">w</a> <a id="3768" href="Cat.Base.html#3768" class="Bound">x</a> <a id="3770" href="Cat.Base.html#3770" class="Bound">y</a> <a id="3772" href="Cat.Base.html#3772" class="Bound">z</a><a id="3773" class="Symbol">}</a> <a id="3775" class="Symbol">(</a><a id="3776" href="Cat.Base.html#3776" class="Bound">f</a> <a id="3778" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="3780" href="Cat.Base.html#1329" class="Field">Hom</a> <a id="3784" href="Cat.Base.html#3770" class="Bound">y</a> <a id="3786" href="Cat.Base.html#3772" class="Bound">z</a><a id="3787" class="Symbol">)</a> <a id="3789" class="Symbol">(</a><a id="3790" href="Cat.Base.html#3790" class="Bound">g</a> <a id="3792" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="3794" href="Cat.Base.html#1329" class="Field">Hom</a> <a id="3798" href="Cat.Base.html#3768" class="Bound">x</a> <a id="3800" href="Cat.Base.html#3770" class="Bound">y</a><a id="3801" class="Symbol">)</a> <a id="3803" class="Symbol">(</a><a id="3804" href="Cat.Base.html#3804" class="Bound">h</a> <a id="3806" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="3808" href="Cat.Base.html#1329" class="Field">Hom</a> <a id="3812" href="Cat.Base.html#3766" class="Bound">w</a> <a id="3814" href="Cat.Base.html#3768" class="Bound">x</a><a id="3815" class="Symbol">)</a>
          <a id="3827" class="Symbol">→</a> <a id="3829" href="Cat.Base.html#3776" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3831" href="Cat.Base.html#2898" class="Field Operator">∘</a> <a id="3833" class="Symbol">(</a><a id="3834" href="Cat.Base.html#3790" class="Bound">g</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3836" href="Cat.Base.html#2898" class="Field Operator">∘</a> <a id="3838" href="Cat.Base.html#3804" class="Bound">h</a><a id="3839" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="3841" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="3843" class="Symbol">(</a><a id="3844" href="Cat.Base.html#3776" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3846" href="Cat.Base.html#2898" class="Field Operator">∘</a> <a id="3848" href="Cat.Base.html#3790" class="Bound">g</a><a id="3849" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3851" href="Cat.Base.html#2898" class="Field Operator">∘</a> <a id="3853" href="Cat.Base.html#3804" class="Bound">h</a>
</pre>
<h2 id="opposites"><a href="#opposites" class="header-link">Opposites<span class="header-link-emoji">🔗</span></a></h2>
<p>A common theme throughout precategory theory is that of <em>duality</em>: The dual of a categorical concept is same concept, with “all the arrows inverted”. To make this formal, we introduce the idea of <em>opposite categories</em>: The opposite of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>,</span> written <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding="application/x-tex">C^{op}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span></span></span></span>,</span> has the same <code class="sourceCode agda">objects</code>, but with <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi mathvariant="normal">H</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi></mrow><msup><mi>C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></msub><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mrow><mi mathvariant="normal">H</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">m</mi></mrow><mi>C</mi></msub><mo stretchy="false">(</mo><mi>y</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{Hom}_{C^{op}}(x, y) = \mathrm{Hom}_{C}(y, x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Hom</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.5935em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Hom</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>.</span></p>
<pre class="Agda"><a id="4237" class="Keyword">infixl</a> <a id="4244" class="Number">60</a> <a data-type="Precategory o₁ h₁ → Precategory o₁ h₁" id="4247" href="Cat.Base.html#4252" class="Function Operator">_^op</a>
<a id="_^op"></a><a data-type="Precategory o₁ h₁ → Precategory o₁ h₁" id="4252" href="Cat.Base.html#4252" class="Function Operator">_^op</a> <a id="4257" class="Symbol">:</a> <a id="4259" class="Symbol">∀</a> <a id="4261" class="Symbol">{</a><a id="4262" href="Cat.Base.html#4262" class="Bound">o₁</a> <a id="4265" href="Cat.Base.html#4265" class="Bound">h₁</a><a id="4267" class="Symbol">}</a> <a id="4269" class="Symbol">→</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="4271" href="Cat.Base.html#611" class="Record">Precategory</a> <a id="4283" href="Cat.Base.html#4262" class="Bound">o₁</a> <a id="4286" href="Cat.Base.html#4265" class="Bound">h₁</a> <a id="4289" class="Symbol">→</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="4291" href="Cat.Base.html#611" class="Record">Precategory</a> <a id="4303" href="Cat.Base.html#4262" class="Bound">o₁</a> <a id="4306" href="Cat.Base.html#4265" class="Bound">h₁</a>
<a id="4309" class="Symbol">(</a><a id="4310" href="Cat.Base.html#4310" class="Bound">C</a> <a data-type="Precategory o₁ h₁ → Precategory o₁ h₁" id="4312" href="Cat.Base.html#4252" class="Function Operator">^op</a><a id="4315" class="Symbol">)</a> <a id="4317" class="Symbol">.</a><a data-type="Precategory o h → Type o" id="4318" href="Cat.Base.html#1312" class="Field">Precategory.Ob</a> <a id="4333" class="Symbol">=</a> <a data-type="Precategory o h → Type o" id="4335" href="Cat.Base.html#1312" class="Field">Precategory.Ob</a> <a id="4350" href="Cat.Base.html#4310" class="Bound">C</a>
<a id="4352" class="Symbol">(</a><a id="4353" href="Cat.Base.html#4353" class="Bound">C</a> <a data-type="Precategory o₁ h₁ → Precategory o₁ h₁" id="4355" href="Cat.Base.html#4252" class="Function Operator">^op</a><a id="4358" class="Symbol">)</a> <a id="4360" class="Symbol">.</a><a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="4361" href="Cat.Base.html#1329" class="Field">Precategory.Hom</a> <a id="4377" href="Cat.Base.html#4377" class="Bound">x</a> <a id="4379" href="Cat.Base.html#4379" class="Bound">y</a> <a id="4381" class="Symbol">=</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="4383" href="Cat.Base.html#1329" class="Field">Precategory.Hom</a> <a id="4399" href="Cat.Base.html#4353" class="Bound">C</a> <a id="4401" href="Cat.Base.html#4379" class="Bound">y</a> <a id="4403" href="Cat.Base.html#4377" class="Bound">x</a>
<a id="4405" class="Symbol">(</a><a id="4406" href="Cat.Base.html#4406" class="Bound">C</a> <a data-type="Precategory o₁ h₁ → Precategory o₁ h₁" id="4408" href="Cat.Base.html#4252" class="Function Operator">^op</a><a id="4411" class="Symbol">)</a> <a id="4413" class="Symbol">.</a><a data-type="(r : Precategory o h) (x y : r .Ob) → isSet (r .Hom x y)" id="4414" href="Cat.Base.html#1677" class="Field">Precategory.Hom-set</a> <a id="4434" href="Cat.Base.html#4434" class="Bound">x</a> <a id="4436" href="Cat.Base.html#4436" class="Bound">y</a> <a id="4438" class="Symbol">=</a> <a data-type="(r : Precategory o h) (x y : r .Ob) → isSet (r .Hom x y)" id="4440" href="Cat.Base.html#1677" class="Field">Precategory.Hom-set</a> <a id="4460" href="Cat.Base.html#4406" class="Bound">C</a> <a id="4462" href="Cat.Base.html#4436" class="Bound">y</a> <a id="4464" href="Cat.Base.html#4434" class="Bound">x</a>
<a id="4466" class="Symbol">(</a><a id="4467" href="Cat.Base.html#4467" class="Bound">C</a> <a data-type="Precategory o₁ h₁ → Precategory o₁ h₁" id="4469" href="Cat.Base.html#4252" class="Function Operator">^op</a><a id="4472" class="Symbol">)</a> <a id="4474" class="Symbol">.</a><a data-type="(r : Precategory o h) → r .Hom x x" id="4475" href="Cat.Base.html#2868" class="Field">Precategory.id</a> <a id="4490" class="Symbol">=</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="4492" href="Cat.Base.html#2868" class="Field">Precategory.id</a> <a id="4507" href="Cat.Base.html#4467" class="Bound">C</a>
<a id="4509" class="Symbol">(</a><a id="4510" href="Cat.Base.html#4510" class="Bound">C</a> <a data-type="Precategory o₁ h₁ → Precategory o₁ h₁" id="4512" href="Cat.Base.html#4252" class="Function Operator">^op</a><a id="4515" class="Symbol">)</a> <a id="4517" class="Symbol">.</a><a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="4518" href="Cat.Base.html#2898" class="Field Operator">Precategory._∘_</a> <a id="4534" href="Cat.Base.html#4534" class="Bound">f</a> <a id="4536" href="Cat.Base.html#4536" class="Bound">g</a> <a id="4538" class="Symbol">=</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="4540" href="Cat.Base.html#2898" class="Field Operator">Precategory._∘_</a> <a id="4556" href="Cat.Base.html#4510" class="Bound">C</a> <a id="4558" href="Cat.Base.html#4536" class="Bound">g</a> <a id="4560" href="Cat.Base.html#4534" class="Bound">f</a>
</pre>
<p>Composition in the opposite precategory <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding="application/x-tex">C^{op}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span></span></span></span> is “backwards” with respect to <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>:</span> <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><msub><mo>∘</mo><mrow><mi>o</mi><mi>p</mi></mrow></msub><mi>g</mi><mo>=</mo><mi>g</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">f \circ_{op} g = g \circ f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">∘</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>.</span> This inversion, applied twice, ends up equal to what we started with by the nature of computation - An equality that arises like this, automatically from what Agda computes, is called <em>definitional</em>.</p>
<pre class="Agda"><a id="4891" class="Symbol">(</a><a id="4892" href="Cat.Base.html#4892" class="Bound">C</a> <a data-type="Precategory o₁ h₁ → Precategory o₁ h₁" id="4894" href="Cat.Base.html#4252" class="Function Operator">^op</a><a id="4897" class="Symbol">)</a> <a id="4899" class="Symbol">.</a><a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" id="4900" href="Cat.Base.html#3376" class="Field">Precategory.idl</a> <a id="4916" href="Cat.Base.html#4916" class="Bound">x</a> <a id="4918" class="Symbol">=</a> <a id="4920" href="Cat.Base.html#4892" class="Bound">C</a> <a id="4922" class="Symbol">.</a><a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" id="4923" href="Cat.Base.html#3331" class="Field">Precategory.idr</a> <a id="4939" href="Cat.Base.html#4916" class="Bound">x</a>
<a id="4941" class="Symbol">(</a><a id="4942" href="Cat.Base.html#4942" class="Bound">C</a> <a data-type="Precategory o₁ h₁ → Precategory o₁ h₁" id="4944" href="Cat.Base.html#4252" class="Function Operator">^op</a><a id="4947" class="Symbol">)</a> <a id="4949" class="Symbol">.</a><a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" id="4950" href="Cat.Base.html#3331" class="Field">Precategory.idr</a> <a id="4966" href="Cat.Base.html#4966" class="Bound">x</a> <a id="4968" class="Symbol">=</a> <a id="4970" href="Cat.Base.html#4942" class="Bound">C</a> <a id="4972" class="Symbol">.</a><a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" id="4973" href="Cat.Base.html#3376" class="Field">Precategory.idl</a> <a id="4989" href="Cat.Base.html#4966" class="Bound">x</a>
</pre>
<p>The left and right identity laws are swapped for the construction of the opposite precategory: For <span class="Agda"><a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" href="Cat.Base.html#3331" class="Field">idr</a></span> one has to show <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><msub><mo>∘</mo><mrow><mi>o</mi><mi>p</mi></mrow></msub><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo>=</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">f \circ_{op} \mathrm{id} = f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">∘</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">id</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>,</span> which computes into having to show that <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><msub><mo>∘</mo><mi>o</mi></msub><mi>p</mi><mi>f</mi><mo>=</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">\mathrm{id} \circ_op{f} = f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathrm">id</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">∘</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>.</span> The case for <span class="Agda"><a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" href="Cat.Base.html#3376" class="Field">idl</a></span> is symmetric.</p>
<pre class="Agda"><a id="5276" class="Symbol">(</a><a id="5277" href="Cat.Base.html#5277" class="Bound">C</a> <a data-type="Precategory o₁ h₁ → Precategory o₁ h₁" id="5279" href="Cat.Base.html#4252" class="Function Operator">^op</a><a id="5282" class="Symbol">)</a> <a id="5284" class="Symbol">.</a><a data-type="(r : Precategory o h) (f : r .Hom y z) (g : r .Hom x y)
(h : r .Hom w x) →
r ._∘_ f (r ._∘_ g h) ≡ r ._∘_ (r ._∘_ f g) h" id="5285" href="Cat.Base.html#3755" class="Field">Precategory.assoc</a> <a id="5303" href="Cat.Base.html#5303" class="Bound">f</a> <a id="5305" href="Cat.Base.html#5305" class="Bound">g</a> <a id="5307" href="Cat.Base.html#5307" class="Bound">h</a> <a id="5309" href="Cat.Base.html#5309" class="Bound">i</a> <a id="5311" class="Symbol">=</a> <a data-type="(r : Precategory o h) (f : r .Hom y z) (g : r .Hom x y)
(h : r .Hom w x) →
r ._∘_ f (r ._∘_ g h) ≡ r ._∘_ (r ._∘_ f g) h" id="5313" href="Cat.Base.html#3755" class="Field">Precategory.assoc</a> <a id="5331" href="Cat.Base.html#5277" class="Bound">C</a> <a id="5333" href="Cat.Base.html#5307" class="Bound">h</a> <a id="5335" href="Cat.Base.html#5305" class="Bound">g</a> <a id="5337" href="Cat.Base.html#5303" class="Bound">f</a> <a id="5339" class="Symbol">(</a><a id="5340" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="5342" href="Cat.Base.html#5309" class="Bound">i</a><a id="5343" class="Symbol">)</a>
</pre>
<p>For associativity, consider the case of <span class="Agda"><a data-type="(r : Precategory o h) (f : r .Hom y z) (g : r .Hom x y)
(h : r .Hom w x) →
r ._∘_ f (r ._∘_ g h) ≡ r ._∘_ (r ._∘_ f g) h" href="Cat.Base.html#3755" class="Field">assoc</a></span> for the opposite precategory <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding="application/x-tex">C^{op}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span></span></span></span>.</span> What we have to show is - by the type of <code class="sourceCode agda">assoc₁</code> - <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><msub><mo>∘</mo><mrow><mi>o</mi><mi>p</mi></mrow></msub><mo stretchy="false">(</mo><mi>g</mi><msub><mo>∘</mo><mrow><mi>o</mi><mi>p</mi></mrow></msub><mi>h</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>f</mi><msub><mo>∘</mo><mrow><mi>o</mi><mi>p</mi></mrow></msub><mi>g</mi><mo stretchy="false">)</mo><msub><mo>∘</mo><mrow><mi>o</mi><mi>p</mi></mrow></msub><mi>h</mi></mrow><annotation encoding="application/x-tex">f \circ_{op} (g \circ_{op} h) = (f \circ_{op} g) \circ_{op} h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">∘</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">∘</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">∘</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">∘</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span>.</span> This computes into <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>h</mi><mo>∘</mo><mi>g</mi><mo stretchy="false">)</mo><mo>∘</mo><mi>f</mi><mo>=</mo><mi>h</mi><mo>∘</mo><mo stretchy="false">(</mo><mi>g</mi><mo>∘</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(h \circ g) \circ f = h \circ (g \circ f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span> - which is exactly what <code>sym (assoc C h g f)</code> shows!</p>
<p>Taking opposite categories is an involution. Since <code>sym (sym p) = p</code> by definition, taking opposite categories is also definitionally involutive.</p>
<pre class="Agda"><a id="5840" href="Cat.Base.html#5840" class="Function">_</a> <a id="5842" class="Symbol">:</a> <a id="5844" class="Symbol">∀</a> <a id="5846" class="Symbol">{</a><a id="5847" href="Cat.Base.html#5847" class="Bound">o₁</a> <a id="5850" href="Cat.Base.html#5850" class="Bound">h₁</a><a id="5852" class="Symbol">}</a> <a id="5854" class="Symbol">{</a><a id="5855" href="Cat.Base.html#5855" class="Bound">C</a> <a id="5857" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="5859" href="Cat.Base.html#611" class="Record">Precategory</a> <a id="5871" href="Cat.Base.html#5847" class="Bound">o₁</a> <a id="5874" href="Cat.Base.html#5850" class="Bound">h₁</a><a id="5876" class="Symbol">}</a> <a id="5878" class="Symbol">→</a> <a id="5880" class="Symbol">(</a><a id="5881" href="Cat.Base.html#5855" class="Bound">C</a> <a data-type="Precategory o₁ h₁ → Precategory o₁ h₁" id="5883" href="Cat.Base.html#4252" class="Function Operator">^op</a><a id="5886" class="Symbol">)</a> <a data-type="Precategory o₁ h₁ → Precategory o₁ h₁" id="5888" href="Cat.Base.html#4252" class="Function Operator">^op</a> <a data-type="A → A → Type ℓ" id="5892" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="5894" href="Cat.Base.html#5855" class="Bound">C</a>
<a id="5896" class="Symbol">_</a> <a id="5898" class="Symbol">=</a> <a data-type="x ≡ x" id="5900" href="1Lab.Path.html#3591" class="Function">refl</a>
</pre>
<h1 id="categories"><a href="#categories" class="header-link">Categories<span class="header-link-emoji">🔗</span></a></h1>
<p>In much the same way that a partial order is a preorder where <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≤</mo><mi>y</mi><mstyle mathcolor="#cc0000"><mtext>\and</mtext></mstyle><mi>y</mi><mo>≤</mo><mi>x</mi><mo>→</mo><mi>x</mi><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \le y \and y \le x \to x = y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord text" style="color:#cc0000;"><span class="mord" style="color:#cc0000;">\and</span></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>,</span> a <strong>category</strong> is a precategory where isomorphic objects are identified. This is a generalisation of the univalence axiom to arbitrary categories, and, indeed, it’s phrased in the same way: asking for a canonically defined map to be an equivalence.</p>
<pre class="Agda"><a id="_[_≅_]"></a><a data-type="(C : Precategory o h) → Ob C → Ob C → Type h" id="6278" href="Cat.Base.html#6278" class="Function Operator">_[_≅_]</a> <a id="6285" class="Symbol">:</a> <a id="6287" class="Symbol">∀</a> <a id="6289" class="Symbol">{</a><a id="6290" href="Cat.Base.html#6290" class="Bound">o</a> <a id="6292" href="Cat.Base.html#6292" class="Bound">h</a><a id="6293" class="Symbol">}</a> <a id="6295" class="Symbol">(</a><a id="6296" href="Cat.Base.html#6296" class="Bound">C</a> <a id="6298" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="6300" href="Cat.Base.html#611" class="Record">Precategory</a> <a id="6312" href="Cat.Base.html#6290" class="Bound">o</a> <a id="6314" href="Cat.Base.html#6292" class="Bound">h</a><a id="6315" class="Symbol">)</a> <a id="6317" class="Symbol">(</a><a id="6318" href="Cat.Base.html#6318" class="Bound">a</a> <a id="6320" href="Cat.Base.html#6320" class="Bound">b</a> <a id="6322" class="Symbol">:</a> <a data-type="Precategory o h → Type o" id="6324" href="Cat.Base.html#1312" class="Field">Precategory.Ob</a> <a id="6339" href="Cat.Base.html#6296" class="Bound">C</a><a id="6340" class="Symbol">)</a> <a id="6342" class="Symbol">→</a> <a id="6344" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="6349" href="Cat.Base.html#6292" class="Bound">h</a>
</pre>
<p>First, we have to define what it means for two objects in a category to be isomorphic. This is the same thing as an <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" href="1Lab.Equiv.html#6241">isomorphism of sets</a>, but with morphisms instead of functions: Morphisms in either direction, such that both ways of composing them are the identity.</p>
<pre class="Agda"><a data-type="(C : Precategory o h) → Ob C → Ob C → Type h" id="6678" href="Cat.Base.html#6278" class="Function Operator">_[_≅_]</a> <a id="6685" href="Cat.Base.html#6685" class="Bound">C</a> <a id="6687" href="Cat.Base.html#6687" class="Bound">a</a> <a id="6689" href="Cat.Base.html#6689" class="Bound">b</a> <a id="6691" class="Symbol">=</a>
  <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="6695" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="6698" href="Cat.Base.html#6698" class="Bound">fg</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="6701" href="1Lab.Type.html#1563" class="Function">∈</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="6703" href="Cat.Base.html#1329" class="Function">C.Hom</a> <a id="6709" href="Cat.Base.html#6687" class="Bound">a</a> <a id="6711" href="Cat.Base.html#6689" class="Bound">b</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="6713" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="6715" href="Cat.Base.html#1329" class="Function">C.Hom</a> <a id="6721" href="Cat.Base.html#6689" class="Bound">b</a> <a id="6723" href="Cat.Base.html#6687" class="Bound">a</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="6725" href="1Lab.Type.html#1563" class="Function">]</a>
  <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="6729" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="6732" href="Cat.Base.html#6732" class="Bound">_</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="6734" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="6736" class="Symbol">(</a><a id="6737" href="Cat.Base.html#6698" class="Bound">fg</a> <a id="6740" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="6741" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="6744" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="6746" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a id="6750" class="Symbol">(</a><a id="6751" href="Cat.Base.html#6698" class="Bound">fg</a> <a id="6754" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="6755" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="6758" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="6760" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="6762" href="Cat.Base.html#2868" class="Function">C.id</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="6767" href="1Lab.Type.html#1563" class="Function">]</a>
  <a id="6771" class="Symbol">(</a><a id="6772" href="Cat.Base.html#6698" class="Bound">fg</a> <a id="6775" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="6776" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="6780" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a id="6784" href="Cat.Base.html#6698" class="Bound">fg</a> <a id="6787" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="6788" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="A → A → Type ℓ" id="6792" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="6794" href="Cat.Base.html#2868" class="Function">C.id</a><a id="6798" class="Symbol">)</a>
  <a id="6802" class="Keyword">where</a> <a id="6808" class="Keyword">module</a> <a id="6815" href="Cat.Base.html#6815" class="Module">C</a> <a id="6817" class="Symbol">=</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="6819" href="Cat.Base.html#611" class="Module">Precategory</a> <a id="6831" href="Cat.Base.html#6685" class="Bound">C</a>

<a id="idIso"></a><a data-type="C [ a ≅ a ]" id="6834" href="Cat.Base.html#6834" class="Function">idIso</a> <a id="6840" class="Symbol">:</a> <a id="6842" class="Symbol">∀</a> <a id="6844" class="Symbol">{</a><a id="6845" href="Cat.Base.html#6845" class="Bound">o</a> <a id="6847" href="Cat.Base.html#6847" class="Bound">h</a><a id="6848" class="Symbol">}</a> <a id="6850" class="Symbol">{</a><a id="6851" href="Cat.Base.html#6851" class="Bound">C</a> <a id="6853" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="6855" href="Cat.Base.html#611" class="Record">Precategory</a> <a id="6867" href="Cat.Base.html#6845" class="Bound">o</a> <a id="6869" href="Cat.Base.html#6847" class="Bound">h</a><a id="6870" class="Symbol">}</a> <a id="6872" class="Symbol">{</a><a id="6873" href="Cat.Base.html#6873" class="Bound">a</a> <a id="6875" class="Symbol">:</a> <a data-type="Precategory o h → Type o" id="6877" href="Cat.Base.html#1312" class="Field">Precategory.Ob</a> <a id="6892" href="Cat.Base.html#6851" class="Bound">C</a><a id="6893" class="Symbol">}</a>
      <a id="6901" class="Symbol">→</a> <a id="6903" href="Cat.Base.html#6851" class="Bound">C</a> <a data-type="(C : Precategory o h) → Ob C → Ob C → Type h" id="6905" href="Cat.Base.html#6278" class="Function Operator">[</a> <a id="6907" href="Cat.Base.html#6873" class="Bound">a</a> <a data-type="(C : Precategory o h) → Ob C → Ob C → Type h" id="6909" href="Cat.Base.html#6278" class="Function Operator">≅</a> <a id="6911" href="Cat.Base.html#6873" class="Bound">a</a> <a data-type="(C : Precategory o h) → Ob C → Ob C → Type h" id="6913" href="Cat.Base.html#6278" class="Function Operator">]</a>
<a data-type="C [ a ≅ a ]" id="6915" href="Cat.Base.html#6834" class="Function">idIso</a> <a id="6921" class="Symbol">{</a><a id="6922" class="Argument">C</a> <a id="6924" class="Symbol">=</a> <a id="6926" href="Cat.Base.html#6926" class="Bound">C</a><a id="6927" class="Symbol">}</a> <a id="6929" class="Symbol">=</a> <a id="6931" class="Symbol">(</a><a data-type="(r : Precategory o h) → r .Hom x x" id="6932" href="Cat.Base.html#2868" class="Function">C.id</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="6937" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="6939" href="Cat.Base.html#2868" class="Function">C.id</a><a id="6943" class="Symbol">)</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="6945" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" id="6947" href="Cat.Base.html#3376" class="Function">C.idl</a> <a id="6953" class="Symbol">_</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="6955" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" id="6957" href="Cat.Base.html#3376" class="Function">C.idl</a> <a id="6963" class="Symbol">_</a>
  <a id="6967" class="Keyword">where</a> <a id="6973" class="Keyword">module</a> <a id="6980" href="Cat.Base.html#6980" class="Module">C</a> <a id="6982" class="Symbol">=</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="6984" href="Cat.Base.html#611" class="Module">Precategory</a> <a id="6996" href="Cat.Base.html#6926" class="Bound">C</a>
</pre>
<p>A precategory is a category precisely when the type <code>(Σ[ B ∈ _ ] C [ A ≅ B ])</code> is contractible. This implies that the type <code>A ≡ B</code> is equivalent to the type <code>C [ A ≃ B ]</code>, for any pair of objects <code>A</code>, <code>B</code> in the category. This is because <code>Σ[ B ∈ _ ] (A ≡ _)</code> is also contractible. Further, the type <code>C [ A ≃ B ]</code> satisfies J, by the same argument used to construct <code class="sourceCode agda">EquivJ</code>.</p>
<pre class="Agda"><a id="isCategory"></a><a data-type="Precategory o h → Type (o ⊔ h)" id="7394" href="Cat.Base.html#7394" class="Function">isCategory</a> <a id="7405" class="Symbol">:</a> <a id="7407" class="Symbol">∀</a> <a id="7409" class="Symbol">{</a><a id="7410" href="Cat.Base.html#7410" class="Bound">o</a> <a id="7412" href="Cat.Base.html#7412" class="Bound">h</a><a id="7413" class="Symbol">}</a> <a id="7415" class="Symbol">→</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="7417" href="Cat.Base.html#611" class="Record">Precategory</a> <a id="7429" href="Cat.Base.html#7410" class="Bound">o</a> <a id="7431" href="Cat.Base.html#7412" class="Bound">h</a> <a id="7433" class="Symbol">→</a> <a id="7435" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="7440" class="Symbol">_</a>
<a data-type="Precategory o h → Type (o ⊔ h)" id="7442" href="Cat.Base.html#7394" class="Function">isCategory</a> <a id="7453" href="Cat.Base.html#7453" class="Bound">C</a> <a id="7455" class="Symbol">=</a> <a id="7457" class="Symbol">∀</a> <a id="7459" class="Symbol">{</a><a id="7460" href="Cat.Base.html#7460" class="Bound">A</a><a id="7461" class="Symbol">}</a> <a id="7463" class="Symbol">→</a> <a data-type="(A : Type ℓ) → Type ℓ" id="7465" href="1Lab.HLevel.html#1328" class="Record">isContr</a> <a id="7473" class="Symbol">(</a><a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="7474" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="7477" href="Cat.Base.html#7477" class="Bound">B</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="7479" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="7481" class="Symbol">_</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="7483" href="1Lab.Type.html#1563" class="Function">]</a> <a id="7485" href="Cat.Base.html#7453" class="Bound">C</a> <a data-type="(C : Precategory o h) → Ob C → Ob C → Type h" id="7487" href="Cat.Base.html#6278" class="Function Operator">[</a> <a id="7489" href="Cat.Base.html#7460" class="Bound">A</a> <a data-type="(C : Precategory o h) → Ob C → Ob C → Type h" id="7491" href="Cat.Base.html#6278" class="Function Operator">≅</a> <a id="7493" href="Cat.Base.html#7477" class="Bound">B</a> <a data-type="(C : Precategory o h) → Ob C → Ob C → Type h" id="7495" href="Cat.Base.html#6278" class="Function Operator">]</a><a id="7496" class="Symbol">)</a>
</pre>
<p>This notion of univalent category corresponds to the usual notion — which is having the canonical map from paths to isomorphisms be an equivalence — by the following argument: Since the types <code>(Σ[ B ∈ _ ] C [ A ≅ B ])</code> and <code>Σ[ B ∈ _ ] A ≣ B</code>, the action of <span class="Agda"><a data-type="A ≡ B₁ → C [ A ≅ B₁ ]" href="Cat.Base.html#7864" class="Function">pathToIso</a></span> on total spaces is an equivalence; Hence <code>pathToIso</code> is an equivalence.</p>
<pre class="Agda"><a id="pathToIso"></a><a data-type="A ≡ B₁ → C [ A ≅ B₁ ]" id="7864" href="Cat.Base.html#7864" class="Function">pathToIso</a> <a id="7874" class="Symbol">:</a> <a id="7876" class="Symbol">∀</a> <a id="7878" class="Symbol">{</a><a id="7879" href="Cat.Base.html#7879" class="Bound">o</a> <a id="7881" href="Cat.Base.html#7881" class="Bound">h</a><a id="7882" class="Symbol">}</a> <a id="7884" class="Symbol">{</a><a id="7885" href="Cat.Base.html#7885" class="Bound">C</a> <a id="7887" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="7889" href="Cat.Base.html#611" class="Record">Precategory</a> <a id="7901" href="Cat.Base.html#7879" class="Bound">o</a> <a id="7903" href="Cat.Base.html#7881" class="Bound">h</a><a id="7904" class="Symbol">}</a> <a id="7906" class="Symbol">{</a><a id="7907" href="Cat.Base.html#7907" class="Bound">A</a> <a id="7909" class="Symbol">:</a> <a data-type="Precategory o h → Type o" id="7911" href="Cat.Base.html#1312" class="Field">Precategory.Ob</a> <a id="7926" href="Cat.Base.html#7885" class="Bound">C</a><a id="7927" class="Symbol">}</a> <a id="7929" class="Symbol">{</a><a id="7930" href="Cat.Base.html#7930" class="Bound">B</a> <a id="7932" class="Symbol">:</a> <a data-type="Precategory o h → Type o" id="7934" href="Cat.Base.html#1312" class="Field">Precategory.Ob</a> <a id="7949" href="Cat.Base.html#7885" class="Bound">C</a><a id="7950" class="Symbol">}</a>
          <a id="7962" class="Symbol">→</a> <a id="7964" href="Cat.Base.html#7907" class="Bound">A</a> <a data-type="A → A → Type ℓ" id="7966" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="7968" href="Cat.Base.html#7930" class="Bound">B</a> <a id="7970" class="Symbol">→</a> <a id="7972" href="Cat.Base.html#7885" class="Bound">C</a> <a data-type="(C : Precategory o h) → Ob C → Ob C → Type h" id="7974" href="Cat.Base.html#6278" class="Function Operator">[</a> <a id="7976" href="Cat.Base.html#7907" class="Bound">A</a> <a data-type="(C : Precategory o h) → Ob C → Ob C → Type h" id="7978" href="Cat.Base.html#6278" class="Function Operator">≅</a> <a id="7980" href="Cat.Base.html#7930" class="Bound">B</a> <a data-type="(C : Precategory o h) → Ob C → Ob C → Type h" id="7982" href="Cat.Base.html#6278" class="Function Operator">]</a>
<a data-type="A ≡ B₁ → C [ A ≅ B₁ ]" id="7984" href="Cat.Base.html#7864" class="Function">pathToIso</a> <a id="7994" class="Symbol">{</a><a id="7995" class="Argument">C</a> <a id="7997" class="Symbol">=</a> <a id="7999" href="Cat.Base.html#7999" class="Bound">C</a><a id="8000" class="Symbol">}</a> <a id="8002" class="Symbol">{</a><a id="8003" class="Argument">A</a> <a id="8005" class="Symbol">=</a> <a id="8007" href="Cat.Base.html#8007" class="Bound">A</a><a id="8008" class="Symbol">}</a> <a id="8010" class="Symbol">=</a> <a data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" id="8012" href="1Lab.Path.html#19603" class="Function">J</a> <a id="8014" class="Symbol">(λ</a> <a id="8017" href="Cat.Base.html#8017" class="Bound">B</a> <a id="8019" href="Cat.Base.html#8019" class="Bound">p</a> <a id="8021" class="Symbol">→</a> <a id="8023" href="Cat.Base.html#7999" class="Bound">C</a> <a data-type="(C : Precategory o h) → Ob C → Ob C → Type h" id="8025" href="Cat.Base.html#6278" class="Function Operator">[</a> <a id="8027" href="Cat.Base.html#8007" class="Bound">A</a> <a data-type="(C : Precategory o h) → Ob C → Ob C → Type h" id="8029" href="Cat.Base.html#6278" class="Function Operator">≅</a> <a id="8031" href="Cat.Base.html#8017" class="Bound">B</a> <a data-type="(C : Precategory o h) → Ob C → Ob C → Type h" id="8033" href="Cat.Base.html#6278" class="Function Operator">]</a><a id="8034" class="Symbol">)</a> <a id="8036" class="Symbol">(</a><a data-type="C [ a ≅ a ]" id="8037" href="Cat.Base.html#6834" class="Function">idIso</a> <a id="8043" class="Symbol">{</a><a id="8044" class="Argument">C</a> <a id="8046" class="Symbol">=</a> <a id="8048" href="Cat.Base.html#7999" class="Bound">C</a><a id="8049" class="Symbol">})</a>
</pre>
<p>First we define, exactly as in the book, the canonical map <span class="Agda"><a data-type="A ≡ B₁ → C [ A ≅ B₁ ]" href="Cat.Base.html#7864" class="Function">pathToIso</a></span>.</p>
<pre class="Agda"><a id="isCategory→isEquiv-pathToIso"></a><a data-type="isCategory C → isEquiv pathToIso" id="8145" href="Cat.Base.html#8145" class="Function">isCategory→isEquiv-pathToIso</a>
  <a id="8176" class="Symbol">:</a> <a id="8178" class="Symbol">∀</a> <a id="8180" class="Symbol">{</a><a id="8181" href="Cat.Base.html#8181" class="Bound">o</a> <a id="8183" href="Cat.Base.html#8183" class="Bound">h</a><a id="8184" class="Symbol">}</a> <a id="8186" class="Symbol">{</a><a id="8187" href="Cat.Base.html#8187" class="Bound">C</a> <a id="8189" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="8191" href="Cat.Base.html#611" class="Record">Precategory</a> <a id="8203" href="Cat.Base.html#8181" class="Bound">o</a> <a id="8205" href="Cat.Base.html#8183" class="Bound">h</a><a id="8206" class="Symbol">}</a>
  <a id="8210" class="Symbol">→</a> <a data-type="Precategory o h → Type (o ⊔ h)" id="8212" href="Cat.Base.html#7394" class="Function">isCategory</a> <a id="8223" href="Cat.Base.html#8187" class="Bound">C</a> <a id="8225" class="Symbol">→</a> <a id="8227" class="Symbol">∀</a> <a id="8229" class="Symbol">{</a><a id="8230" href="Cat.Base.html#8230" class="Bound">A</a> <a id="8232" href="Cat.Base.html#8232" class="Bound">B</a><a id="8233" class="Symbol">}</a>
  <a id="8237" class="Symbol">→</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="8239" href="1Lab.Equiv.html#2293" class="Record">isEquiv</a> <a id="8247" class="Symbol">(</a><a data-type="A ≡ B₁ → C [ A ≅ B₁ ]" id="8248" href="Cat.Base.html#7864" class="Function">pathToIso</a> <a id="8258" class="Symbol">{</a><a id="8259" class="Argument">C</a> <a id="8261" class="Symbol">=</a> <a id="8263" href="Cat.Base.html#8187" class="Bound">C</a><a id="8264" class="Symbol">}</a> <a id="8266" class="Symbol">{</a><a id="8267" class="Argument">A</a> <a id="8269" class="Symbol">=</a> <a id="8271" href="Cat.Base.html#8230" class="Bound">A</a><a id="8272" class="Symbol">}</a> <a id="8274" class="Symbol">{</a><a id="8275" class="Argument">B</a> <a id="8277" class="Symbol">=</a> <a id="8279" href="Cat.Base.html#8232" class="Bound">B</a><a id="8280" class="Symbol">})</a>
<a data-type="isCategory C → isEquiv pathToIso" id="8283" href="Cat.Base.html#8145" class="Function">isCategory→isEquiv-pathToIso</a> <a id="8312" class="Symbol">{</a><a id="8313" class="Argument">C</a> <a id="8315" class="Symbol">=</a> <a id="8317" href="Cat.Base.html#8317" class="Bound">C</a><a id="8318" class="Symbol">}</a> <a id="8320" href="Cat.Base.html#8320" class="Bound">iscat</a> <a id="8326" class="Symbol">{</a><a id="8327" href="Cat.Base.html#8327" class="Bound">A</a><a id="8328" class="Symbol">}</a> <a id="8330" class="Symbol">{</a><a id="8331" href="Cat.Base.html#8331" class="Bound">B</a><a id="8332" class="Symbol">}</a> <a id="8334" class="Symbol">=</a> <a data-type="isEquiv (total f) → isEquiv (f x)" id="8336" href="1Lab.Equiv.Fibrewise.html#1929" class="Function">total→equiv</a> <a id="8348" href="Cat.Base.html#8785" class="Function">isEquiv-total</a> <a id="8362" class="Keyword">where</a>
  <a id="8370" href="Cat.Base.html#8370" class="Function">P</a> <a id="8372" href="Cat.Base.html#8372" class="Function">Q</a> <a id="8374" class="Symbol">:</a> <a data-type="Precategory o h → Type o" id="8376" href="Cat.Base.html#1312" class="Field">Precategory.Ob</a> <a id="8391" href="Cat.Base.html#8317" class="Bound">C</a> <a id="8393" class="Symbol">→</a> <a id="8395" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="8400" class="Symbol">_</a>
  <a id="8404" href="Cat.Base.html#8370" class="Function">P</a> <a id="8406" href="Cat.Base.html#8406" class="Bound">B</a> <a id="8408" class="Symbol">=</a> <a id="8410" href="Cat.Base.html#8327" class="Bound">A</a> <a data-type="A → A → Type ℓ" id="8412" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="8414" href="Cat.Base.html#8406" class="Bound">B</a>
  <a id="8418" href="Cat.Base.html#8372" class="Function">Q</a> <a id="8420" href="Cat.Base.html#8420" class="Bound">B</a> <a id="8422" class="Symbol">=</a> <a id="8424" href="Cat.Base.html#8317" class="Bound">C</a> <a data-type="(C : Precategory o h) → Ob C → Ob C → Type h" id="8426" href="Cat.Base.html#6278" class="Function Operator">[</a> <a id="8428" href="Cat.Base.html#8327" class="Bound">A</a> <a data-type="(C : Precategory o h) → Ob C → Ob C → Type h" id="8430" href="Cat.Base.html#6278" class="Function Operator">≅</a> <a id="8432" href="Cat.Base.html#8420" class="Bound">B</a> <a data-type="(C : Precategory o h) → Ob C → Ob C → Type h" id="8434" href="Cat.Base.html#6278" class="Function Operator">]</a>
</pre>
<p>We consider the map <span class="Agda"><a data-type="A ≡ B₁ → C [ A ≅ B₁ ]" href="Cat.Base.html#7864" class="Function">pathToIso</a></span> as a <a href="1Lab.Equiv.Fibrewise.html">fibrewise equivalence</a> between the two families <code>A ≡ -</code> and <code>C [ A ≅ - ]</code>. This lets us reduce the problem of proving that <span class="Agda"><a data-type="A ≡ B₁ → C [ A ≅ B₁ ]" href="Cat.Base.html#7864" class="Function">pathToIso</a></span> is an equivalence to the problem of proving that it induces an equivalence of total spaces.</p>
<pre class="Agda">  <a id="8785" href="Cat.Base.html#8785" class="Function">isEquiv-total</a> <a id="8799" class="Symbol">:</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="8801" href="1Lab.Equiv.html#2293" class="Record">isEquiv</a> <a id="8809" class="Symbol">(</a><a data-type="((x : A) → P x → Q x) → Σ P → Σ Q" id="8810" href="1Lab.Equiv.Fibrewise.html#633" class="Function">total</a> <a id="8816" class="Symbol">{</a><a id="8817" class="Argument">P</a> <a id="8819" class="Symbol">=</a> <a id="8821" href="Cat.Base.html#8370" class="Function">P</a><a id="8822" class="Symbol">}</a> <a id="8824" class="Symbol">{</a><a id="8825" class="Argument">Q</a> <a id="8827" class="Symbol">=</a> <a id="8829" href="Cat.Base.html#8372" class="Function">Q</a><a id="8830" class="Symbol">}</a> <a id="8832" class="Symbol">(λ</a> <a id="8835" href="Cat.Base.html#8835" class="Bound">A</a> <a id="8837" href="Cat.Base.html#8837" class="Bound">p</a> <a id="8839" class="Symbol">→</a> <a data-type="A ≡ B₁ → C [ A ≅ B₁ ]" id="8841" href="Cat.Base.html#7864" class="Function">pathToIso</a> <a id="8851" class="Symbol">{</a><a id="8852" class="Argument">C</a> <a id="8854" class="Symbol">=</a> <a id="8856" href="Cat.Base.html#8317" class="Bound">C</a><a id="8857" class="Symbol">}</a> <a id="8859" href="Cat.Base.html#8837" class="Bound">p</a><a id="8860" class="Symbol">))</a>
  <a id="8865" href="Cat.Base.html#8785" class="Function">isEquiv-total</a> <a id="8879" class="Symbol">=</a>
    <a data-type="isContr A → isContr B₁ → isEquiv f" id="8885" href="1Lab.Equiv.html#20328" class="Function">isContr→isEquiv</a> <a id="8901" class="Symbol">(</a><a data-type="(centre₁ : A) (paths₁ : (x : A) → centre₁ ≡ x) → isContr A" id="8902" href="1Lab.HLevel.html#1382" class="InductiveConstructor">contr</a> <a id="8908" class="Symbol">(</a><a id="8909" href="Cat.Base.html#8327" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="8911" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8913" class="Symbol">λ</a> <a id="8915" href="Cat.Base.html#8915" class="Bound">i</a> <a id="8917" class="Symbol">→</a> <a id="8919" href="Cat.Base.html#8327" class="Bound">A</a><a id="8920" class="Symbol">)</a> <a data-type="(y : Singleton x) → Path (Singleton x) (x , refl) y" id="8922" href="1Lab.Path.html#19256" class="Function">isContr-Singleton</a><a id="8939" class="Symbol">)</a>
                    <a id="8961" href="Cat.Base.html#8320" class="Bound">iscat</a>
</pre>
<p>Since the total spaces are contractible (<code>Σ P</code> by <span class="Agda"><a data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" href="1Lab.Path.html#19603" class="Function">path induction</a></span>, <code>Σ Q</code> by the assumption that C is a category) <a data-type="isContr A → isContr B₁ → isEquiv f" href="1Lab.Equiv.html#20328">any map between them is an equivalence</a>. This implies that we can turn categorical isomorphisms into paths of objects:</p>
<pre class="Agda"><a id="isCategory→isoToPath"></a><a data-type="isCategory C → C [ A ≅ B₁ ] → A ≡ B₁" id="9265" href="Cat.Base.html#9265" class="Function">isCategory→isoToPath</a> <a id="9286" class="Symbol">:</a> <a id="9288" class="Symbol">∀</a> <a id="9290" class="Symbol">{</a><a id="9291" href="Cat.Base.html#9291" class="Bound">o</a> <a id="9293" href="Cat.Base.html#9293" class="Bound">h</a><a id="9294" class="Symbol">}</a> <a id="9296" class="Symbol">{</a><a id="9297" href="Cat.Base.html#9297" class="Bound">C</a> <a id="9299" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="9301" href="Cat.Base.html#611" class="Record">Precategory</a> <a id="9313" href="Cat.Base.html#9291" class="Bound">o</a> <a id="9315" href="Cat.Base.html#9293" class="Bound">h</a><a id="9316" class="Symbol">}</a>
                     <a id="9339" class="Symbol">→</a> <a data-type="Precategory o h → Type (o ⊔ h)" id="9341" href="Cat.Base.html#7394" class="Function">isCategory</a> <a id="9352" href="Cat.Base.html#9297" class="Bound">C</a>
                     <a id="9375" class="Symbol">→</a> <a id="9377" class="Symbol">∀</a> <a id="9379" class="Symbol">{</a><a id="9380" href="Cat.Base.html#9380" class="Bound">A</a> <a id="9382" href="Cat.Base.html#9382" class="Bound">B</a><a id="9383" class="Symbol">}</a>
                     <a id="9406" class="Symbol">→</a> <a id="9408" href="Cat.Base.html#9297" class="Bound">C</a> <a data-type="(C : Precategory o h) → Ob C → Ob C → Type h" id="9410" href="Cat.Base.html#6278" class="Function Operator">[</a> <a id="9412" href="Cat.Base.html#9380" class="Bound">A</a> <a data-type="(C : Precategory o h) → Ob C → Ob C → Type h" id="9414" href="Cat.Base.html#6278" class="Function Operator">≅</a> <a id="9416" href="Cat.Base.html#9382" class="Bound">B</a> <a data-type="(C : Precategory o h) → Ob C → Ob C → Type h" id="9418" href="Cat.Base.html#6278" class="Function Operator">]</a>
                     <a id="9441" class="Symbol">→</a> <a id="9443" href="Cat.Base.html#9380" class="Bound">A</a> <a data-type="A → A → Type ℓ" id="9445" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="9447" href="Cat.Base.html#9382" class="Bound">B</a>
<a data-type="isCategory C → C [ A ≅ B₁ ] → A ≡ B₁" id="9449" href="Cat.Base.html#9265" class="Function">isCategory→isoToPath</a> <a id="9470" class="Symbol">{</a><a id="9471" class="Argument">C</a> <a id="9473" class="Symbol">=</a> <a id="9475" href="Cat.Base.html#9475" class="Bound">C</a><a id="9476" class="Symbol">}</a> <a id="9478" href="Cat.Base.html#9478" class="Bound">cat</a> <a id="9482" class="Symbol">=</a>
  <a data-type="isEquiv f → isIso f" id="9486" href="1Lab.Equiv.html#6787" class="Function">isEquiv→isIso</a> <a id="9500" class="Symbol">(</a><a data-type="isCategory C → isEquiv pathToIso" id="9501" href="Cat.Base.html#8145" class="Function">isCategory→isEquiv-pathToIso</a> <a id="9530" class="Symbol">{</a><a id="9531" class="Argument">C</a> <a id="9533" class="Symbol">=</a> <a id="9535" href="Cat.Base.html#9475" class="Bound">C</a><a id="9536" class="Symbol">}</a> <a id="9538" href="Cat.Base.html#9478" class="Bound">cat</a><a id="9541" class="Symbol">)</a> <a id="9543" class="Symbol">.</a><a data-type="isIso f → B₁ → A" id="9544" href="1Lab.Equiv.html#6080" class="Field">isIso.inv</a>
</pre>
<p>Furthermore, we have that this function is an equivalence, and so the type of objects in a univalent category is at most a <a data-type="Type ℓ → Type ℓ" href="1Lab.HLevel.html#3617">groupoid</a>. We use the fact that <a data-type="(n : Nat) (f : A → B₁) → isEquiv f → isHLevel A n → isHLevel B₁ n" href="1Lab.HLevel.Retracts.html#3755">h-levels are closed under equivalences</a> and that <a data-type="(n : Nat) →
isHLevel A n → ((x : A) → isHLevel (B₁ x) n) → isHLevel (Σ B₁) n" href="1Lab.HLevel.Retracts.html#5094">dependent sums preserve h-levels</a>.</p>
<pre class="Agda"><a id="isCategory→isGroupoid-Ob"></a><a data-type="isCategory C → isGroupoid (C .Ob)" id="10012" href="Cat.Base.html#10012" class="Function">isCategory→isGroupoid-Ob</a> <a id="10037" class="Symbol">:</a> <a id="10039" class="Symbol">∀</a> <a id="10041" class="Symbol">{</a><a id="10042" href="Cat.Base.html#10042" class="Bound">o</a> <a id="10044" href="Cat.Base.html#10044" class="Bound">h</a><a id="10045" class="Symbol">}</a> <a id="10047" class="Symbol">{</a><a id="10048" href="Cat.Base.html#10048" class="Bound">C</a> <a id="10050" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="10052" href="Cat.Base.html#611" class="Record">Precategory</a> <a id="10064" href="Cat.Base.html#10042" class="Bound">o</a> <a id="10066" href="Cat.Base.html#10044" class="Bound">h</a><a id="10067" class="Symbol">}</a>
                         <a id="10094" class="Symbol">→</a> <a data-type="Precategory o h → Type (o ⊔ h)" id="10096" href="Cat.Base.html#7394" class="Function">isCategory</a> <a id="10107" href="Cat.Base.html#10048" class="Bound">C</a>
                         <a id="10134" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="10136" href="1Lab.HLevel.html#3617" class="Function">isGroupoid</a> <a id="10147" class="Symbol">(</a><a id="10148" href="Cat.Base.html#10048" class="Bound">C</a> <a id="10150" class="Symbol">.</a><a data-type="Precategory o h → Type o" id="10151" href="Cat.Base.html#1312" class="Field">Precategory.Ob</a><a id="10165" class="Symbol">)</a>
<a data-type="isCategory C → isGroupoid (C .Ob)" id="10167" href="Cat.Base.html#10012" class="Function">isCategory→isGroupoid-Ob</a> <a id="10192" class="Symbol">{</a><a id="10193" class="Argument">C</a> <a id="10195" class="Symbol">=</a> <a id="10197" href="Cat.Base.html#10197" class="Bound">C</a><a id="10198" class="Symbol">}</a> <a id="10200" href="Cat.Base.html#10200" class="Bound">iscat</a> <a id="10206" href="Cat.Base.html#10206" class="Bound">x</a> <a id="10208" href="Cat.Base.html#10208" class="Bound">y</a> <a id="10210" class="Symbol">=</a>
  <a data-type="(n : Nat) (f : A → B₁) → isEquiv f → isHLevel A n → isHLevel B₁ n" id="10214" href="1Lab.HLevel.Retracts.html#3755" class="Function">isHLevel-equiv</a> <a id="10229" class="Number">2</a>
    <a id="10235" class="Symbol">(</a><a data-type="isCategory C → C [ A ≅ B₁ ] → A ≡ B₁" id="10236" href="Cat.Base.html#9265" class="Function">isCategory→isoToPath</a> <a id="10257" class="Symbol">{</a><a id="10258" class="Argument">C</a> <a id="10260" class="Symbol">=</a> <a id="10262" href="Cat.Base.html#10197" class="Bound">C</a><a id="10263" class="Symbol">}</a> <a id="10265" href="Cat.Base.html#10200" class="Bound">iscat</a><a id="10270" class="Symbol">)</a>
    <a id="10276" class="Symbol">(((_</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="10281" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isCategory C → isEquiv pathToIso" id="10283" href="Cat.Base.html#8145" class="Function">isCategory→isEquiv-pathToIso</a> <a id="10312" class="Symbol">{</a><a id="10313" class="Argument">C</a> <a id="10315" class="Symbol">=</a> <a id="10317" href="Cat.Base.html#10197" class="Bound">C</a><a id="10318" class="Symbol">}</a> <a id="10320" href="Cat.Base.html#10200" class="Bound">iscat</a><a id="10325" class="Symbol">)</a> <a data-type="A ≃ B₁ → B₁ ≃ A" id="10327" href="1Lab.Equiv.html#21256" class="Function Operator">e⁻¹</a><a id="10330" class="Symbol">)</a> <a id="10332" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="10333" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="10336" class="Symbol">)</a>
</pre>
<p>Since <span class="Agda"><a data-type="(C : Precategory o h) → Ob C → Ob C → Type h" href="Cat.Base.html#6278" class="Function Operator">an isomorphism</a></span> is a big dependent sum of <a data-type="Type ℓ → Type ℓ" href="1Lab.HLevel.html#3342">sets</a>, we have that the paths <code>x ≡ y</code> are a set, and so <code>C</code> is a groupoid.</p>
<pre class="Agda">    <a id="10536" class="Symbol">(</a><a data-type="(n : Nat) →
isHLevel A n → ((x : A) → isHLevel (B₁ x) n) → isHLevel (Σ B₁) n" id="10537" href="1Lab.HLevel.Retracts.html#5094" class="Function">isHLevelΣ</a> <a id="10547" class="Number">2</a>
      <a id="10555" class="Symbol">(</a><a data-type="(n : Nat) →
isHLevel A n → ((x : A) → isHLevel (B₁ x) n) → isHLevel (Σ B₁) n" id="10556" href="1Lab.HLevel.Retracts.html#5094" class="Function">isHLevelΣ</a> <a id="10566" class="Number">2</a>
        <a id="10576" class="Symbol">(</a><a data-type="(r : Precategory o h) (x y : r .Ob) → isSet (r .Hom x y)" id="10577" href="Cat.Base.html#1677" class="Function">C.Hom-set</a> <a id="10587" class="Symbol">_</a> <a id="10589" class="Symbol">_)</a> <a id="10592" class="Symbol">λ</a> <a id="10594" href="Cat.Base.html#10594" class="Bound">_</a> <a id="10596" class="Symbol">→</a> <a data-type="(r : Precategory o h) (x y : r .Ob) → isSet (r .Hom x y)" id="10598" href="Cat.Base.html#1677" class="Function">C.Hom-set</a> <a id="10608" class="Symbol">_</a> <a id="10610" class="Symbol">_)</a>
        <a id="10621" class="Symbol">λ</a> <a id="10623" class="Symbol">{</a> <a id="10625" class="Symbol">(</a><a id="10626" href="Cat.Base.html#10626" class="Bound">f</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="10628" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="10630" href="Cat.Base.html#10630" class="Bound">g</a><a id="10631" class="Symbol">)</a> <a id="10633" class="Symbol">→</a>
            <a data-type="isProp A → isSet A" id="10647" href="1Lab.HLevel.html#5654" class="Function">isProp→isSet</a> <a id="10660" class="Symbol">(</a><a data-type="(n : Nat) →
isHLevel A n → ((x : A) → isHLevel (B₁ x) n) → isHLevel (Σ B₁) n" id="10661" href="1Lab.HLevel.Retracts.html#5094" class="Function">isHLevelΣ</a> <a id="10671" class="Number">1</a> <a id="10673" class="Symbol">(</a><a data-type="(r : Precategory o h) (x y : r .Ob) → isSet (r .Hom x y)" id="10674" href="Cat.Base.html#1677" class="Function">C.Hom-set</a> <a id="10684" class="Symbol">_</a> <a id="10686" class="Symbol">_</a> <a id="10688" class="Symbol">_</a> <a id="10690" class="Symbol">_)</a>
                                      <a id="10731" class="Symbol">λ</a> <a id="10733" href="Cat.Base.html#10733" class="Bound">_</a> <a id="10735" class="Symbol">→</a> <a data-type="(r : Precategory o h) (x y : r .Ob) → isSet (r .Hom x y)" id="10737" href="Cat.Base.html#1677" class="Function">C.Hom-set</a> <a id="10747" class="Symbol">_</a> <a id="10749" class="Symbol">_</a> <a id="10751" class="Symbol">_</a> <a id="10753" class="Symbol">_)</a> <a id="10756" class="Symbol">})</a>
  <a id="10761" class="Keyword">where</a> <a id="10767" class="Keyword">module</a> <a id="10774" href="Cat.Base.html#10774" class="Module">C</a> <a id="10776" class="Symbol">=</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="10778" href="Cat.Base.html#611" class="Module">Precategory</a> <a id="10790" href="Cat.Base.html#10197" class="Bound">C</a>
</pre>
<h2 id="the-category-of-sets"><a href="#the-category-of-sets" class="header-link">The category of Sets<span class="header-link-emoji">🔗</span></a></h2>
<p>Given a <a href="1Lab.Type.html">universe level</a>, we can consider the collection of <a data-type="(ℓ : Level) → Type (lsuc ℓ)" href="1Lab.HLevel.html#3398">all sets</a> of that level. This assembles into a <span class="Agda"><a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" href="Cat.Base.html#611" class="Record">precategory</a></span> quite nicely, since functions preserve h-levels.</p>
<pre class="Agda"><a id="11098" class="Keyword">module</a> <a id="11105" href="Cat.Base.html#11105" class="Module">_</a> <a id="11107" class="Keyword">where</a>
  <a id="11115" class="Keyword">open</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="11120" href="Cat.Base.html#611" class="Module">Precategory</a>

  <a data-type="(o : Level) → Precategory (lsuc o) o" id="11135" href="Cat.Base.html#11135" class="Function">Sets</a> <a id="11140" class="Symbol">:</a> <a id="11142" class="Symbol">(</a><a id="11143" href="Cat.Base.html#11143" class="Bound">o</a> <a id="11145" class="Symbol">:</a> <a id="11147" class="Symbol">_)</a> <a id="11150" class="Symbol">→</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="11152" href="Cat.Base.html#611" class="Record">Precategory</a> <a id="11164" class="Symbol">(</a><a data-type="Level → Level" id="11165" href="Agda.Primitive.html#780" class="Primitive">lsuc</a> <a id="11170" href="Cat.Base.html#11143" class="Bound">o</a><a id="11171" class="Symbol">)</a> <a id="11173" href="Cat.Base.html#11143" class="Bound">o</a>
  <a data-type="(o : Level) → Precategory (lsuc o) o" id="11177" href="Cat.Base.html#11135" class="Function">Sets</a> <a id="11182" href="Cat.Base.html#11182" class="Bound">o</a> <a id="11184" class="Symbol">.</a><a data-type="Precategory o h → Type o" id="11185" href="Cat.Base.html#1312" class="Field">Ob</a> <a id="11188" class="Symbol">=</a> <a data-type="(ℓ : Level) → Type (lsuc ℓ)" id="11190" href="1Lab.HLevel.html#3398" class="Function">Set</a> <a id="11194" href="Cat.Base.html#11182" class="Bound">o</a>
  <a data-type="(o : Level) → Precategory (lsuc o) o" id="11198" href="Cat.Base.html#11135" class="Function">Sets</a> <a id="11203" href="Cat.Base.html#11203" class="Bound">o</a> <a id="11205" class="Symbol">.</a><a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="11206" href="Cat.Base.html#1329" class="Field">Hom</a> <a id="11210" href="Cat.Base.html#11210" class="Bound">A</a> <a id="11212" href="Cat.Base.html#11212" class="Bound">B</a> <a id="11214" class="Symbol">=</a> <a id="11216" href="Cat.Base.html#11210" class="Bound">A</a> <a id="11218" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="11219" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="11223" class="Symbol">→</a> <a id="11225" href="Cat.Base.html#11212" class="Bound">B</a> <a id="11227" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="11228" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a>
  <a data-type="(o : Level) → Precategory (lsuc o) o" id="11234" href="Cat.Base.html#11135" class="Function">Sets</a> <a id="11239" href="Cat.Base.html#11239" class="Bound">o</a> <a id="11241" class="Symbol">.</a><a data-type="(r : Precategory o h) (x y : r .Ob) → isSet (r .Hom x y)" id="11242" href="Cat.Base.html#1677" class="Field">Hom-set</a> <a id="11250" class="Symbol">_</a> <a id="11252" class="Symbol">(</a><a id="11253" href="Cat.Base.html#11253" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="11255" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="11257" href="Cat.Base.html#11257" class="Bound">bset</a><a id="11261" class="Symbol">)</a> <a id="11263" href="Cat.Base.html#11263" class="Bound">f</a> <a id="11265" href="Cat.Base.html#11265" class="Bound">g</a> <a id="11267" href="Cat.Base.html#11267" class="Bound">p</a> <a id="11269" href="Cat.Base.html#11269" class="Bound">q</a> <a id="11271" href="Cat.Base.html#11271" class="Bound">i</a> <a id="11273" href="Cat.Base.html#11273" class="Bound">j</a> <a id="11275" href="Cat.Base.html#11275" class="Bound">a</a> <a id="11277" class="Symbol">=</a>
    <a id="11283" href="Cat.Base.html#11257" class="Bound">bset</a> <a id="11288" class="Symbol">(</a><a id="11289" href="Cat.Base.html#11263" class="Bound">f</a> <a id="11291" href="Cat.Base.html#11275" class="Bound">a</a><a id="11292" class="Symbol">)</a> <a id="11294" class="Symbol">(</a><a id="11295" href="Cat.Base.html#11265" class="Bound">g</a> <a id="11297" href="Cat.Base.html#11275" class="Bound">a</a><a id="11298" class="Symbol">)</a> <a id="11300" class="Symbol">(</a><a data-type="f ≡ g → (x : A) → f x ≡ g x" id="11301" href="1Lab.Path.html#58047" class="Function">happly</a> <a id="11308" href="Cat.Base.html#11267" class="Bound">p</a> <a id="11310" href="Cat.Base.html#11275" class="Bound">a</a><a id="11311" class="Symbol">)</a> <a id="11313" class="Symbol">(</a><a data-type="f ≡ g → (x : A) → f x ≡ g x" id="11314" href="1Lab.Path.html#58047" class="Function">happly</a> <a id="11321" href="Cat.Base.html#11269" class="Bound">q</a> <a id="11323" href="Cat.Base.html#11275" class="Bound">a</a><a id="11324" class="Symbol">)</a> <a id="11326" href="Cat.Base.html#11271" class="Bound">i</a> <a id="11328" href="Cat.Base.html#11273" class="Bound">j</a>
  <a data-type="(o : Level) → Precategory (lsuc o) o" id="11332" href="Cat.Base.html#11135" class="Function">Sets</a> <a id="11337" href="Cat.Base.html#11337" class="Bound">o</a> <a id="11339" class="Symbol">.</a><a data-type="(r : Precategory o h) → r .Hom x x" id="11340" href="Cat.Base.html#2868" class="Field">id</a> <a id="11343" href="Cat.Base.html#11343" class="Bound">x</a> <a id="11345" class="Symbol">=</a> <a id="11347" href="Cat.Base.html#11343" class="Bound">x</a>
  <a data-type="(o : Level) → Precategory (lsuc o) o" id="11351" href="Cat.Base.html#11135" class="Function">Sets</a> <a id="11356" href="Cat.Base.html#11356" class="Bound">o</a> <a id="11358" class="Symbol">.</a><a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="11359" href="Cat.Base.html#2898" class="Field Operator">_∘_</a> <a id="11363" href="Cat.Base.html#11363" class="Bound">f</a> <a id="11365" href="Cat.Base.html#11365" class="Bound">g</a> <a id="11367" href="Cat.Base.html#11367" class="Bound">x</a> <a id="11369" class="Symbol">=</a> <a id="11371" href="Cat.Base.html#11363" class="Bound">f</a> <a id="11373" class="Symbol">(</a><a id="11374" href="Cat.Base.html#11365" class="Bound">g</a> <a id="11376" href="Cat.Base.html#11367" class="Bound">x</a><a id="11377" class="Symbol">)</a>
  <a data-type="(o : Level) → Precategory (lsuc o) o" id="11381" href="Cat.Base.html#11135" class="Function">Sets</a> <a id="11386" href="Cat.Base.html#11386" class="Bound">o</a> <a id="11388" class="Symbol">.</a><a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" id="11389" href="Cat.Base.html#3376" class="Field">idl</a> <a id="11393" href="Cat.Base.html#11393" class="Bound">f</a> <a id="11395" class="Symbol">=</a> <a data-type="x ≡ x" id="11397" href="1Lab.Path.html#3591" class="Function">refl</a>
  <a data-type="(o : Level) → Precategory (lsuc o) o" id="11404" href="Cat.Base.html#11135" class="Function">Sets</a> <a id="11409" href="Cat.Base.html#11409" class="Bound">o</a> <a id="11411" class="Symbol">.</a><a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" id="11412" href="Cat.Base.html#3331" class="Field">idr</a> <a id="11416" href="Cat.Base.html#11416" class="Bound">f</a> <a id="11418" class="Symbol">=</a> <a data-type="x ≡ x" id="11420" href="1Lab.Path.html#3591" class="Function">refl</a>
  <a data-type="(o : Level) → Precategory (lsuc o) o" id="11427" href="Cat.Base.html#11135" class="Function">Sets</a> <a id="11432" href="Cat.Base.html#11432" class="Bound">o</a> <a id="11434" class="Symbol">.</a><a data-type="(r : Precategory o h) (f : r .Hom y z) (g : r .Hom x y)
(h : r .Hom w x) →
r ._∘_ f (r ._∘_ g h) ≡ r ._∘_ (r ._∘_ f g) h" id="11435" href="Cat.Base.html#3755" class="Field">assoc</a> <a id="11441" href="Cat.Base.html#11441" class="Bound">f</a> <a id="11443" href="Cat.Base.html#11443" class="Bound">g</a> <a id="11445" href="Cat.Base.html#11445" class="Bound">h</a> <a id="11447" class="Symbol">=</a> <a data-type="x ≡ x" id="11449" href="1Lab.Path.html#3591" class="Function">refl</a>
</pre>
<p>Furthermore, Sets is a univalent category, essentially by the same argument used to prove <a data-type="(P : (B₁ : Type ℓ) → A ≃ B₁ → Type ℓ&#39;) →
P A ((λ x → x) , idEquiv) → (e : A ≃ B₁) → P B₁ e" href="1Lab.Univalence.html#19819">EquivJ</a>.</p>
<pre class="Agda">  <a data-type="isCategory (Sets o)" id="11611" href="Cat.Base.html#11611" class="Function">Sets-category</a> <a id="11625" class="Symbol">:</a> <a id="11627" class="Symbol">∀</a> <a id="11629" class="Symbol">{</a><a id="11630" href="Cat.Base.html#11630" class="Bound">o</a><a id="11631" class="Symbol">}</a> <a id="11633" class="Symbol">→</a> <a data-type="Precategory o h → Type (o ⊔ h)" id="11635" href="Cat.Base.html#7394" class="Function">isCategory</a> <a id="11646" class="Symbol">(</a><a data-type="(o : Level) → Precategory (lsuc o) o" id="11647" href="Cat.Base.html#11135" class="Function">Sets</a> <a id="11652" href="Cat.Base.html#11630" class="Bound">o</a><a id="11653" class="Symbol">)</a>
  <a data-type="isCategory (Sets o)" id="11657" href="Cat.Base.html#11611" class="Function">Sets-category</a> <a id="11671" class="Symbol">{</a><a id="11672" class="Argument">o</a> <a id="11674" class="Symbol">=</a> <a id="11676" href="Cat.Base.html#11676" class="Bound">o</a><a id="11677" class="Symbol">}</a> <a id="11679" class="Symbol">{</a><a id="11680" class="Argument">A</a> <a id="11682" class="Symbol">=</a> <a id="11684" href="Cat.Base.html#11684" class="Bound">a</a><a id="11685" class="Symbol">}</a> <a id="11687" class="Symbol">.</a><a data-type="isContr A → A" id="11688" href="1Lab.HLevel.html#1400" class="Field">centre</a> <a id="11695" class="Symbol">=</a> <a id="11697" href="Cat.Base.html#11684" class="Bound">a</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="11699" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="C [ a ≅ a ]" id="11701" href="Cat.Base.html#6834" class="Function">idIso</a> <a id="11707" class="Symbol">{</a><a id="11708" class="Argument">C</a> <a id="11710" class="Symbol">=</a> <a data-type="(o : Level) → Precategory (lsuc o) o" id="11712" href="Cat.Base.html#11135" class="Function">Sets</a> <a id="11717" href="Cat.Base.html#11676" class="Bound">o</a><a id="11718" class="Symbol">}</a> <a id="11720" class="Symbol">{</a><a id="11721" class="Argument">a</a> <a id="11723" class="Symbol">=</a> <a id="11725" href="Cat.Base.html#11684" class="Bound">a</a><a id="11726" class="Symbol">}</a>
</pre>
<p>We take the centre of contraction to be the object itself, together with the identity isomorphism. Given any other object and isomorphism, we can use <span class="Agda"><a data-type="A ≃ B₁ → A ≡ B₁" href="1Lab.Univalence.html#8828" class="Function">ua</a></span> to get a path <code>a ≡ b</code>, and it’s not too hard - but quite tedious - to prove that the other isomorphism is equal to the identity isomorphism <a href="1Lab.Path.html#dependent-paths">over</a> ua.</p>
<pre class="Agda">  <a data-type="isCategory (Sets o)" id="12097" href="Cat.Base.html#11611" class="Function">Sets-category</a> <a id="12111" class="Symbol">{</a><a id="12112" class="Argument">o</a> <a id="12114" class="Symbol">=</a> <a id="12116" href="Cat.Base.html#12116" class="Bound">o</a><a id="12117" class="Symbol">}</a> <a id="12119" class="Symbol">{</a><a id="12120" class="Argument">A</a> <a id="12122" class="Symbol">=</a> <a id="12124" href="Cat.Base.html#12124" class="Bound">a</a><a id="12125" class="Symbol">}</a> <a id="12127" class="Symbol">.</a><a data-type="(r : isContr A) (x : A) → r .centre ≡ x" id="12128" href="1Lab.HLevel.html#1415" class="Field">paths</a> <a id="12134" class="Symbol">(</a><a id="12135" href="Cat.Base.html#12135" class="Bound">b</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="12137" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="12139" href="Cat.Base.html#12139" class="Bound">isiso</a><a id="12144" class="Symbol">)</a> <a id="12146" class="Symbol">=</a>
    <a data-type="(p : x .fst ≡ y .fst) → subst B₁ p (x .snd) ≡ y .snd → x ≡ y" id="12152" href="1Lab.Path.html#57584" class="Function">Σ-Path</a>
      <a id="12165" class="Symbol">(</a><a data-type="(p : x .fst ≡ y .fst) → subst B₁ p (x .snd) ≡ y .snd → x ≡ y" id="12166" href="1Lab.Path.html#57584" class="Function">Σ-Path</a> <a id="12173" class="Symbol">(</a><a data-type="A ≃ B₁ → A ≡ B₁" id="12174" href="1Lab.Univalence.html#8828" class="Function">ua</a> <a id="12177" href="Cat.Base.html#12873" class="Function">eqv</a><a id="12180" class="Symbol">)</a> <a id="12182" class="Symbol">(</a><a data-type="(n : Nat) → isProp (isHLevel A n)" id="12183" href="1Lab.HLevel.html#12488" class="Function">isProp-isHLevel</a> <a id="12199" class="Number">2</a> <a id="12201" class="Symbol">_</a> <a id="12203" class="Symbol">_))</a>
      <a id="12213" class="Symbol">(</a><a data-type="(p : x .fst ≡ y .fst) → subst B₁ p (x .snd) ≡ y .snd → x ≡ y" id="12214" href="1Lab.Path.html#57584" class="Function">Σ-Path</a> <a id="12221" class="Symbol">(λ</a> <a id="12224" href="Cat.Base.html#12224" class="Bound">i</a> <a id="12226" class="Symbol">→</a> <a id="12228" class="Symbol">(λ</a> <a id="12231" href="Cat.Base.html#12231" class="Bound">x</a> <a id="12233" class="Symbol">→</a> <a id="12235" href="1Lab.Path.html#2405" class="Primitive">transp</a> <a id="12242" class="Symbol">(λ</a> <a id="12245" href="Cat.Base.html#12245" class="Bound">i</a> <a id="12247" class="Symbol">→</a> <a id="12249" href="Cat.Base.html#12135" class="Bound">b</a> <a id="12251" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="12252" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="12255" class="Symbol">)</a> <a id="12257" href="Cat.Base.html#12224" class="Bound">i</a>
                              <a id="12289" class="Symbol">(</a><a id="12290" href="Cat.Base.html#12139" class="Bound">isiso</a> <a id="12296" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="12297" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="12301" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="12302" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="12306" class="Symbol">(</a><a id="12307" href="1Lab.Path.html#2405" class="Primitive">transp</a> <a id="12314" class="Symbol">(λ</a> <a id="12317" href="Cat.Base.html#12317" class="Bound">i</a> <a id="12319" class="Symbol">→</a> <a id="12321" href="Cat.Base.html#12124" class="Bound">a</a> <a id="12323" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="12324" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="12327" class="Symbol">)</a> <a id="12329" href="Cat.Base.html#12224" class="Bound">i</a> <a id="12331" href="Cat.Base.html#12231" class="Bound">x</a><a id="12332" class="Symbol">)))</a>
                   <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="12355" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="12357" class="Symbol">(λ</a> <a id="12360" href="Cat.Base.html#12360" class="Bound">x</a> <a id="12362" class="Symbol">→</a> <a id="12364" href="1Lab.Path.html#2405" class="Primitive">transp</a> <a id="12371" class="Symbol">(λ</a> <a id="12374" href="Cat.Base.html#12374" class="Bound">i</a> <a id="12376" class="Symbol">→</a> <a id="12378" href="Cat.Base.html#12124" class="Bound">a</a> <a id="12380" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="12381" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="12384" class="Symbol">)</a> <a id="12386" href="Cat.Base.html#12224" class="Bound">i</a>
                              <a id="12418" class="Symbol">(</a><a id="12419" href="Cat.Base.html#12139" class="Bound">isiso</a> <a id="12425" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="12426" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="12430" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="12431" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="12435" class="Symbol">(</a><a id="12436" href="1Lab.Path.html#2405" class="Primitive">transp</a> <a id="12443" class="Symbol">(λ</a> <a id="12446" href="Cat.Base.html#12446" class="Bound">i</a> <a id="12448" class="Symbol">→</a> <a id="12450" href="Cat.Base.html#12135" class="Bound">b</a> <a id="12452" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="12453" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="12456" class="Symbol">)</a> <a id="12458" href="Cat.Base.html#12224" class="Bound">i</a> <a id="12460" href="Cat.Base.html#12360" class="Bound">x</a><a id="12461" class="Symbol">))))</a>
</pre>
<p>The functions that make up the isomorphism are equal essentially by a <a data-type="(p : A ≡ B₁) (x : A) → PathP (λ i → p i) x (transport p x)" href="1Lab.Path.html#14075">transport filler</a>, and the data that proves this is an isomorphism does not matter since <span class="Agda"><a data-type="(r : Precategory o h) (x y : r .Ob) → isSet (r .Hom x y)" href="Cat.Base.html#1677" class="Field">hom-sets are sets</a></span>.</p>
<pre class="Agda">              <a id="12751" class="Symbol">(</a><a data-type="(p : x .fst ≡ y .fst) → subst B₁ p (x .snd) ≡ y .snd → x ≡ y" id="12752" href="1Lab.Path.html#57584" class="Function">Σ-Path</a> <a id="12759" class="Symbol">(</a><a data-type="(n : Nat) →
((x : A) → isHLevel (B₁ x) n) → isHLevel ((x : A) → B₁ x) n" id="12760" href="1Lab.HLevel.Retracts.html#4179" class="Function">isHLevelΠ</a> <a id="12770" class="Number">2</a> <a id="12772" class="Symbol">(λ</a> <a id="12775" href="Cat.Base.html#12775" class="Bound">_</a> <a id="12777" class="Symbol">→</a> <a id="12779" href="Cat.Base.html#12135" class="Bound">b</a> <a id="12781" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="12782" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="12785" class="Symbol">)</a> <a id="12787" class="Symbol">_</a> <a id="12789" class="Symbol">_</a> <a id="12791" class="Symbol">_</a> <a id="12793" class="Symbol">_)</a>
                      <a id="12818" class="Symbol">(</a><a data-type="(n : Nat) →
((x : A) → isHLevel (B₁ x) n) → isHLevel ((x : A) → B₁ x) n" id="12819" href="1Lab.HLevel.Retracts.html#4179" class="Function">isHLevelΠ</a> <a id="12829" class="Number">2</a> <a id="12831" class="Symbol">(λ</a> <a id="12834" href="Cat.Base.html#12834" class="Bound">_</a> <a id="12836" class="Symbol">→</a> <a id="12838" href="Cat.Base.html#12124" class="Bound">a</a> <a id="12840" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="12841" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="12844" class="Symbol">)</a> <a id="12846" class="Symbol">_</a> <a id="12848" class="Symbol">_</a> <a id="12850" class="Symbol">_</a> <a id="12852" class="Symbol">_)))</a>
    <a id="12861" class="Keyword">where</a>
      <a id="12873" href="Cat.Base.html#12873" class="Function">eqv</a> <a id="12877" class="Symbol">:</a> <a id="12879" href="Cat.Base.html#12124" class="Bound">a</a> <a id="12881" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="12882" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="12886" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="12888" href="Cat.Base.html#12135" class="Bound">b</a> <a id="12890" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="12891" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a>
      <a id="12901" href="Cat.Base.html#12873" class="Function">eqv</a> <a id="12905" class="Symbol">=</a> <a data-type="Iso A B₁ → A ≃ B₁" id="12907" href="1Lab.Equiv.html#20100" class="Function">Iso→Equiv</a> <a id="12917" class="Symbol">(</a> <a id="12919" href="Cat.Base.html#12139" class="Bound">isiso</a> <a id="12925" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="12926" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="12930" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="12931" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a>
                      <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="12957" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="(inv₁ : B₁ → A) (rinv₁ : isRightInverse inv₁ f)
(linv₁ : isLeftInverse inv₁ f) →
isIso f" id="12959" href="1Lab.Equiv.html#6064" class="InductiveConstructor">iso</a> <a id="12963" class="Symbol">(</a><a id="12964" href="Cat.Base.html#12139" class="Bound">isiso</a> <a id="12970" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="12971" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="12975" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="12976" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="12979" class="Symbol">)</a>
                          <a id="13007" class="Symbol">(</a><a data-type="f ≡ g → (x : A) → f x ≡ g x" id="13008" href="1Lab.Path.html#58047" class="Function">happly</a> <a id="13015" class="Symbol">(</a><a id="13016" href="Cat.Base.html#12139" class="Bound">isiso</a> <a id="13022" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="13023" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="13027" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="13028" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="13031" class="Symbol">))</a>
                          <a id="13060" class="Symbol">(</a><a data-type="f ≡ g → (x : A) → f x ≡ g x" id="13061" href="1Lab.Path.html#58047" class="Function">happly</a> <a id="13068" class="Symbol">(</a><a id="13069" href="Cat.Base.html#12139" class="Bound">isiso</a> <a id="13075" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="13076" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="13080" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="13081" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="13084" class="Symbol">)))</a>
</pre>
<h1 id="functors"><a href="#functors" class="header-link">Functors<span class="header-link-emoji">🔗</span></a></h1>
<pre class="Agda"><a id="13113" class="Keyword">record</a>
  <a id="Functor"></a><a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="13122" href="Cat.Base.html#13122" class="Record">Functor</a>
    <a id="13134" class="Symbol">{</a><a id="13135" href="Cat.Base.html#13135" class="Bound">o₁</a> <a id="13138" href="Cat.Base.html#13138" class="Bound">h₁</a> <a id="13141" href="Cat.Base.html#13141" class="Bound">o₂</a> <a id="13144" href="Cat.Base.html#13144" class="Bound">h₂</a><a id="13146" class="Symbol">}</a>
    <a id="13152" class="Symbol">(</a><a id="13153" href="Cat.Base.html#13153" class="Bound">C</a> <a id="13155" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="13157" href="Cat.Base.html#611" class="Record">Precategory</a> <a id="13169" href="Cat.Base.html#13135" class="Bound">o₁</a> <a id="13172" href="Cat.Base.html#13138" class="Bound">h₁</a><a id="13174" class="Symbol">)</a>
    <a id="13180" class="Symbol">(</a><a id="13181" href="Cat.Base.html#13181" class="Bound">D</a> <a id="13183" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="13185" href="Cat.Base.html#611" class="Record">Precategory</a> <a id="13197" href="Cat.Base.html#13141" class="Bound">o₂</a> <a id="13200" href="Cat.Base.html#13144" class="Bound">h₂</a><a id="13202" class="Symbol">)</a>
  <a id="13206" class="Symbol">:</a> <a id="13208" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13213" class="Symbol">(</a><a id="13214" href="Cat.Base.html#13135" class="Bound">o₁</a> <a data-type="Level → Level → Level" id="13217" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="13219" href="Cat.Base.html#13138" class="Bound">h₁</a> <a data-type="Level → Level → Level" id="13222" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="13224" href="Cat.Base.html#13141" class="Bound">o₂</a> <a data-type="Level → Level → Level" id="13227" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="13229" href="Cat.Base.html#13144" class="Bound">h₂</a><a id="13231" class="Symbol">)</a>
  <a id="13235" class="Keyword">where</a>

  <a id="13244" class="Keyword">private</a>
    <a id="13256" class="Keyword">module</a> <a id="Functor.C"></a><a id="13263" href="Cat.Base.html#13263" class="Module">C</a> <a id="13265" class="Symbol">=</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="13267" href="Cat.Base.html#611" class="Module">Precategory</a> <a id="13279" href="Cat.Base.html#13153" class="Bound">C</a>
    <a id="13285" class="Keyword">module</a> <a id="Functor.D"></a><a id="13292" href="Cat.Base.html#13292" class="Module">D</a> <a id="13294" class="Symbol">=</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="13296" href="Cat.Base.html#611" class="Module">Precategory</a> <a id="13308" href="Cat.Base.html#13181" class="Bound">D</a>
</pre>
<p>Since a category is an algebraic structure, there is a natural definition of <em>homomorphism of categories</em> defined in the same fashion as, for instance, a <em>homomorphism of groups</em>. Since this kind of morphism is ubiquitous, it gets a shorter name: <span class="Agda"><a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" href="Cat.Base.html#13122" class="Record">Functor</a></span>.</p>
<p>Alternatively, functors can be characterised as the “proof-relevant version” of a monotone map: A monotone map is a map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">F : C \to D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> which preserves the ordering relation, <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≤</mo><mi>y</mi><mo>→</mo><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>F</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x \le y \to F(x) \le F(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>.</span> Categorifying, “preserves the ordering relation” becomes a function between Hom-sets.</p>
<pre class="Agda">  <a id="13880" class="Keyword">field</a>
    <a id="Functor.F₀"></a><a data-type="Functor C D → C .Ob → Ob D" id="13890" href="Cat.Base.html#13890" class="Field">F₀</a> <a id="13893" class="Symbol">:</a> <a data-type="Precategory o h → Type o" id="13895" href="Cat.Base.html#1312" class="Function">C.Ob</a> <a id="13900" class="Symbol">→</a> <a data-type="Precategory o h → Type o" id="13902" href="Cat.Base.html#1312" class="Function">D.Ob</a>
    <a id="Functor.F₁"></a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="13911" href="Cat.Base.html#13911" class="Field">F₁</a> <a id="13914" class="Symbol">:</a> <a id="13916" class="Symbol">∀</a> <a id="13918" class="Symbol">{</a><a id="13919" href="Cat.Base.html#13919" class="Bound">x</a> <a id="13921" href="Cat.Base.html#13921" class="Bound">y</a><a id="13922" class="Symbol">}</a> <a id="13924" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="13926" href="Cat.Base.html#1329" class="Function">C.Hom</a> <a id="13932" href="Cat.Base.html#13919" class="Bound">x</a> <a id="13934" href="Cat.Base.html#13921" class="Bound">y</a> <a id="13936" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="13938" href="Cat.Base.html#1329" class="Function">D.Hom</a> <a id="13944" class="Symbol">(</a><a data-type="Functor C D → C .Ob → Ob D" id="13945" href="Cat.Base.html#13890" class="Field">F₀</a> <a id="13948" href="Cat.Base.html#13919" class="Bound">x</a><a id="13949" class="Symbol">)</a> <a id="13951" class="Symbol">(</a><a data-type="Functor C D → C .Ob → Ob D" id="13952" href="Cat.Base.html#13890" class="Field">F₀</a> <a id="13955" href="Cat.Base.html#13921" class="Bound">y</a><a id="13956" class="Symbol">)</a>
</pre>
<p>A Functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">F : C \to D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> consists of a <span class="Agda"><a data-type="Functor C D → C .Ob → Ob D" href="Cat.Base.html#13890" class="Field">function between the object sets</a></span> - <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mn>0</mn></msub><mo>:</mo><mrow><mi mathvariant="normal">O</mi><mi mathvariant="normal">b</mi></mrow><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo><mo>→</mo><mrow><mi mathvariant="normal">O</mi><mi mathvariant="normal">b</mi></mrow><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F_0 : \mathrm{Ob}(C) \to \mathrm{Ob}(D)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">Ob</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">Ob</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mclose">)</span></span></span></span>,</span> and a <span class="Agda"><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" href="Cat.Base.html#13911" class="Field">function between Hom-sets</a></span> - which takes <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>x</mi><mo>→</mo><mi>y</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">f : x \to y \in C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> to <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>:</mo><msub><mi>F</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>→</mo><msub><mi>F</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">F_1(f) : F_0(x) \to F_0(y) \in D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>.</span></p>
<pre class="Agda">  <a id="14235" class="Keyword">field</a>
    <a id="Functor.F-id"></a><a data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" id="14245" href="Cat.Base.html#14245" class="Field">F-id</a> <a id="14250" class="Symbol">:</a> <a id="14252" class="Symbol">∀</a> <a id="14254" class="Symbol">{</a><a id="14255" href="Cat.Base.html#14255" class="Bound">x</a><a id="14256" class="Symbol">}</a> <a id="14258" class="Symbol">→</a> <a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="14260" href="Cat.Base.html#13911" class="Field">F₁</a> <a id="14263" class="Symbol">(</a><a data-type="(r : Precategory o h) → r .Hom x x" id="14264" href="Cat.Base.html#2868" class="Function">C.id</a> <a id="14269" class="Symbol">{</a><a id="14270" href="Cat.Base.html#14255" class="Bound">x</a><a id="14271" class="Symbol">})</a> <a data-type="A → A → Type ℓ" id="14274" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="14276" href="Cat.Base.html#2868" class="Function">D.id</a>
    <a id="Functor.F-∘"></a><a data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" id="14285" href="Cat.Base.html#14285" class="Field">F-∘</a> <a id="14289" class="Symbol">:</a> <a id="14291" class="Symbol">∀</a> <a id="14293" class="Symbol">{</a><a id="14294" href="Cat.Base.html#14294" class="Bound">x</a> <a id="14296" href="Cat.Base.html#14296" class="Bound">y</a> <a id="14298" href="Cat.Base.html#14298" class="Bound">z</a><a id="14299" class="Symbol">}</a> <a id="14301" class="Symbol">(</a><a id="14302" href="Cat.Base.html#14302" class="Bound">f</a> <a id="14304" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="14306" href="Cat.Base.html#1329" class="Function">C.Hom</a> <a id="14312" href="Cat.Base.html#14296" class="Bound">y</a> <a id="14314" href="Cat.Base.html#14298" class="Bound">z</a><a id="14315" class="Symbol">)</a> <a id="14317" class="Symbol">(</a><a id="14318" href="Cat.Base.html#14318" class="Bound">g</a> <a id="14320" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="14322" href="Cat.Base.html#1329" class="Function">C.Hom</a> <a id="14328" href="Cat.Base.html#14294" class="Bound">x</a> <a id="14330" href="Cat.Base.html#14296" class="Bound">y</a><a id="14331" class="Symbol">)</a>
        <a id="14341" class="Symbol">→</a> <a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="14343" href="Cat.Base.html#13911" class="Field">F₁</a> <a id="14346" class="Symbol">(</a><a id="14347" href="Cat.Base.html#14302" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="14349" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a id="14353" href="Cat.Base.html#14318" class="Bound">g</a><a id="14354" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="14356" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="14358" href="Cat.Base.html#13911" class="Field">F₁</a> <a id="14361" href="Cat.Base.html#14302" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="14363" href="Cat.Base.html#2898" class="Function Operator">D.∘</a> <a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="14367" href="Cat.Base.html#13911" class="Field">F₁</a> <a id="14370" href="Cat.Base.html#14318" class="Bound">g</a>
</pre>
<p>Furthermore, the morphism mapping <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">F_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> must be homomorphic: Identity morphisms are taken to identity morphisms (<span class="Agda"><a data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" href="Cat.Base.html#14245" class="Field">F-id</a></span>) and compositions are taken to compositions (<span class="Agda"><a data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" href="Cat.Base.html#14285" class="Field">F-∘</a></span>).</p>
<!--
<pre class="Agda">  <a id="14576" class="Comment">-- Alias for F₀ for use in Functor record modules.</a>
  <a id="Functor.₀"></a><a id="14629" href="Cat.Base.html#14629" class="Function">₀</a> <a id="14631" class="Symbol">:</a> <a id="14633" href="Cat.Base.html#1312" class="Function">C.Ob</a> <a id="14638" class="Symbol">→</a> <a id="14640" href="Cat.Base.html#1312" class="Function">D.Ob</a>
  <a id="14647" href="Cat.Base.html#14629" class="Function">₀</a> <a id="14649" class="Symbol">=</a> <a id="14651" href="Cat.Base.html#13890" class="Field">F₀</a>

  <a id="14657" class="Comment">-- Alias for F₁ for use in Functor record modules.</a>
  <a id="Functor.₁"></a><a id="14710" href="Cat.Base.html#14710" class="Function">₁</a> <a id="14712" class="Symbol">:</a> <a id="14714" class="Symbol">∀</a> <a id="14716" class="Symbol">{</a><a id="14717" href="Cat.Base.html#14717" class="Bound">x</a> <a id="14719" href="Cat.Base.html#14719" class="Bound">y</a><a id="14720" class="Symbol">}</a> <a id="14722" class="Symbol">→</a> <a id="14724" href="Cat.Base.html#1329" class="Function">C.Hom</a> <a id="14730" href="Cat.Base.html#14717" class="Bound">x</a> <a id="14732" href="Cat.Base.html#14719" class="Bound">y</a> <a id="14734" class="Symbol">→</a> <a id="14736" href="Cat.Base.html#1329" class="Function">D.Hom</a> <a id="14742" class="Symbol">(</a><a id="14743" href="Cat.Base.html#13890" class="Field">F₀</a> <a id="14746" href="Cat.Base.html#14717" class="Bound">x</a><a id="14747" class="Symbol">)</a> <a id="14749" class="Symbol">(</a><a id="14750" href="Cat.Base.html#13890" class="Field">F₀</a> <a id="14753" href="Cat.Base.html#14719" class="Bound">y</a><a id="14754" class="Symbol">)</a>
  <a id="14758" href="Cat.Base.html#14710" class="Function">₁</a> <a id="14760" class="Symbol">=</a> <a id="14762" href="Cat.Base.html#13911" class="Field">F₁</a>
</pre>-->
<p>Functors also have duals: The opposite of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">F : C \to D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> is <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>:</mo><msup><mi>C</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>→</mo><msup><mi>D</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding="application/x-tex">F^{op} : C^{op} \to D^{op}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span></span></span></span>.</span></p>
<pre class="Agda">  <a id="Functor.op"></a><a data-type="(r : Functor C D) → Functor (C ^op) (D ^op)" id="14874" href="Cat.Base.html#14874" class="Function">op</a> <a id="14877" class="Symbol">:</a> <a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="14879" href="Cat.Base.html#13122" class="Record">Functor</a> <a id="14887" class="Symbol">(</a><a id="14888" href="Cat.Base.html#13153" class="Bound">C</a> <a data-type="Precategory o₁ h₁ → Precategory o₁ h₁" id="14890" href="Cat.Base.html#4252" class="Function Operator">^op</a><a id="14893" class="Symbol">)</a> <a id="14895" class="Symbol">(</a><a id="14896" href="Cat.Base.html#13181" class="Bound">D</a> <a data-type="Precategory o₁ h₁ → Precategory o₁ h₁" id="14898" href="Cat.Base.html#4252" class="Function Operator">^op</a><a id="14901" class="Symbol">)</a>
  <a data-type="Functor C D → C .Ob → Ob D" id="14905" href="Cat.Base.html#13890" class="Field">F₀</a> <a data-type="(r : Functor C D) → Functor (C ^op) (D ^op)" id="14908" href="Cat.Base.html#14874" class="Function">op</a>      <a id="14916" class="Symbol">=</a> <a data-type="Functor C D → C .Ob → Ob D" id="14918" href="Cat.Base.html#13890" class="Field">F₀</a>
  <a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="14923" href="Cat.Base.html#13911" class="Field">F₁</a> <a data-type="(r : Functor C D) → Functor (C ^op) (D ^op)" id="14926" href="Cat.Base.html#14874" class="Function">op</a>      <a id="14934" class="Symbol">=</a> <a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="14936" href="Cat.Base.html#13911" class="Field">F₁</a>
  <a data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" id="14941" href="Cat.Base.html#14245" class="Field">F-id</a> <a data-type="(r : Functor C D) → Functor (C ^op) (D ^op)" id="14946" href="Cat.Base.html#14874" class="Function">op</a>    <a id="14952" class="Symbol">=</a> <a data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" id="14954" href="Cat.Base.html#14245" class="Field">F-id</a>
  <a data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" id="14961" href="Cat.Base.html#14285" class="Field">F-∘</a> <a data-type="(r : Functor C D) → Functor (C ^op) (D ^op)" id="14965" href="Cat.Base.html#14874" class="Function">op</a> <a id="14968" href="Cat.Base.html#14968" class="Bound">f</a> <a id="14970" href="Cat.Base.html#14970" class="Bound">g</a> <a id="14972" class="Symbol">=</a> <a data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" id="14974" href="Cat.Base.html#14285" class="Field">F-∘</a> <a id="14978" href="Cat.Base.html#14970" class="Bound">g</a> <a id="14980" href="Cat.Base.html#14968" class="Bound">f</a>
</pre>
<h2 id="composition"><a href="#composition" class="header-link">Composition<span class="header-link-emoji">🔗</span></a></h2>
<pre class="Agda"><a id="_F∘_"></a><a data-type="Functor D E → Functor C D → Functor C E" id="15011" href="Cat.Base.html#15011" class="Function Operator">_F∘_</a> <a id="15016" class="Symbol">:</a> <a id="15018" class="Symbol">∀</a> <a id="15020" class="Symbol">{</a><a id="15021" href="Cat.Base.html#15021" class="Bound">o₁</a> <a id="15024" href="Cat.Base.html#15024" class="Bound">h₁</a> <a id="15027" href="Cat.Base.html#15027" class="Bound">o₂</a> <a id="15030" href="Cat.Base.html#15030" class="Bound">h₂</a> <a id="15033" href="Cat.Base.html#15033" class="Bound">o₃</a> <a id="15036" href="Cat.Base.html#15036" class="Bound">h₃</a><a id="15038" class="Symbol">}</a>
       <a id="15047" class="Symbol">{</a><a id="15048" href="Cat.Base.html#15048" class="Bound">C</a> <a id="15050" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="15052" href="Cat.Base.html#611" class="Record">Precategory</a> <a id="15064" href="Cat.Base.html#15021" class="Bound">o₁</a> <a id="15067" href="Cat.Base.html#15024" class="Bound">h₁</a><a id="15069" class="Symbol">}</a> <a id="15071" class="Symbol">{</a><a id="15072" href="Cat.Base.html#15072" class="Bound">D</a> <a id="15074" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="15076" href="Cat.Base.html#611" class="Record">Precategory</a> <a id="15088" href="Cat.Base.html#15027" class="Bound">o₂</a> <a id="15091" href="Cat.Base.html#15030" class="Bound">h₂</a><a id="15093" class="Symbol">}</a> <a id="15095" class="Symbol">{</a><a id="15096" href="Cat.Base.html#15096" class="Bound">E</a> <a id="15098" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="15100" href="Cat.Base.html#611" class="Record">Precategory</a> <a id="15112" href="Cat.Base.html#15033" class="Bound">o₃</a> <a id="15115" href="Cat.Base.html#15036" class="Bound">h₃</a><a id="15117" class="Symbol">}</a>
     <a id="15124" class="Symbol">→</a> <a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="15126" href="Cat.Base.html#13122" class="Record">Functor</a> <a id="15134" href="Cat.Base.html#15072" class="Bound">D</a> <a id="15136" href="Cat.Base.html#15096" class="Bound">E</a> <a id="15138" class="Symbol">→</a> <a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="15140" href="Cat.Base.html#13122" class="Record">Functor</a> <a id="15148" href="Cat.Base.html#15048" class="Bound">C</a> <a id="15150" href="Cat.Base.html#15072" class="Bound">D</a> <a id="15152" class="Symbol">→</a> <a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="15154" href="Cat.Base.html#13122" class="Record">Functor</a> <a id="15162" href="Cat.Base.html#15048" class="Bound">C</a> <a id="15164" href="Cat.Base.html#15096" class="Bound">E</a>
</pre>
<p>Functors, being made up of functions, can themselves be composed. The object mapping of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>F</mi><mo>∘</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(F \circ G)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mclose">)</span></span></span></span> is given by <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mn>0</mn></msub><mo>∘</mo><msub><mi>G</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">F_0 \circ G_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,</span> and similarly for the morphism mapping. Alternatively, composition of functors is a categorification of the fact that monotone maps compose.</p>
<pre class="Agda"><a data-type="Functor D E → Functor C D → Functor C E" id="15452" href="Cat.Base.html#15011" class="Function Operator">_F∘_</a> <a id="15457" class="Symbol">{</a><a id="15458" class="Argument">C</a> <a id="15460" class="Symbol">=</a> <a id="15462" href="Cat.Base.html#15462" class="Bound">C</a><a id="15463" class="Symbol">}</a> <a id="15465" class="Symbol">{</a><a id="15466" href="Cat.Base.html#15466" class="Bound">D</a><a id="15467" class="Symbol">}</a> <a id="15469" class="Symbol">{</a><a id="15470" href="Cat.Base.html#15470" class="Bound">E</a><a id="15471" class="Symbol">}</a> <a id="15473" href="Cat.Base.html#15473" class="Bound">F</a> <a id="15475" href="Cat.Base.html#15475" class="Bound">G</a> <a id="15477" class="Symbol">=</a> <a id="15479" class="Keyword">record</a> <a id="15486" class="Symbol">{</a> <a data-type="Functor C D → C .Ob → Ob D" id="15488" href="Cat.Base.html#13890" class="Field">F₀</a> <a id="15491" class="Symbol">=</a> <a id="15493" href="Cat.Base.html#15685" class="Function">F₀</a> <a id="15496" class="Symbol">;</a> <a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="15498" href="Cat.Base.html#13911" class="Field">F₁</a> <a id="15501" class="Symbol">=</a> <a id="15503" href="Cat.Base.html#15732" class="Function">F₁</a> <a id="15506" class="Symbol">;</a> <a data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" id="15508" href="Cat.Base.html#14245" class="Field">F-id</a> <a id="15513" class="Symbol">=</a> <a id="15515" href="Cat.Base.html#15955" class="Function">F-id</a> <a id="15520" class="Symbol">;</a> <a data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" id="15522" href="Cat.Base.html#14285" class="Field">F-∘</a> <a id="15526" class="Symbol">=</a> <a id="15528" href="Cat.Base.html#16132" class="Function">F-∘</a> <a id="15532" class="Symbol">}</a>
  <a id="15536" class="Keyword">where</a>
    <a id="15546" class="Keyword">module</a> <a id="15553" href="Cat.Base.html#15553" class="Module">C</a> <a id="15555" class="Symbol">=</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="15557" href="Cat.Base.html#611" class="Module">Precategory</a> <a id="15569" href="Cat.Base.html#15462" class="Bound">C</a>
    <a id="15575" class="Keyword">module</a> <a id="15582" href="Cat.Base.html#15582" class="Module">D</a> <a id="15584" class="Symbol">=</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="15586" href="Cat.Base.html#611" class="Module">Precategory</a> <a id="15598" href="Cat.Base.html#15466" class="Bound">D</a>
    <a id="15604" class="Keyword">module</a> <a id="15611" href="Cat.Base.html#15611" class="Module">E</a> <a id="15613" class="Symbol">=</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="15615" href="Cat.Base.html#611" class="Module">Precategory</a> <a id="15627" href="Cat.Base.html#15470" class="Bound">E</a>

    <a id="15634" class="Keyword">module</a> <a id="15641" href="Cat.Base.html#15641" class="Module">F</a> <a id="15643" class="Symbol">=</a> <a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="15645" href="Cat.Base.html#13122" class="Module">Functor</a> <a id="15653" href="Cat.Base.html#15473" class="Bound">F</a>
    <a id="15659" class="Keyword">module</a> <a id="15666" href="Cat.Base.html#15666" class="Module">G</a> <a id="15668" class="Symbol">=</a> <a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="15670" href="Cat.Base.html#13122" class="Module">Functor</a> <a id="15678" href="Cat.Base.html#15475" class="Bound">G</a>

    <a id="15685" href="Cat.Base.html#15685" class="Function">F₀</a> <a id="15688" class="Symbol">:</a> <a data-type="Precategory o h → Type o" id="15690" href="Cat.Base.html#1312" class="Function">C.Ob</a> <a id="15695" class="Symbol">→</a> <a data-type="Precategory o h → Type o" id="15697" href="Cat.Base.html#1312" class="Function">E.Ob</a>
    <a id="15706" href="Cat.Base.html#15685" class="Function">F₀</a> <a id="15709" href="Cat.Base.html#15709" class="Bound">x</a> <a id="15711" class="Symbol">=</a> <a data-type="Functor C D → C .Ob → Ob D" id="15713" href="Cat.Base.html#13890" class="Function">F.F₀</a> <a id="15718" class="Symbol">(</a><a data-type="Functor C D → C .Ob → Ob D" id="15719" href="Cat.Base.html#13890" class="Field">G.F₀</a> <a id="15724" href="Cat.Base.html#15709" class="Bound">x</a><a id="15725" class="Symbol">)</a>

    <a id="15732" href="Cat.Base.html#15732" class="Function">F₁</a> <a id="15735" class="Symbol">:</a> <a id="15737" class="Symbol">{</a><a id="15738" href="Cat.Base.html#15738" class="Bound">x</a> <a id="15740" href="Cat.Base.html#15740" class="Bound">y</a> <a id="15742" class="Symbol">:</a> <a data-type="Precategory o h → Type o" id="15744" href="Cat.Base.html#1312" class="Function">C.Ob</a><a id="15748" class="Symbol">}</a> <a id="15750" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="15752" href="Cat.Base.html#1329" class="Function">C.Hom</a> <a id="15758" href="Cat.Base.html#15738" class="Bound">x</a> <a id="15760" href="Cat.Base.html#15740" class="Bound">y</a> <a id="15762" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="15764" href="Cat.Base.html#1329" class="Function">E.Hom</a> <a id="15770" class="Symbol">(</a><a id="15771" href="Cat.Base.html#15685" class="Function">F₀</a> <a id="15774" href="Cat.Base.html#15738" class="Bound">x</a><a id="15775" class="Symbol">)</a> <a id="15777" class="Symbol">(</a><a id="15778" href="Cat.Base.html#15685" class="Function">F₀</a> <a id="15781" href="Cat.Base.html#15740" class="Bound">y</a><a id="15782" class="Symbol">)</a>
    <a id="15788" href="Cat.Base.html#15732" class="Function">F₁</a> <a id="15791" href="Cat.Base.html#15791" class="Bound">f</a> <a id="15793" class="Symbol">=</a> <a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="15795" href="Cat.Base.html#13911" class="Function">F.F₁</a> <a id="15800" class="Symbol">(</a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="15801" href="Cat.Base.html#13911" class="Field">G.F₁</a> <a id="15806" href="Cat.Base.html#15791" class="Bound">f</a><a id="15807" class="Symbol">)</a>
</pre>
<p>To verify that the result is functorial, equational reasoning is employed, using the witnesses that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> are functorial.</p>
<pre class="Agda">    <a id="15955" href="Cat.Base.html#15955" class="Function">F-id</a> <a id="15960" class="Symbol">:</a> <a id="15962" class="Symbol">{</a><a id="15963" href="Cat.Base.html#15963" class="Bound">x</a> <a id="15965" class="Symbol">:</a> <a data-type="Precategory o h → Type o" id="15967" href="Cat.Base.html#1312" class="Function">C.Ob</a><a id="15971" class="Symbol">}</a> <a id="15973" class="Symbol">→</a> <a id="15975" href="Cat.Base.html#15732" class="Function">F₁</a> <a id="15978" class="Symbol">(</a><a data-type="(r : Precategory o h) → r .Hom x x" id="15979" href="Cat.Base.html#2868" class="Function">C.id</a> <a id="15984" class="Symbol">{</a><a id="15985" href="Cat.Base.html#15963" class="Bound">x</a><a id="15986" class="Symbol">})</a> <a data-type="A → A → Type ℓ" id="15989" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="15991" href="Cat.Base.html#2868" class="Function">E.id</a> <a id="15996" class="Symbol">{</a><a id="15997" href="Cat.Base.html#15685" class="Function">F₀</a> <a id="16000" href="Cat.Base.html#15963" class="Bound">x</a><a id="16001" class="Symbol">}</a>
    <a id="16007" href="Cat.Base.html#15955" class="Function">F-id</a> <a id="16012" class="Symbol">{</a><a id="16013" href="Cat.Base.html#16013" class="Bound">x</a><a id="16014" class="Symbol">}</a> <a id="16016" class="Symbol">=</a>
        <a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="16026" href="Cat.Base.html#13911" class="Function">F.F₁</a> <a id="16031" class="Symbol">(</a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="16032" href="Cat.Base.html#13911" class="Field">G.F₁</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="16037" href="Cat.Base.html#2868" class="Function">C.id</a><a id="16041" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="16043" href="1Lab.Path.html#46757" class="Function Operator">≡⟨</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="16046" href="1Lab.Path.html#20807" class="Function">ap</a> <a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="16049" href="Cat.Base.html#13911" class="Function">F.F₁</a> <a data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" id="16054" href="Cat.Base.html#14245" class="Field">G.F-id</a> <a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="16061" href="1Lab.Path.html#46757" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡</span></span>
        <a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="16071" href="Cat.Base.html#13911" class="Function">F.F₁</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="16076" href="Cat.Base.html#2868" class="Function">D.id</a>        <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="16088" href="1Lab.Path.html#46757" class="Function Operator">≡⟨</a> <a data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" id="16091" href="Cat.Base.html#14245" class="Function">F.F-id</a> <a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="16098" href="1Lab.Path.html#46757" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡</span></span>
        <a data-type="(r : Precategory o h) → r .Hom x x" id="16108" href="Cat.Base.html#2868" class="Function">E.id</a>             <a data-type="(x : A) → x ≡ x" id="16125" href="1Lab.Path.html#46923" class="Function Operator">∎</a>

    <a id="16132" href="Cat.Base.html#16132" class="Function">F-∘</a> <a id="16136" class="Symbol">:</a> <a id="16138" class="Symbol">{</a><a id="16139" href="Cat.Base.html#16139" class="Bound">x</a> <a id="16141" href="Cat.Base.html#16141" class="Bound">y</a> <a id="16143" href="Cat.Base.html#16143" class="Bound">z</a> <a id="16145" class="Symbol">:</a> <a data-type="Precategory o h → Type o" id="16147" href="Cat.Base.html#1312" class="Function">C.Ob</a><a id="16151" class="Symbol">}</a> <a id="16153" class="Symbol">(</a><a id="16154" href="Cat.Base.html#16154" class="Bound">f</a> <a id="16156" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="16158" href="Cat.Base.html#1329" class="Function">C.Hom</a> <a id="16164" href="Cat.Base.html#16141" class="Bound">y</a> <a id="16166" href="Cat.Base.html#16143" class="Bound">z</a><a id="16167" class="Symbol">)</a> <a id="16169" class="Symbol">(</a><a id="16170" href="Cat.Base.html#16170" class="Bound">g</a> <a id="16172" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="16174" href="Cat.Base.html#1329" class="Function">C.Hom</a> <a id="16180" href="Cat.Base.html#16139" class="Bound">x</a> <a id="16182" href="Cat.Base.html#16141" class="Bound">y</a><a id="16183" class="Symbol">)</a>
        <a id="16193" class="Symbol">→</a> <a id="16195" href="Cat.Base.html#15732" class="Function">F₁</a> <a id="16198" class="Symbol">(</a><a id="16199" href="Cat.Base.html#16154" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="16201" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a id="16205" href="Cat.Base.html#16170" class="Bound">g</a><a id="16206" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="16208" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="16210" class="Symbol">(</a><a id="16211" href="Cat.Base.html#15732" class="Function">F₁</a> <a id="16214" href="Cat.Base.html#16154" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="16216" href="Cat.Base.html#2898" class="Function Operator">E.∘</a> <a id="16220" href="Cat.Base.html#15732" class="Function">F₁</a> <a id="16223" href="Cat.Base.html#16170" class="Bound">g</a><a id="16224" class="Symbol">)</a>
    <a id="16230" href="Cat.Base.html#16132" class="Function">F-∘</a> <a id="16234" href="Cat.Base.html#16234" class="Bound">f</a> <a id="16236" href="Cat.Base.html#16236" class="Bound">g</a> <a id="16238" class="Symbol">=</a>
        <a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="16248" href="Cat.Base.html#13911" class="Function">F.F₁</a> <a id="16253" class="Symbol">(</a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="16254" href="Cat.Base.html#13911" class="Field">G.F₁</a> <a id="16259" class="Symbol">(</a><a id="16260" href="Cat.Base.html#16234" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="16262" href="Cat.Base.html#2898" class="Function Operator">C.∘</a> <a id="16266" href="Cat.Base.html#16236" class="Bound">g</a><a id="16267" class="Symbol">))</a>     <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="16274" href="1Lab.Path.html#46757" class="Function Operator">≡⟨</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="16277" href="1Lab.Path.html#20807" class="Function">ap</a> <a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="16280" href="Cat.Base.html#13911" class="Function">F.F₁</a> <a id="16285" class="Symbol">(</a><a data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" id="16286" href="Cat.Base.html#14285" class="Field">G.F-∘</a> <a id="16292" href="Cat.Base.html#16234" class="Bound">f</a> <a id="16294" href="Cat.Base.html#16236" class="Bound">g</a><a id="16295" class="Symbol">)</a> <a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="16297" href="1Lab.Path.html#46757" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡</span></span>
        <a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="16307" href="Cat.Base.html#13911" class="Function">F.F₁</a> <a id="16312" class="Symbol">(</a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="16313" href="Cat.Base.html#13911" class="Field">G.F₁</a> <a id="16318" href="Cat.Base.html#16234" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="16320" href="Cat.Base.html#2898" class="Function Operator">D.∘</a> <a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="16324" href="Cat.Base.html#13911" class="Field">G.F₁</a> <a id="16329" href="Cat.Base.html#16236" class="Bound">g</a><a id="16330" class="Symbol">)</a>  <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="16333" href="1Lab.Path.html#46757" class="Function Operator">≡⟨</a> <a data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" id="16336" href="Cat.Base.html#14285" class="Function">F.F-∘</a> <a id="16342" class="Symbol">_</a> <a id="16344" class="Symbol">_</a> <a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="16346" href="1Lab.Path.html#46757" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡</span></span>
        <a id="16356" href="Cat.Base.html#15732" class="Function">F₁</a> <a id="16359" href="Cat.Base.html#16234" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="16361" href="Cat.Base.html#2898" class="Function Operator">E.∘</a> <a id="16365" href="Cat.Base.html#15732" class="Function">F₁</a> <a id="16368" href="Cat.Base.html#16236" class="Bound">g</a>             <a data-type="(x : A) → x ≡ x" id="16382" href="1Lab.Path.html#46923" class="Function Operator">∎</a>
</pre>
<!--
The identity function (twice) is a functor $C \to C$. These composition
and identities assemble into a category, where the objects are
categories: [Cat](agda://Cat.Instances.Cat.Base#Cat). The
construction of Cat is not in this module for performance reasons.
-->
<pre class="Agda"><a id="Id"></a><a data-type="Functor C C" id="16667" href="Cat.Base.html#16667" class="Function">Id</a> <a id="16670" class="Symbol">:</a> <a id="16672" class="Symbol">∀</a> <a id="16674" class="Symbol">{</a><a id="16675" href="Cat.Base.html#16675" class="Bound">o₁</a> <a id="16678" href="Cat.Base.html#16678" class="Bound">h₁</a><a id="16680" class="Symbol">}</a> <a id="16682" class="Symbol">{</a><a id="16683" href="Cat.Base.html#16683" class="Bound">C</a> <a id="16685" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="16687" href="Cat.Base.html#611" class="Record">Precategory</a> <a id="16699" href="Cat.Base.html#16675" class="Bound">o₁</a> <a id="16702" href="Cat.Base.html#16678" class="Bound">h₁</a><a id="16704" class="Symbol">}</a> <a id="16706" class="Symbol">→</a> <a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="16708" href="Cat.Base.html#13122" class="Record">Functor</a> <a id="16716" href="Cat.Base.html#16683" class="Bound">C</a> <a id="16718" href="Cat.Base.html#16683" class="Bound">C</a>
<a data-type="Functor C D → C .Ob → Ob D" id="16720" href="Cat.Base.html#13890" class="Field">Functor.F₀</a> <a data-type="Functor C C" id="16731" href="Cat.Base.html#16667" class="Function">Id</a> <a id="16734" href="Cat.Base.html#16734" class="Bound">x</a> <a id="16736" class="Symbol">=</a> <a id="16738" href="Cat.Base.html#16734" class="Bound">x</a>
<a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="16740" href="Cat.Base.html#13911" class="Field">Functor.F₁</a> <a data-type="Functor C C" id="16751" href="Cat.Base.html#16667" class="Function">Id</a> <a id="16754" href="Cat.Base.html#16754" class="Bound">f</a> <a id="16756" class="Symbol">=</a> <a id="16758" href="Cat.Base.html#16754" class="Bound">f</a>
<a data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" id="16760" href="Cat.Base.html#14245" class="Field">Functor.F-id</a> <a data-type="Functor C C" id="16773" href="Cat.Base.html#16667" class="Function">Id</a> <a id="16776" class="Symbol">=</a> <a data-type="x ≡ x" id="16778" href="1Lab.Path.html#3591" class="Function">refl</a>
<a data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" id="16783" href="Cat.Base.html#14285" class="Field">Functor.F-∘</a> <a data-type="Functor C C" id="16795" href="Cat.Base.html#16667" class="Function">Id</a> <a id="16798" href="Cat.Base.html#16798" class="Bound">f</a> <a id="16800" href="Cat.Base.html#16800" class="Bound">g</a> <a id="16802" class="Symbol">=</a> <a data-type="x ≡ x" id="16804" href="1Lab.Path.html#3591" class="Function">refl</a>
</pre>
<h1 id="natural-transformations"><a href="#natural-transformations" class="header-link">Natural Transformations<span class="header-link-emoji">🔗</span></a></h1>
<p>Another common theme in category theory is that roughly <em>every</em> concept can be considered the objects of a category. This is the case for functors, as well! The functors between <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span> assemble into a category, notated <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>C</mi><mo separator="true">,</mo><mi>D</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[C, D]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mclose">]</span></span></span></span> - the <a href="Cat.Instances.Functor.html">functor category</a> between <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> and <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span></span></span></span>.</span></p>
<pre class="Agda"><a id="17179" class="Keyword">record</a> <a id="_=&gt;_"></a><a data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" id="17186" href="Cat.Base.html#17186" class="Record Operator">_=&gt;_</a> <a id="17191" class="Symbol">{</a><a id="17192" href="Cat.Base.html#17192" class="Bound">o₁</a> <a id="17195" href="Cat.Base.html#17195" class="Bound">h₁</a> <a id="17198" href="Cat.Base.html#17198" class="Bound">o₂</a> <a id="17201" href="Cat.Base.html#17201" class="Bound">h₂</a><a id="17203" class="Symbol">}</a>
            <a id="17217" class="Symbol">{</a><a id="17218" href="Cat.Base.html#17218" class="Bound">C</a> <a id="17220" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="17222" href="Cat.Base.html#611" class="Record">Precategory</a> <a id="17234" href="Cat.Base.html#17192" class="Bound">o₁</a> <a id="17237" href="Cat.Base.html#17195" class="Bound">h₁</a><a id="17239" class="Symbol">}</a>
            <a id="17253" class="Symbol">{</a><a id="17254" href="Cat.Base.html#17254" class="Bound">D</a> <a id="17256" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="17258" href="Cat.Base.html#611" class="Record">Precategory</a> <a id="17270" href="Cat.Base.html#17198" class="Bound">o₂</a> <a id="17273" href="Cat.Base.html#17201" class="Bound">h₂</a><a id="17275" class="Symbol">}</a> 
            <a id="17290" class="Symbol">(</a><a id="17291" href="Cat.Base.html#17291" class="Bound">F</a> <a id="17293" href="Cat.Base.html#17293" class="Bound">G</a> <a id="17295" class="Symbol">:</a> <a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="17297" href="Cat.Base.html#13122" class="Record">Functor</a> <a id="17305" href="Cat.Base.html#17218" class="Bound">C</a> <a id="17307" href="Cat.Base.html#17254" class="Bound">D</a><a id="17308" class="Symbol">)</a>
      <a id="17316" class="Symbol">:</a> <a id="17318" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="17323" class="Symbol">(</a><a id="17324" href="Cat.Base.html#17192" class="Bound">o₁</a> <a data-type="Level → Level → Level" id="17327" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="17329" href="Cat.Base.html#17195" class="Bound">h₁</a> <a data-type="Level → Level → Level" id="17332" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="17334" href="Cat.Base.html#17201" class="Bound">h₂</a><a id="17336" class="Symbol">)</a>
  <a id="17340" class="Keyword">where</a>
  <a id="17348" class="Keyword">constructor</a> <a id="NT"></a><a data-type="(η : (x : C .Ob) → D .Hom (₀ F x) (₀ G x))
(is-natural
 : (x y : C .Ob) (f : C .Hom x y) →
   D ._∘_ (η y) (₁ F f) ≡ D ._∘_ (₁ G f) (η x)) →
F =&gt; G" id="17360" href="Cat.Base.html#17360" class="InductiveConstructor">NT</a>
</pre>
<p>The morphisms between functors are called <strong>natural transformations</strong>. A natural transformation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>⇒</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">F \Rightarrow G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> can be thought of as a way of turning <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>s</span> into <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>s</span> that doesn’t involve any “arbitrary choices”.</p>
<pre class="Agda">  <a id="17598" class="Keyword">private</a>
    <a id="17610" class="Keyword">module</a> <a id="_=&gt;_.F"></a><a id="17617" href="Cat.Base.html#17617" class="Module">F</a> <a id="17619" class="Symbol">=</a> <a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="17621" href="Cat.Base.html#13122" class="Module">Functor</a> <a id="17629" href="Cat.Base.html#17291" class="Bound">F</a>
    <a id="17635" class="Keyword">module</a> <a id="_=&gt;_.G"></a><a id="17642" href="Cat.Base.html#17642" class="Module">G</a> <a id="17644" class="Symbol">=</a> <a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="17646" href="Cat.Base.html#13122" class="Module">Functor</a> <a id="17654" href="Cat.Base.html#17293" class="Bound">G</a>
    <a id="17660" class="Keyword">module</a> <a id="_=&gt;_.D"></a><a id="17667" href="Cat.Base.html#17667" class="Module">D</a> <a id="17669" class="Symbol">=</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="17671" href="Cat.Base.html#611" class="Module">Precategory</a> <a id="17683" href="Cat.Base.html#17254" class="Bound">D</a>
    <a id="17689" class="Keyword">module</a> <a id="_=&gt;_.C"></a><a id="17696" href="Cat.Base.html#17696" class="Module">C</a> <a id="17698" class="Symbol">=</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="17700" href="Cat.Base.html#611" class="Module">Precategory</a> <a id="17712" href="Cat.Base.html#17218" class="Bound">C</a>

  <a id="17717" class="Keyword">field</a>
    <a id="_=&gt;_.η"></a><a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" id="17727" href="Cat.Base.html#17727" class="Field">η</a> <a id="17729" class="Symbol">:</a> <a id="17731" class="Symbol">(</a><a id="17732" href="Cat.Base.html#17732" class="Bound">x</a> <a id="17734" class="Symbol">:</a> <a id="17736" class="Symbol">_)</a> <a id="17739" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="17741" href="Cat.Base.html#1329" class="Function">D.Hom</a> <a id="17747" class="Symbol">(</a><a data-type="(r : Functor C D) → C .Ob → D .Ob" id="17748" href="Cat.Base.html#14629" class="Function">F.₀</a> <a id="17752" href="Cat.Base.html#17732" class="Bound">x</a><a id="17753" class="Symbol">)</a> <a id="17755" class="Symbol">(</a><a data-type="(r : Functor C D) → C .Ob → D .Ob" id="17756" href="Cat.Base.html#14629" class="Function">G.₀</a> <a id="17760" href="Cat.Base.html#17732" class="Bound">x</a><a id="17761" class="Symbol">)</a>
</pre>
<p>The transformation itself is given by <span class="Agda"><a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" href="Cat.Base.html#17727" class="Field">η</a></span>, the family of <em>components</em>, where the component at <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> is a map <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>→</mo><mi>G</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(x) \to G(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>.</span> The “without arbitrary choices” part is encoded in the field <span class="Agda"><a data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" href="Cat.Base.html#18305" class="Field">is-natural</a></span>, which encodes commutativity of the square below:</p>
<div class="diagram-container">
<img src="b7a5f3eceba564155b1ccad918d86cb1b2dbeab6.svg" title="commutative diagram" class="diagram quiver"></img>
</div>
<pre class="Agda">    <a id="_=&gt;_.is-natural"></a><a data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" id="18305" href="Cat.Base.html#18305" class="Field">is-natural</a> <a id="18316" class="Symbol">:</a> <a id="18318" class="Symbol">(</a><a id="18319" href="Cat.Base.html#18319" class="Bound">x</a> <a id="18321" href="Cat.Base.html#18321" class="Bound">y</a> <a id="18323" class="Symbol">:</a> <a id="18325" class="Symbol">_)</a> <a id="18328" class="Symbol">(</a><a id="18329" href="Cat.Base.html#18329" class="Bound">f</a> <a id="18331" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="18333" href="Cat.Base.html#1329" class="Function">C.Hom</a> <a id="18339" href="Cat.Base.html#18319" class="Bound">x</a> <a id="18341" href="Cat.Base.html#18321" class="Bound">y</a><a id="18342" class="Symbol">)</a>
               <a id="18359" class="Symbol">→</a> <a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" id="18361" href="Cat.Base.html#17727" class="Field">η</a> <a id="18363" href="Cat.Base.html#18321" class="Bound">y</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="18365" href="Cat.Base.html#2898" class="Function Operator">D.∘</a> <a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="18369" href="Cat.Base.html#14710" class="Function">F.₁</a> <a id="18373" href="Cat.Base.html#18329" class="Bound">f</a> <a data-type="A → A → Type ℓ" id="18375" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="18377" href="Cat.Base.html#14710" class="Function">G.₁</a> <a id="18381" href="Cat.Base.html#18329" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="18383" href="Cat.Base.html#2898" class="Function Operator">D.∘</a> <a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" id="18387" href="Cat.Base.html#17727" class="Field">η</a> <a id="18389" href="Cat.Base.html#18319" class="Bound">x</a>
</pre>
<!--
Alternatively, natural transformations can be thought of as [homotopies
between functors](agda://Cat.Functor.NatTrans.Homotopy). That
module contains a direct proof of the correspondence, but an argument by
abstract nonsense is even simpler to write down: Since [Cat is cartesian
closed](agda://Cat.Instances.Cat.Closed#Cat-closed), there is [an
isomorphism of Hom-sets](agda://Cat.Functor.Adjoints) from the
[tensor-hom
adjunction](agda://Cat.Structure.CartesianClosed#Tensor⊣Hom)

$$
\mathrm{Hom}_{\mathrm{Cat}}(C \times \left\{0 \le 1\right\}, D) \simeq
\mathrm{Hom}_{\mathrm{Cat}}(\left\{0 \le 1\right\}, [C, D])
$$

Since a functor from [the interval
category](agda://Cat.Instances.Interval) $\left\{0 \le 1\right\}$
amounts to a choice of morphism, we conclude that a functor $C \times
\left\{0\le 1\right\} \to D$ is the same as a natural transformation $C
\Rightarrow D$. There is more to this correspondence: the [geometric
realisation] of a natural transformation is a [homotopy in the
topological sense].

[geometric realisation]: https://ncatlab.org/nlab/show/geometric+realization+of+categories
[homotopy in the topological sense]: https://ncatlab.org/nlab/show/homotopy
-->
<p>Natural transformations also dualize. The opposite of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi><mo>:</mo><mi>F</mi><mo>⇒</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">\eta : F \Rightarrow G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">η</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> is <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>η</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>:</mo><msup><mi>G</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup><mo>⇒</mo><msup><mi>F</mi><mrow><mi>o</mi><mi>p</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\eta^{op} : G^{op} \Rightarrow F^{op}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8588em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">η</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span></span></span></span></span>.</span></p>
<pre class="Agda">  <a id="_=&gt;_.op"></a><a data-type="(r : F =&gt; G) → op G =&gt; op F" id="19724" href="Cat.Base.html#19724" class="Function">op</a> <a id="19727" class="Symbol">:</a> <a data-type="(r : Functor C D) → Functor (C ^op) (D ^op)" id="19729" href="Cat.Base.html#14874" class="Function">Functor.op</a> <a id="19740" href="Cat.Base.html#17293" class="Bound">G</a> <a data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" id="19742" href="Cat.Base.html#17186" class="Record Operator">=&gt;</a> <a data-type="(r : Functor C D) → Functor (C ^op) (D ^op)" id="19745" href="Cat.Base.html#14874" class="Function">Functor.op</a> <a id="19756" href="Cat.Base.html#17291" class="Bound">F</a>
  <a data-type="(r : F =&gt; G) → op G =&gt; op F" id="19760" href="Cat.Base.html#19724" class="Function">op</a> <a id="19763" class="Symbol">=</a> <a id="19765" class="Keyword">record</a>
    <a id="19776" class="Symbol">{</a> <a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" id="19778" href="Cat.Base.html#17727" class="Field">η</a> <a id="19780" class="Symbol">=</a> <a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" id="19782" href="Cat.Base.html#17727" class="Field">η</a>
    <a id="19788" class="Symbol">;</a> <a data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" id="19790" href="Cat.Base.html#18305" class="Field">is-natural</a> <a id="19801" class="Symbol">=</a> <a id="19803" class="Symbol">λ</a> <a id="19805" href="Cat.Base.html#19805" class="Bound">x</a> <a id="19807" href="Cat.Base.html#19807" class="Bound">y</a> <a id="19809" href="Cat.Base.html#19809" class="Bound">f</a> <a id="19811" class="Symbol">→</a> <a data-type="x ≡ y → y ≡ x" id="19813" href="1Lab.Path.html#10628" class="Function">sym</a> <a id="19817" class="Symbol">(</a><a data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" id="19818" href="Cat.Base.html#18305" class="Field">is-natural</a> <a id="19829" class="Symbol">_</a> <a id="19831" class="Symbol">_</a> <a id="19833" href="Cat.Base.html#19809" class="Bound">f</a><a id="19834" class="Symbol">)</a>
    <a id="19840" class="Symbol">}</a>
</pre>
<p>We verify that natural transformations are <a data-type="Type ℓ → Type ℓ" href="1Lab.HLevel.html#3342">sets</a> by showing that <code>F =&gt; G</code> is equivalent to a Σ-type which can be shown to be a set by the closure properties of h-levels.</p>
<pre class="Agda"><a id="20027" class="Keyword">module</a> <a id="20034" href="Cat.Base.html#20034" class="Module">_</a> <a id="20036" class="Symbol">{</a><a id="20037" href="Cat.Base.html#20037" class="Bound">o₁</a> <a id="20040" href="Cat.Base.html#20040" class="Bound">h₁</a> <a id="20043" href="Cat.Base.html#20043" class="Bound">o₂</a> <a id="20046" href="Cat.Base.html#20046" class="Bound">h₂</a><a id="20048" class="Symbol">}</a>
         <a id="20059" class="Symbol">{</a><a id="20060" href="Cat.Base.html#20060" class="Bound">C</a> <a id="20062" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="20064" href="Cat.Base.html#611" class="Record">Precategory</a> <a id="20076" href="Cat.Base.html#20037" class="Bound">o₁</a> <a id="20079" href="Cat.Base.html#20040" class="Bound">h₁</a><a id="20081" class="Symbol">}</a>
         <a id="20092" class="Symbol">{</a><a id="20093" href="Cat.Base.html#20093" class="Bound">D</a> <a id="20095" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="20097" href="Cat.Base.html#611" class="Record">Precategory</a> <a id="20109" href="Cat.Base.html#20043" class="Bound">o₂</a> <a id="20112" href="Cat.Base.html#20046" class="Bound">h₂</a><a id="20114" class="Symbol">}</a> 
         <a id="20126" class="Symbol">{</a><a id="20127" href="Cat.Base.html#20127" class="Bound">F</a> <a id="20129" href="Cat.Base.html#20129" class="Bound">G</a> <a id="20131" class="Symbol">:</a> <a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="20133" href="Cat.Base.html#13122" class="Record">Functor</a> <a id="20141" href="Cat.Base.html#20060" class="Bound">C</a> <a id="20143" href="Cat.Base.html#20093" class="Bound">D</a><a id="20144" class="Symbol">}</a> <a id="20146" class="Keyword">where</a>
  <a id="20154" class="Keyword">private</a>
    <a id="20166" class="Keyword">module</a> <a id="20173" href="Cat.Base.html#20173" class="Module">F</a> <a id="20175" class="Symbol">=</a> <a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="20177" href="Cat.Base.html#13122" class="Module">Functor</a> <a id="20185" href="Cat.Base.html#20127" class="Bound">F</a>
    <a id="20191" class="Keyword">module</a> <a id="20198" href="Cat.Base.html#20198" class="Module">G</a> <a id="20200" class="Symbol">=</a> <a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="20202" href="Cat.Base.html#13122" class="Module">Functor</a> <a id="20210" href="Cat.Base.html#20129" class="Bound">G</a>
    <a id="20216" class="Keyword">module</a> <a id="20223" href="Cat.Base.html#20223" class="Module">D</a> <a id="20225" class="Symbol">=</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="20227" href="Cat.Base.html#611" class="Module">Precategory</a> <a id="20239" href="Cat.Base.html#20093" class="Bound">D</a>
    <a id="20245" class="Keyword">module</a> <a id="20252" href="Cat.Base.html#20252" class="Module">C</a> <a id="20254" class="Symbol">=</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="20256" href="Cat.Base.html#611" class="Module">Precategory</a> <a id="20268" href="Cat.Base.html#20060" class="Bound">C</a>

  <a id="20273" class="Keyword">open</a> <a data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" id="20278" href="Cat.Base.html#17186" class="Module Operator">_=&gt;_</a>

  <a data-type="isSet (F =&gt; G)" id="20286" href="Cat.Base.html#20286" class="Function">isSet-Nat</a> <a id="20296" class="Symbol">:</a> <a data-type="Type ℓ → Type ℓ" id="20298" href="1Lab.HLevel.html#3342" class="Function">isSet</a> <a id="20304" class="Symbol">(</a><a id="20305" href="Cat.Base.html#20127" class="Bound">F</a> <a data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" id="20307" href="Cat.Base.html#17186" class="Record Operator">=&gt;</a> <a id="20310" href="Cat.Base.html#20129" class="Bound">G</a><a id="20311" class="Symbol">)</a>
  <a data-type="isSet (F =&gt; G)" id="20315" href="Cat.Base.html#20286" class="Function">isSet-Nat</a> <a id="20325" class="Symbol">=</a> <a data-type="(n : Nat) (f : A → B₁) (g : B₁ → A) →
isLeftInverse f g → isHLevel A n → isHLevel B₁ n" id="20327" href="1Lab.HLevel.Retracts.html#1639" class="Function">isHLevel-retract</a> <a id="20344" class="Number">2</a> <a id="20346" href="Cat.Base.html#20557" class="Function">NT&#39;→NT</a> <a id="20353" href="Cat.Base.html#20666" class="Function">NT→NT&#39;</a> <a id="20360" class="Symbol">(λ</a> <a id="20363" href="Cat.Base.html#20363" class="Bound">x</a> <a id="20365" class="Symbol">→</a> <a data-type="x ≡ x" id="20367" href="1Lab.Path.html#3591" class="Function">refl</a><a id="20371" class="Symbol">)</a> <a id="20373" href="Cat.Base.html#21068" class="Function">NT&#39;-isSet</a> <a id="20383" class="Keyword">where</a>

      <a id="20396" href="Cat.Base.html#20396" class="Function">NT&#39;</a> <a id="20400" class="Symbol">:</a> <a id="20402" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="20407" class="Symbol">_</a>
      <a id="20415" href="Cat.Base.html#20396" class="Function">NT&#39;</a> <a id="20419" class="Symbol">=</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="20421" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="20424" href="Cat.Base.html#20424" class="Bound">eta</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="20428" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="20430" class="Symbol">((</a><a id="20432" href="Cat.Base.html#20432" class="Bound">x</a> <a id="20434" class="Symbol">:</a> <a id="20436" class="Symbol">_)</a> <a id="20439" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="20441" href="Cat.Base.html#1329" class="Function">D.Hom</a> <a id="20447" class="Symbol">(</a><a data-type="(r : Functor C D) → C .Ob → D .Ob" id="20448" href="Cat.Base.html#14629" class="Function">F.₀</a> <a id="20452" href="Cat.Base.html#20432" class="Bound">x</a><a id="20453" class="Symbol">)</a> <a id="20455" class="Symbol">(</a><a data-type="(r : Functor C D) → C .Ob → D .Ob" id="20456" href="Cat.Base.html#14629" class="Function">G.₀</a> <a id="20460" href="Cat.Base.html#20432" class="Bound">x</a><a id="20461" class="Symbol">))</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="20464" href="1Lab.Type.html#1563" class="Function">]</a>
              <a id="20480" class="Symbol">((</a><a id="20482" href="Cat.Base.html#20482" class="Bound">x</a> <a id="20484" href="Cat.Base.html#20484" class="Bound">y</a> <a id="20486" class="Symbol">:</a> <a id="20488" class="Symbol">_)</a> <a id="20491" class="Symbol">(</a><a id="20492" href="Cat.Base.html#20492" class="Bound">f</a> <a id="20494" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="20496" href="Cat.Base.html#1329" class="Function">C.Hom</a> <a id="20502" href="Cat.Base.html#20482" class="Bound">x</a> <a id="20504" href="Cat.Base.html#20484" class="Bound">y</a><a id="20505" class="Symbol">)</a> <a id="20507" class="Symbol">→</a> <a id="20509" href="Cat.Base.html#20424" class="Bound">eta</a> <a id="20513" href="Cat.Base.html#20484" class="Bound">y</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="20515" href="Cat.Base.html#2898" class="Function Operator">D.∘</a> <a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="20519" href="Cat.Base.html#14710" class="Function">F.₁</a> <a id="20523" href="Cat.Base.html#20492" class="Bound">f</a> <a data-type="A → A → Type ℓ" id="20525" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="20527" href="Cat.Base.html#14710" class="Function">G.₁</a> <a id="20531" href="Cat.Base.html#20492" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="20533" href="Cat.Base.html#2898" class="Function Operator">D.∘</a> <a id="20537" href="Cat.Base.html#20424" class="Bound">eta</a> <a id="20541" href="Cat.Base.html#20482" class="Bound">x</a><a id="20542" class="Symbol">)</a>
      
      <a id="20557" href="Cat.Base.html#20557" class="Function">NT&#39;→NT</a> <a id="20564" class="Symbol">:</a> <a id="20566" href="Cat.Base.html#20396" class="Function">NT&#39;</a> <a id="20570" class="Symbol">→</a> <a id="20572" href="Cat.Base.html#20127" class="Bound">F</a> <a data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" id="20574" href="Cat.Base.html#17186" class="Record Operator">=&gt;</a> <a id="20577" href="Cat.Base.html#20129" class="Bound">G</a>
      <a id="20585" href="Cat.Base.html#20557" class="Function">NT&#39;→NT</a> <a id="20592" class="Symbol">(</a><a id="20593" href="Cat.Base.html#20593" class="Bound">eta</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="20597" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="20599" href="Cat.Base.html#20599" class="Bound">is-n</a><a id="20603" class="Symbol">)</a> <a id="20605" class="Symbol">.</a><a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" id="20606" href="Cat.Base.html#17727" class="Field">η</a> <a id="20608" class="Symbol">=</a> <a id="20610" href="Cat.Base.html#20593" class="Bound">eta</a>
      <a id="20620" href="Cat.Base.html#20557" class="Function">NT&#39;→NT</a> <a id="20627" class="Symbol">(</a><a id="20628" href="Cat.Base.html#20628" class="Bound">eta</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="20632" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="20634" href="Cat.Base.html#20634" class="Bound">is-n</a><a id="20638" class="Symbol">)</a> <a id="20640" class="Symbol">.</a><a data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" id="20641" href="Cat.Base.html#18305" class="Field">is-natural</a> <a id="20652" class="Symbol">=</a> <a id="20654" href="Cat.Base.html#20634" class="Bound">is-n</a>

      <a id="20666" href="Cat.Base.html#20666" class="Function">NT→NT&#39;</a> <a id="20673" class="Symbol">:</a> <a id="20675" href="Cat.Base.html#20127" class="Bound">F</a> <a data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" id="20677" href="Cat.Base.html#17186" class="Record Operator">=&gt;</a> <a id="20680" href="Cat.Base.html#20129" class="Bound">G</a> <a id="20682" class="Symbol">→</a> <a id="20684" href="Cat.Base.html#20396" class="Function">NT&#39;</a>
      <a id="20694" href="Cat.Base.html#20666" class="Function">NT→NT&#39;</a> <a id="20701" href="Cat.Base.html#20701" class="Bound">x</a> <a id="20703" class="Symbol">=</a> <a id="20705" href="Cat.Base.html#20701" class="Bound">x</a> <a id="20707" class="Symbol">.</a><a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" id="20708" href="Cat.Base.html#17727" class="Field">η</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="20710" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="20712" href="Cat.Base.html#20701" class="Bound">x</a> <a id="20714" class="Symbol">.</a><a data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" id="20715" href="Cat.Base.html#18305" class="Field">is-natural</a>
</pre>
<p>The type <span class="Agda"><a href="Cat.Base.html#20396" class="Function">NT&#39;</a></span> is a literal restatement of the definition of <span class="Agda"><a data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" href="Cat.Base.html#17186" class="Record Operator">_=&gt;_</a></span> using <code class="sourceCode agda">Σ</code> rather than an Agda record. The trade-off is that a record has semantic information (the names <span class="Agda"><a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" href="Cat.Base.html#17727" class="Field">η</a></span> and <span class="Agda"><a data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" href="Cat.Base.html#18305" class="Field">is-natural</a></span> mean more than <code>fst</code> and <code>snd</code>), but a <code class="sourceCode agda">Σ</code> can be proven to be a set compositionally:</p>
<pre class="Agda">      <a id="21068" href="Cat.Base.html#21068" class="Function">NT&#39;-isSet</a> <a id="21078" class="Symbol">:</a> <a data-type="Type ℓ → Type ℓ" id="21080" href="1Lab.HLevel.html#3342" class="Function">isSet</a> <a id="21086" href="Cat.Base.html#20396" class="Function">NT&#39;</a>
      <a id="21096" href="Cat.Base.html#21068" class="Function">NT&#39;-isSet</a> <a id="21106" class="Symbol">=</a>
        <a data-type="(n : Nat) →
isHLevel A n → ((x : A) → isHLevel (B₁ x) n) → isHLevel (Σ B₁) n" id="21116" href="1Lab.HLevel.Retracts.html#5094" class="Function">isHLevelΣ</a> <a id="21126" class="Number">2</a> <a id="21128" class="Symbol">(</a><a data-type="(n : Nat) →
((x : A) → isHLevel (B₁ x) n) → isHLevel ((x : A) → B₁ x) n" id="21129" href="1Lab.HLevel.Retracts.html#4179" class="Function">isHLevelΠ</a> <a id="21139" class="Number">2</a> <a id="21141" class="Symbol">λ</a> <a id="21143" href="Cat.Base.html#21143" class="Bound">x</a> <a id="21145" class="Symbol">→</a> <a data-type="(r : Precategory o h) (x y : r .Ob) → isSet (r .Hom x y)" id="21147" href="Cat.Base.html#1677" class="Function">D.Hom-set</a> <a id="21157" class="Symbol">_</a> <a id="21159" class="Symbol">_)</a>
                    <a id="21182" class="Symbol">(λ</a> <a id="21185" href="Cat.Base.html#21185" class="Bound">_</a> <a id="21187" class="Symbol">→</a> <a data-type="(n : Nat) →
((x : A) → isHLevel (B₁ x) n) → isHLevel ((x : A) → B₁ x) n" id="21189" href="1Lab.HLevel.Retracts.html#4179" class="Function">isHLevelΠ</a> <a id="21199" class="Number">2</a>
                     <a id="21222" class="Symbol">λ</a> <a id="21224" href="Cat.Base.html#21224" class="Bound">_</a> <a id="21226" class="Symbol">→</a> <a data-type="(n : Nat) →
((x : A) → isHLevel (B₁ x) n) → isHLevel ((x : A) → B₁ x) n" id="21228" href="1Lab.HLevel.Retracts.html#4179" class="Function">isHLevelΠ</a> <a id="21238" class="Number">2</a>
                     <a id="21261" class="Symbol">λ</a> <a id="21263" href="Cat.Base.html#21263" class="Bound">_</a> <a id="21265" class="Symbol">→</a> <a data-type="(n : Nat) →
((x : A) → isHLevel (B₁ x) n) → isHLevel ((x : A) → B₁ x) n" id="21267" href="1Lab.HLevel.Retracts.html#4179" class="Function">isHLevelΠ</a> <a id="21277" class="Number">2</a>
                     <a id="21300" class="Symbol">λ</a> <a id="21302" href="Cat.Base.html#21302" class="Bound">_</a> <a id="21304" href="Cat.Base.html#21304" class="Bound">x</a> <a id="21306" href="Cat.Base.html#21306" class="Bound">y</a> <a id="21308" href="Cat.Base.html#21308" class="Bound">p</a> <a id="21310" href="Cat.Base.html#21310" class="Bound">q</a> <a id="21312" class="Symbol">→</a> <a data-type="(n : Nat) → isHLevel A n → isHLevel A (suc n)" id="21314" href="1Lab.HLevel.html#8658" class="Function">isHLevel-suc</a> <a id="21327" class="Number">2</a> <a id="21329" class="Symbol">(</a><a data-type="(r : Precategory o h) (x y : r .Ob) → isSet (r .Hom x y)" id="21330" href="Cat.Base.html#1677" class="Function">D.Hom-set</a> <a id="21340" class="Symbol">_</a> <a id="21342" class="Symbol">_)</a> <a id="21345" class="Symbol">_</a> <a id="21347" class="Symbol">_</a> <a id="21349" href="Cat.Base.html#21304" class="Bound">x</a> <a id="21351" href="Cat.Base.html#21306" class="Bound">y</a> <a id="21353" href="Cat.Base.html#21308" class="Bound">p</a> <a id="21355" href="Cat.Base.html#21310" class="Bound">q</a><a id="21356" class="Symbol">)</a> 
</pre>
<p>Another fundamental lemma is that equality of natural transformations depends only on equality of the family of morphisms, since being natural is a proposition:</p>
<pre class="Agda">  <a data-type="((x : C .Ob) → a .η x ≡ b .η x) → a ≡ b" id="21536" href="Cat.Base.html#21536" class="Function">Nat-path</a> <a id="21545" class="Symbol">:</a> <a id="21547" class="Symbol">{</a><a id="21548" href="Cat.Base.html#21548" class="Bound">a</a> <a id="21550" href="Cat.Base.html#21550" class="Bound">b</a> <a id="21552" class="Symbol">:</a> <a id="21554" href="Cat.Base.html#20127" class="Bound">F</a> <a data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" id="21556" href="Cat.Base.html#17186" class="Record Operator">=&gt;</a> <a id="21559" href="Cat.Base.html#20129" class="Bound">G</a><a id="21560" class="Symbol">}</a>
           <a id="21573" class="Symbol">→</a> <a id="21575" class="Symbol">((</a><a id="21577" href="Cat.Base.html#21577" class="Bound">x</a> <a id="21579" class="Symbol">:</a> <a id="21581" class="Symbol">_)</a> <a id="21584" class="Symbol">→</a> <a id="21586" href="Cat.Base.html#21548" class="Bound">a</a> <a id="21588" class="Symbol">.</a><a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" id="21589" href="Cat.Base.html#17727" class="Field">η</a> <a id="21591" href="Cat.Base.html#21577" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="21593" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="21595" href="Cat.Base.html#21550" class="Bound">b</a> <a id="21597" class="Symbol">.</a><a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" id="21598" href="Cat.Base.html#17727" class="Field">η</a> <a id="21600" href="Cat.Base.html#21577" class="Bound">x</a><a id="21601" class="Symbol">)</a>
           <a id="21614" class="Symbol">→</a> <a id="21616" href="Cat.Base.html#21548" class="Bound">a</a> <a data-type="A → A → Type ℓ" id="21618" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="21620" href="Cat.Base.html#21550" class="Bound">b</a>
  <a data-type="((x : C .Ob) → a .η x ≡ b .η x) → a ≡ b" id="21624" href="Cat.Base.html#21536" class="Function">Nat-path</a> <a id="21633" href="Cat.Base.html#21633" class="Bound">path</a> <a id="21638" href="Cat.Base.html#21638" class="Bound">i</a> <a id="21640" class="Symbol">.</a><a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" id="21641" href="Cat.Base.html#17727" class="Field">η</a> <a id="21643" href="Cat.Base.html#21643" class="Bound">x</a> <a id="21645" class="Symbol">=</a> <a id="21647" href="Cat.Base.html#21633" class="Bound">path</a> <a id="21652" href="Cat.Base.html#21643" class="Bound">x</a> <a id="21654" href="Cat.Base.html#21638" class="Bound">i</a>
  <a data-type="((x : C .Ob) → a .η x ≡ b .η x) → a ≡ b" id="21658" href="Cat.Base.html#21536" class="Function">Nat-path</a> <a id="21667" class="Symbol">{</a><a id="21668" href="Cat.Base.html#21668" class="Bound">a</a><a id="21669" class="Symbol">}</a> <a id="21671" class="Symbol">{</a><a id="21672" href="Cat.Base.html#21672" class="Bound">b</a><a id="21673" class="Symbol">}</a> <a id="21675" href="Cat.Base.html#21675" class="Bound">path</a> <a id="21680" href="Cat.Base.html#21680" class="Bound">i</a> <a id="21682" class="Symbol">.</a><a data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" id="21683" href="Cat.Base.html#18305" class="Field">is-natural</a> <a id="21694" href="Cat.Base.html#21694" class="Bound">x</a> <a id="21696" href="Cat.Base.html#21696" class="Bound">y</a> <a id="21698" href="Cat.Base.html#21698" class="Bound">f</a> <a id="21700" class="Symbol">=</a>
    <a data-type="((i : I) → isProp (B₁ i)) →
(b0 : B₁ i0) (b1 : B₁ i1) → PathP B₁ b0 b1" id="21706" href="1Lab.HLevel.html#13502" class="Function">isProp→PathP</a> <a id="21719" class="Symbol">(λ</a> <a id="21722" href="Cat.Base.html#21722" class="Bound">i</a> <a id="21724" class="Symbol">→</a> <a data-type="(r : Precategory o h) (x y : r .Ob) → isSet (r .Hom x y)" id="21726" href="Cat.Base.html#1677" class="Function">D.Hom-set</a> <a id="21736" class="Symbol">_</a> <a id="21738" class="Symbol">_</a> <a id="21740" class="Symbol">(</a><a id="21741" href="Cat.Base.html#21675" class="Bound">path</a> <a id="21746" href="Cat.Base.html#21696" class="Bound">y</a> <a id="21748" href="Cat.Base.html#21722" class="Bound">i</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="21750" href="Cat.Base.html#2898" class="Function Operator">D.∘</a> <a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="21754" href="Cat.Base.html#14710" class="Function">F.₁</a> <a id="21758" href="Cat.Base.html#21698" class="Bound">f</a><a id="21759" class="Symbol">)</a> <a id="21761" class="Symbol">(</a><a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="21762" href="Cat.Base.html#14710" class="Function">G.₁</a> <a id="21766" href="Cat.Base.html#21698" class="Bound">f</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="21768" href="Cat.Base.html#2898" class="Function Operator">D.∘</a> <a id="21772" href="Cat.Base.html#21675" class="Bound">path</a> <a id="21777" href="Cat.Base.html#21694" class="Bound">x</a> <a id="21779" href="Cat.Base.html#21722" class="Bound">i</a><a id="21780" class="Symbol">))</a>
                 <a id="21800" class="Symbol">(</a><a id="21801" href="Cat.Base.html#21668" class="Bound">a</a> <a id="21803" class="Symbol">.</a><a data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" id="21804" href="Cat.Base.html#18305" class="Field">is-natural</a> <a id="21815" href="Cat.Base.html#21694" class="Bound">x</a> <a id="21817" href="Cat.Base.html#21696" class="Bound">y</a> <a id="21819" href="Cat.Base.html#21698" class="Bound">f</a><a id="21820" class="Symbol">)</a>
                 <a id="21839" class="Symbol">(</a><a id="21840" href="Cat.Base.html#21672" class="Bound">b</a> <a id="21842" class="Symbol">.</a><a data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" id="21843" href="Cat.Base.html#18305" class="Field">is-natural</a> <a id="21854" href="Cat.Base.html#21694" class="Bound">x</a> <a id="21856" href="Cat.Base.html#21696" class="Bound">y</a> <a id="21858" href="Cat.Base.html#21698" class="Bound">f</a><a id="21859" class="Symbol">)</a> <a id="21861" href="Cat.Base.html#21680" class="Bound">i</a>
</pre>
<h2 id="natural-isomorphism"><a href="#natural-isomorphism" class="header-link">Natural Isomorphism<span class="header-link-emoji">🔗</span></a></h2>
<pre class="Agda"><a id="21900" class="Keyword">record</a>
  <a id="_≅_"></a><a data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" id="21909" href="Cat.Base.html#21909" class="Record Operator">_≅_</a> <a id="21913" class="Symbol">{</a><a id="21914" href="Cat.Base.html#21914" class="Bound">o₁</a> <a id="21917" href="Cat.Base.html#21917" class="Bound">h₁</a> <a id="21920" href="Cat.Base.html#21920" class="Bound">o₂</a> <a id="21923" href="Cat.Base.html#21923" class="Bound">h₂</a><a id="21925" class="Symbol">}</a> <a id="21927" class="Symbol">{</a><a id="21928" href="Cat.Base.html#21928" class="Bound">C</a> <a id="21930" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="21932" href="Cat.Base.html#611" class="Record">Precategory</a> <a id="21944" href="Cat.Base.html#21914" class="Bound">o₁</a> <a id="21947" href="Cat.Base.html#21917" class="Bound">h₁</a><a id="21949" class="Symbol">}</a> <a id="21951" class="Symbol">{</a><a id="21952" href="Cat.Base.html#21952" class="Bound">D</a> <a id="21954" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="21956" href="Cat.Base.html#611" class="Record">Precategory</a> <a id="21968" href="Cat.Base.html#21920" class="Bound">o₂</a> <a id="21971" href="Cat.Base.html#21923" class="Bound">h₂</a><a id="21973" class="Symbol">}</a>
       <a id="21982" class="Symbol">(</a><a id="21983" href="Cat.Base.html#21983" class="Bound">F</a> <a id="21985" href="Cat.Base.html#21985" class="Bound">G</a> <a id="21987" class="Symbol">:</a> <a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="21989" href="Cat.Base.html#13122" class="Record">Functor</a> <a id="21997" href="Cat.Base.html#21928" class="Bound">C</a> <a id="21999" href="Cat.Base.html#21952" class="Bound">D</a><a id="22000" class="Symbol">)</a>
  <a id="22004" class="Symbol">:</a> <a id="22006" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="22011" class="Symbol">(</a><a id="22012" href="Cat.Base.html#21914" class="Bound">o₁</a> <a data-type="Level → Level → Level" id="22015" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="22017" href="Cat.Base.html#21917" class="Bound">h₁</a> <a data-type="Level → Level → Level" id="22020" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="22022" href="Cat.Base.html#21923" class="Bound">h₂</a><a id="22024" class="Symbol">)</a>
  <a id="22028" class="Keyword">where</a>
  <a id="22036" class="Keyword">private</a>
    <a id="22048" class="Keyword">module</a> <a id="_≅_.D"></a><a id="22055" href="Cat.Base.html#22055" class="Module">D</a> <a id="22057" class="Symbol">=</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="22059" href="Cat.Base.html#611" class="Module">Precategory</a> <a id="22071" href="Cat.Base.html#21952" class="Bound">D</a>
  <a id="22075" class="Keyword">open</a> <a data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" id="22080" href="Cat.Base.html#17186" class="Module Operator">_=&gt;_</a>
</pre>
<p>A natural transformation where all the <span class="Agda"><a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" href="Cat.Base.html#17727" class="Field">components</a></span> are isomorphisms is called a <span class="Agda"><a data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" href="Cat.Base.html#21909" class="Record Operator">natural isomorphism</a></span>. This is equivalently a natural transformation with a two-sided inverse.</p>
<pre class="Agda">  <a id="22307" class="Keyword">field</a>
    <a id="_≅_.to"></a><a data-type="F ≅ G → F =&gt; G" id="22317" href="Cat.Base.html#22317" class="Field">to</a>   <a id="22322" class="Symbol">:</a> <a id="22324" href="Cat.Base.html#21983" class="Bound">F</a> <a data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" id="22326" href="Cat.Base.html#17186" class="Record Operator">=&gt;</a> <a id="22329" href="Cat.Base.html#21985" class="Bound">G</a>
    <a id="_≅_.from"></a><a data-type="F ≅ G → G =&gt; F" id="22335" href="Cat.Base.html#22335" class="Field">from</a> <a id="22340" class="Symbol">:</a> <a id="22342" href="Cat.Base.html#21985" class="Bound">G</a> <a data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" id="22344" href="Cat.Base.html#17186" class="Record Operator">=&gt;</a> <a id="22347" href="Cat.Base.html#21983" class="Bound">F</a>
  
  <a id="22354" class="Keyword">field</a>
    <a id="_≅_.to-from"></a><a data-type="(r : F ≅ G) → D ._∘_ (η (r .from) x) (η (r .to) x) ≡ D .id" id="22364" href="Cat.Base.html#22364" class="Field">to-from</a> <a id="22372" class="Symbol">:</a> <a id="22374" class="Symbol">{</a><a id="22375" href="Cat.Base.html#22375" class="Bound">x</a> <a id="22377" class="Symbol">:</a> <a data-type="Precategory o h → Type o" id="22379" href="Cat.Base.html#1312" class="Field">Precategory.Ob</a> <a id="22394" href="Cat.Base.html#21928" class="Bound">C</a><a id="22395" class="Symbol">}</a> <a id="22397" class="Symbol">→</a> <a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" id="22399" href="Cat.Base.html#17727" class="Field">η</a> <a data-type="F ≅ G → G =&gt; F" id="22401" href="Cat.Base.html#22335" class="Field">from</a> <a id="22406" href="Cat.Base.html#22375" class="Bound">x</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="22408" href="Cat.Base.html#2898" class="Function Operator">D.∘</a> <a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" id="22412" href="Cat.Base.html#17727" class="Field">η</a> <a data-type="F ≅ G → F =&gt; G" id="22414" href="Cat.Base.html#22317" class="Field">to</a> <a id="22417" href="Cat.Base.html#22375" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="22419" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="22421" href="Cat.Base.html#2868" class="Function">D.id</a>
    <a id="_≅_.from-to"></a><a data-type="(r : F ≅ G) → D ._∘_ (η (r .to) x) (η (r .from) x) ≡ D .id" id="22430" href="Cat.Base.html#22430" class="Field">from-to</a> <a id="22438" class="Symbol">:</a> <a id="22440" class="Symbol">{</a><a id="22441" href="Cat.Base.html#22441" class="Bound">x</a> <a id="22443" class="Symbol">:</a> <a data-type="Precategory o h → Type o" id="22445" href="Cat.Base.html#1312" class="Field">Precategory.Ob</a> <a id="22460" href="Cat.Base.html#21928" class="Bound">C</a><a id="22461" class="Symbol">}</a> <a id="22463" class="Symbol">→</a> <a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" id="22465" href="Cat.Base.html#17727" class="Field">η</a> <a data-type="F ≅ G → F =&gt; G" id="22467" href="Cat.Base.html#22317" class="Field">to</a> <a id="22470" href="Cat.Base.html#22441" class="Bound">x</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="22472" href="Cat.Base.html#2898" class="Function Operator">D.∘</a> <a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" id="22476" href="Cat.Base.html#17727" class="Field">η</a> <a data-type="F ≅ G → G =&gt; F" id="22478" href="Cat.Base.html#22335" class="Field">from</a> <a id="22483" href="Cat.Base.html#22441" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="22485" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="22487" href="Cat.Base.html#2868" class="Function">D.id</a>
</pre>
<p>Natural isomorphisms are the <code class="sourceCode agda" data-ident="is-Iso">isomorphisms</code> in <a href="Cat.Instances.Functor.html">functor categories</a>, but this explicit characterisation improves compilation time by untangling the dependency graph.</p>
  </article>
</div>

</main>
</body>
</html>
