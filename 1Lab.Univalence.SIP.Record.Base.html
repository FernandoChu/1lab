<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>1Lab.Univalence.SIP.Record.Base</title><link rel="stylesheet" href="/css/agda-cats.css"></head><body><pre class="Agda"><a id="1" class="Keyword">open</a> <a id="6" class="Keyword">import</a> <a id="13" href="1Lab.Univalence.SIP.html" class="Module">1Lab.Univalence.SIP</a>
<a id="33" class="Keyword">open</a> <a id="38" class="Keyword">import</a> <a id="45" href="1Lab.Reflection.html" class="Module">1Lab.Reflection</a>
<a id="61" class="Keyword">open</a> <a id="66" class="Keyword">import</a> <a id="73" href="1Lab.Type.Sigma.html" class="Module">1Lab.Type.Sigma</a>
<a id="89" class="Keyword">open</a> <a id="94" class="Keyword">import</a> <a id="101" href="1Lab.Univalence.html" class="Module">1Lab.Univalence</a>
<a id="117" class="Keyword">open</a> <a id="122" class="Keyword">import</a> <a id="129" href="1Lab.HLevel.html" class="Module">1Lab.HLevel</a>
<a id="141" class="Keyword">open</a> <a id="146" class="Keyword">import</a> <a id="153" href="1Lab.Equiv.html" class="Module">1Lab.Equiv</a>
<a id="164" class="Keyword">open</a> <a id="169" class="Keyword">import</a> <a id="176" href="1Lab.Path.html" class="Module">1Lab.Path</a>
<a id="186" class="Keyword">open</a> <a id="191" class="Keyword">import</a> <a id="198" href="1Lab.Type.html" class="Module">1Lab.Type</a>

<a id="209" class="Keyword">open</a> <a id="214" class="Keyword">import</a> <a id="221" href="Data.List.html" class="Module">Data.List</a>

<a id="232" class="Keyword">module</a> <a id="239" href="1Lab.Univalence.SIP.Record.Base.html" class="Module">1Lab.Univalence.SIP.Record.Base</a> <a id="271" class="Keyword">where</a>

<a id="IsHomT"></a><a data-type="(l : Level) → (Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁ ⊔ lsuc l)" id="278" href="1Lab.Univalence.SIP.Record.Base.html#278" class="Function">IsHomT</a> <a id="285" class="Symbol">:</a> <a id="287" class="Symbol">∀</a> <a id="289" class="Symbol">{</a><a id="290" href="1Lab.Univalence.SIP.Record.Base.html#290" class="Bound">ℓ</a> <a id="292" href="1Lab.Univalence.SIP.Record.Base.html#292" class="Bound">ℓ₁</a><a id="294" class="Symbol">}</a> <a id="296" class="Symbol">(</a><a id="297" href="1Lab.Univalence.SIP.Record.Base.html#297" class="Bound">l</a> <a id="299" class="Symbol">:</a> <a data-type="Type" id="301" href="Agda.Primitive.html#597" class="Postulate">Level</a><a id="306" class="Symbol">)</a> <a id="308" class="Symbol">→</a> <a id="310" class="Symbol">(</a><a id="311" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="316" href="1Lab.Univalence.SIP.Record.Base.html#290" class="Bound">ℓ</a> <a id="318" class="Symbol">→</a> <a id="320" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="325" href="1Lab.Univalence.SIP.Record.Base.html#292" class="Bound">ℓ₁</a><a id="327" class="Symbol">)</a> <a id="329" class="Symbol">→</a> <a id="331" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="336" class="Symbol">_</a>
<a data-type="(l : Level) → (Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁ ⊔ lsuc l)" id="338" href="1Lab.Univalence.SIP.Record.Base.html#278" class="Function">IsHomT</a> <a id="345" href="1Lab.Univalence.SIP.Record.Base.html#345" class="Bound">l</a> <a id="347" href="1Lab.Univalence.SIP.Record.Base.html#347" class="Bound">S</a> <a id="349" class="Symbol">=</a> <a id="351" class="Symbol">(</a><a id="352" href="1Lab.Univalence.SIP.Record.Base.html#352" class="Bound">A</a> <a id="354" href="1Lab.Univalence.SIP.Record.Base.html#354" class="Bound">B</a> <a id="356" class="Symbol">:</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="358" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="360" href="1Lab.Univalence.SIP.Record.Base.html#347" class="Bound">S</a><a id="361" class="Symbol">)</a> <a id="363" class="Symbol">→</a> <a id="365" class="Symbol">(</a><a id="366" href="1Lab.Univalence.SIP.Record.Base.html#352" class="Bound">A</a> <a id="368" class="Symbol">.</a><a data-type="∑ A B → A" id="369" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="373" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="375" href="1Lab.Univalence.SIP.Record.Base.html#354" class="Bound">B</a> <a id="377" class="Symbol">.</a><a data-type="∑ A B → A" id="378" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="381" class="Symbol">)</a> <a id="383" class="Symbol">→</a> <a id="385" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="390" href="1Lab.Univalence.SIP.Record.Base.html#345" class="Bound">l</a>

<a id="393" class="Comment">-- We declare, inductively-recursively(!), a syntax for describing how</a>
<a id="464" class="Comment">-- to project the fields _and_ their corresponding presentation</a>
<a id="528" class="Comment">-- properties from a pair of records. Here are the signatures for stuff</a>
<a id="600" class="Comment">-- involved in the recursion:</a>
<a id="630" class="Keyword">module</a> <a id="637" href="1Lab.Univalence.SIP.Record.Base.html#637" class="Module">_</a> <a id="639" class="Symbol">{</a><a id="640" href="1Lab.Univalence.SIP.Record.Base.html#640" class="Bound">ℓ</a> <a id="642" href="1Lab.Univalence.SIP.Record.Base.html#642" class="Bound">ℓ₁</a> <a id="645" href="1Lab.Univalence.SIP.Record.Base.html#645" class="Bound">ℓ₁&#39;</a><a id="648" class="Symbol">}</a> <a id="650" class="Keyword">where</a>
  <a id="658" class="Comment">-- Actual descriptors for record fields</a>
  <a id="700" class="Keyword">data</a> <a data-type="(R₁ : Type ℓ → Type ℓ₁) → IsHomT ℓ₁&#39; R₁ → Typeω" id="705" href="1Lab.Univalence.SIP.Record.Base.html#705" class="Datatype">RecordFields</a> <a id="718" class="Symbol">(</a><a id="719" href="1Lab.Univalence.SIP.Record.Base.html#719" class="Bound">R</a> <a id="721" class="Symbol">:</a> <a id="723" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="728" href="1Lab.Univalence.SIP.Record.Base.html#640" class="Bound">ℓ</a> <a id="730" class="Symbol">→</a> <a id="732" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="737" href="1Lab.Univalence.SIP.Record.Base.html#642" class="Bound">ℓ₁</a><a id="739" class="Symbol">)</a> <a id="741" class="Symbol">(</a><a id="742" href="1Lab.Univalence.SIP.Record.Base.html#742" class="Bound">ι</a> <a id="744" class="Symbol">:</a> <a data-type="(l : Level) → (Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁ ⊔ lsuc l)" id="746" href="1Lab.Univalence.SIP.Record.Base.html#278" class="Function">IsHomT</a> <a id="753" href="1Lab.Univalence.SIP.Record.Base.html#645" class="Bound">ℓ₁&#39;</a> <a id="757" href="1Lab.Univalence.SIP.Record.Base.html#719" class="Bound">R</a><a id="758" class="Symbol">)</a> <a id="760" class="Symbol">:</a> <a id="762" href="1Lab.Type.html#409" class="Primitive">Typeω</a>

  <a id="771" class="Comment">-- Computes the LUB level of the fields described</a>
  <a data-type="RecordFields R₁ ι → Level" id="823" href="1Lab.Univalence.SIP.Record.Base.html#823" class="Function">level-of-fields→prod</a>
    <a id="848" class="Symbol">:</a> <a id="850" class="Symbol">{</a><a id="851" href="1Lab.Univalence.SIP.Record.Base.html#851" class="Bound">R</a> <a id="853" class="Symbol">:</a> <a id="855" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="860" href="1Lab.Univalence.SIP.Record.Base.html#640" class="Bound">ℓ</a> <a id="862" class="Symbol">→</a> <a id="864" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="869" href="1Lab.Univalence.SIP.Record.Base.html#642" class="Bound">ℓ₁</a><a id="871" class="Symbol">}</a> <a id="873" class="Symbol">{</a><a id="874" href="1Lab.Univalence.SIP.Record.Base.html#874" class="Bound">ι</a> <a id="876" class="Symbol">:</a> <a data-type="(l : Level) → (Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁ ⊔ lsuc l)" id="878" href="1Lab.Univalence.SIP.Record.Base.html#278" class="Function">IsHomT</a> <a id="885" href="1Lab.Univalence.SIP.Record.Base.html#645" class="Bound">ℓ₁&#39;</a> <a id="889" href="1Lab.Univalence.SIP.Record.Base.html#851" class="Bound">R</a><a id="890" class="Symbol">}</a>
    <a id="896" class="Symbol">→</a> <a data-type="(R₁ : Type ℓ → Type ℓ₁) → IsHomT ℓ₁&#39; R₁ → Typeω" id="898" href="1Lab.Univalence.SIP.Record.Base.html#705" class="Datatype">RecordFields</a> <a id="911" href="1Lab.Univalence.SIP.Record.Base.html#851" class="Bound">R</a> <a id="913" href="1Lab.Univalence.SIP.Record.Base.html#874" class="Bound">ι</a>
    <a id="919" class="Symbol">→</a> <a data-type="Type" id="921" href="Agda.Primitive.html#597" class="Postulate">Level</a>
  
  <a id="932" class="Comment">-- Computes a nested product type of the fields described</a>
  <a data-type="(fields : RecordFields R₁ ι) →
Type ℓ → Type (level-of-fields→prod fields)" id="992" href="1Lab.Univalence.SIP.Record.Base.html#992" class="Function">fields→prod</a>
    <a id="1008" class="Symbol">:</a> <a id="1010" class="Symbol">{</a><a id="1011" href="1Lab.Univalence.SIP.Record.Base.html#1011" class="Bound">R</a> <a id="1013" class="Symbol">:</a> <a id="1015" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="1020" href="1Lab.Univalence.SIP.Record.Base.html#640" class="Bound">ℓ</a> <a id="1022" class="Symbol">→</a> <a id="1024" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="1029" href="1Lab.Univalence.SIP.Record.Base.html#642" class="Bound">ℓ₁</a><a id="1031" class="Symbol">}</a> <a id="1033" class="Symbol">{</a><a id="1034" href="1Lab.Univalence.SIP.Record.Base.html#1034" class="Bound">ι</a> <a id="1036" class="Symbol">:</a> <a data-type="(l : Level) → (Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁ ⊔ lsuc l)" id="1038" href="1Lab.Univalence.SIP.Record.Base.html#278" class="Function">IsHomT</a> <a id="1045" href="1Lab.Univalence.SIP.Record.Base.html#645" class="Bound">ℓ₁&#39;</a> <a id="1049" href="1Lab.Univalence.SIP.Record.Base.html#1011" class="Bound">R</a><a id="1050" class="Symbol">}</a>
      <a id="1058" class="Symbol">(</a><a id="1059" href="1Lab.Univalence.SIP.Record.Base.html#1059" class="Bound">fields</a> <a id="1066" class="Symbol">:</a> <a data-type="(R₁ : Type ℓ → Type ℓ₁) → IsHomT ℓ₁&#39; R₁ → Typeω" id="1068" href="1Lab.Univalence.SIP.Record.Base.html#705" class="Datatype">RecordFields</a> <a id="1081" href="1Lab.Univalence.SIP.Record.Base.html#1011" class="Bound">R</a> <a id="1083" href="1Lab.Univalence.SIP.Record.Base.html#1034" class="Bound">ι</a><a id="1084" class="Symbol">)</a>
    <a id="1090" class="Symbol">→</a> <a id="1092" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="1097" href="1Lab.Univalence.SIP.Record.Base.html#640" class="Bound">ℓ</a> <a id="1099" class="Symbol">→</a> <a id="1101" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="1106" class="Symbol">(</a><a data-type="RecordFields R₁ ι → Level" id="1107" href="1Lab.Univalence.SIP.Record.Base.html#823" class="Function">level-of-fields→prod</a> <a id="1128" href="1Lab.Univalence.SIP.Record.Base.html#1059" class="Bound">fields</a><a id="1134" class="Symbol">)</a>

  <a id="1139" class="Comment">-- Projects the fields described into the nested product type</a>
  <a id="1203" class="Comment">-- structure</a>
  <a data-type="(fs : RecordFields R₁ ι) → R₁ X → fields→prod fs X" id="1218" href="1Lab.Univalence.SIP.Record.Base.html#1218" class="Function">project-fields</a>
    <a id="1237" class="Symbol">:</a> <a id="1239" class="Symbol">{</a><a id="1240" href="1Lab.Univalence.SIP.Record.Base.html#1240" class="Bound">R</a> <a id="1242" class="Symbol">:</a> <a id="1244" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="1249" href="1Lab.Univalence.SIP.Record.Base.html#640" class="Bound">ℓ</a> <a id="1251" class="Symbol">→</a> <a id="1253" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="1258" href="1Lab.Univalence.SIP.Record.Base.html#642" class="Bound">ℓ₁</a><a id="1260" class="Symbol">}</a> <a id="1262" class="Symbol">{</a><a id="1263" href="1Lab.Univalence.SIP.Record.Base.html#1263" class="Bound">ι</a> <a id="1265" class="Symbol">:</a> <a data-type="(l : Level) → (Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁ ⊔ lsuc l)" id="1267" href="1Lab.Univalence.SIP.Record.Base.html#278" class="Function">IsHomT</a> <a id="1274" href="1Lab.Univalence.SIP.Record.Base.html#645" class="Bound">ℓ₁&#39;</a> <a id="1278" href="1Lab.Univalence.SIP.Record.Base.html#1240" class="Bound">R</a><a id="1279" class="Symbol">}</a>
      <a id="1287" class="Symbol">(</a><a id="1288" href="1Lab.Univalence.SIP.Record.Base.html#1288" class="Bound">fs</a> <a id="1291" class="Symbol">:</a> <a data-type="(R₁ : Type ℓ → Type ℓ₁) → IsHomT ℓ₁&#39; R₁ → Typeω" id="1293" href="1Lab.Univalence.SIP.Record.Base.html#705" class="Datatype">RecordFields</a> <a id="1306" href="1Lab.Univalence.SIP.Record.Base.html#1240" class="Bound">R</a> <a id="1308" href="1Lab.Univalence.SIP.Record.Base.html#1263" class="Bound">ι</a><a id="1309" class="Symbol">)</a>
    <a id="1315" class="Symbol">→</a> <a id="1317" class="Symbol">{</a><a id="1318" href="1Lab.Univalence.SIP.Record.Base.html#1318" class="Bound">X</a> <a id="1320" class="Symbol">:</a> <a id="1322" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="1327" href="1Lab.Univalence.SIP.Record.Base.html#640" class="Bound">ℓ</a><a id="1328" class="Symbol">}</a> <a id="1330" class="Symbol">→</a> <a id="1332" href="1Lab.Univalence.SIP.Record.Base.html#1240" class="Bound">R</a> <a id="1334" href="1Lab.Univalence.SIP.Record.Base.html#1318" class="Bound">X</a> <a id="1336" class="Symbol">→</a> <a data-type="(fields : RecordFields R₁ ι) →
Type ℓ → Type (level-of-fields→prod fields)" id="1338" href="1Lab.Univalence.SIP.Record.Base.html#992" class="Function">fields→prod</a> <a id="1350" href="1Lab.Univalence.SIP.Record.Base.html#1288" class="Bound">fs</a> <a id="1353" href="1Lab.Univalence.SIP.Record.Base.html#1318" class="Bound">X</a>

  <a id="1358" class="Comment">-- What it means for P to be a proposition over the fields fs</a>
  <a data-type="(R₁ : Type ℓ → Type ℓ₁) (ι : IsHomT ℓ₁&#39; R₁)
(fs : RecordFields R₁ ι) →
((X : Type ℓ) → fields→prod fs X → Type ℓ₂) →
Type (lsuc ℓ ⊔ ℓ₁ ⊔ ℓ₂)" id="1422" href="1Lab.Univalence.SIP.Record.Base.html#1422" class="Function">isPropProperty</a>
    <a id="1441" class="Symbol">:</a> <a id="1443" class="Symbol">∀</a> <a id="1445" class="Symbol">{</a><a id="1446" href="1Lab.Univalence.SIP.Record.Base.html#1446" class="Bound">ℓ₂</a><a id="1448" class="Symbol">}</a> <a id="1450" class="Symbol">(</a><a id="1451" href="1Lab.Univalence.SIP.Record.Base.html#1451" class="Bound">R</a> <a id="1453" class="Symbol">:</a> <a id="1455" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="1460" href="1Lab.Univalence.SIP.Record.Base.html#640" class="Bound">ℓ</a> <a id="1462" class="Symbol">→</a> <a id="1464" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="1469" href="1Lab.Univalence.SIP.Record.Base.html#642" class="Bound">ℓ₁</a><a id="1471" class="Symbol">)</a> <a id="1473" class="Symbol">(</a><a id="1474" href="1Lab.Univalence.SIP.Record.Base.html#1474" class="Bound">ι</a> <a id="1476" class="Symbol">:</a> <a data-type="(l : Level) → (Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁ ⊔ lsuc l)" id="1478" href="1Lab.Univalence.SIP.Record.Base.html#278" class="Function">IsHomT</a> <a id="1485" href="1Lab.Univalence.SIP.Record.Base.html#645" class="Bound">ℓ₁&#39;</a> <a id="1489" href="1Lab.Univalence.SIP.Record.Base.html#1451" class="Bound">R</a><a id="1490" class="Symbol">)</a>
        <a id="1500" class="Symbol">(</a><a id="1501" href="1Lab.Univalence.SIP.Record.Base.html#1501" class="Bound">fs</a> <a id="1504" class="Symbol">:</a> <a data-type="(R₁ : Type ℓ → Type ℓ₁) → IsHomT ℓ₁&#39; R₁ → Typeω" id="1506" href="1Lab.Univalence.SIP.Record.Base.html#705" class="Datatype">RecordFields</a> <a id="1519" href="1Lab.Univalence.SIP.Record.Base.html#1451" class="Bound">R</a> <a id="1521" href="1Lab.Univalence.SIP.Record.Base.html#1474" class="Bound">ι</a><a id="1522" class="Symbol">)</a>
        <a id="1532" class="Symbol">(</a><a id="1533" href="1Lab.Univalence.SIP.Record.Base.html#1533" class="Bound">P</a> <a id="1535" class="Symbol">:</a> <a id="1537" class="Symbol">(</a><a id="1538" href="1Lab.Univalence.SIP.Record.Base.html#1538" class="Bound">X</a> <a id="1540" class="Symbol">:</a> <a id="1542" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="1547" href="1Lab.Univalence.SIP.Record.Base.html#640" class="Bound">ℓ</a><a id="1548" class="Symbol">)</a> <a id="1550" class="Symbol">→</a> <a data-type="(fields : RecordFields R₁ ι) →
Type ℓ → Type (level-of-fields→prod fields)" id="1552" href="1Lab.Univalence.SIP.Record.Base.html#992" class="Function">fields→prod</a> <a id="1564" href="1Lab.Univalence.SIP.Record.Base.html#1501" class="Bound">fs</a> <a id="1567" href="1Lab.Univalence.SIP.Record.Base.html#1538" class="Bound">X</a> <a id="1569" class="Symbol">→</a> <a id="1571" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="1576" href="1Lab.Univalence.SIP.Record.Base.html#1446" class="Bound">ℓ₂</a><a id="1578" class="Symbol">)</a>
    <a id="1584" class="Symbol">→</a> <a id="1586" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="1591" class="Symbol">(</a><a data-type="Level → Level" id="1592" href="Agda.Primitive.html#780" class="Primitive">lsuc</a> <a id="1597" href="1Lab.Univalence.SIP.Record.Base.html#640" class="Bound">ℓ</a> <a data-type="Level → Level → Level" id="1599" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="1601" href="1Lab.Univalence.SIP.Record.Base.html#642" class="Bound">ℓ₁</a> <a data-type="Level → Level → Level" id="1604" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="1606" href="1Lab.Univalence.SIP.Record.Base.html#1446" class="Bound">ℓ₂</a><a id="1608" class="Symbol">)</a>
  <a data-type="(R₁ : Type ℓ → Type ℓ₁) (ι : IsHomT ℓ₁&#39; R₁)
(fs : RecordFields R₁ ι) →
((X : Type ℓ) → fields→prod fs X → Type ℓ₂) →
Type (lsuc ℓ ⊔ ℓ₁ ⊔ ℓ₂)" id="1612" href="1Lab.Univalence.SIP.Record.Base.html#1422" class="Function">isPropProperty</a> <a id="1627" href="1Lab.Univalence.SIP.Record.Base.html#1627" class="Bound">R</a> <a id="1629" href="1Lab.Univalence.SIP.Record.Base.html#1629" class="Bound">ι</a> <a id="1631" href="1Lab.Univalence.SIP.Record.Base.html#1631" class="Bound">fs</a> <a id="1634" href="1Lab.Univalence.SIP.Record.Base.html#1634" class="Bound">P</a> <a id="1636" class="Symbol">=</a>
    <a id="1642" class="Symbol">{</a><a id="1643" href="1Lab.Univalence.SIP.Record.Base.html#1643" class="Bound">X</a> <a id="1645" class="Symbol">:</a> <a id="1647" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="1652" href="1Lab.Univalence.SIP.Record.Base.html#640" class="Bound">ℓ</a><a id="1653" class="Symbol">}</a> <a id="1655" class="Symbol">(</a><a id="1656" href="1Lab.Univalence.SIP.Record.Base.html#1656" class="Bound">r</a>  <a id="1659" class="Symbol">:</a> <a id="1661" href="1Lab.Univalence.SIP.Record.Base.html#1627" class="Bound">R</a> <a id="1663" href="1Lab.Univalence.SIP.Record.Base.html#1643" class="Bound">X</a><a id="1664" class="Symbol">)</a> <a id="1666" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="1668" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="1675" class="Symbol">(</a><a id="1676" href="1Lab.Univalence.SIP.Record.Base.html#1634" class="Bound">P</a> <a id="1678" href="1Lab.Univalence.SIP.Record.Base.html#1643" class="Bound">X</a> <a id="1680" class="Symbol">(</a><a data-type="(fs : RecordFields R₁ ι) → R₁ X → fields→prod fs X" id="1681" href="1Lab.Univalence.SIP.Record.Base.html#1218" class="Function">project-fields</a> <a id="1696" href="1Lab.Univalence.SIP.Record.Base.html#1631" class="Bound">fs</a> <a id="1699" href="1Lab.Univalence.SIP.Record.Base.html#1656" class="Bound">r</a><a id="1700" class="Symbol">))</a>

  <a id="1706" class="Comment">-- Now the actual definitions.</a>
  <a id="1739" class="Keyword">data</a> <a data-type="(R₁ : Type ℓ → Type ℓ₁) → IsHomT ℓ₁&#39; R₁ → Typeω" id="1744" href="1Lab.Univalence.SIP.Record.Base.html#705" class="Datatype">RecordFields</a> <a id="1757" href="1Lab.Univalence.SIP.Record.Base.html#1757" class="Bound">R</a> <a id="1759" href="1Lab.Univalence.SIP.Record.Base.html#1759" class="Bound">ι</a> <a id="1761" class="Keyword">where</a>
    <a id="1771" class="Comment">-- The empty record descriptor</a>
    <a data-type="RecordFields R₁ ι" id="1806" href="1Lab.Univalence.SIP.Record.Base.html#1806" class="InductiveConstructor">record:</a> <a id="1814" class="Symbol">:</a> <a data-type="(R₁ : Type ℓ → Type ℓ₁) → IsHomT ℓ₁&#39; R₁ → Typeω" id="1816" href="1Lab.Univalence.SIP.Record.Base.html#705" class="Datatype">RecordFields</a> <a id="1829" href="1Lab.Univalence.SIP.Record.Base.html#1757" class="Bound">R</a> <a id="1831" href="1Lab.Univalence.SIP.Record.Base.html#1759" class="Bound">ι</a>

    <a id="1838" class="Comment">-- Project a field (must not depend on previous fields of the</a>
    <a id="1904" class="Comment">-- record)</a>
    <a data-type="RecordFields R₁ ι →
(project : R₁ X → S₁ X) →
(ι A B e → ι&#39; (Σ-map₂ project A) (Σ-map₂ project B) e) →
RecordFields R₁ ι" id="1919" href="1Lab.Univalence.SIP.Record.Base.html#1919" class="InductiveConstructor Operator">_field[_by_]</a>
      <a id="1938" class="Symbol">:</a> <a id="1940" class="Symbol">(</a><a id="1941" href="1Lab.Univalence.SIP.Record.Base.html#1941" class="Bound">previous-fields</a> <a id="1957" class="Symbol">:</a> <a data-type="(R₁ : Type ℓ → Type ℓ₁) → IsHomT ℓ₁&#39; R₁ → Typeω" id="1959" href="1Lab.Univalence.SIP.Record.Base.html#705" class="Datatype">RecordFields</a> <a id="1972" href="1Lab.Univalence.SIP.Record.Base.html#1757" class="Bound">R</a> <a id="1974" href="1Lab.Univalence.SIP.Record.Base.html#1759" class="Bound">ι</a><a id="1975" class="Symbol">)</a>

      <a id="1984" class="Symbol">→</a> <a id="1986" class="Symbol">∀</a> <a id="1988" class="Symbol">{</a><a id="1989" href="1Lab.Univalence.SIP.Record.Base.html#1989" class="Bound">ℓ₂</a> <a id="1992" href="1Lab.Univalence.SIP.Record.Base.html#1992" class="Bound">ℓ₂&#39;</a><a id="1995" class="Symbol">}</a> <a id="1997" class="Symbol">{</a><a id="1998" href="1Lab.Univalence.SIP.Record.Base.html#1998" class="Bound">S</a> <a id="2000" class="Symbol">:</a> <a id="2002" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2007" href="1Lab.Univalence.SIP.Record.Base.html#640" class="Bound">ℓ</a> <a id="2009" class="Symbol">→</a> <a id="2011" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2016" href="1Lab.Univalence.SIP.Record.Base.html#1989" class="Bound">ℓ₂</a><a id="2018" class="Symbol">}</a> <a id="2020" class="Symbol">{</a><a id="2021" href="1Lab.Univalence.SIP.Record.Base.html#2021" class="Bound">ι&#39;</a> <a id="2024" class="Symbol">:</a> <a data-type="(l : Level) → (Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁ ⊔ lsuc l)" id="2026" href="1Lab.Univalence.SIP.Record.Base.html#278" class="Function">IsHomT</a> <a id="2033" href="1Lab.Univalence.SIP.Record.Base.html#1992" class="Bound">ℓ₂&#39;</a> <a id="2037" href="1Lab.Univalence.SIP.Record.Base.html#1998" class="Bound">S</a><a id="2038" class="Symbol">}</a>
      <a id="2046" class="Comment">--           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</a>
      <a id="2108" class="Comment">--           These arguments specify a notion of structure</a>
      <a id="2173" class="Comment">--           for the field</a>

      <a id="2207" class="Symbol">→</a> <a id="2209" class="Symbol">(</a><a id="2210" href="1Lab.Univalence.SIP.Record.Base.html#2210" class="Bound">project</a> <a id="2218" class="Symbol">:</a> <a id="2220" class="Symbol">{</a><a id="2221" href="1Lab.Univalence.SIP.Record.Base.html#2221" class="Bound">X</a> <a id="2223" class="Symbol">:</a> <a id="2225" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2230" href="1Lab.Univalence.SIP.Record.Base.html#640" class="Bound">ℓ</a><a id="2231" class="Symbol">}</a> <a id="2233" class="Symbol">→</a> <a id="2235" href="1Lab.Univalence.SIP.Record.Base.html#1757" class="Bound">R</a> <a id="2237" href="1Lab.Univalence.SIP.Record.Base.html#2221" class="Bound">X</a> <a id="2239" class="Symbol">→</a> <a id="2241" href="1Lab.Univalence.SIP.Record.Base.html#1998" class="Bound">S</a> <a id="2243" href="1Lab.Univalence.SIP.Record.Base.html#2221" class="Bound">X</a><a id="2244" class="Symbol">)</a>
      <a id="2252" class="Comment">-- ^ Projection from the record to the notion of structure</a>

      <a id="2318" class="Symbol">→</a> <a id="2320" class="Symbol">(</a><a id="2321" href="1Lab.Univalence.SIP.Record.Base.html#2321" class="Bound">project-preservation</a> <a id="2342" class="Symbol">:</a> <a id="2344" class="Symbol">{</a><a id="2345" href="1Lab.Univalence.SIP.Record.Base.html#2345" class="Bound">A</a> <a id="2347" href="1Lab.Univalence.SIP.Record.Base.html#2347" class="Bound">B</a> <a id="2349" class="Symbol">:</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="2351" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="2353" href="1Lab.Univalence.SIP.Record.Base.html#1757" class="Bound">R</a><a id="2354" class="Symbol">}</a> <a id="2356" class="Symbol">{</a><a id="2357" href="1Lab.Univalence.SIP.Record.Base.html#2357" class="Bound">e</a> <a id="2359" class="Symbol">:</a> <a id="2361" href="1Lab.Univalence.SIP.Record.Base.html#2345" class="Bound">A</a> <a id="2363" class="Symbol">.</a><a data-type="∑ A B → A" id="2364" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="2368" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="2370" href="1Lab.Univalence.SIP.Record.Base.html#2347" class="Bound">B</a> <a id="2372" class="Symbol">.</a><a data-type="∑ A B → A" id="2373" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="2376" class="Symbol">}</a>
                              <a id="2408" class="Symbol">→</a> <a id="2410" href="1Lab.Univalence.SIP.Record.Base.html#1759" class="Bound">ι</a> <a id="2412" href="1Lab.Univalence.SIP.Record.Base.html#2345" class="Bound">A</a> <a id="2414" href="1Lab.Univalence.SIP.Record.Base.html#2347" class="Bound">B</a> <a id="2416" href="1Lab.Univalence.SIP.Record.Base.html#2357" class="Bound">e</a>
                              <a id="2448" class="Symbol">→</a> <a id="2450" href="1Lab.Univalence.SIP.Record.Base.html#2021" class="Bound">ι&#39;</a> <a id="2453" class="Symbol">(</a><a data-type="(P x → Q x) → Σ P → Σ Q" id="2454" href="1Lab.Type.Sigma.html#7771" class="Function">Σ-map₂</a> <a id="2461" href="1Lab.Univalence.SIP.Record.Base.html#2210" class="Bound">project</a> <a id="2469" href="1Lab.Univalence.SIP.Record.Base.html#2345" class="Bound">A</a><a id="2470" class="Symbol">)</a> <a id="2472" class="Symbol">(</a><a data-type="(P x → Q x) → Σ P → Σ Q" id="2473" href="1Lab.Type.Sigma.html#7771" class="Function">Σ-map₂</a> <a id="2480" href="1Lab.Univalence.SIP.Record.Base.html#2210" class="Bound">project</a> <a id="2488" href="1Lab.Univalence.SIP.Record.Base.html#2347" class="Bound">B</a><a id="2489" class="Symbol">)</a> <a id="2491" href="1Lab.Univalence.SIP.Record.Base.html#2357" class="Bound">e</a><a id="2492" class="Symbol">)</a>
      <a id="2500" class="Comment">-- ^ Corresponding preservation datum for the field</a>

      <a id="2559" class="Symbol">→</a> <a data-type="(R₁ : Type ℓ → Type ℓ₁) → IsHomT ℓ₁&#39; R₁ → Typeω" id="2561" href="1Lab.Univalence.SIP.Record.Base.html#705" class="Datatype">RecordFields</a> <a id="2574" href="1Lab.Univalence.SIP.Record.Base.html#1757" class="Bound">R</a> <a id="2576" href="1Lab.Univalence.SIP.Record.Base.html#1759" class="Bound">ι</a>

    <a id="2583" class="Comment">-- Project a proposition/predicate, which /can/ depend on previous</a>
    <a id="2654" class="Comment">-- fields of the record.</a>
    <a data-type="(previous-fields : RecordFields R₁ ι) →
((r : R₁ X) → P X (project-fields previous-fields r)) →
isPropProperty R₁ ι previous-fields P → RecordFields R₁ ι" id="2683" href="1Lab.Univalence.SIP.Record.Base.html#2683" class="InductiveConstructor Operator">_axiom[_by_]</a>
      <a id="2702" class="Symbol">:</a> <a id="2704" class="Symbol">(</a><a id="2705" href="1Lab.Univalence.SIP.Record.Base.html#2705" class="Bound">previous-fields</a> <a id="2721" class="Symbol">:</a> <a data-type="(R₁ : Type ℓ → Type ℓ₁) → IsHomT ℓ₁&#39; R₁ → Typeω" id="2723" href="1Lab.Univalence.SIP.Record.Base.html#705" class="Datatype">RecordFields</a> <a id="2736" href="1Lab.Univalence.SIP.Record.Base.html#1757" class="Bound">R</a> <a id="2738" href="1Lab.Univalence.SIP.Record.Base.html#1759" class="Bound">ι</a><a id="2739" class="Symbol">)</a>
      <a id="2747" class="Comment">-- ^ The previous fields</a>

      <a id="2779" class="Symbol">→</a> <a id="2781" class="Symbol">∀</a> <a id="2783" class="Symbol">{</a><a id="2784" href="1Lab.Univalence.SIP.Record.Base.html#2784" class="Bound">ℓ₂</a><a id="2786" class="Symbol">}</a> <a id="2788" class="Symbol">{</a><a id="2789" href="1Lab.Univalence.SIP.Record.Base.html#2789" class="Bound">P</a> <a id="2791" class="Symbol">:</a> <a id="2793" class="Symbol">(</a><a id="2794" href="1Lab.Univalence.SIP.Record.Base.html#2794" class="Bound">X</a> <a id="2796" class="Symbol">:</a> <a id="2798" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2803" href="1Lab.Univalence.SIP.Record.Base.html#640" class="Bound">ℓ</a><a id="2804" class="Symbol">)</a> <a id="2806" class="Symbol">→</a> <a data-type="(fields : RecordFields R₁ ι) →
Type ℓ → Type (level-of-fields→prod fields)" id="2808" href="1Lab.Univalence.SIP.Record.Base.html#992" class="Function">fields→prod</a> <a id="2820" href="1Lab.Univalence.SIP.Record.Base.html#2705" class="Bound">previous-fields</a> <a id="2836" href="1Lab.Univalence.SIP.Record.Base.html#2794" class="Bound">X</a> <a id="2838" class="Symbol">→</a> <a id="2840" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2845" href="1Lab.Univalence.SIP.Record.Base.html#2784" class="Bound">ℓ₂</a><a id="2847" class="Symbol">}</a>
      <a id="2855" class="Comment">--       ^ The actual proposition</a>

      <a id="2896" class="Symbol">→</a> <a id="2898" class="Symbol">(</a><a id="2899" href="1Lab.Univalence.SIP.Record.Base.html#2899" class="Bound">predicate</a> <a id="2909" class="Symbol">:</a> <a id="2911" class="Symbol">{</a><a id="2912" href="1Lab.Univalence.SIP.Record.Base.html#2912" class="Bound">X</a> <a id="2914" class="Symbol">:</a> <a id="2916" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2921" href="1Lab.Univalence.SIP.Record.Base.html#640" class="Bound">ℓ</a><a id="2922" class="Symbol">}</a> <a id="2924" class="Symbol">(</a><a id="2925" href="1Lab.Univalence.SIP.Record.Base.html#2925" class="Bound">r</a> <a id="2927" class="Symbol">:</a> <a id="2929" href="1Lab.Univalence.SIP.Record.Base.html#1757" class="Bound">R</a> <a id="2931" href="1Lab.Univalence.SIP.Record.Base.html#2912" class="Bound">X</a><a id="2932" class="Symbol">)</a> <a id="2934" class="Symbol">→</a> <a id="2936" href="1Lab.Univalence.SIP.Record.Base.html#2789" class="Bound">P</a> <a id="2938" href="1Lab.Univalence.SIP.Record.Base.html#2912" class="Bound">X</a> <a id="2940" class="Symbol">(</a><a data-type="(fs : RecordFields R₁ ι) → R₁ X → fields→prod fs X" id="2941" href="1Lab.Univalence.SIP.Record.Base.html#1218" class="Function">project-fields</a> <a id="2956" href="1Lab.Univalence.SIP.Record.Base.html#2705" class="Bound">previous-fields</a> <a id="2972" href="1Lab.Univalence.SIP.Record.Base.html#2925" class="Bound">r</a><a id="2973" class="Symbol">))</a>
      <a id="2982" class="Comment">-- ^ Extract a proof of the proposition from the record</a>

      <a id="3045" class="Symbol">→</a> <a data-type="(R₁ : Type ℓ → Type ℓ₁) (ι : IsHomT ℓ₁&#39; R₁)
(fs : RecordFields R₁ ι) →
((X : Type ℓ) → fields→prod fs X → Type ℓ₂) →
Type (lsuc ℓ ⊔ ℓ₁ ⊔ ℓ₂)" id="3047" href="1Lab.Univalence.SIP.Record.Base.html#1422" class="Function">isPropProperty</a> <a id="3062" href="1Lab.Univalence.SIP.Record.Base.html#1757" class="Bound">R</a> <a id="3064" href="1Lab.Univalence.SIP.Record.Base.html#1759" class="Bound">ι</a> <a id="3066" href="1Lab.Univalence.SIP.Record.Base.html#2705" class="Bound">previous-fields</a> <a id="3082" href="1Lab.Univalence.SIP.Record.Base.html#2789" class="Bound">P</a>
      <a id="3090" class="Comment">-- ^ &quot;Preservation datum&quot; (P must be a proposition)</a>

      <a id="3149" class="Symbol">→</a> <a data-type="(R₁ : Type ℓ → Type ℓ₁) → IsHomT ℓ₁&#39; R₁ → Typeω" id="3151" href="1Lab.Univalence.SIP.Record.Base.html#705" class="Datatype">RecordFields</a> <a id="3164" href="1Lab.Univalence.SIP.Record.Base.html#1757" class="Bound">R</a> <a id="3166" href="1Lab.Univalence.SIP.Record.Base.html#1759" class="Bound">ι</a>

  <a data-type="RecordFields R₁ ι → Level" id="3171" href="1Lab.Univalence.SIP.Record.Base.html#823" class="Function">level-of-fields→prod</a> <a data-type="RecordFields R₁ ι" id="3192" href="1Lab.Univalence.SIP.Record.Base.html#1806" class="InductiveConstructor">record:</a> <a id="3200" class="Symbol">=</a> <a data-type="Level" id="3202" href="Agda.Primitive.html#764" class="Primitive">lzero</a>
  <a data-type="RecordFields R₁ ι → Level" id="3210" href="1Lab.Univalence.SIP.Record.Base.html#823" class="Function">level-of-fields→prod</a> <a id="3231" class="Symbol">(</a><a data-type="RecordFields R₁ ι →
(project : R₁ X → S₁ X) →
(ι A B e → ι&#39; (Σ-map₂ project A) (Σ-map₂ project B) e) →
RecordFields R₁ ι" id="3232" href="1Lab.Univalence.SIP.Record.Base.html#1919" class="InductiveConstructor Operator">_field[_by_]</a> <a id="3245" href="1Lab.Univalence.SIP.Record.Base.html#3245" class="Bound">fs</a> <a id="3248" class="Symbol">{</a><a id="3249" class="Argument">ℓ₂</a> <a id="3252" class="Symbol">=</a> <a id="3254" href="1Lab.Univalence.SIP.Record.Base.html#3254" class="Bound">ℓ₂</a><a id="3256" class="Symbol">}</a> <a id="3258" class="Symbol">_</a> <a id="3260" class="Symbol">_)</a> <a id="3263" class="Symbol">=</a>
    <a data-type="RecordFields R₁ ι → Level" id="3269" href="1Lab.Univalence.SIP.Record.Base.html#823" class="Function">level-of-fields→prod</a> <a id="3290" href="1Lab.Univalence.SIP.Record.Base.html#3245" class="Bound">fs</a> <a data-type="Level → Level → Level" id="3293" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="3295" href="1Lab.Univalence.SIP.Record.Base.html#3254" class="Bound">ℓ₂</a>
  <a data-type="RecordFields R₁ ι → Level" id="3300" href="1Lab.Univalence.SIP.Record.Base.html#823" class="Function">level-of-fields→prod</a> <a id="3321" class="Symbol">(</a><a data-type="(previous-fields : RecordFields R₁ ι) →
((r : R₁ X) → P X (project-fields previous-fields r)) →
isPropProperty R₁ ι previous-fields P → RecordFields R₁ ι" id="3322" href="1Lab.Univalence.SIP.Record.Base.html#2683" class="InductiveConstructor Operator">_axiom[_by_]</a> <a id="3335" href="1Lab.Univalence.SIP.Record.Base.html#3335" class="Bound">fs</a> <a id="3338" class="Symbol">{</a><a id="3339" class="Argument">ℓ₂</a> <a id="3342" class="Symbol">=</a> <a id="3344" href="1Lab.Univalence.SIP.Record.Base.html#3344" class="Bound">ℓ₂</a><a id="3346" class="Symbol">}</a> <a id="3348" class="Symbol">_</a> <a id="3350" class="Symbol">_)</a> <a id="3353" class="Symbol">=</a>
    <a data-type="RecordFields R₁ ι → Level" id="3359" href="1Lab.Univalence.SIP.Record.Base.html#823" class="Function">level-of-fields→prod</a> <a id="3380" href="1Lab.Univalence.SIP.Record.Base.html#3335" class="Bound">fs</a> <a data-type="Level → Level → Level" id="3383" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="3385" href="1Lab.Univalence.SIP.Record.Base.html#3344" class="Bound">ℓ₂</a>

  <a data-type="(fields : RecordFields R₁ ι) →
Type ℓ → Type (level-of-fields→prod fields)" id="3391" href="1Lab.Univalence.SIP.Record.Base.html#992" class="Function">fields→prod</a> <a data-type="RecordFields R₁ ι" id="3403" href="1Lab.Univalence.SIP.Record.Base.html#1806" class="InductiveConstructor">record:</a> <a id="3411" class="Symbol">_</a> <a id="3413" class="Symbol">=</a> <a data-type="Type" id="3415" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
  <a data-type="(fields : RecordFields R₁ ι) →
Type ℓ → Type (level-of-fields→prod fields)" id="3419" href="1Lab.Univalence.SIP.Record.Base.html#992" class="Function">fields→prod</a> <a id="3431" class="Symbol">(</a><a data-type="RecordFields R₁ ι →
(project : R₁ X → S₁ X) →
(ι A B e → ι&#39; (Σ-map₂ project A) (Σ-map₂ project B) e) →
RecordFields R₁ ι" id="3432" href="1Lab.Univalence.SIP.Record.Base.html#1919" class="InductiveConstructor Operator">_field[_by_]</a> <a id="3445" href="1Lab.Univalence.SIP.Record.Base.html#3445" class="Bound">fs</a> <a id="3448" class="Symbol">{</a><a id="3449" class="Argument">S</a> <a id="3451" class="Symbol">=</a> <a id="3453" href="1Lab.Univalence.SIP.Record.Base.html#3453" class="Bound">S</a><a id="3454" class="Symbol">}</a> <a id="3456" class="Symbol">_</a> <a id="3458" class="Symbol">_)</a> <a id="3461" href="1Lab.Univalence.SIP.Record.Base.html#3461" class="Bound">X</a> <a id="3463" class="Symbol">=</a>
    <a data-type="(fields : RecordFields R₁ ι) →
Type ℓ → Type (level-of-fields→prod fields)" id="3469" href="1Lab.Univalence.SIP.Record.Base.html#992" class="Function">fields→prod</a> <a id="3481" href="1Lab.Univalence.SIP.Record.Base.html#3445" class="Bound">fs</a> <a id="3484" href="1Lab.Univalence.SIP.Record.Base.html#3461" class="Bound">X</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="3486" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="3488" href="1Lab.Univalence.SIP.Record.Base.html#3453" class="Bound">S</a> <a id="3490" href="1Lab.Univalence.SIP.Record.Base.html#3461" class="Bound">X</a>
  <a data-type="(fields : RecordFields R₁ ι) →
Type ℓ → Type (level-of-fields→prod fields)" id="3494" href="1Lab.Univalence.SIP.Record.Base.html#992" class="Function">fields→prod</a> <a id="3506" class="Symbol">(</a><a data-type="(previous-fields : RecordFields R₁ ι) →
((r : R₁ X) → P X (project-fields previous-fields r)) →
isPropProperty R₁ ι previous-fields P → RecordFields R₁ ι" id="3507" href="1Lab.Univalence.SIP.Record.Base.html#2683" class="InductiveConstructor Operator">_axiom[_by_]</a> <a id="3520" href="1Lab.Univalence.SIP.Record.Base.html#3520" class="Bound">fs</a> <a id="3523" class="Symbol">{</a><a id="3524" class="Argument">P</a> <a id="3526" class="Symbol">=</a> <a id="3528" href="1Lab.Univalence.SIP.Record.Base.html#3528" class="Bound">P</a><a id="3529" class="Symbol">}</a> <a id="3531" class="Symbol">_</a> <a id="3533" class="Symbol">_)</a> <a id="3536" href="1Lab.Univalence.SIP.Record.Base.html#3536" class="Bound">X</a> <a id="3538" class="Symbol">=</a>
    <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="3544" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="3547" href="1Lab.Univalence.SIP.Record.Base.html#3547" class="Bound">S</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="3549" href="1Lab.Type.html#1563" class="Function">∈</a> <a data-type="(fields : RecordFields R₁ ι) →
Type ℓ → Type (level-of-fields→prod fields)" id="3551" href="1Lab.Univalence.SIP.Record.Base.html#992" class="Function">fields→prod</a> <a id="3563" href="1Lab.Univalence.SIP.Record.Base.html#3520" class="Bound">fs</a> <a id="3566" href="1Lab.Univalence.SIP.Record.Base.html#3536" class="Bound">X</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="3568" href="1Lab.Type.html#1563" class="Function">]</a> <a id="3570" class="Symbol">(</a><a id="3571" href="1Lab.Univalence.SIP.Record.Base.html#3528" class="Bound">P</a> <a id="3573" href="1Lab.Univalence.SIP.Record.Base.html#3536" class="Bound">X</a> <a id="3575" href="1Lab.Univalence.SIP.Record.Base.html#3547" class="Bound">S</a><a id="3576" class="Symbol">)</a>

  <a data-type="(fs : RecordFields R₁ ι) → R₁ X → fields→prod fs X" id="3581" href="1Lab.Univalence.SIP.Record.Base.html#1218" class="Function">project-fields</a> <a data-type="RecordFields R₁ ι" id="3596" href="1Lab.Univalence.SIP.Record.Base.html#1806" class="InductiveConstructor">record:</a> <a id="3604" href="1Lab.Univalence.SIP.Record.Base.html#3604" class="Bound">x₁</a> <a id="3607" class="Symbol">=</a> <a data-type="⊤" id="3609" href="Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a>
  <a data-type="(fs : RecordFields R₁ ι) → R₁ X → fields→prod fs X" id="3614" href="1Lab.Univalence.SIP.Record.Base.html#1218" class="Function">project-fields</a> <a id="3629" class="Symbol">(</a><a id="3630" href="1Lab.Univalence.SIP.Record.Base.html#3630" class="Bound">x</a> <a data-type="RecordFields R₁ ι →
(project : R₁ X → S₁ X) →
(ι A B e → ι&#39; (Σ-map₂ project A) (Σ-map₂ project B) e) →
RecordFields R₁ ι" id="3632" href="1Lab.Univalence.SIP.Record.Base.html#1919" class="InductiveConstructor Operator">field[</a> <a id="3639" href="1Lab.Univalence.SIP.Record.Base.html#3639" class="Bound">project</a> <a data-type="RecordFields R₁ ι →
(project : R₁ X → S₁ X) →
(ι A B e → ι&#39; (Σ-map₂ project A) (Σ-map₂ project B) e) →
RecordFields R₁ ι" id="3647" href="1Lab.Univalence.SIP.Record.Base.html#1919" class="InductiveConstructor Operator">by</a> <a id="3650" href="1Lab.Univalence.SIP.Record.Base.html#3650" class="Bound">project-preservation</a> <a data-type="RecordFields R₁ ι →
(project : R₁ X → S₁ X) →
(ι A B e → ι&#39; (Σ-map₂ project A) (Σ-map₂ project B) e) →
RecordFields R₁ ι" id="3671" href="1Lab.Univalence.SIP.Record.Base.html#1919" class="InductiveConstructor Operator">]</a><a id="3672" class="Symbol">)</a> <a id="3674" href="1Lab.Univalence.SIP.Record.Base.html#3674" class="Bound">str</a> <a id="3678" class="Symbol">=</a>
    <a data-type="(fs : RecordFields R₁ ι) → R₁ X → fields→prod fs X" id="3684" href="1Lab.Univalence.SIP.Record.Base.html#1218" class="Function">project-fields</a> <a id="3699" href="1Lab.Univalence.SIP.Record.Base.html#3630" class="Bound">x</a> <a id="3701" href="1Lab.Univalence.SIP.Record.Base.html#3674" class="Bound">str</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="3705" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3707" href="1Lab.Univalence.SIP.Record.Base.html#3639" class="Bound">project</a> <a id="3715" href="1Lab.Univalence.SIP.Record.Base.html#3674" class="Bound">str</a>
  <a data-type="(fs : RecordFields R₁ ι) → R₁ X → fields→prod fs X" id="3721" href="1Lab.Univalence.SIP.Record.Base.html#1218" class="Function">project-fields</a> <a id="3736" class="Symbol">(</a><a id="3737" href="1Lab.Univalence.SIP.Record.Base.html#3737" class="Bound">x</a> <a data-type="(previous-fields : RecordFields R₁ ι) →
((r : R₁ X) → P X (project-fields previous-fields r)) →
isPropProperty R₁ ι previous-fields P → RecordFields R₁ ι" id="3739" href="1Lab.Univalence.SIP.Record.Base.html#2683" class="InductiveConstructor Operator">axiom[</a> <a id="3746" href="1Lab.Univalence.SIP.Record.Base.html#3746" class="Bound">x₂</a> <a data-type="(previous-fields : RecordFields R₁ ι) →
((r : R₁ X) → P X (project-fields previous-fields r)) →
isPropProperty R₁ ι previous-fields P → RecordFields R₁ ι" id="3749" href="1Lab.Univalence.SIP.Record.Base.html#2683" class="InductiveConstructor Operator">by</a> <a id="3752" href="1Lab.Univalence.SIP.Record.Base.html#3752" class="Bound">x₃</a> <a data-type="(previous-fields : RecordFields R₁ ι) →
((r : R₁ X) → P X (project-fields previous-fields r)) →
isPropProperty R₁ ι previous-fields P → RecordFields R₁ ι" id="3755" href="1Lab.Univalence.SIP.Record.Base.html#2683" class="InductiveConstructor Operator">]</a><a id="3756" class="Symbol">)</a> <a id="3758" href="1Lab.Univalence.SIP.Record.Base.html#3758" class="Bound">x₁</a> <a id="3761" class="Symbol">=</a>
    <a id="3767" class="Symbol">(</a><a data-type="(fs : RecordFields R₁ ι) → R₁ X → fields→prod fs X" id="3768" href="1Lab.Univalence.SIP.Record.Base.html#1218" class="Function">project-fields</a> <a id="3783" href="1Lab.Univalence.SIP.Record.Base.html#3737" class="Bound">x</a> <a id="3785" href="1Lab.Univalence.SIP.Record.Base.html#3758" class="Bound">x₁</a><a id="3787" class="Symbol">)</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="3789" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3791" href="1Lab.Univalence.SIP.Record.Base.html#3746" class="Bound">x₂</a> <a id="3794" href="1Lab.Univalence.SIP.Record.Base.html#3758" class="Bound">x₁</a>

<a id="3798" class="Keyword">data</a> <a id="AutoRecord"></a><a data-type="Typeω" id="3803" href="1Lab.Univalence.SIP.Record.Base.html#3803" class="Datatype">AutoRecord</a> <a id="3814" class="Symbol">:</a> <a id="3816" href="1Lab.Type.html#409" class="Primitive">Typeω</a> <a id="3822" class="Keyword">where</a>
  <a id="AutoRecord.autoRecord"></a><a data-type="(R₁ : Type ℓ → Type ℓ₁) (ι : IsHomT ℓ₁&#39; R₁) →
RecordFields R₁ ι → AutoRecord" id="3830" href="1Lab.Univalence.SIP.Record.Base.html#3830" class="InductiveConstructor">autoRecord</a> <a id="3841" class="Symbol">:</a> <a id="3843" class="Symbol">∀</a> <a id="3845" class="Symbol">{</a><a id="3846" href="1Lab.Univalence.SIP.Record.Base.html#3846" class="Bound">ℓ</a> <a id="3848" href="1Lab.Univalence.SIP.Record.Base.html#3848" class="Bound">ℓ₁</a> <a id="3851" href="1Lab.Univalence.SIP.Record.Base.html#3851" class="Bound">ℓ₁&#39;</a><a id="3854" class="Symbol">}</a>
             <a id="3869" class="Symbol">→</a> <a id="3871" class="Symbol">(</a><a id="3872" href="1Lab.Univalence.SIP.Record.Base.html#3872" class="Bound">R</a> <a id="3874" class="Symbol">:</a> <a id="3876" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3881" href="1Lab.Univalence.SIP.Record.Base.html#3846" class="Bound">ℓ</a> <a id="3883" class="Symbol">→</a> <a id="3885" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3890" href="1Lab.Univalence.SIP.Record.Base.html#3848" class="Bound">ℓ₁</a><a id="3892" class="Symbol">)</a> <a id="3894" class="Symbol">(</a><a id="3895" href="1Lab.Univalence.SIP.Record.Base.html#3895" class="Bound">ι</a> <a id="3897" class="Symbol">:</a> <a data-type="(l : Level) → (Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁ ⊔ lsuc l)" id="3899" href="1Lab.Univalence.SIP.Record.Base.html#278" class="Function">IsHomT</a> <a id="3906" href="1Lab.Univalence.SIP.Record.Base.html#3851" class="Bound">ℓ₁&#39;</a> <a id="3910" href="1Lab.Univalence.SIP.Record.Base.html#3872" class="Bound">R</a><a id="3911" class="Symbol">)</a>
             <a id="3926" class="Symbol">→</a> <a data-type="(R₁ : Type ℓ → Type ℓ₁) → IsHomT ℓ₁&#39; R₁ → Typeω" id="3928" href="1Lab.Univalence.SIP.Record.Base.html#705" class="Datatype">RecordFields</a> <a id="3941" href="1Lab.Univalence.SIP.Record.Base.html#3872" class="Bound">R</a> <a id="3943" href="1Lab.Univalence.SIP.Record.Base.html#3895" class="Bound">ι</a>
             <a id="3958" class="Symbol">→</a> <a data-type="Typeω" id="3960" href="1Lab.Univalence.SIP.Record.Base.html#3803" class="Datatype">AutoRecord</a>

  <a id="3974" class="Comment">-- ^ Package a record, notion of structure, and field descriptors onto</a>
  <a id="4047" class="Comment">-- an AutoRecord that the autoUnivalentRecord macro can consume.</a>

<a id="isUnivalent&#39;"></a><a data-type="(S₁ : Type ℓ → Type ℓ₁) → IsHomT ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁ ⊔ ℓ₂)" id="4113" href="1Lab.Univalence.SIP.Record.Base.html#4113" class="Function">isUnivalent&#39;</a> <a id="4126" class="Symbol">:</a> <a id="4128" class="Symbol">∀</a> <a id="4130" class="Symbol">{</a><a id="4131" href="1Lab.Univalence.SIP.Record.Base.html#4131" class="Bound">ℓ</a> <a id="4133" href="1Lab.Univalence.SIP.Record.Base.html#4133" class="Bound">ℓ₁</a> <a id="4136" href="1Lab.Univalence.SIP.Record.Base.html#4136" class="Bound">ℓ₂</a><a id="4138" class="Symbol">}</a> <a id="4140" class="Symbol">(</a><a id="4141" href="1Lab.Univalence.SIP.Record.Base.html#4141" class="Bound">S</a> <a id="4143" class="Symbol">:</a> <a id="4145" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="4150" href="1Lab.Univalence.SIP.Record.Base.html#4131" class="Bound">ℓ</a> <a id="4152" class="Symbol">→</a> <a id="4154" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="4159" href="1Lab.Univalence.SIP.Record.Base.html#4133" class="Bound">ℓ₁</a><a id="4161" class="Symbol">)</a> <a id="4163" class="Symbol">→</a> <a data-type="(l : Level) → (Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁ ⊔ lsuc l)" id="4165" href="1Lab.Univalence.SIP.Record.Base.html#278" class="Function">IsHomT</a> <a id="4172" href="1Lab.Univalence.SIP.Record.Base.html#4136" class="Bound">ℓ₂</a> <a id="4175" href="1Lab.Univalence.SIP.Record.Base.html#4141" class="Bound">S</a> <a id="4177" class="Symbol">→</a> <a id="4179" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="4184" class="Symbol">_</a>
<a data-type="(S₁ : Type ℓ → Type ℓ₁) → IsHomT ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁ ⊔ ℓ₂)" id="4186" href="1Lab.Univalence.SIP.Record.Base.html#4113" class="Function">isUnivalent&#39;</a> <a id="4199" href="1Lab.Univalence.SIP.Record.Base.html#4199" class="Bound">S</a> <a id="4201" href="1Lab.Univalence.SIP.Record.Base.html#4201" class="Bound">ι</a> <a id="4203" class="Symbol">=</a>
  <a id="4207" class="Symbol">∀</a> <a id="4209" class="Symbol">(</a><a id="4210" href="1Lab.Univalence.SIP.Record.Base.html#4210" class="Bound">X</a> <a id="4212" href="1Lab.Univalence.SIP.Record.Base.html#4212" class="Bound">Y</a> <a id="4214" class="Symbol">:</a> <a id="4216" class="Symbol">_)</a>
  <a id="4221" class="Symbol">→</a> <a id="4223" class="Symbol">(</a><a id="4224" href="1Lab.Univalence.SIP.Record.Base.html#4224" class="Bound">f</a> <a id="4226" class="Symbol">:</a> <a id="4228" href="1Lab.Univalence.SIP.Record.Base.html#4210" class="Bound">X</a> <a id="4230" class="Symbol">.</a><a data-type="∑ A B → A" id="4231" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="4235" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="4237" href="1Lab.Univalence.SIP.Record.Base.html#4212" class="Bound">Y</a> <a id="4239" class="Symbol">.</a><a data-type="∑ A B → A" id="4240" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="4243" class="Symbol">)</a>
  <a id="4247" class="Symbol">→</a> <a id="4249" href="1Lab.Univalence.SIP.Record.Base.html#4201" class="Bound">ι</a> <a id="4251" href="1Lab.Univalence.SIP.Record.Base.html#4210" class="Bound">X</a> <a id="4253" href="1Lab.Univalence.SIP.Record.Base.html#4212" class="Bound">Y</a> <a id="4255" href="1Lab.Univalence.SIP.Record.Base.html#4224" class="Bound">f</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="4257" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="4259" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="4265" class="Symbol">(λ</a> <a id="4268" href="1Lab.Univalence.SIP.Record.Base.html#4268" class="Bound">i</a> <a id="4270" class="Symbol">→</a> <a id="4272" href="1Lab.Univalence.SIP.Record.Base.html#4199" class="Bound">S</a> <a id="4274" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="4275" href="1Lab.Univalence.html#8828" class="Function">ua</a> <a id="4278" href="1Lab.Univalence.SIP.Record.Base.html#4224" class="Bound">f</a> <a id="4280" href="1Lab.Univalence.SIP.Record.Base.html#4268" class="Bound">i</a><a id="4281" class="Symbol">))</a> <a id="4284" class="Symbol">(</a><a id="4285" href="1Lab.Univalence.SIP.Record.Base.html#4210" class="Bound">X</a> <a id="4287" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="4288" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="4291" class="Symbol">)</a> <a id="4293" class="Symbol">(</a><a id="4294" href="1Lab.Univalence.SIP.Record.Base.html#4212" class="Bound">Y</a> <a id="4296" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="4297" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="4300" class="Symbol">)</a>

<a id="tm→isHomT"></a><a data-type="StrTm ℓ ℓ₁ S₁ → IsHomT ℓ₁ S₁" id="4303" href="1Lab.Univalence.SIP.Record.Base.html#4303" class="Function">tm→isHomT</a> <a id="4313" class="Symbol">:</a> <a id="4315" class="Symbol">∀</a> <a id="4317" class="Symbol">{</a><a id="4318" href="1Lab.Univalence.SIP.Record.Base.html#4318" class="Bound">ℓ</a> <a id="4320" href="1Lab.Univalence.SIP.Record.Base.html#4320" class="Bound">ℓ₁</a><a id="4322" class="Symbol">}</a> <a id="4324" class="Symbol">{</a><a id="4325" href="1Lab.Univalence.SIP.Record.Base.html#4325" class="Bound">S</a><a id="4326" class="Symbol">}</a> <a id="4328" class="Symbol">(</a><a id="4329" href="1Lab.Univalence.SIP.Record.Base.html#4329" class="Bound">tm</a> <a id="4332" class="Symbol">:</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="4334" href="1Lab.Univalence.SIP.html#24034" class="Datatype">StrTm</a> <a id="4340" href="1Lab.Univalence.SIP.Record.Base.html#4318" class="Bound">ℓ</a> <a id="4342" href="1Lab.Univalence.SIP.Record.Base.html#4320" class="Bound">ℓ₁</a> <a id="4345" href="1Lab.Univalence.SIP.Record.Base.html#4325" class="Bound">S</a><a id="4346" class="Symbol">)</a> <a id="4348" class="Symbol">→</a> <a data-type="(l : Level) → (Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁ ⊔ lsuc l)" id="4350" href="1Lab.Univalence.SIP.Record.Base.html#278" class="Function">IsHomT</a> <a id="4357" href="1Lab.Univalence.SIP.Record.Base.html#4320" class="Bound">ℓ₁</a> <a id="4360" href="1Lab.Univalence.SIP.Record.Base.html#4325" class="Bound">S</a>
<a data-type="StrTm ℓ ℓ₁ S₁ → IsHomT ℓ₁ S₁" id="4362" href="1Lab.Univalence.SIP.Record.Base.html#4303" class="Function">tm→isHomT</a> <a id="4372" href="1Lab.Univalence.SIP.Record.Base.html#4372" class="Bound">tm</a> <a id="4375" class="Symbol">=</a> <a data-type="StrTm ℓ ℓ₁ S₁ → Structure ℓ₁ S₁" id="4377" href="1Lab.Univalence.SIP.html#24679" class="Function">tm→Structure</a> <a id="4390" href="1Lab.Univalence.SIP.Record.Base.html#4372" class="Bound">tm</a> <a id="4393" class="Symbol">.</a><a data-type="Structure ℓ₃ S₁ → (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃" id="4394" href="1Lab.Univalence.SIP.html#2879" class="Field">is-hom</a>

<a id="tm→⌜isUnivalent⌝"></a><a data-type="(tm : StrTm ℓ ℓ₁ S₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="4402" href="1Lab.Univalence.SIP.Record.Base.html#4402" class="Function">tm→⌜isUnivalent⌝</a> <a id="4419" class="Symbol">:</a> <a id="4421" class="Symbol">∀</a> <a id="4423" class="Symbol">{</a><a id="4424" href="1Lab.Univalence.SIP.Record.Base.html#4424" class="Bound">ℓ</a> <a id="4426" href="1Lab.Univalence.SIP.Record.Base.html#4426" class="Bound">ℓ₁</a><a id="4428" class="Symbol">}</a> <a id="4430" class="Symbol">{</a><a id="4431" href="1Lab.Univalence.SIP.Record.Base.html#4431" class="Bound">S</a><a id="4432" class="Symbol">}</a> <a id="4434" class="Symbol">(</a><a id="4435" href="1Lab.Univalence.SIP.Record.Base.html#4435" class="Bound">tm</a> <a id="4438" class="Symbol">:</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="4440" href="1Lab.Univalence.SIP.html#24034" class="Datatype">StrTm</a> <a id="4446" href="1Lab.Univalence.SIP.Record.Base.html#4424" class="Bound">ℓ</a> <a id="4448" href="1Lab.Univalence.SIP.Record.Base.html#4426" class="Bound">ℓ₁</a> <a id="4451" href="1Lab.Univalence.SIP.Record.Base.html#4431" class="Bound">S</a><a id="4452" class="Symbol">)</a> <a id="4454" class="Symbol">→</a> <a id="4456" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="4461" class="Symbol">_</a>
<a data-type="(tm : StrTm ℓ ℓ₁ S₁) → Type (lsuc ℓ ⊔ ℓ₁)" id="4463" href="1Lab.Univalence.SIP.Record.Base.html#4402" class="Function">tm→⌜isUnivalent⌝</a> <a id="4480" href="1Lab.Univalence.SIP.Record.Base.html#4480" class="Bound">tm</a> <a id="4483" class="Symbol">=</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → IsHomT ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁ ⊔ ℓ₂)" id="4485" href="1Lab.Univalence.SIP.Record.Base.html#4113" class="Function">isUnivalent&#39;</a> <a id="4498" class="Symbol">_</a> <a id="4500" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → IsHomT ℓ₁ S₁" id="4501" href="1Lab.Univalence.SIP.Record.Base.html#4303" class="Function">tm→isHomT</a> <a id="4511" href="1Lab.Univalence.SIP.Record.Base.html#4480" class="Bound">tm</a><a id="4513" class="Symbol">)</a>

<a id="tm→isUnivalent&#39;"></a><a data-type="(tm : StrTm ℓ ℓ₁ S₁) → isUnivalent&#39; S₁ (tm→isHomT tm)" id="4516" href="1Lab.Univalence.SIP.Record.Base.html#4516" class="Function">tm→isUnivalent&#39;</a> <a id="4532" class="Symbol">:</a> <a id="4534" class="Symbol">∀</a> <a id="4536" class="Symbol">{</a><a id="4537" href="1Lab.Univalence.SIP.Record.Base.html#4537" class="Bound">ℓ</a> <a id="4539" href="1Lab.Univalence.SIP.Record.Base.html#4539" class="Bound">ℓ₁</a><a id="4541" class="Symbol">}</a> <a id="4543" class="Symbol">{</a><a id="4544" href="1Lab.Univalence.SIP.Record.Base.html#4544" class="Bound">S</a><a id="4545" class="Symbol">}</a> <a id="4547" class="Symbol">(</a><a id="4548" href="1Lab.Univalence.SIP.Record.Base.html#4548" class="Bound">tm</a> <a id="4551" class="Symbol">:</a> <a data-type="(ℓ ℓ₁ : Level) → (Type ℓ → Type ℓ₁) → Typeω" id="4553" href="1Lab.Univalence.SIP.html#24034" class="Datatype">StrTm</a> <a id="4559" href="1Lab.Univalence.SIP.Record.Base.html#4537" class="Bound">ℓ</a> <a id="4561" href="1Lab.Univalence.SIP.Record.Base.html#4539" class="Bound">ℓ₁</a> <a id="4564" href="1Lab.Univalence.SIP.Record.Base.html#4544" class="Bound">S</a><a id="4565" class="Symbol">)</a> <a id="4567" class="Symbol">→</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → IsHomT ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁ ⊔ ℓ₂)" id="4569" href="1Lab.Univalence.SIP.Record.Base.html#4113" class="Function">isUnivalent&#39;</a> <a id="4582" href="1Lab.Univalence.SIP.Record.Base.html#4544" class="Bound">S</a> <a id="4584" class="Symbol">(</a><a data-type="StrTm ℓ ℓ₁ S₁ → IsHomT ℓ₁ S₁" id="4585" href="1Lab.Univalence.SIP.Record.Base.html#4303" class="Function">tm→isHomT</a> <a id="4595" href="1Lab.Univalence.SIP.Record.Base.html#4548" class="Bound">tm</a><a id="4597" class="Symbol">)</a>
<a data-type="(tm : StrTm ℓ ℓ₁ S₁) → isUnivalent&#39; S₁ (tm→isHomT tm)" id="4599" href="1Lab.Univalence.SIP.Record.Base.html#4516" class="Function">tm→isUnivalent&#39;</a> <a id="4615" href="1Lab.Univalence.SIP.Record.Base.html#4615" class="Bound">tm</a> <a id="4618" href="1Lab.Univalence.SIP.Record.Base.html#4618" class="Bound">X</a> <a id="4620" href="1Lab.Univalence.SIP.Record.Base.html#4620" class="Bound">Y</a> <a id="4622" href="1Lab.Univalence.SIP.Record.Base.html#4622" class="Bound">f</a> <a id="4624" class="Symbol">=</a> <a data-type="(s : StrTm ℓ ℓ₁ S₁) → isUnivalent (tm→Structure s)" id="4626" href="1Lab.Univalence.SIP.html#26498" class="Function">tm→Structure-univalent</a> <a id="4649" href="1Lab.Univalence.SIP.Record.Base.html#4615" class="Bound">tm</a> <a id="4652" href="1Lab.Univalence.SIP.Record.Base.html#4622" class="Bound">f</a>

<a id="isUnivalent&#39;→isUnivalent"></a><a data-type="(S₁ : Type ℓ → Type ℓ₁) (ι : IsHomT ℓ₂ S₁) →
isUnivalent&#39; S₁ ι → isUnivalent (HomT→Str ι)" id="4655" href="1Lab.Univalence.SIP.Record.Base.html#4655" class="Function">isUnivalent&#39;→isUnivalent</a>
  <a id="4682" class="Symbol">:</a> <a id="4684" class="Symbol">∀</a> <a id="4686" class="Symbol">{</a><a id="4687" href="1Lab.Univalence.SIP.Record.Base.html#4687" class="Bound">ℓ</a> <a id="4689" href="1Lab.Univalence.SIP.Record.Base.html#4689" class="Bound">ℓ₁</a> <a id="4692" href="1Lab.Univalence.SIP.Record.Base.html#4692" class="Bound">ℓ₂</a> <a id="4695" class="Symbol">:</a> <a data-type="Type" id="4697" href="Agda.Primitive.html#597" class="Postulate">Level</a><a id="4702" class="Symbol">}</a> <a id="4704" class="Symbol">(</a><a id="4705" href="1Lab.Univalence.SIP.Record.Base.html#4705" class="Bound">S</a> <a id="4707" class="Symbol">:</a> <a id="4709" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="4714" href="1Lab.Univalence.SIP.Record.Base.html#4687" class="Bound">ℓ</a> <a id="4716" class="Symbol">→</a> <a id="4718" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="4723" href="1Lab.Univalence.SIP.Record.Base.html#4689" class="Bound">ℓ₁</a><a id="4725" class="Symbol">)</a>
  <a id="4729" class="Symbol">→</a> <a id="4731" class="Symbol">(</a><a id="4732" href="1Lab.Univalence.SIP.Record.Base.html#4732" class="Bound">ι</a> <a id="4734" class="Symbol">:</a> <a data-type="(l : Level) → (Type ℓ → Type ℓ₁) → Type (lsuc ℓ ⊔ ℓ₁ ⊔ lsuc l)" id="4736" href="1Lab.Univalence.SIP.Record.Base.html#278" class="Function">IsHomT</a> <a id="4743" href="1Lab.Univalence.SIP.Record.Base.html#4692" class="Bound">ℓ₂</a> <a id="4746" href="1Lab.Univalence.SIP.Record.Base.html#4705" class="Bound">S</a><a id="4747" class="Symbol">)</a>
  <a id="4751" class="Symbol">→</a> <a data-type="(S₁ : Type ℓ → Type ℓ₁) → IsHomT ℓ₂ S₁ → Type (lsuc ℓ ⊔ ℓ₁ ⊔ ℓ₂)" id="4753" href="1Lab.Univalence.SIP.Record.Base.html#4113" class="Function">isUnivalent&#39;</a> <a id="4766" href="1Lab.Univalence.SIP.Record.Base.html#4705" class="Bound">S</a> <a id="4768" href="1Lab.Univalence.SIP.Record.Base.html#4732" class="Bound">ι</a>
  <a id="4772" class="Symbol">→</a> <a data-type="Structure ℓ S₁ → Type (ℓ ⊔ lsuc S.ℓ ⊔ S.ℓ₁)" id="4774" href="1Lab.Univalence.SIP.html#3849" class="Function">isUnivalent</a> <a id="4786" class="Symbol">{</a><a id="4787" class="Argument">ℓ</a> <a id="4789" class="Symbol">=</a> <a id="4791" href="1Lab.Univalence.SIP.Record.Base.html#4692" class="Bound">ℓ₂</a><a id="4793" class="Symbol">}</a> <a id="4795" class="Symbol">{</a><a id="4796" class="Argument">S</a> <a id="4798" class="Symbol">=</a> <a id="4800" href="1Lab.Univalence.SIP.Record.Base.html#4705" class="Bound">S</a><a id="4801" class="Symbol">}</a> <a id="4803" class="Symbol">(</a><a data-type="(is-hom₁ : (A B : Σ S₁) → A .fst ≃ B .fst → Type ℓ₃) →
Structure ℓ₃ S₁" id="4804" href="1Lab.Univalence.SIP.html#2054" class="InductiveConstructor">HomT→Str</a> <a id="4813" href="1Lab.Univalence.SIP.Record.Base.html#4732" class="Bound">ι</a><a id="4814" class="Symbol">)</a>
<a data-type="(S₁ : Type ℓ → Type ℓ₁) (ι : IsHomT ℓ₂ S₁) →
isUnivalent&#39; S₁ ι → isUnivalent (HomT→Str ι)" id="4816" href="1Lab.Univalence.SIP.Record.Base.html#4655" class="Function">isUnivalent&#39;→isUnivalent</a> <a id="4841" href="1Lab.Univalence.SIP.Record.Base.html#4841" class="Bound">S</a> <a id="4843" href="1Lab.Univalence.SIP.Record.Base.html#4843" class="Bound">ι</a> <a id="4845" href="1Lab.Univalence.SIP.Record.Base.html#4845" class="Bound">ua</a> <a id="4848" class="Symbol">{</a><a id="4849" href="1Lab.Univalence.SIP.Record.Base.html#4849" class="Bound">X</a><a id="4850" class="Symbol">}</a> <a id="4852" class="Symbol">{</a><a id="4853" href="1Lab.Univalence.SIP.Record.Base.html#4853" class="Bound">Y</a><a id="4854" class="Symbol">}</a> <a id="4856" class="Symbol">=</a> <a id="4858" href="1Lab.Univalence.SIP.Record.Base.html#4845" class="Bound">ua</a> <a id="4861" href="1Lab.Univalence.SIP.Record.Base.html#4849" class="Bound">X</a> <a id="4863" href="1Lab.Univalence.SIP.Record.Base.html#4853" class="Bound">Y</a>

<a id="4866" class="Keyword">record</a> <a id="TypedTm"></a><a data-type="Type" id="4873" href="1Lab.Univalence.SIP.Record.Base.html#4873" class="Record">TypedTm</a> <a id="4881" class="Symbol">:</a> <a id="4883" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="4888" class="Keyword">where</a>
  <a id="4896" class="Keyword">field</a> <a id="TypedTm.type"></a><a data-type="TypedTm → Term" id="4902" href="1Lab.Univalence.SIP.Record.Base.html#4902" class="Field">type</a> <a id="4907" class="Symbol">:</a> <a data-type="Type" id="4909" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
        <a id="TypedTm.term"></a><a data-type="TypedTm → Term" id="4922" href="1Lab.Univalence.SIP.Record.Base.html#4922" class="Field">term</a> <a id="4927" class="Symbol">:</a> <a data-type="Type" id="4929" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>

<a id="4935" class="Keyword">data</a> <a id="InternalField"></a><a data-type="Type" id="4940" href="1Lab.Univalence.SIP.Record.Base.html#4940" class="Datatype">InternalField</a> <a id="4954" class="Symbol">:</a> <a id="4956" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="4961" class="Keyword">where</a>
  <a id="InternalField.structureField"></a><a data-type="Name → Name → InternalField" id="4969" href="1Lab.Univalence.SIP.Record.Base.html#4969" class="InductiveConstructor">structureField</a> <a id="4984" class="Symbol">:</a> <a data-type="Type" id="4986" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="4991" class="Symbol">→</a> <a data-type="Type" id="4993" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="4998" class="Symbol">→</a> <a data-type="Type" id="5000" href="1Lab.Univalence.SIP.Record.Base.html#4940" class="Datatype">InternalField</a>
  <a id="InternalField.propertyField"></a><a data-type="Name → InternalField" id="5016" href="1Lab.Univalence.SIP.Record.Base.html#5016" class="InductiveConstructor">propertyField</a> <a id="5030" class="Symbol">:</a> <a data-type="Type" id="5032" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="5037" class="Symbol">→</a> <a data-type="Type" id="5039" href="1Lab.Univalence.SIP.Record.Base.html#4940" class="Datatype">InternalField</a>

<a id="5054" class="Keyword">record</a> <a id="Spec"></a><a data-type="(A : Type) → Type" id="5061" href="1Lab.Univalence.SIP.Record.Base.html#5061" class="Record">Spec</a> <a id="5066" class="Symbol">(</a><a id="5067" href="1Lab.Univalence.SIP.Record.Base.html#5067" class="Bound">A</a> <a id="5069" class="Symbol">:</a> <a id="5071" href="1Lab.Type.html#394" class="Primitive">Type</a><a id="5075" class="Symbol">)</a> <a id="5077" class="Symbol">:</a> <a id="5079" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="5084" class="Keyword">where</a>
  <a id="5092" class="Keyword">field</a>
    <a id="Spec.structure"></a><a data-type="Spec A → Term" id="5102" href="1Lab.Univalence.SIP.Record.Base.html#5102" class="Field">structure</a>    <a id="5115" class="Symbol">:</a> <a data-type="Type" id="5117" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
    <a id="Spec.homomorphism"></a><a data-type="Spec A → Term" id="5126" href="1Lab.Univalence.SIP.Record.Base.html#5126" class="Field">homomorphism</a> <a id="5139" class="Symbol">:</a> <a data-type="Type" id="5141" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
    <a id="Spec.fields"></a><a data-type="Spec A → List (InternalField × A)" id="5150" href="1Lab.Univalence.SIP.Record.Base.html#5150" class="Field">fields</a> <a id="5157" class="Symbol">:</a> <a data-type="Type a → Type a" id="5159" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="5164" class="Symbol">(</a><a data-type="Type" id="5165" href="1Lab.Univalence.SIP.Record.Base.html#4940" class="Datatype">InternalField</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="5179" href="1Lab.Type.html#1836" class="Function Operator">×</a> <a id="5181" href="1Lab.Univalence.SIP.Record.Base.html#5067" class="Bound">A</a><a id="5182" class="Symbol">)</a>
</pre></body></html>