<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>1Lab.Equiv - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />
  <link rel="stylesheet" href="/css/agda-cats.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="1Lab.Equiv - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="1Lab.Equiv - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script src="/equations.js"></script>
  <script src="/highlight-hover.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>
</head>

<body>
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">1Lab.Equiv</a>
              </h3>

      <!-- Cube logo -->
      <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#equivalences"><a href="#equivalences" class="header-link">Equivalences<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#is-equiv-is-propositional"><a href="#is-equiv-is-propositional" class="header-link">is-equiv is propositional<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#isomorphisms-from-equivalences"><a href="#isomorphisms-from-equivalences" class="header-link">Isomorphisms from equivalences<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#equivalences-from-isomorphisms"><a href="#equivalences-from-isomorphisms" class="header-link">Equivalences from isomorphisms<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#equivalence-reasoning"><a href="#equivalence-reasoning" class="header-link">Equivalence Reasoning<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#propositional-extensionality"><a href="#propositional-extensionality" class="header-link">Propositional Extensionality<span class="header-link-emoji">🔗</span></a></a></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
              <a href="index.html">️back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/29922faf18cde06919e28d7f9372ac7cc93158e7/src/1Lab/Equiv.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="index.html">️back to index</a>
      </div>
      
      <!-- Font toggle checkbox -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="1Lab.HLevel.html" class="Module">1Lab.HLevel</a>
<a id="33" class="Keyword">open</a> <a id="38" class="Keyword">import</a> <a id="45" href="1Lab.Path.html" class="Module">1Lab.Path</a>
<a id="55" class="Keyword">open</a> <a id="60" class="Keyword">import</a> <a id="67" href="1Lab.Type.html" class="Module">1Lab.Type</a>

<a id="78" class="Keyword">open</a> <a data-type="(A : Type ℓ) → Type ℓ" id="83" href="1Lab.HLevel.html#1328" class="Module">is-contr</a>

<a id="93" class="Keyword">module</a> <a id="100" href="1Lab.Equiv.html" class="Module">1Lab.Equiv</a> <a id="111" class="Keyword">where</a>
</pre>
<h1 id="equivalences"><a href="#equivalences" class="header-link">Equivalences<span class="header-link-emoji">🔗</span></a></h1>
<p>The big idea of homotopy type theory is that isomorphic types can be identified: the <a href="1Lab.Univalence.html">univalence axiom</a>. However, the notion of <span class="Agda"><a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" href="1Lab.Equiv.html#6049" class="Record">isomorphism</a></span>, is, in a sense, not “coherent” enough to be used in the definition. For that, we need a coherent definition of <em>equivalence</em>, where “being an equivalence” is <a data-type="Type ℓ → Type ℓ" href="1Lab.HLevel.html#2597">a proposition</a>.</p>
<p>To be more specific, what we need for a notion of equivalence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mo>−</mo><mi mathvariant="normal">e</mi><mi mathvariant="normal">q</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">v</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{is-equiv}(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">is</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm" style="margin-right:0.01389em;">equiv</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span> to be “coherent” is:</p>
<ul>
<li><p>Being an <span class="Agda"><a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" href="1Lab.Equiv.html#6049" class="Record">isomorphism</a></span> implies being an <span class="Agda"><a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" href="1Lab.Equiv.html#2306" class="Record">equivalence</a></span> (<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mo>−</mo><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">o</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>→</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mo>−</mo><mi mathvariant="normal">e</mi><mi mathvariant="normal">q</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">v</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{is-iso}(f) \to \mathrm{is-equiv}(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">is</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm">iso</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">is</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm" style="margin-right:0.01389em;">equiv</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>)</span></p></li>
<li><p>Being an equivalence implies being an isomorphism (<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mo>−</mo><mi mathvariant="normal">e</mi><mi mathvariant="normal">q</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">v</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>→</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mo>−</mo><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">o</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{is-equiv}(f) \to \mathrm{is-iso}(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">is</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm" style="margin-right:0.01389em;">equiv</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">is</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm">iso</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>);</span> Taken together with the first point we may summarise: “Being an equivalence and being an isomorphism are logically equivalent.”</p></li>
<li><p>Most importantly, being an equivalence <em>must</em> be a proposition.</p></li>
</ul>
<p>The notion we adopt is due to Voevodsky: An equivalence is one that has <span class="Agda"><a data-type="(A : Type ℓ) → Type ℓ" href="1Lab.HLevel.html#1328" class="Module">contractible</a></span> <span class="Agda"><a data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" href="1Lab.Equiv.html#1893" class="Function">fibres</a></span>. Other definitions are possible (e.g.: <a href="1Lab.Equiv.Biinv.html">bi-inverible maps</a>) — but contractible fibres are “privileged” in Cubical Agda because for <a href="1Lab.Univalence.html#Glue">glueing</a> to work, we need a proof that <span class="Agda"><a data-type="(A : Type a) (B₁ : Type b) (w : A ≃ B₁) (a : B₁) (ψ : I) →
Partial ψ (fibre (w .fst) a) → fibre (w .fst) a" href="1Lab.Equiv.html#3694" class="Function">equivalences have contractible fibres</a></span> anyway.</p>
<pre class="Agda"><a id="1567" class="Keyword">private</a>
  <a id="1577" class="Keyword">variable</a>
    <a id="1590" href="1Lab.Equiv.html#1590" class="Generalizable">ℓ₁</a> <a id="1593" href="1Lab.Equiv.html#1593" class="Generalizable">ℓ₂</a> <a id="1596" class="Symbol">:</a> <a data-type="Type" id="1598" href="Agda.Primitive.html#597" class="Postulate">Level</a>
    <a id="1608" href="1Lab.Equiv.html#1608" class="Generalizable">A</a> <a id="1610" href="1Lab.Equiv.html#1610" class="Generalizable">B</a> <a id="1612" class="Symbol">:</a> <a id="1614" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="1619" href="1Lab.Equiv.html#1590" class="Generalizable">ℓ₁</a>
</pre>
<p>A <em>homotopy fibre</em>, <em>fibre</em> or <em>preimage</em> of a function <code>f</code> at a point <code>y : B</code> is the collection of all elements of <code>A</code> that <code>f</code> maps to <code>y</code>. Since many choices of name are possible, we settle on the one that is shortest and most aesthetic: <span class="Agda"><a data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" href="1Lab.Equiv.html#1893" class="Function">fibre</a></span>.</p>
<pre class="Agda"><a id="fibre"></a><a data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="1893" href="1Lab.Equiv.html#1893" class="Function">fibre</a> <a id="1899" class="Symbol">:</a> <a id="1901" class="Symbol">(</a><a id="1902" href="1Lab.Equiv.html#1608" class="Generalizable">A</a> <a id="1904" class="Symbol">→</a> <a id="1906" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="1907" class="Symbol">)</a> <a id="1909" class="Symbol">→</a> <a id="1911" href="1Lab.Equiv.html#1610" class="Generalizable">B</a> <a id="1913" class="Symbol">→</a> <a id="1915" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="1920" class="Symbol">_</a>
<a data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="1922" href="1Lab.Equiv.html#1893" class="Function">fibre</a> <a id="1928" href="1Lab.Equiv.html#1928" class="Bound">f</a> <a id="1930" href="1Lab.Equiv.html#1930" class="Bound">y</a> <a id="1932" class="Symbol">=</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="1934" href="1Lab.Type.html#1573" class="Function">Σ</a> <a id="1936" class="Symbol">λ</a> <a id="1938" href="1Lab.Equiv.html#1938" class="Bound">x</a> <a id="1940" class="Symbol">→</a> <a id="1942" href="1Lab.Equiv.html#1928" class="Bound">f</a> <a id="1944" href="1Lab.Equiv.html#1938" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="1946" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="1948" href="1Lab.Equiv.html#1930" class="Bound">y</a>
</pre>
<p>A function <code>f</code> is an equivalence if every one of its fibres is <a data-type="(A : Type ℓ) → Type ℓ" href="1Lab.HLevel.html#1328">contractible</a> - that is, for any element <code>y</code> in the range, there is exactly one element in the domain which <code>f</code> maps to <code>y</code>. Using set-theoretic language, <code>f</code> is an equivalence if the preimage of every element of the codomain is a singleton.</p>
<pre class="Agda"><a id="2299" class="Keyword">record</a> <a id="is-equiv"></a><a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="2306" href="1Lab.Equiv.html#2306" class="Record">is-equiv</a> <a id="2315" class="Symbol">(</a><a id="2316" href="1Lab.Equiv.html#2316" class="Bound">f</a> <a id="2318" class="Symbol">:</a> <a id="2320" href="1Lab.Equiv.html#1608" class="Generalizable">A</a> <a id="2322" class="Symbol">→</a> <a id="2324" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="2325" class="Symbol">)</a> <a id="2327" class="Symbol">:</a> <a id="2329" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2334" class="Symbol">(</a><a data-type="Type ℓ → Level" id="2335" href="1Lab.Type.html#921" class="Function">level-of</a> <a id="2344" href="1Lab.Equiv.html#2320" class="Bound">A</a> <a data-type="Level → Level → Level" id="2346" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a data-type="Type ℓ → Level" id="2348" href="1Lab.Type.html#921" class="Function">level-of</a> <a id="2357" href="1Lab.Equiv.html#2324" class="Bound">B</a><a id="2358" class="Symbol">)</a> <a id="2360" class="Keyword">where</a>
  <a id="2368" class="Keyword">no-eta-equality</a>
  <a id="2386" class="Keyword">field</a>
    <a id="is-equiv.is-eqv"></a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="2396" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="2403" class="Symbol">:</a> <a id="2405" class="Symbol">(</a><a id="2406" href="1Lab.Equiv.html#2406" class="Bound">y</a> <a id="2408" class="Symbol">:</a> <a id="2410" href="1Lab.Equiv.html#2324" class="Bound">B</a><a id="2411" class="Symbol">)</a> <a id="2413" class="Symbol">→</a> <a data-type="(A : Type ℓ) → Type ℓ" id="2415" href="1Lab.HLevel.html#1328" class="Record">is-contr</a> <a id="2424" class="Symbol">(</a><a data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="2425" href="1Lab.Equiv.html#1893" class="Function">fibre</a> <a id="2431" href="1Lab.Equiv.html#2316" class="Bound">f</a> <a id="2433" href="1Lab.Equiv.html#2406" class="Bound">y</a><a id="2434" class="Symbol">)</a>

<a id="2437" class="Keyword">open</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="2442" href="1Lab.Equiv.html#2306" class="Module">is-equiv</a> <a id="2451" class="Keyword">public</a>

<a id="_≃_"></a><a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="2459" href="1Lab.Equiv.html#2459" class="Function Operator">_≃_</a> <a id="2463" class="Symbol">:</a> <a id="2465" class="Symbol">∀</a> <a id="2467" class="Symbol">{</a><a id="2468" href="1Lab.Equiv.html#2468" class="Bound">ℓ₁</a> <a id="2471" href="1Lab.Equiv.html#2471" class="Bound">ℓ₂</a><a id="2473" class="Symbol">}</a> <a id="2475" class="Symbol">→</a> <a id="2477" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2482" href="1Lab.Equiv.html#2468" class="Bound">ℓ₁</a> <a id="2485" class="Symbol">→</a> <a id="2487" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2492" href="1Lab.Equiv.html#2471" class="Bound">ℓ₂</a> <a id="2495" class="Symbol">→</a> <a id="2497" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2502" class="Symbol">_</a>
<a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="2504" href="1Lab.Equiv.html#2459" class="Function Operator">_≃_</a> <a id="2508" href="1Lab.Equiv.html#2508" class="Bound">A</a> <a id="2510" href="1Lab.Equiv.html#2510" class="Bound">B</a> <a id="2512" class="Symbol">=</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="2514" href="1Lab.Type.html#1573" class="Function">Σ</a> <a id="2516" class="Symbol">(</a><a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="2517" href="1Lab.Equiv.html#2306" class="Record">is-equiv</a> <a id="2526" class="Symbol">{</a><a id="2527" class="Argument">A</a> <a id="2529" class="Symbol">=</a> <a id="2531" href="1Lab.Equiv.html#2508" class="Bound">A</a><a id="2532" class="Symbol">}</a> <a id="2534" class="Symbol">{</a><a id="2535" class="Argument">B</a> <a id="2537" class="Symbol">=</a> <a id="2539" href="1Lab.Equiv.html#2510" class="Bound">B</a><a id="2540" class="Symbol">})</a>

<a id="id-equiv"></a><a data-type="is-equiv (λ x → x)" id="2544" href="1Lab.Equiv.html#2544" class="Function">id-equiv</a> <a id="2553" class="Symbol">:</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="2555" href="1Lab.Equiv.html#2306" class="Record">is-equiv</a> <a id="2564" class="Symbol">{</a><a id="2565" class="Argument">A</a> <a id="2567" class="Symbol">=</a> <a id="2569" href="1Lab.Equiv.html#1608" class="Generalizable">A</a><a id="2570" class="Symbol">}</a> <a id="2572" class="Symbol">(λ</a> <a id="2575" href="1Lab.Equiv.html#2575" class="Bound">x</a> <a id="2577" class="Symbol">→</a> <a id="2579" href="1Lab.Equiv.html#2575" class="Bound">x</a><a id="2580" class="Symbol">)</a>
<a data-type="is-equiv (λ x → x)" id="2582" href="1Lab.Equiv.html#2544" class="Function">id-equiv</a> <a id="2591" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="2592" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="2599" href="1Lab.Equiv.html#2599" class="Bound">y</a> <a id="2601" class="Symbol">=</a> 
  <a data-type="(centre₁ : A) (paths₁ : (x : A) → centre₁ ≡ x) → is-contr A" id="2606" href="1Lab.HLevel.html#1383" class="InductiveConstructor">contr</a> <a id="2612" class="Symbol">(</a><a id="2613" href="1Lab.Equiv.html#2599" class="Bound">y</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="2615" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2617" class="Symbol">λ</a> <a id="2619" href="1Lab.Equiv.html#2619" class="Bound">i</a> <a id="2621" class="Symbol">→</a> <a id="2623" href="1Lab.Equiv.html#2599" class="Bound">y</a><a id="2624" class="Symbol">)</a> 
    <a id="2631" class="Symbol">λ</a> <a id="2633" class="Symbol">{</a> <a id="2635" class="Symbol">(</a><a id="2636" href="1Lab.Equiv.html#2636" class="Bound">y&#39;</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="2639" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2641" href="1Lab.Equiv.html#2641" class="Bound">p</a><a id="2642" class="Symbol">)</a> <a id="2644" href="1Lab.Equiv.html#2644" class="Bound">i</a> <a id="2646" class="Symbol">→</a> <a id="2648" href="1Lab.Equiv.html#2641" class="Bound">p</a> <a id="2650" class="Symbol">(</a><a id="2651" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="2653" href="1Lab.Equiv.html#2644" class="Bound">i</a><a id="2654" class="Symbol">)</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="2656" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2658" class="Symbol">λ</a> <a id="2660" href="1Lab.Equiv.html#2660" class="Bound">j</a> <a id="2662" class="Symbol">→</a> <a id="2664" href="1Lab.Equiv.html#2641" class="Bound">p</a> <a id="2666" class="Symbol">(</a><a id="2667" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="2669" href="1Lab.Equiv.html#2644" class="Bound">i</a> <a id="2671" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="2673" href="1Lab.Equiv.html#2660" class="Bound">j</a><a id="2674" class="Symbol">)</a> <a id="2676" class="Symbol">}</a> 
</pre>
<!--
<pre class="Agda"><a id="2693" class="Comment">-- This helper is for functions f, g that cancel eachother, up to</a>
<a id="2759" class="Comment">-- definitional equality, without any case analysis on the argument:</a>

<a id="strict-fibres"></a><a id="2829" href="1Lab.Equiv.html#2829" class="Function">strict-fibres</a> <a id="2843" class="Symbol">:</a> <a id="2845" class="Symbol">∀</a> <a id="2847" class="Symbol">{</a><a id="2848" href="1Lab.Equiv.html#2848" class="Bound">ℓ</a> <a id="2850" href="1Lab.Equiv.html#2850" class="Bound">ℓ&#39;</a><a id="2852" class="Symbol">}</a> <a id="2854" class="Symbol">{</a><a id="2855" href="1Lab.Equiv.html#2855" class="Bound">A</a> <a id="2857" class="Symbol">:</a> <a id="2859" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2864" href="1Lab.Equiv.html#2848" class="Bound">ℓ</a><a id="2865" class="Symbol">}</a> <a id="2867" class="Symbol">{</a><a id="2868" href="1Lab.Equiv.html#2868" class="Bound">B</a> <a id="2870" class="Symbol">:</a> <a id="2872" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2877" href="1Lab.Equiv.html#2850" class="Bound">ℓ&#39;</a><a id="2879" class="Symbol">}</a> <a id="2881" class="Symbol">{</a><a id="2882" href="1Lab.Equiv.html#2882" class="Bound">f</a> <a id="2884" class="Symbol">:</a> <a id="2886" href="1Lab.Equiv.html#2855" class="Bound">A</a> <a id="2888" class="Symbol">→</a> <a id="2890" href="1Lab.Equiv.html#2868" class="Bound">B</a><a id="2891" class="Symbol">}</a> <a id="2893" class="Symbol">(</a><a id="2894" href="1Lab.Equiv.html#2894" class="Bound">g</a> <a id="2896" class="Symbol">:</a> <a id="2898" href="1Lab.Equiv.html#2868" class="Bound">B</a> <a id="2900" class="Symbol">→</a> <a id="2902" href="1Lab.Equiv.html#2855" class="Bound">A</a><a id="2903" class="Symbol">)</a> <a id="2905" class="Symbol">(</a><a id="2906" href="1Lab.Equiv.html#2906" class="Bound">b</a> <a id="2908" class="Symbol">:</a> <a id="2910" href="1Lab.Equiv.html#2868" class="Bound">B</a><a id="2911" class="Symbol">)</a>
  <a id="2915" class="Symbol">→</a> <a id="2917" href="1Lab.Type.html#1573" class="Function">Σ[</a> <a id="2920" href="1Lab.Equiv.html#2920" class="Bound">t</a> <a id="2922" href="1Lab.Type.html#1573" class="Function">∈</a> <a id="2924" href="1Lab.Equiv.html#1893" class="Function">fibre</a> <a id="2930" href="1Lab.Equiv.html#2882" class="Bound">f</a> <a id="2932" class="Symbol">(</a><a id="2933" href="1Lab.Equiv.html#2882" class="Bound">f</a> <a id="2935" class="Symbol">(</a><a id="2936" href="1Lab.Equiv.html#2894" class="Bound">g</a> <a id="2938" href="1Lab.Equiv.html#2906" class="Bound">b</a><a id="2939" class="Symbol">))</a> <a id="2942" href="1Lab.Type.html#1573" class="Function">]</a>
    <a id="2948" class="Symbol">((</a><a id="2950" href="1Lab.Equiv.html#2950" class="Bound">t&#39;</a> <a id="2953" class="Symbol">:</a> <a id="2955" href="1Lab.Equiv.html#1893" class="Function">fibre</a> <a id="2961" href="1Lab.Equiv.html#2882" class="Bound">f</a> <a id="2963" href="1Lab.Equiv.html#2906" class="Bound">b</a><a id="2964" class="Symbol">)</a> <a id="2966" class="Symbol">→</a> <a id="2968" href="1Lab.Path.html#2466" class="Function">Path</a> <a id="2973" class="Symbol">(</a><a id="2974" href="1Lab.Equiv.html#1893" class="Function">fibre</a> <a id="2980" href="1Lab.Equiv.html#2882" class="Bound">f</a> <a id="2982" class="Symbol">(</a><a id="2983" href="1Lab.Equiv.html#2882" class="Bound">f</a> <a id="2985" class="Symbol">(</a><a id="2986" href="1Lab.Equiv.html#2894" class="Bound">g</a> <a id="2988" href="1Lab.Equiv.html#2906" class="Bound">b</a><a id="2989" class="Symbol">)))</a> <a id="2993" href="1Lab.Equiv.html#2920" class="Bound">t</a>
                          <a id="3021" class="Symbol">(</a><a id="3022" href="1Lab.Equiv.html#2894" class="Bound">g</a> <a id="3024" class="Symbol">(</a><a id="3025" href="1Lab.Equiv.html#2882" class="Bound">f</a> <a id="3027" class="Symbol">(</a><a id="3028" href="1Lab.Equiv.html#2950" class="Bound">t&#39;</a> <a id="3031" class="Symbol">.</a><a id="3032" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="3035" class="Symbol">))</a> <a id="3038" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3040" href="1Lab.Path.html#20830" class="Function">ap</a> <a id="3043" class="Symbol">(</a><a id="3044" href="1Lab.Equiv.html#2882" class="Bound">f</a> <a id="3046" href="1Lab.Type.html#2227" class="Function Operator">∘</a> <a id="3048" href="1Lab.Equiv.html#2894" class="Bound">g</a><a id="3049" class="Symbol">)</a> <a id="3051" class="Symbol">(</a><a id="3052" href="1Lab.Equiv.html#2950" class="Bound">t&#39;</a> <a id="3055" class="Symbol">.</a><a id="3056" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="3059" class="Symbol">)))</a>
<a id="3063" href="1Lab.Equiv.html#2829" class="Function">strict-fibres</a> <a id="3077" class="Symbol">{</a><a id="3078" class="Argument">f</a> <a id="3080" class="Symbol">=</a> <a id="3082" href="1Lab.Equiv.html#3082" class="Bound">f</a><a id="3083" class="Symbol">}</a> <a id="3085" href="1Lab.Equiv.html#3085" class="Bound">g</a> <a id="3087" href="1Lab.Equiv.html#3087" class="Bound">b</a> <a id="3089" class="Symbol">.</a><a id="3090" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="3094" class="Symbol">=</a> <a id="3096" class="Symbol">(</a><a id="3097" href="1Lab.Equiv.html#3085" class="Bound">g</a> <a id="3099" href="1Lab.Equiv.html#3087" class="Bound">b</a> <a id="3101" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3103" href="1Lab.Path.html#3593" class="Function">refl</a><a id="3107" class="Symbol">)</a>
<a id="3109" href="1Lab.Equiv.html#2829" class="Function">strict-fibres</a> <a id="3123" class="Symbol">{</a><a id="3124" class="Argument">f</a> <a id="3126" class="Symbol">=</a> <a id="3128" href="1Lab.Equiv.html#3128" class="Bound">f</a><a id="3129" class="Symbol">}</a> <a id="3131" href="1Lab.Equiv.html#3131" class="Bound">g</a> <a id="3133" href="1Lab.Equiv.html#3133" class="Bound">b</a> <a id="3135" class="Symbol">.</a><a id="3136" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="3140" class="Symbol">(</a><a id="3141" href="1Lab.Equiv.html#3141" class="Bound">a</a> <a id="3143" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3145" href="1Lab.Equiv.html#3145" class="Bound">p</a><a id="3146" class="Symbol">)</a> <a id="3148" href="1Lab.Equiv.html#3148" class="Bound">i</a> <a id="3150" class="Symbol">=</a> <a id="3152" class="Symbol">(</a><a id="3153" href="1Lab.Equiv.html#3131" class="Bound">g</a> <a id="3155" class="Symbol">(</a><a id="3156" href="1Lab.Equiv.html#3145" class="Bound">p</a> <a id="3158" class="Symbol">(</a><a id="3159" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="3161" href="1Lab.Equiv.html#3148" class="Bound">i</a><a id="3162" class="Symbol">))</a> <a id="3165" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3167" class="Symbol">λ</a> <a id="3169" href="1Lab.Equiv.html#3169" class="Bound">j</a> <a id="3171" class="Symbol">→</a> <a id="3173" href="1Lab.Equiv.html#3128" class="Bound">f</a> <a id="3175" class="Symbol">(</a><a id="3176" href="1Lab.Equiv.html#3131" class="Bound">g</a> <a id="3178" class="Symbol">(</a><a id="3179" href="1Lab.Equiv.html#3145" class="Bound">p</a> <a id="3181" class="Symbol">(</a><a id="3182" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="3184" href="1Lab.Equiv.html#3148" class="Bound">i</a> <a id="3186" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="3188" href="1Lab.Equiv.html#3169" class="Bound">j</a><a id="3189" class="Symbol">))))</a>

<a id="3195" class="Comment">-- This is more efficient than using Iso→Equiv. When f (g x) is definitionally x,</a>
<a id="3277" class="Comment">-- the type reduces to essentially is-contr (fibre f b).</a>
</pre>-->
<p>For Cubical Agda, the type of equivalences is distinguished, so we have to make a small wrapper to match the interface Agda expects. This is the geometric definition of contractibility, in terms of <a href="1Lab.Path.html#extensibility">partial elements</a> and extensibility.</p>
<pre class="Agda"><a id="3638" class="Symbol">{-#</a> <a id="3642" class="Keyword">BUILTIN</a> <a id="3650" class="Keyword">EQUIV</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="3656" href="1Lab.Equiv.html#2459" class="Function Operator">_≃_</a> <a id="3660" class="Symbol">#-}</a>
<a id="3664" class="Symbol">{-#</a> <a id="3668" class="Keyword">BUILTIN</a> <a id="3676" class="Keyword">EQUIVFUN</a> <a data-type="∑ A B₁ → A" id="3685" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="3689" class="Symbol">#-}</a>

<a id="is-eqv&#39;"></a><a data-type="(A : Type a) (B₁ : Type b) (w : A ≃ B₁) (a : B₁) (ψ : I) →
Partial ψ (fibre (w .fst) a) → fibre (w .fst) a" id="3694" href="1Lab.Equiv.html#3694" class="Function">is-eqv&#39;</a> <a id="3702" class="Symbol">:</a> <a id="3704" class="Symbol">∀</a> <a id="3706" class="Symbol">{</a><a id="3707" href="1Lab.Equiv.html#3707" class="Bound">a</a> <a id="3709" href="1Lab.Equiv.html#3709" class="Bound">b</a><a id="3710" class="Symbol">}</a> <a id="3712" class="Symbol">(</a><a id="3713" href="1Lab.Equiv.html#3713" class="Bound">A</a> <a id="3715" class="Symbol">:</a> <a id="3717" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="3722" href="1Lab.Equiv.html#3707" class="Bound">a</a><a id="3723" class="Symbol">)</a> <a id="3725" class="Symbol">(</a><a id="3726" href="1Lab.Equiv.html#3726" class="Bound">B</a> <a id="3728" class="Symbol">:</a> <a id="3730" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="3735" href="1Lab.Equiv.html#3709" class="Bound">b</a><a id="3736" class="Symbol">)</a>
        <a id="3746" class="Symbol">→</a> <a id="3748" class="Symbol">(</a><a id="3749" href="1Lab.Equiv.html#3749" class="Bound">w</a> <a id="3751" class="Symbol">:</a> <a id="3753" href="1Lab.Equiv.html#3713" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="3755" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="3757" href="1Lab.Equiv.html#3726" class="Bound">B</a><a id="3758" class="Symbol">)</a> <a id="3760" class="Symbol">(</a><a id="3761" href="1Lab.Equiv.html#3761" class="Bound">a</a> <a id="3763" class="Symbol">:</a> <a id="3765" href="1Lab.Equiv.html#3726" class="Bound">B</a><a id="3766" class="Symbol">)</a>
        <a id="3776" class="Symbol">→</a> <a id="3778" class="Symbol">(</a><a id="3779" href="1Lab.Equiv.html#3779" class="Bound">ψ</a> <a id="3781" class="Symbol">:</a> <a id="3783" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="3784" class="Symbol">)</a>
        <a id="3794" class="Symbol">→</a> <a id="3796" href="Agda.Primitive.Cubical.html#1065" class="Primitive">Partial</a> <a id="3804" href="1Lab.Equiv.html#3779" class="Bound">ψ</a> <a id="3806" class="Symbol">(</a><a data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="3807" href="1Lab.Equiv.html#1893" class="Function">fibre</a> <a id="3813" class="Symbol">(</a><a id="3814" href="1Lab.Equiv.html#3749" class="Bound">w</a> <a id="3816" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="3817" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="3820" class="Symbol">)</a> <a id="3822" href="1Lab.Equiv.html#3761" class="Bound">a</a><a id="3823" class="Symbol">)</a>
        <a id="3833" class="Symbol">→</a> <a data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="3835" href="1Lab.Equiv.html#1893" class="Function">fibre</a> <a id="3841" class="Symbol">(</a><a id="3842" href="1Lab.Equiv.html#3749" class="Bound">w</a> <a id="3844" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="3845" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="3848" class="Symbol">)</a> <a id="3850" href="1Lab.Equiv.html#3761" class="Bound">a</a>
<a data-type="(A : Type a) (B₁ : Type b) (w : A ≃ B₁) (a : B₁) (ψ : I) →
Partial ψ (fibre (w .fst) a) → fibre (w .fst) a" id="3852" href="1Lab.Equiv.html#3694" class="Function">is-eqv&#39;</a> <a id="3860" href="1Lab.Equiv.html#3860" class="Bound">A</a> <a id="3862" href="1Lab.Equiv.html#3862" class="Bound">B</a> <a id="3864" class="Symbol">(</a><a id="3865" href="1Lab.Equiv.html#3865" class="Bound">f</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="3867" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3869" href="1Lab.Equiv.html#3869" class="Bound">is-equiv</a><a id="3877" class="Symbol">)</a> <a id="3879" href="1Lab.Equiv.html#3879" class="Bound">a</a> <a id="3881" href="1Lab.Equiv.html#3881" class="Bound">ψ</a> <a id="3883" href="1Lab.Equiv.html#3883" class="Bound">u0</a> <a id="3886" class="Symbol">=</a>
  <a id="3890" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="3896" class="Symbol">(λ</a> <a id="3899" href="1Lab.Equiv.html#3899" class="Bound">i</a> <a id="3901" class="Symbol">→</a> <a id="3903" class="Symbol">λ</a> <a id="3905" class="Symbol">{</a> <a id="3907" class="Symbol">(</a><a id="3908" href="1Lab.Equiv.html#3881" class="Bound">ψ</a> <a id="3910" class="Symbol">=</a> <a id="3912" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="3914" class="Symbol">)</a> <a id="3916" class="Symbol">→</a> <a id="3918" href="1Lab.Equiv.html#4026" class="Function">c</a> <a id="3920" class="Symbol">.</a><a data-type="is-contr A → A" id="3921" href="1Lab.HLevel.html#1401" class="Field">centre</a>
                 <a id="3945" class="Symbol">;</a> <a id="3947" class="Symbol">(</a><a id="3948" href="1Lab.Equiv.html#3881" class="Bound">ψ</a> <a id="3950" class="Symbol">=</a> <a id="3952" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="3954" class="Symbol">)</a> <a id="3956" class="Symbol">→</a> <a id="3958" href="1Lab.Equiv.html#4026" class="Function">c</a> <a id="3960" class="Symbol">.</a><a data-type="(r : is-contr A) (x : A) → r .centre ≡ x" id="3961" href="1Lab.HLevel.html#1416" class="Field">paths</a> <a id="3967" class="Symbol">(</a><a id="3968" href="1Lab.Equiv.html#3883" class="Bound">u0</a> <a id="3971" href="1Lab.Path.html#2443" class="Postulate">1=1</a><a id="3974" class="Symbol">)</a> <a id="3976" href="1Lab.Equiv.html#3899" class="Bound">i</a>
                 <a id="3995" class="Symbol">})</a>
        <a id="4006" class="Symbol">(</a><a id="4007" href="1Lab.Equiv.html#4026" class="Function">c</a> <a id="4009" class="Symbol">.</a><a data-type="is-contr A → A" id="4010" href="1Lab.HLevel.html#1401" class="Field">centre</a><a id="4016" class="Symbol">)</a>
  <a id="4020" class="Keyword">where</a> <a id="4026" href="1Lab.Equiv.html#4026" class="Function">c</a> <a id="4028" class="Symbol">=</a> <a id="4030" href="1Lab.Equiv.html#3869" class="Bound">is-equiv</a> <a id="4039" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="4040" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="4047" href="1Lab.Equiv.html#3879" class="Bound">a</a>

<a id="4050" class="Symbol">{-#</a> <a id="4054" class="Keyword">BUILTIN</a> <a id="4062" class="Keyword">EQUIVPROOF</a> <a data-type="(A : Type a) (B₁ : Type b) (w : A ≃ B₁) (a : B₁) (ψ : I) →
Partial ψ (fibre (w .fst) a) → fibre (w .fst) a" id="4073" href="1Lab.Equiv.html#3694" class="Function">is-eqv&#39;</a> <a id="4081" class="Symbol">#-}</a>
</pre>
<!--
<pre class="Agda"><a id="equiv-centre"></a><a id="4099" href="1Lab.Equiv.html#4099" class="Function">equiv-centre</a> <a id="4112" class="Symbol">:</a> <a id="4114" class="Symbol">(</a><a id="4115" href="1Lab.Equiv.html#4115" class="Bound">e</a> <a id="4117" class="Symbol">:</a> <a id="4119" href="1Lab.Equiv.html#1608" class="Generalizable">A</a> <a id="4121" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="4123" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="4124" class="Symbol">)</a> <a id="4126" class="Symbol">(</a><a id="4127" href="1Lab.Equiv.html#4127" class="Bound">y</a> <a id="4129" class="Symbol">:</a> <a id="4131" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="4132" class="Symbol">)</a> <a id="4134" class="Symbol">→</a> <a id="4136" href="1Lab.Equiv.html#1893" class="Function">fibre</a> <a id="4142" class="Symbol">(</a><a id="4143" href="1Lab.Equiv.html#4115" class="Bound">e</a> <a id="4145" class="Symbol">.</a><a id="4146" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="4149" class="Symbol">)</a> <a id="4151" href="1Lab.Equiv.html#4127" class="Bound">y</a>
<a id="4153" href="1Lab.Equiv.html#4099" class="Function">equiv-centre</a> <a id="4166" href="1Lab.Equiv.html#4166" class="Bound">e</a> <a id="4168" href="1Lab.Equiv.html#4168" class="Bound">y</a> <a id="4170" class="Symbol">=</a> <a id="4172" href="1Lab.Equiv.html#4166" class="Bound">e</a> <a id="4174" class="Symbol">.</a><a id="4175" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="4179" class="Symbol">.</a><a id="4180" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="4187" href="1Lab.Equiv.html#4168" class="Bound">y</a> <a id="4189" class="Symbol">.</a><a id="4190" href="1Lab.HLevel.html#1401" class="Field">centre</a>

<a id="equiv-path"></a><a id="4198" href="1Lab.Equiv.html#4198" class="Function">equiv-path</a> <a id="4209" class="Symbol">:</a> <a id="4211" class="Symbol">(</a><a id="4212" href="1Lab.Equiv.html#4212" class="Bound">e</a> <a id="4214" class="Symbol">:</a> <a id="4216" href="1Lab.Equiv.html#1608" class="Generalizable">A</a> <a id="4218" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="4220" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="4221" class="Symbol">)</a> <a id="4223" class="Symbol">(</a><a id="4224" href="1Lab.Equiv.html#4224" class="Bound">y</a> <a id="4226" class="Symbol">:</a> <a id="4228" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="4229" class="Symbol">)</a> <a id="4231" class="Symbol">→</a>
  <a id="4235" class="Symbol">(</a><a id="4236" href="1Lab.Equiv.html#4236" class="Bound">v</a> <a id="4238" class="Symbol">:</a> <a id="4240" href="1Lab.Equiv.html#1893" class="Function">fibre</a> <a id="4246" class="Symbol">(</a><a id="4247" href="1Lab.Equiv.html#4212" class="Bound">e</a> <a id="4249" class="Symbol">.</a><a id="4250" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="4253" class="Symbol">)</a> <a id="4255" href="1Lab.Equiv.html#4224" class="Bound">y</a><a id="4256" class="Symbol">)</a> <a id="4258" class="Symbol">→</a> <a id="4260" href="1Lab.Path.html#2466" class="Function">Path</a> <a id="4265" class="Symbol">_</a> <a id="4267" class="Symbol">(</a><a id="4268" href="1Lab.Equiv.html#4099" class="Function">equiv-centre</a> <a id="4281" href="1Lab.Equiv.html#4212" class="Bound">e</a> <a id="4283" href="1Lab.Equiv.html#4224" class="Bound">y</a><a id="4284" class="Symbol">)</a> <a id="4286" href="1Lab.Equiv.html#4236" class="Bound">v</a>
<a id="4288" href="1Lab.Equiv.html#4198" class="Function">equiv-path</a> <a id="4299" href="1Lab.Equiv.html#4299" class="Bound">e</a> <a id="4301" href="1Lab.Equiv.html#4301" class="Bound">y</a> <a id="4303" class="Symbol">=</a> <a id="4305" href="1Lab.Equiv.html#4299" class="Bound">e</a> <a id="4307" class="Symbol">.</a><a id="4308" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="4312" class="Symbol">.</a><a id="4313" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="4320" href="1Lab.Equiv.html#4301" class="Bound">y</a> <a id="4322" class="Symbol">.</a><a id="4323" href="1Lab.HLevel.html#1416" class="Field">paths</a>
</pre>-->
<h2 id="is-equiv-is-propositional"><a href="#is-equiv-is-propositional" class="header-link">is-equiv is propositional<span class="header-link-emoji">🔗</span></a></h2>
<p>A function can be an equivalence in at most one way. This follows from propositions being closed under dependent products, and <span class="Agda"><a data-type="(A : Type ℓ) → Type ℓ" href="1Lab.HLevel.html#1328" class="Module">is-contr</a></span> being a proposition.</p>
<pre class="Agda"><a id="4543" class="Keyword">module</a> <a id="4550" href="1Lab.Equiv.html#4550" class="Module">_</a> <a id="4552" class="Keyword">where</a> <a id="4558" class="Keyword">private</a>
  <a id="4568" href="1Lab.Equiv.html#4568" class="Function">is-equiv-is-prop</a> <a id="4585" class="Symbol">:</a> <a id="4587" class="Symbol">(</a><a id="4588" href="1Lab.Equiv.html#4588" class="Bound">f</a> <a id="4590" class="Symbol">:</a> <a id="4592" href="1Lab.Equiv.html#1608" class="Generalizable">A</a> <a id="4594" class="Symbol">→</a> <a id="4596" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="4597" class="Symbol">)</a> <a id="4599" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="4601" href="1Lab.HLevel.html#2597" class="Function">is-prop</a> <a id="4609" class="Symbol">(</a><a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="4610" href="1Lab.Equiv.html#2306" class="Record">is-equiv</a> <a id="4619" href="1Lab.Equiv.html#4588" class="Bound">f</a><a id="4620" class="Symbol">)</a>
  <a id="4624" href="1Lab.Equiv.html#4568" class="Function">is-equiv-is-prop</a> <a id="4641" href="1Lab.Equiv.html#4641" class="Bound">f</a> <a id="4643" href="1Lab.Equiv.html#4643" class="Bound">x</a> <a id="4645" href="1Lab.Equiv.html#4645" class="Bound">y</a> <a id="4647" href="1Lab.Equiv.html#4647" class="Bound">i</a> <a id="4649" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="4650" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="4657" href="1Lab.Equiv.html#4657" class="Bound">p</a> <a id="4659" class="Symbol">=</a> <a data-type="is-prop (is-contr A)" id="4661" href="1Lab.HLevel.html#11707" class="Function">is-contr-is-prop</a> <a id="4678" class="Symbol">(</a><a id="4679" href="1Lab.Equiv.html#4643" class="Bound">x</a> <a id="4681" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="4682" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="4689" href="1Lab.Equiv.html#4657" class="Bound">p</a><a id="4690" class="Symbol">)</a> <a id="4692" class="Symbol">(</a><a id="4693" href="1Lab.Equiv.html#4645" class="Bound">y</a> <a id="4695" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="4696" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="4703" href="1Lab.Equiv.html#4657" class="Bound">p</a><a id="4704" class="Symbol">)</a> <a id="4706" href="1Lab.Equiv.html#4647" class="Bound">i</a>
</pre>
<details>
<summary>
Even though the proof above works, we use the direct cubical proof in this <code>&lt;details&gt;</code> tag (lifted from the Cubical Agda library) in the rest of the development for efficiency concerns.
</summary>
<pre class="Agda"><a id="is-equiv-is-prop"></a><a data-type="(f : A → B₁) → is-prop (is-equiv f)" id="4939" href="1Lab.Equiv.html#4939" class="Function">is-equiv-is-prop</a> <a id="4956" class="Symbol">:</a> <a id="4958" class="Symbol">(</a><a id="4959" href="1Lab.Equiv.html#4959" class="Bound">f</a> <a id="4961" class="Symbol">:</a> <a id="4963" href="1Lab.Equiv.html#1608" class="Generalizable">A</a> <a id="4965" class="Symbol">→</a> <a id="4967" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="4968" class="Symbol">)</a> <a id="4970" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="4972" href="1Lab.HLevel.html#2597" class="Function">is-prop</a> <a id="4980" class="Symbol">(</a><a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="4981" href="1Lab.Equiv.html#2306" class="Record">is-equiv</a> <a id="4990" href="1Lab.Equiv.html#4959" class="Bound">f</a><a id="4991" class="Symbol">)</a>
<a data-type="(f : A → B₁) → is-prop (is-equiv f)" id="4993" href="1Lab.Equiv.html#4939" class="Function">is-equiv-is-prop</a> <a id="5010" href="1Lab.Equiv.html#5010" class="Bound">f</a> <a id="5012" href="1Lab.Equiv.html#5012" class="Bound">p</a> <a id="5014" href="1Lab.Equiv.html#5014" class="Bound">q</a> <a id="5016" href="1Lab.Equiv.html#5016" class="Bound">i</a> <a id="5018" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="5019" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="5026" href="1Lab.Equiv.html#5026" class="Bound">y</a> <a id="5028" class="Symbol">=</a>
  <a id="5032" class="Keyword">let</a> <a id="5036" href="1Lab.Equiv.html#5036" class="Bound">p2</a> <a id="5039" class="Symbol">=</a> <a id="5041" href="1Lab.Equiv.html#5012" class="Bound">p</a> <a id="5043" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="5044" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="5051" href="1Lab.Equiv.html#5026" class="Bound">y</a> <a id="5053" class="Symbol">.</a><a data-type="(r : is-contr A) (x : A) → r .centre ≡ x" id="5054" href="1Lab.HLevel.html#1416" class="Field">paths</a>
      <a id="5066" href="1Lab.Equiv.html#5066" class="Bound">q2</a> <a id="5069" class="Symbol">=</a> <a id="5071" href="1Lab.Equiv.html#5014" class="Bound">q</a> <a id="5073" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="5074" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="5081" href="1Lab.Equiv.html#5026" class="Bound">y</a> <a id="5083" class="Symbol">.</a><a data-type="(r : is-contr A) (x : A) → r .centre ≡ x" id="5084" href="1Lab.HLevel.html#1416" class="Field">paths</a>
  <a id="5092" class="Keyword">in</a> <a data-type="(centre₁ : A) (paths₁ : (x : A) → centre₁ ≡ x) → is-contr A" id="5095" href="1Lab.HLevel.html#1383" class="InductiveConstructor">contr</a> <a id="5101" class="Symbol">(</a><a id="5102" href="1Lab.Equiv.html#5036" class="Bound">p2</a> <a id="5105" class="Symbol">(</a><a id="5106" href="1Lab.Equiv.html#5014" class="Bound">q</a> <a id="5108" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="5109" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="5116" href="1Lab.Equiv.html#5026" class="Bound">y</a> <a id="5118" class="Symbol">.</a><a data-type="is-contr A → A" id="5119" href="1Lab.HLevel.html#1401" class="Field">centre</a><a id="5125" class="Symbol">)</a> <a id="5127" href="1Lab.Equiv.html#5016" class="Bound">i</a><a id="5128" class="Symbol">)</a>
      <a id="5136" class="Symbol">λ</a> <a id="5138" href="1Lab.Equiv.html#5138" class="Bound">w</a> <a id="5140" href="1Lab.Equiv.html#5140" class="Bound">j</a> <a id="5142" class="Symbol">→</a> <a id="5144" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="5150" class="Symbol">(λ</a> <a id="5153" href="1Lab.Equiv.html#5153" class="Bound">k</a> <a id="5155" class="Symbol">→</a> <a id="5157" class="Symbol">λ</a> <a id="5159" class="Symbol">{</a> <a id="5161" class="Symbol">(</a><a id="5162" href="1Lab.Equiv.html#5016" class="Bound">i</a> <a id="5164" class="Symbol">=</a> <a id="5166" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="5168" class="Symbol">)</a> <a id="5170" class="Symbol">→</a> <a id="5172" href="1Lab.Equiv.html#5036" class="Bound">p2</a> <a id="5175" href="1Lab.Equiv.html#5138" class="Bound">w</a> <a id="5177" href="1Lab.Equiv.html#5140" class="Bound">j</a>
                             <a id="5208" class="Symbol">;</a> <a id="5210" class="Symbol">(</a><a id="5211" href="1Lab.Equiv.html#5016" class="Bound">i</a> <a id="5213" class="Symbol">=</a> <a id="5215" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="5217" class="Symbol">)</a> <a id="5219" class="Symbol">→</a> <a id="5221" href="1Lab.Equiv.html#5066" class="Bound">q2</a> <a id="5224" href="1Lab.Equiv.html#5138" class="Bound">w</a> <a id="5226" class="Symbol">(</a><a id="5227" href="1Lab.Equiv.html#5140" class="Bound">j</a> <a id="5229" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="5231" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="5233" href="1Lab.Equiv.html#5153" class="Bound">k</a><a id="5234" class="Symbol">)</a>
                             <a id="5265" class="Symbol">;</a> <a id="5267" class="Symbol">(</a><a id="5268" href="1Lab.Equiv.html#5140" class="Bound">j</a> <a id="5270" class="Symbol">=</a> <a id="5272" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="5274" class="Symbol">)</a> <a id="5276" class="Symbol">→</a> <a id="5278" href="1Lab.Equiv.html#5036" class="Bound">p2</a> <a id="5281" class="Symbol">(</a><a id="5282" href="1Lab.Equiv.html#5066" class="Bound">q2</a> <a id="5285" href="1Lab.Equiv.html#5138" class="Bound">w</a> <a id="5287" class="Symbol">(</a><a id="5288" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="5290" href="1Lab.Equiv.html#5153" class="Bound">k</a><a id="5291" class="Symbol">))</a> <a id="5294" href="1Lab.Equiv.html#5016" class="Bound">i</a>
                             <a id="5325" class="Symbol">;</a> <a id="5327" class="Symbol">(</a><a id="5328" href="1Lab.Equiv.html#5140" class="Bound">j</a> <a id="5330" class="Symbol">=</a> <a id="5332" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="5334" class="Symbol">)</a> <a id="5336" class="Symbol">→</a> <a id="5338" href="1Lab.Equiv.html#5138" class="Bound">w</a> <a id="5340" class="Symbol">})</a>
                    <a id="5363" class="Symbol">(</a><a id="5364" href="1Lab.Equiv.html#5036" class="Bound">p2</a> <a id="5367" href="1Lab.Equiv.html#5138" class="Bound">w</a> <a id="5369" class="Symbol">(</a><a id="5370" href="1Lab.Equiv.html#5016" class="Bound">i</a> <a id="5372" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="5374" href="1Lab.Equiv.html#5140" class="Bound">j</a><a id="5375" class="Symbol">))</a>
</pre>
</details>
<h1 id="isomorphisms-from-equivalences"><a href="#isomorphisms-from-equivalences" class="header-link">Isomorphisms from equivalences<span class="header-link-emoji">🔗</span></a></h1>
<p>For this section, we need a definition of <em>isomorphism</em>. This is the same as ever! An isomorphism is a function that has a two-sided inverse. We first define what it means for a function to invert another on the left and on the right:</p>
<pre class="Agda"><a id="is-left-inverse"></a><a data-type="(B₁ → A) → (A → B₁) → Type A.ℓ₁" id="5672" href="1Lab.Equiv.html#5672" class="Function">is-left-inverse</a> <a id="5688" class="Symbol">:</a> <a id="5690" class="Symbol">(</a><a id="5691" href="1Lab.Equiv.html#1610" class="Generalizable">B</a> <a id="5693" class="Symbol">→</a> <a id="5695" href="1Lab.Equiv.html#1608" class="Generalizable">A</a><a id="5696" class="Symbol">)</a> <a id="5698" class="Symbol">→</a> <a id="5700" class="Symbol">(</a><a id="5701" href="1Lab.Equiv.html#1608" class="Generalizable">A</a> <a id="5703" class="Symbol">→</a> <a id="5705" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="5706" class="Symbol">)</a> <a id="5708" class="Symbol">→</a> <a id="5710" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="5715" class="Symbol">_</a>
<a data-type="(B₁ → A) → (A → B₁) → Type A.ℓ₁" id="5717" href="1Lab.Equiv.html#5672" class="Function">is-left-inverse</a> <a id="5733" href="1Lab.Equiv.html#5733" class="Bound">g</a> <a id="5735" href="1Lab.Equiv.html#5735" class="Bound">f</a> <a id="5737" class="Symbol">=</a> <a id="5739" class="Symbol">(</a><a id="5740" href="1Lab.Equiv.html#5740" class="Bound">x</a> <a id="5742" class="Symbol">:</a> <a id="5744" class="Symbol">_)</a> <a id="5747" class="Symbol">→</a> <a id="5749" href="1Lab.Equiv.html#5733" class="Bound">g</a> <a id="5751" class="Symbol">(</a><a id="5752" href="1Lab.Equiv.html#5735" class="Bound">f</a> <a id="5754" href="1Lab.Equiv.html#5740" class="Bound">x</a><a id="5755" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="5757" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="5759" href="1Lab.Equiv.html#5740" class="Bound">x</a>

<a id="is-right-inverse"></a><a data-type="(B₁ → A) → (A → B₁) → Type B.ℓ₁" id="5762" href="1Lab.Equiv.html#5762" class="Function">is-right-inverse</a> <a id="5779" class="Symbol">:</a> <a id="5781" class="Symbol">(</a><a id="5782" href="1Lab.Equiv.html#1610" class="Generalizable">B</a> <a id="5784" class="Symbol">→</a> <a id="5786" href="1Lab.Equiv.html#1608" class="Generalizable">A</a><a id="5787" class="Symbol">)</a> <a id="5789" class="Symbol">→</a> <a id="5791" class="Symbol">(</a><a id="5792" href="1Lab.Equiv.html#1608" class="Generalizable">A</a> <a id="5794" class="Symbol">→</a> <a id="5796" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="5797" class="Symbol">)</a> <a id="5799" class="Symbol">→</a> <a id="5801" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="5806" class="Symbol">_</a>
<a data-type="(B₁ → A) → (A → B₁) → Type B.ℓ₁" id="5808" href="1Lab.Equiv.html#5762" class="Function">is-right-inverse</a> <a id="5825" href="1Lab.Equiv.html#5825" class="Bound">g</a> <a id="5827" href="1Lab.Equiv.html#5827" class="Bound">f</a> <a id="5829" class="Symbol">=</a> <a id="5831" class="Symbol">(</a><a id="5832" href="1Lab.Equiv.html#5832" class="Bound">x</a> <a id="5834" class="Symbol">:</a> <a id="5836" class="Symbol">_)</a> <a id="5839" class="Symbol">→</a> <a id="5841" href="1Lab.Equiv.html#5827" class="Bound">f</a> <a id="5843" class="Symbol">(</a><a id="5844" href="1Lab.Equiv.html#5825" class="Bound">g</a> <a id="5846" href="1Lab.Equiv.html#5832" class="Bound">x</a><a id="5847" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="5849" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="5851" href="1Lab.Equiv.html#5832" class="Bound">x</a>
</pre>
<p>A proof that a function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> is an isomorphism consists of a function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> in the other direction, together with homotopies exhibiting <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> as a left- and right- inverse to <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>.</span></p>
<pre class="Agda"><a id="6042" class="Keyword">record</a> <a id="is-iso"></a><a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="6049" href="1Lab.Equiv.html#6049" class="Record">is-iso</a> <a id="6056" class="Symbol">(</a><a id="6057" href="1Lab.Equiv.html#6057" class="Bound">f</a> <a id="6059" class="Symbol">:</a> <a id="6061" href="1Lab.Equiv.html#1608" class="Generalizable">A</a> <a id="6063" class="Symbol">→</a> <a id="6065" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="6066" class="Symbol">)</a> <a id="6068" class="Symbol">:</a> <a id="6070" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="6075" class="Symbol">(</a><a data-type="Type ℓ → Level" id="6076" href="1Lab.Type.html#921" class="Function">level-of</a> <a id="6085" href="1Lab.Equiv.html#6061" class="Bound">A</a> <a data-type="Level → Level → Level" id="6087" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a data-type="Type ℓ → Level" id="6089" href="1Lab.Type.html#921" class="Function">level-of</a> <a id="6098" href="1Lab.Equiv.html#6065" class="Bound">B</a><a id="6099" class="Symbol">)</a> <a id="6101" class="Keyword">where</a>
  <a id="6109" class="Keyword">no-eta-equality</a>
  <a id="6127" class="Keyword">constructor</a> <a id="iso"></a><a data-type="(inv₁ : B₁ → A) (rinv₁ : is-right-inverse inv₁ f)
(linv₁ : is-left-inverse inv₁ f) →
is-iso f" id="6139" href="1Lab.Equiv.html#6139" class="InductiveConstructor">iso</a>
  <a id="6145" class="Keyword">field</a>
    <a id="is-iso.inv"></a><a data-type="is-iso f → B₁ → A" id="6155" href="1Lab.Equiv.html#6155" class="Field">inv</a> <a id="6159" class="Symbol">:</a> <a id="6161" href="1Lab.Equiv.html#6065" class="Bound">B</a> <a id="6163" class="Symbol">→</a> <a id="6165" href="1Lab.Equiv.html#6061" class="Bound">A</a>
    <a id="is-iso.rinv"></a><a data-type="(r : is-iso f) → is-right-inverse (r .inv) f" id="6171" href="1Lab.Equiv.html#6171" class="Field">rinv</a> <a id="6176" class="Symbol">:</a> <a data-type="(B₁ → A) → (A → B₁) → Type B.ℓ₁" id="6178" href="1Lab.Equiv.html#5762" class="Function">is-right-inverse</a> <a data-type="is-iso f → B₁ → A" id="6195" href="1Lab.Equiv.html#6155" class="Field">inv</a> <a id="6199" href="1Lab.Equiv.html#6057" class="Bound">f</a>
    <a id="is-iso.linv"></a><a data-type="(r : is-iso f) → is-left-inverse (r .inv) f" id="6205" href="1Lab.Equiv.html#6205" class="Field">linv</a> <a id="6210" class="Symbol">:</a> <a data-type="(B₁ → A) → (A → B₁) → Type A.ℓ₁" id="6212" href="1Lab.Equiv.html#5672" class="Function">is-left-inverse</a> <a data-type="is-iso f → B₁ → A" id="6228" href="1Lab.Equiv.html#6155" class="Field">inv</a> <a id="6232" href="1Lab.Equiv.html#6057" class="Bound">f</a>

  <a id="is-iso.inverse"></a><a data-type="(r : is-iso f) → is-iso (inv r)" id="6237" href="1Lab.Equiv.html#6237" class="Function">inverse</a> <a id="6245" class="Symbol">:</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="6247" href="1Lab.Equiv.html#6049" class="Record">is-iso</a> <a data-type="is-iso f → B₁ → A" id="6254" href="1Lab.Equiv.html#6155" class="Field">inv</a>
  <a data-type="is-iso f → B₁ → A" id="6260" href="1Lab.Equiv.html#6155" class="Field">inv</a> <a data-type="(r : is-iso f) → is-iso (inv r)" id="6264" href="1Lab.Equiv.html#6237" class="Function">inverse</a> <a id="6272" class="Symbol">=</a> <a id="6274" href="1Lab.Equiv.html#6057" class="Bound">f</a>
  <a data-type="(r : is-iso f) → is-right-inverse (r .inv) f" id="6278" href="1Lab.Equiv.html#6171" class="Field">rinv</a> <a data-type="(r : is-iso f) → is-iso (inv r)" id="6283" href="1Lab.Equiv.html#6237" class="Function">inverse</a> <a id="6291" class="Symbol">=</a> <a data-type="(r : is-iso f) → is-left-inverse (r .inv) f" id="6293" href="1Lab.Equiv.html#6205" class="Field">linv</a>
  <a data-type="(r : is-iso f) → is-left-inverse (r .inv) f" id="6300" href="1Lab.Equiv.html#6205" class="Field">linv</a> <a data-type="(r : is-iso f) → is-iso (inv r)" id="6305" href="1Lab.Equiv.html#6237" class="Function">inverse</a> <a id="6313" class="Symbol">=</a> <a data-type="(r : is-iso f) → is-right-inverse (r .inv) f" id="6315" href="1Lab.Equiv.html#6171" class="Field">rinv</a>

<a id="Iso"></a><a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="6321" href="1Lab.Equiv.html#6321" class="Function">Iso</a> <a id="6325" class="Symbol">:</a> <a id="6327" class="Symbol">∀</a> <a id="6329" class="Symbol">{</a><a id="6330" href="1Lab.Equiv.html#6330" class="Bound">ℓ₁</a> <a id="6333" href="1Lab.Equiv.html#6333" class="Bound">ℓ₂</a><a id="6335" class="Symbol">}</a> <a id="6337" class="Symbol">→</a> <a id="6339" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="6344" href="1Lab.Equiv.html#6330" class="Bound">ℓ₁</a> <a id="6347" class="Symbol">→</a> <a id="6349" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="6354" href="1Lab.Equiv.html#6333" class="Bound">ℓ₂</a> <a id="6357" class="Symbol">→</a> <a id="6359" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="6364" class="Symbol">_</a>
<a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="6366" href="1Lab.Equiv.html#6321" class="Function">Iso</a> <a id="6370" href="1Lab.Equiv.html#6370" class="Bound">A</a> <a id="6372" href="1Lab.Equiv.html#6372" class="Bound">B</a> <a id="6374" class="Symbol">=</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="6376" href="1Lab.Type.html#1573" class="Function">Σ</a> <a id="6378" class="Symbol">(</a><a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="6379" href="1Lab.Equiv.html#6049" class="Record">is-iso</a> <a id="6386" class="Symbol">{</a><a id="6387" class="Argument">A</a> <a id="6389" class="Symbol">=</a> <a id="6391" href="1Lab.Equiv.html#6370" class="Bound">A</a><a id="6392" class="Symbol">}</a> <a id="6394" class="Symbol">{</a><a id="6395" class="Argument">B</a> <a id="6397" class="Symbol">=</a> <a id="6399" href="1Lab.Equiv.html#6372" class="Bound">B</a><a id="6400" class="Symbol">})</a>
</pre>
<p>Any function that is an equivalence is an isomorphism:</p>
<pre class="Agda"><a id="equiv→inverse"></a><a data-type="is-equiv f → B₁ → A" id="6472" href="1Lab.Equiv.html#6472" class="Function">equiv→inverse</a> <a id="6486" class="Symbol">:</a> <a id="6488" class="Symbol">{</a><a id="6489" href="1Lab.Equiv.html#6489" class="Bound">f</a> <a id="6491" class="Symbol">:</a> <a id="6493" href="1Lab.Equiv.html#1608" class="Generalizable">A</a> <a id="6495" class="Symbol">→</a> <a id="6497" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="6498" class="Symbol">}</a> <a id="6500" class="Symbol">→</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="6502" href="1Lab.Equiv.html#2306" class="Record">is-equiv</a> <a id="6511" href="1Lab.Equiv.html#6489" class="Bound">f</a> <a id="6513" class="Symbol">→</a> <a id="6515" href="1Lab.Equiv.html#1610" class="Generalizable">B</a> <a id="6517" class="Symbol">→</a> <a id="6519" href="1Lab.Equiv.html#1608" class="Generalizable">A</a>
<a data-type="is-equiv f → B₁ → A" id="6521" href="1Lab.Equiv.html#6472" class="Function">equiv→inverse</a> <a id="6535" href="1Lab.Equiv.html#6535" class="Bound">eqv</a> <a id="6539" href="1Lab.Equiv.html#6539" class="Bound">y</a> <a id="6541" class="Symbol">=</a> <a id="6543" href="1Lab.Equiv.html#6535" class="Bound">eqv</a> <a id="6547" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="6548" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="6555" href="1Lab.Equiv.html#6539" class="Bound">y</a> <a id="6557" class="Symbol">.</a><a data-type="is-contr A → A" id="6558" href="1Lab.HLevel.html#1401" class="Field">centre</a> <a id="6565" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="6566" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a>

<a id="equiv→section"></a><a data-type="(eqv : is-equiv f) → is-right-inverse (equiv→inverse eqv) f" id="6571" href="1Lab.Equiv.html#6571" class="Function">equiv→section</a> 
  <a id="6588" class="Symbol">:</a> <a id="6590" class="Symbol">{</a><a id="6591" href="1Lab.Equiv.html#6591" class="Bound">f</a> <a id="6593" class="Symbol">:</a> <a id="6595" href="1Lab.Equiv.html#1608" class="Generalizable">A</a> <a id="6597" class="Symbol">→</a> <a id="6599" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="6600" class="Symbol">}</a> <a id="6602" class="Symbol">(</a><a id="6603" href="1Lab.Equiv.html#6603" class="Bound">eqv</a> <a id="6607" class="Symbol">:</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="6609" href="1Lab.Equiv.html#2306" class="Record">is-equiv</a> <a id="6618" href="1Lab.Equiv.html#6591" class="Bound">f</a><a id="6619" class="Symbol">)</a> <a id="6621" class="Symbol">→</a> <a data-type="(B₁ → A) → (A → B₁) → Type B.ℓ₁" id="6623" href="1Lab.Equiv.html#5762" class="Function">is-right-inverse</a> <a id="6640" class="Symbol">(</a><a data-type="is-equiv f → B₁ → A" id="6641" href="1Lab.Equiv.html#6472" class="Function">equiv→inverse</a> <a id="6655" href="1Lab.Equiv.html#6603" class="Bound">eqv</a><a id="6658" class="Symbol">)</a> <a id="6660" href="1Lab.Equiv.html#6591" class="Bound">f</a>
<a data-type="(eqv : is-equiv f) → is-right-inverse (equiv→inverse eqv) f" id="6662" href="1Lab.Equiv.html#6571" class="Function">equiv→section</a> <a id="6676" href="1Lab.Equiv.html#6676" class="Bound">eqv</a> <a id="6680" href="1Lab.Equiv.html#6680" class="Bound">y</a> <a id="6682" class="Symbol">=</a> <a id="6684" href="1Lab.Equiv.html#6676" class="Bound">eqv</a> <a id="6688" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="6689" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="6696" href="1Lab.Equiv.html#6680" class="Bound">y</a> <a id="6698" class="Symbol">.</a><a data-type="is-contr A → A" id="6699" href="1Lab.HLevel.html#1401" class="Field">centre</a> <a id="6706" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="6707" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a>

<a id="equiv→retraction"></a><a data-type="(eqv : is-equiv f) → is-left-inverse (equiv→inverse eqv) f" id="6712" href="1Lab.Equiv.html#6712" class="Function">equiv→retraction</a> 
  <a id="6732" class="Symbol">:</a> <a id="6734" class="Symbol">{</a><a id="6735" href="1Lab.Equiv.html#6735" class="Bound">f</a> <a id="6737" class="Symbol">:</a> <a id="6739" href="1Lab.Equiv.html#1608" class="Generalizable">A</a> <a id="6741" class="Symbol">→</a> <a id="6743" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="6744" class="Symbol">}</a> <a id="6746" class="Symbol">(</a><a id="6747" href="1Lab.Equiv.html#6747" class="Bound">eqv</a> <a id="6751" class="Symbol">:</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="6753" href="1Lab.Equiv.html#2306" class="Record">is-equiv</a> <a id="6762" href="1Lab.Equiv.html#6735" class="Bound">f</a><a id="6763" class="Symbol">)</a> <a id="6765" class="Symbol">→</a> <a data-type="(B₁ → A) → (A → B₁) → Type A.ℓ₁" id="6767" href="1Lab.Equiv.html#5672" class="Function">is-left-inverse</a> <a id="6783" class="Symbol">(</a><a data-type="is-equiv f → B₁ → A" id="6784" href="1Lab.Equiv.html#6472" class="Function">equiv→inverse</a> <a id="6798" href="1Lab.Equiv.html#6747" class="Bound">eqv</a><a id="6801" class="Symbol">)</a> <a id="6803" href="1Lab.Equiv.html#6735" class="Bound">f</a>
<a data-type="(eqv : is-equiv f) → is-left-inverse (equiv→inverse eqv) f" id="6805" href="1Lab.Equiv.html#6712" class="Function">equiv→retraction</a> <a id="6822" class="Symbol">{</a><a id="6823" class="Argument">f</a> <a id="6825" class="Symbol">=</a> <a id="6827" href="1Lab.Equiv.html#6827" class="Bound">f</a><a id="6828" class="Symbol">}</a> <a id="6830" href="1Lab.Equiv.html#6830" class="Bound">eqv</a> <a id="6834" href="1Lab.Equiv.html#6834" class="Bound">x</a> <a id="6836" href="1Lab.Equiv.html#6836" class="Bound">i</a> <a id="6838" class="Symbol">=</a> <a id="6840" href="1Lab.Equiv.html#6830" class="Bound">eqv</a> <a id="6844" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="6845" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="6852" class="Symbol">(</a><a id="6853" href="1Lab.Equiv.html#6827" class="Bound">f</a> <a id="6855" href="1Lab.Equiv.html#6834" class="Bound">x</a><a id="6856" class="Symbol">)</a> <a id="6858" class="Symbol">.</a><a data-type="(r : is-contr A) (x : A) → r .centre ≡ x" id="6859" href="1Lab.HLevel.html#1416" class="Field">paths</a> <a id="6865" class="Symbol">(</a><a id="6866" href="1Lab.Equiv.html#6834" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="6868" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="x ≡ x" id="6870" href="1Lab.Path.html#3593" class="Function">refl</a><a id="6874" class="Symbol">)</a> <a id="6876" href="1Lab.Equiv.html#6836" class="Bound">i</a> <a id="6878" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="6879" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a>

<a id="is-equiv→is-iso"></a><a data-type="is-equiv f → is-iso f" id="6884" href="1Lab.Equiv.html#6884" class="Function">is-equiv→is-iso</a> <a id="6900" class="Symbol">:</a> <a id="6902" class="Symbol">{</a><a id="6903" href="1Lab.Equiv.html#6903" class="Bound">f</a> <a id="6905" class="Symbol">:</a> <a id="6907" href="1Lab.Equiv.html#1608" class="Generalizable">A</a> <a id="6909" class="Symbol">→</a> <a id="6911" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="6912" class="Symbol">}</a> <a id="6914" class="Symbol">→</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="6916" href="1Lab.Equiv.html#2306" class="Record">is-equiv</a> <a id="6925" href="1Lab.Equiv.html#6903" class="Bound">f</a> <a id="6927" class="Symbol">→</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="6929" href="1Lab.Equiv.html#6049" class="Record">is-iso</a> <a id="6936" href="1Lab.Equiv.html#6903" class="Bound">f</a>
<a data-type="is-iso f → B₁ → A" id="6938" href="1Lab.Equiv.html#6155" class="Field">is-iso.inv</a> <a id="6949" class="Symbol">(</a><a data-type="is-equiv f → is-iso f" id="6950" href="1Lab.Equiv.html#6884" class="Function">is-equiv→is-iso</a> <a id="6966" href="1Lab.Equiv.html#6966" class="Bound">eqv</a><a id="6969" class="Symbol">)</a> <a id="6971" class="Symbol">=</a> <a data-type="is-equiv f → B₁ → A" id="6973" href="1Lab.Equiv.html#6472" class="Function">equiv→inverse</a> <a id="6987" href="1Lab.Equiv.html#6966" class="Bound">eqv</a>
</pre>
<p>We can get an element of <code>x</code> from the proof that <code>f</code> is an equivalence - it’s the point of <code>A</code> mapped to <code>y</code>, which we get from centre of contraction for the fibres of <code>f</code> over <code>y</code>.</p>
<pre class="Agda"><a data-type="(r : is-iso f) → is-right-inverse (r .inv) f" id="7187" href="1Lab.Equiv.html#6171" class="Field">is-iso.rinv</a> <a id="7199" class="Symbol">(</a><a data-type="is-equiv f → is-iso f" id="7200" href="1Lab.Equiv.html#6884" class="Function">is-equiv→is-iso</a> <a id="7216" href="1Lab.Equiv.html#7216" class="Bound">eqv</a><a id="7219" class="Symbol">)</a> <a id="7221" href="1Lab.Equiv.html#7221" class="Bound">y</a> <a id="7223" class="Symbol">=</a>
  <a id="7227" href="1Lab.Equiv.html#7216" class="Bound">eqv</a> <a id="7231" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="7232" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="7239" href="1Lab.Equiv.html#7221" class="Bound">y</a> <a id="7241" class="Symbol">.</a><a data-type="is-contr A → A" id="7242" href="1Lab.HLevel.html#1401" class="Field">centre</a> <a id="7249" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="7250" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a>
</pre>
<p>Similarly, that one fibre gives us a proof that the function above is a right inverse to <code>f</code>.</p>
<pre class="Agda"><a data-type="(r : is-iso f) → is-left-inverse (r .inv) f" id="7362" href="1Lab.Equiv.html#6205" class="Field">is-iso.linv</a> <a id="7374" class="Symbol">(</a><a data-type="is-equiv f → is-iso f" id="7375" href="1Lab.Equiv.html#6884" class="Function">is-equiv→is-iso</a> <a id="7391" class="Symbol">{</a><a id="7392" class="Argument">f</a> <a id="7394" class="Symbol">=</a> <a id="7396" href="1Lab.Equiv.html#7396" class="Bound">f</a><a id="7397" class="Symbol">}</a> <a id="7399" href="1Lab.Equiv.html#7399" class="Bound">eqv</a><a id="7402" class="Symbol">)</a> <a id="7404" href="1Lab.Equiv.html#7404" class="Bound">x</a> <a id="7406" href="1Lab.Equiv.html#7406" class="Bound">i</a> <a id="7408" class="Symbol">=</a>
  <a id="7412" href="1Lab.Equiv.html#7399" class="Bound">eqv</a> <a id="7416" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="7417" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="7424" class="Symbol">(</a><a id="7425" href="1Lab.Equiv.html#7396" class="Bound">f</a> <a id="7427" href="1Lab.Equiv.html#7404" class="Bound">x</a><a id="7428" class="Symbol">)</a> <a id="7430" class="Symbol">.</a><a data-type="(r : is-contr A) (x : A) → r .centre ≡ x" id="7431" href="1Lab.HLevel.html#1416" class="Field">paths</a> <a id="7437" class="Symbol">(</a><a id="7438" href="1Lab.Equiv.html#7404" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="7440" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="x ≡ x" id="7442" href="1Lab.Path.html#3593" class="Function">refl</a><a id="7446" class="Symbol">)</a> <a id="7448" href="1Lab.Equiv.html#7406" class="Bound">i</a> <a id="7450" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="7451" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a>
</pre>
<p>The proof that the function is a <em>left</em> inverse comes from the fibres of <code>f</code> over <code>y</code> being contractible. Since we have a fibre - namely, <code>f</code> maps <code>x</code> to <code>f x</code> by <span class="Agda"><a data-type="x ≡ x" href="1Lab.Path.html#3593" class="Function">refl</a></span> - we can get any other we want!</p>
<h1 id="equivalences-from-isomorphisms"><a href="#equivalences-from-isomorphisms" class="header-link">Equivalences from isomorphisms<span class="header-link-emoji">🔗</span></a></h1>
<p>Any isomorphism can be upgraded into an equivalence, in a way that preserves the function <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>,</span> its inverse <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>,</span> <em>and</em> the proof <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> is a right inverse to <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>.</span> We can not preserve <em>everything</em>, though, as is usual when making something “more coherent”. Furthermore, if everything was preserved, <span class="Agda"><a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" href="1Lab.Equiv.html#6049" class="Record">is-iso</a></span> would be a proposition, and this is <a href="1Lab.Counterexamples.IsIso.html">provably not the case</a>.</p>
<p>The argument presented here is done directly in cubical style, but a less direct proof is also available, by showing that every isomorphism is a <a href="1Lab.Equiv.HalfAdjoint.html">half-adjoint equivalence</a>, and that half-adjoint equivalences have contractible fibres.</p>
<pre class="Agda"><a id="8443" class="Keyword">module</a> <a id="8450" href="1Lab.Equiv.html#8450" class="Module">_</a> <a id="8452" class="Symbol">{</a><a id="8453" href="1Lab.Equiv.html#8453" class="Bound">f</a> <a id="8455" class="Symbol">:</a> <a id="8457" href="1Lab.Equiv.html#1608" class="Generalizable">A</a> <a id="8459" class="Symbol">→</a> <a id="8461" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="8462" class="Symbol">}</a> <a id="8464" class="Symbol">(</a><a id="8465" href="1Lab.Equiv.html#8465" class="Bound">i</a> <a id="8467" class="Symbol">:</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="8469" href="1Lab.Equiv.html#6049" class="Record">is-iso</a> <a id="8476" href="1Lab.Equiv.html#8453" class="Bound">f</a><a id="8477" class="Symbol">)</a> <a id="8479" class="Keyword">where</a>

  <a id="8488" class="Keyword">open</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="8493" href="1Lab.Equiv.html#6049" class="Module">is-iso</a> <a id="8500" href="1Lab.Equiv.html#8465" class="Bound">i</a> <a id="8502" class="Keyword">renaming</a> <a id="8511" class="Symbol">(</a> <a data-type="is-iso f → B₁ → A" id="8513" href="1Lab.Equiv.html#6155" class="Field">inv</a> <a id="8517" class="Symbol">to</a> <a id="8520" class="Field">g</a>
                         <a id="8547" class="Symbol">;</a> <a data-type="(r : is-iso f) → is-right-inverse (r .inv) f" id="8549" href="1Lab.Equiv.html#6171" class="Field">rinv</a> <a id="8554" class="Symbol">to</a> <a id="8557" class="Field">s</a>
                         <a id="8584" class="Symbol">;</a> <a data-type="(r : is-iso f) → is-left-inverse (r .inv) f" id="8586" href="1Lab.Equiv.html#6205" class="Field">linv</a> <a id="8591" class="Symbol">to</a> <a id="8594" class="Field">t</a>
                         <a id="8621" class="Symbol">)</a>
</pre>
<p>Suppose, then, that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f : A \to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> and <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>:</mo><mi>B</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">g : B \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>,</span> and we’re given witnesses <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>:</mo><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mtext> </mtext><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">s : f (g\ x) = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>:</mo><mi>g</mi><mo stretchy="false">(</mo><mi>f</mi><mtext> </mtext><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">t : g (f\ x) = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> (named for <strong>s</strong>ection and re<strong>t</strong>raction) that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> are inverses. We want to show that, for any <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>,</span> the <span class="Agda"><a data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" href="1Lab.Equiv.html#1893" class="Function">fibre</a></span> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> is contractible. It suffices to show that the fibre is propositional, and that it is inhabited.</p>
<p>We begin with showing that the fibre over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> is propositional, since that’s the harder of the two arguments. Suppose that we have <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>,</span> <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,</span> <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,</span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">p_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> as below; Note that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>p</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_0, p_0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>p</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_1, p_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> are fibres of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> over <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>.</span> What we need to show is that we have some <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>:</mo><msub><mi>x</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi : x_0 ≡ x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6138em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_0 ≡ p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> <em><code class="sourceCode agda" data-ident="PathP">over</code></em> <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>.</span></p>
<pre class="Agda">  <a id="9356" class="Keyword">private</a> <a id="9364" class="Keyword">module</a> <a id="9371" href="1Lab.Equiv.html#9371" class="Module">_</a> <a id="9373" class="Symbol">(</a><a id="9374" href="1Lab.Equiv.html#9374" class="Bound">y</a> <a id="9376" class="Symbol">:</a> <a id="9378" href="1Lab.Equiv.html#8461" class="Bound">B</a><a id="9379" class="Symbol">)</a> <a id="9381" class="Symbol">(</a><a id="9382" href="1Lab.Equiv.html#9382" class="Bound">x0</a> <a id="9385" href="1Lab.Equiv.html#9385" class="Bound">x1</a> <a id="9388" class="Symbol">:</a> <a id="9390" href="1Lab.Equiv.html#8457" class="Bound">A</a><a id="9391" class="Symbol">)</a> <a id="9393" class="Symbol">(</a><a id="9394" href="1Lab.Equiv.html#9394" class="Bound">p0</a> <a id="9397" class="Symbol">:</a> <a id="9399" href="1Lab.Equiv.html#8453" class="Bound">f</a> <a id="9401" href="1Lab.Equiv.html#9382" class="Bound">x0</a> <a data-type="A → A → Type ℓ" id="9404" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="9406" href="1Lab.Equiv.html#9374" class="Bound">y</a><a id="9407" class="Symbol">)</a> <a id="9409" class="Symbol">(</a><a id="9410" href="1Lab.Equiv.html#9410" class="Bound">p1</a> <a id="9413" class="Symbol">:</a> <a id="9415" href="1Lab.Equiv.html#8453" class="Bound">f</a> <a id="9417" href="1Lab.Equiv.html#9385" class="Bound">x1</a> <a data-type="A → A → Type ℓ" id="9420" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="9422" href="1Lab.Equiv.html#9374" class="Bound">y</a><a id="9423" class="Symbol">)</a> <a id="9425" class="Keyword">where</a>
</pre>
<p>As an intermediate step in proving that <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_0 ≡ p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,</span> we <em>must</em> show that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_0 ≡ x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6138em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> - without this, we can’t even <em>state</em> that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">p_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> are identified, since they live in different types! To this end, we will build <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>:</mo><msub><mi>p</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi : p_0 ≡ p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,</span> parts of which will be required to assemble the overall proof that <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_0 ≡ p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span></p>
<p>We’ll detail the construction of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\pi_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>;</span> for <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,</span> the same method is used. We want to construct a <em>line</em>, which we can do by exhibiting that line as the missing face in a <em>square</em>. We have equations <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mtext> </mtext><mi>y</mi><mo>≡</mo><mi>g</mi><mtext> </mtext><mi>y</mi></mrow><annotation encoding="application/x-tex">g\ y ≡ g\ y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> (<span class="Agda"><a data-type="x ≡ x" href="1Lab.Path.html#3593" class="Function">refl</a></span>), <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>f</mi><mtext> </mtext><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>≡</mo><mi>g</mi><mtext> </mtext><mi>y</mi></mrow><annotation encoding="application/x-tex">g\ (f\ x_0) ≡ g\ y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> (the action of <code>g</code> on <code>p0</code>), and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>f</mi><mtext> </mtext><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">g\ (f\ x_0) = x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> by the assumption that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> is a right inverse to <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>.</span> Diagramatically, these fit together into a square:</p>
<div class="diagram-container">
<img src="193afca482e4eaf959452d27288a9c224bb0eaf2.svg" title="commutative diagram" class="diagram quiver" />
</div>
<p>The missing line in this square is <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\pi_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span> Since the <em>inside</em> (the <span class="Agda"><a data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ]) →
outS u0 ≡ hcomp u (outS u0)" href="1Lab.Path.html#35620" class="Function">filler</a></span>) will be useful to us later, we also give it a name: <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>.</span></p>
<pre class="Agda">    <a id="10779" href="1Lab.Equiv.html#10779" class="Function">π₀</a> <a id="10782" class="Symbol">:</a> <a id="10784" href="1Lab.Equiv.html#8520" class="Field">g</a> <a id="10786" href="1Lab.Equiv.html#9374" class="Bound">y</a> <a data-type="A → A → Type ℓ" id="10788" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10790" href="1Lab.Equiv.html#9382" class="Bound">x0</a>
    <a id="10797" href="1Lab.Equiv.html#10779" class="Function">π₀</a> <a id="10800" href="1Lab.Equiv.html#10800" class="Bound">i</a> <a id="10802" class="Symbol">=</a> <a id="10804" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="10810" class="Symbol">(λ</a> <a id="10813" href="1Lab.Equiv.html#10813" class="Bound">k</a> <a id="10815" class="Symbol">→</a> <a id="10817" class="Symbol">λ</a> <a id="10819" class="Symbol">{</a> <a id="10821" class="Symbol">(</a><a id="10822" href="1Lab.Equiv.html#10800" class="Bound">i</a> <a id="10824" class="Symbol">=</a> <a id="10826" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="10828" class="Symbol">)</a> <a id="10830" class="Symbol">→</a> <a id="10832" href="1Lab.Equiv.html#8520" class="Field">g</a> <a id="10834" href="1Lab.Equiv.html#9374" class="Bound">y</a>
                          <a id="10862" class="Symbol">;</a> <a id="10864" class="Symbol">(</a><a id="10865" href="1Lab.Equiv.html#10800" class="Bound">i</a> <a id="10867" class="Symbol">=</a> <a id="10869" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="10871" class="Symbol">)</a> <a id="10873" class="Symbol">→</a> <a id="10875" href="1Lab.Equiv.html#8594" class="Field">t</a> <a id="10877" href="1Lab.Equiv.html#9382" class="Bound">x0</a> <a id="10880" href="1Lab.Equiv.html#10813" class="Bound">k</a>
                          <a id="10908" class="Symbol">})</a>
                    <a id="10931" class="Symbol">(</a><a id="10932" href="1Lab.Equiv.html#8520" class="Field">g</a> <a id="10934" class="Symbol">(</a><a id="10935" href="1Lab.Equiv.html#9394" class="Bound">p0</a> <a id="10938" class="Symbol">(</a><a id="10939" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="10941" href="1Lab.Equiv.html#10800" class="Bound">i</a><a id="10942" class="Symbol">)))</a>

    <a id="10951" href="1Lab.Equiv.html#10951" class="Function">θ₀</a> <a id="10954" class="Symbol">:</a> <a data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" id="10956" href="1Lab.Path.html#9482" class="Function">Square</a> <a id="10963" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="10964" href="1Lab.Path.html#20830" class="Function">ap</a> <a id="10967" href="1Lab.Equiv.html#8520" class="Field">g</a> <a id="10969" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="10970" href="1Lab.Path.html#10631" class="Function">sym</a> <a id="10974" href="1Lab.Equiv.html#9394" class="Bound">p0</a><a id="10976" class="Symbol">))</a> <a data-type="x ≡ x" id="10979" href="1Lab.Path.html#3593" class="Function">refl</a> <a id="10984" class="Symbol">(</a><a id="10985" href="1Lab.Equiv.html#8594" class="Field">t</a> <a id="10987" href="1Lab.Equiv.html#9382" class="Bound">x0</a><a id="10989" class="Symbol">)</a> <a id="10991" href="1Lab.Equiv.html#10779" class="Function">π₀</a>
    <a id="10998" href="1Lab.Equiv.html#10951" class="Function">θ₀</a> <a id="11001" href="1Lab.Equiv.html#11001" class="Bound">i</a> <a id="11003" href="1Lab.Equiv.html#11003" class="Bound">j</a> <a id="11005" class="Symbol">=</a> <a data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ]) →
outS u0 ≡ hcomp u (outS u0)" id="11007" href="1Lab.Path.html#35620" class="Function">hfill</a> <a id="11013" class="Symbol">(λ</a> <a id="11016" href="1Lab.Equiv.html#11016" class="Bound">k</a> <a id="11018" class="Symbol">→</a> <a id="11020" class="Symbol">λ</a> <a id="11022" class="Symbol">{</a> <a id="11024" class="Symbol">(</a><a id="11025" href="1Lab.Equiv.html#11001" class="Bound">i</a> <a id="11027" class="Symbol">=</a> <a id="11029" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="11031" class="Symbol">)</a> <a id="11033" class="Symbol">→</a> <a id="11035" href="1Lab.Equiv.html#8520" class="Field">g</a> <a id="11037" href="1Lab.Equiv.html#9374" class="Bound">y</a>
                            <a id="11067" class="Symbol">;</a> <a id="11069" class="Symbol">(</a><a id="11070" href="1Lab.Equiv.html#11001" class="Bound">i</a> <a id="11072" class="Symbol">=</a> <a id="11074" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="11076" class="Symbol">)</a> <a id="11078" class="Symbol">→</a> <a id="11080" href="1Lab.Equiv.html#8594" class="Field">t</a> <a id="11082" href="1Lab.Equiv.html#9382" class="Bound">x0</a> <a id="11085" href="1Lab.Equiv.html#11016" class="Bound">k</a>
                            <a id="11115" class="Symbol">})</a>
                   <a id="11137" class="Symbol">(</a><a id="11138" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="11142" class="Symbol">(</a><a id="11143" href="1Lab.Equiv.html#8520" class="Field">g</a> <a id="11145" class="Symbol">(</a><a id="11146" href="1Lab.Equiv.html#9394" class="Bound">p0</a> <a id="11149" class="Symbol">(</a><a id="11150" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="11152" href="1Lab.Equiv.html#11001" class="Bound">i</a><a id="11153" class="Symbol">))))</a> <a id="11158" href="1Lab.Equiv.html#11003" class="Bound">j</a>
</pre>
<p>Since the construction of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is analogous, I’ll simply present the square. We correspondingly name the missing face <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and the filler <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\theta_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span></p>
<div class="mathpar">
<div class="diagram-container">
<img src="7b944591e80866a5b04179d5ec65b925a6e46ba7.svg" title="commutative diagram" class="diagram quiver" />
</div>
<pre class="Agda">    <a id="11786" href="1Lab.Equiv.html#11786" class="Function">π₁</a> <a id="11789" class="Symbol">:</a> <a id="11791" href="1Lab.Equiv.html#8520" class="Field">g</a> <a id="11793" href="1Lab.Equiv.html#9374" class="Bound">y</a> <a data-type="A → A → Type ℓ" id="11795" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="11797" href="1Lab.Equiv.html#9385" class="Bound">x1</a>
    <a id="11804" href="1Lab.Equiv.html#11786" class="Function">π₁</a> <a id="11807" href="1Lab.Equiv.html#11807" class="Bound">i</a> <a id="11809" class="Symbol">=</a> <a id="11811" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="11817" class="Symbol">(λ</a> <a id="11820" href="1Lab.Equiv.html#11820" class="Bound">k</a> <a id="11822" class="Symbol">→</a> <a id="11824" class="Symbol">λ</a> <a id="11826" class="Symbol">{</a> <a id="11828" class="Symbol">(</a><a id="11829" href="1Lab.Equiv.html#11807" class="Bound">i</a> <a id="11831" class="Symbol">=</a> <a id="11833" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="11835" class="Symbol">)</a> <a id="11837" class="Symbol">→</a> <a id="11839" href="1Lab.Equiv.html#8520" class="Field">g</a> <a id="11841" href="1Lab.Equiv.html#9374" class="Bound">y</a>
                          <a id="11869" class="Symbol">;</a> <a id="11871" class="Symbol">(</a><a id="11872" href="1Lab.Equiv.html#11807" class="Bound">i</a> <a id="11874" class="Symbol">=</a> <a id="11876" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="11878" class="Symbol">)</a> <a id="11880" class="Symbol">→</a> <a id="11882" href="1Lab.Equiv.html#8594" class="Field">t</a> <a id="11884" href="1Lab.Equiv.html#9385" class="Bound">x1</a> <a id="11887" href="1Lab.Equiv.html#11820" class="Bound">k</a>
                          <a id="11915" class="Symbol">})</a>
                    <a id="11938" class="Symbol">(</a><a id="11939" href="1Lab.Equiv.html#8520" class="Field">g</a> <a id="11941" class="Symbol">(</a><a id="11942" href="1Lab.Equiv.html#9410" class="Bound">p1</a> <a id="11945" class="Symbol">(</a><a id="11946" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="11948" href="1Lab.Equiv.html#11807" class="Bound">i</a><a id="11949" class="Symbol">)))</a>

    <a id="11958" href="1Lab.Equiv.html#11958" class="Function">θ₁</a> <a id="11961" class="Symbol">:</a> <a data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" id="11963" href="1Lab.Path.html#9482" class="Function">Square</a> <a id="11970" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="11971" href="1Lab.Path.html#20830" class="Function">ap</a> <a id="11974" href="1Lab.Equiv.html#8520" class="Field">g</a> <a id="11976" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="11977" href="1Lab.Path.html#10631" class="Function">sym</a> <a id="11981" href="1Lab.Equiv.html#9410" class="Bound">p1</a><a id="11983" class="Symbol">))</a> <a data-type="x ≡ x" id="11986" href="1Lab.Path.html#3593" class="Function">refl</a> <a id="11991" class="Symbol">(</a><a id="11992" href="1Lab.Equiv.html#8594" class="Field">t</a> <a id="11994" href="1Lab.Equiv.html#9385" class="Bound">x1</a><a id="11996" class="Symbol">)</a> <a id="11998" href="1Lab.Equiv.html#11786" class="Function">π₁</a>
    <a id="12005" href="1Lab.Equiv.html#11958" class="Function">θ₁</a> <a id="12008" href="1Lab.Equiv.html#12008" class="Bound">i</a> <a id="12010" href="1Lab.Equiv.html#12010" class="Bound">j</a> <a id="12012" class="Symbol">=</a> <a data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ]) →
outS u0 ≡ hcomp u (outS u0)" id="12014" href="1Lab.Path.html#35620" class="Function">hfill</a> <a id="12020" class="Symbol">(λ</a> <a id="12023" href="1Lab.Equiv.html#12023" class="Bound">k</a> <a id="12025" class="Symbol">→</a> <a id="12027" class="Symbol">λ</a> <a id="12029" class="Symbol">{</a> <a id="12031" class="Symbol">(</a><a id="12032" href="1Lab.Equiv.html#12008" class="Bound">i</a> <a id="12034" class="Symbol">=</a> <a id="12036" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="12038" class="Symbol">)</a> <a id="12040" class="Symbol">→</a> <a id="12042" href="1Lab.Equiv.html#8520" class="Field">g</a> <a id="12044" href="1Lab.Equiv.html#9374" class="Bound">y</a>
                            <a id="12074" class="Symbol">;</a> <a id="12076" class="Symbol">(</a><a id="12077" href="1Lab.Equiv.html#12008" class="Bound">i</a> <a id="12079" class="Symbol">=</a> <a id="12081" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="12083" class="Symbol">)</a> <a id="12085" class="Symbol">→</a> <a id="12087" href="1Lab.Equiv.html#8594" class="Field">t</a> <a id="12089" href="1Lab.Equiv.html#9385" class="Bound">x1</a> <a id="12092" href="1Lab.Equiv.html#12023" class="Bound">k</a>
                            <a id="12122" class="Symbol">})</a>
                      <a id="12147" class="Symbol">(</a><a id="12148" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="12152" class="Symbol">(</a><a id="12153" href="1Lab.Equiv.html#8520" class="Field">g</a> <a id="12155" class="Symbol">(</a><a id="12156" href="1Lab.Equiv.html#9410" class="Bound">p1</a> <a id="12159" class="Symbol">(</a><a id="12160" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="12162" href="1Lab.Equiv.html#12008" class="Bound">i</a><a id="12163" class="Symbol">))))</a> <a id="12168" href="1Lab.Equiv.html#12010" class="Bound">j</a>
</pre>
</div>
<p>Joining these paths by their common <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mtext> </mtext><mi>y</mi></mrow><annotation encoding="application/x-tex">g\ y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> face, we obtain <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>:</mo><msub><mi>x</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi : x_0 ≡ x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6138em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span> This square <em>also</em> has a filler, connecting <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\pi_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> over the line <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mtext> </mtext><mi>y</mi><mo>≡</mo><mi>π</mi><mtext> </mtext><mi>i</mi></mrow><annotation encoding="application/x-tex">g\ y ≡ \pi\ i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace"> </span><span class="mord mathnormal">i</span></span></span></span>.</span></p>
<div class="mathpar">
<div class="diagram-container">
<img src="696d9aa257c82c2ac2da8bebd91fc997e3206334.svg" title="commutative diagram" class="diagram quiver" />
</div>
<pre class="Agda">    <a id="12794" href="1Lab.Equiv.html#12794" class="Function">π</a> <a id="12796" class="Symbol">:</a> <a id="12798" href="1Lab.Equiv.html#9382" class="Bound">x0</a> <a data-type="A → A → Type ℓ" id="12801" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="12803" href="1Lab.Equiv.html#9385" class="Bound">x1</a>
    <a id="12810" href="1Lab.Equiv.html#12794" class="Function">π</a> <a id="12812" href="1Lab.Equiv.html#12812" class="Bound">i</a> <a id="12814" class="Symbol">=</a> <a id="12816" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="12822" class="Symbol">(λ</a> <a id="12825" href="1Lab.Equiv.html#12825" class="Bound">k</a> <a id="12827" class="Symbol">→</a> <a id="12829" class="Symbol">λ</a> <a id="12831" class="Symbol">{</a> <a id="12833" class="Symbol">(</a><a id="12834" href="1Lab.Equiv.html#12812" class="Bound">i</a> <a id="12836" class="Symbol">=</a> <a id="12838" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="12840" class="Symbol">)</a> <a id="12842" class="Symbol">→</a> <a id="12844" href="1Lab.Equiv.html#10779" class="Function">π₀</a> <a id="12847" href="1Lab.Equiv.html#12825" class="Bound">k</a>
                         <a id="12874" class="Symbol">;</a> <a id="12876" class="Symbol">(</a><a id="12877" href="1Lab.Equiv.html#12812" class="Bound">i</a> <a id="12879" class="Symbol">=</a> <a id="12881" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="12883" class="Symbol">)</a> <a id="12885" class="Symbol">→</a> <a id="12887" href="1Lab.Equiv.html#11786" class="Function">π₁</a> <a id="12890" href="1Lab.Equiv.html#12825" class="Bound">k</a>
                         <a id="12917" class="Symbol">})</a>
                <a id="12936" class="Symbol">(</a><a id="12937" href="1Lab.Equiv.html#8520" class="Field">g</a> <a id="12939" href="1Lab.Equiv.html#9374" class="Bound">y</a><a id="12940" class="Symbol">)</a>
</pre>
</div>
<p>This concludes the construction of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>,</span> and thus, the 2D part of the proof. Now, we want to show that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_0 ≡ p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> over a path induced by <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>.</span> This is a <em>square</em> with a specific boundary, which can be built by constructing an appropriate <em>open cube</em>, where the missing face is that square. As an intermediate step, we define <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> to be the filler for the square above.</p>
<pre class="Agda">    <a id="13343" href="1Lab.Equiv.html#13343" class="Function">θ</a> <a id="13345" class="Symbol">:</a> <a data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" id="13347" href="1Lab.Path.html#9482" class="Function">Square</a> <a data-type="x ≡ x" id="13354" href="1Lab.Path.html#3593" class="Function">refl</a> <a id="13359" href="1Lab.Equiv.html#10779" class="Function">π₀</a> <a id="13362" href="1Lab.Equiv.html#11786" class="Function">π₁</a> <a id="13365" href="1Lab.Equiv.html#12794" class="Function">π</a>
    <a id="13371" href="1Lab.Equiv.html#13343" class="Function">θ</a> <a id="13373" href="1Lab.Equiv.html#13373" class="Bound">i</a> <a id="13375" href="1Lab.Equiv.html#13375" class="Bound">j</a> <a id="13377" class="Symbol">=</a> <a data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ]) →
outS u0 ≡ hcomp u (outS u0)" id="13379" href="1Lab.Path.html#35620" class="Function">hfill</a> <a id="13385" class="Symbol">(λ</a> <a id="13388" href="1Lab.Equiv.html#13388" class="Bound">k</a> <a id="13390" class="Symbol">→</a> <a id="13392" class="Symbol">λ</a> <a id="13394" class="Symbol">{</a> <a id="13396" class="Symbol">(</a><a id="13397" href="1Lab.Equiv.html#13373" class="Bound">i</a> <a id="13399" class="Symbol">=</a> <a id="13401" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="13403" class="Symbol">)</a> <a id="13405" class="Symbol">→</a> <a id="13407" href="1Lab.Equiv.html#11786" class="Function">π₁</a> <a id="13410" href="1Lab.Equiv.html#13388" class="Bound">k</a>
                           <a id="13439" class="Symbol">;</a> <a id="13441" class="Symbol">(</a><a id="13442" href="1Lab.Equiv.html#13373" class="Bound">i</a> <a id="13444" class="Symbol">=</a> <a id="13446" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="13448" class="Symbol">)</a> <a id="13450" class="Symbol">→</a> <a id="13452" href="1Lab.Equiv.html#10779" class="Function">π₀</a> <a id="13455" href="1Lab.Equiv.html#13388" class="Bound">k</a>
                           <a id="13484" class="Symbol">})</a>
                      <a id="13509" class="Symbol">(</a><a id="13510" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="13514" class="Symbol">(</a><a id="13515" href="1Lab.Equiv.html#8520" class="Field">g</a> <a id="13517" href="1Lab.Equiv.html#9374" class="Bound">y</a><a id="13518" class="Symbol">))</a> <a id="13521" href="1Lab.Equiv.html#13375" class="Bound">j</a>
</pre>
<p>Observe that we can coherently alter <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> to get <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ι</mi></mrow><annotation encoding="application/x-tex">\iota</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ι</span></span></span></span> below, which expresses that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi></mrow><mtext> </mtext><mi>g</mi><mtext> </mtext><msub><mi>p</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\mathrm{ap}\ g\ p_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">ap</span></span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi></mrow><mtext> </mtext><mi>g</mi><mtext> </mtext><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\mathrm{ap}\ g\ p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">ap</span></span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> are identified.</p>
<pre class="Agda">    <a id="13694" href="1Lab.Equiv.html#13694" class="Function">ι</a> <a id="13696" class="Symbol">:</a> <a data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" id="13698" href="1Lab.Path.html#9482" class="Function">Square</a> <a id="13705" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="13706" href="1Lab.Path.html#20830" class="Function">ap</a> <a id="13709" class="Symbol">(</a><a id="13710" href="1Lab.Equiv.html#8520" class="Field">g</a> <a data-type="((y : B₁ x) → C x y) → (f : (x : A) → B₁ x) (x : A) → C x (f x)" id="13712" href="1Lab.Type.html#2227" class="Function Operator">∘</a> <a id="13714" href="1Lab.Equiv.html#8453" class="Bound">f</a><a id="13715" class="Symbol">)</a> <a id="13717" href="1Lab.Equiv.html#12794" class="Function">π</a><a id="13718" class="Symbol">)</a> <a id="13720" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="13721" href="1Lab.Path.html#20830" class="Function">ap</a> <a id="13724" href="1Lab.Equiv.html#8520" class="Field">g</a> <a id="13726" href="1Lab.Equiv.html#9394" class="Bound">p0</a><a id="13728" class="Symbol">)</a> <a id="13730" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="13731" href="1Lab.Path.html#20830" class="Function">ap</a> <a id="13734" href="1Lab.Equiv.html#8520" class="Field">g</a> <a id="13736" href="1Lab.Equiv.html#9410" class="Bound">p1</a><a id="13738" class="Symbol">)</a> <a data-type="x ≡ x" id="13740" href="1Lab.Path.html#3593" class="Function">refl</a>
    <a id="13749" href="1Lab.Equiv.html#13694" class="Function">ι</a> <a id="13751" href="1Lab.Equiv.html#13751" class="Bound">i</a> <a id="13753" href="1Lab.Equiv.html#13753" class="Bound">j</a> <a id="13755" class="Symbol">=</a> <a id="13757" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="13763" class="Symbol">(λ</a> <a id="13766" href="1Lab.Equiv.html#13766" class="Bound">k</a> <a id="13768" class="Symbol">→</a> <a id="13770" class="Symbol">λ</a> <a id="13772" class="Symbol">{</a> <a id="13774" class="Symbol">(</a><a id="13775" href="1Lab.Equiv.html#13751" class="Bound">i</a> <a id="13777" class="Symbol">=</a> <a id="13779" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="13781" class="Symbol">)</a> <a id="13783" class="Symbol">→</a> <a id="13785" href="1Lab.Equiv.html#10951" class="Function">θ₀</a> <a id="13788" class="Symbol">(</a><a id="13789" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="13791" href="1Lab.Equiv.html#13753" class="Bound">j</a><a id="13792" class="Symbol">)</a> <a id="13794" class="Symbol">(</a><a id="13795" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="13797" href="1Lab.Equiv.html#13766" class="Bound">k</a><a id="13798" class="Symbol">)</a>
                           <a id="13827" class="Symbol">;</a> <a id="13829" class="Symbol">(</a><a id="13830" href="1Lab.Equiv.html#13751" class="Bound">i</a> <a id="13832" class="Symbol">=</a> <a id="13834" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="13836" class="Symbol">)</a> <a id="13838" class="Symbol">→</a> <a id="13840" href="1Lab.Equiv.html#11958" class="Function">θ₁</a> <a id="13843" class="Symbol">(</a><a id="13844" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="13846" href="1Lab.Equiv.html#13753" class="Bound">j</a><a id="13847" class="Symbol">)</a> <a id="13849" class="Symbol">(</a><a id="13850" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="13852" href="1Lab.Equiv.html#13766" class="Bound">k</a><a id="13853" class="Symbol">)</a>
                           <a id="13882" class="Symbol">;</a> <a id="13884" class="Symbol">(</a><a id="13885" href="1Lab.Equiv.html#13753" class="Bound">j</a> <a id="13887" class="Symbol">=</a> <a id="13889" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="13891" class="Symbol">)</a> <a id="13893" class="Symbol">→</a> <a id="13895" href="1Lab.Equiv.html#8594" class="Field">t</a> <a id="13897" class="Symbol">(</a><a id="13898" href="1Lab.Equiv.html#12794" class="Function">π</a> <a id="13900" href="1Lab.Equiv.html#13751" class="Bound">i</a><a id="13901" class="Symbol">)</a> <a id="13903" class="Symbol">(</a><a id="13904" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="13906" href="1Lab.Equiv.html#13766" class="Bound">k</a><a id="13907" class="Symbol">)</a>
                           <a id="13936" class="Symbol">;</a> <a id="13938" class="Symbol">(</a><a id="13939" href="1Lab.Equiv.html#13753" class="Bound">j</a> <a id="13941" class="Symbol">=</a> <a id="13943" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="13945" class="Symbol">)</a> <a id="13947" class="Symbol">→</a> <a id="13949" href="1Lab.Equiv.html#8520" class="Field">g</a> <a id="13951" href="1Lab.Equiv.html#9374" class="Bound">y</a>
                           <a id="13980" class="Symbol">})</a>
                  <a id="14001" class="Symbol">(</a><a id="14002" href="1Lab.Equiv.html#13343" class="Function">θ</a> <a id="14004" href="1Lab.Equiv.html#13751" class="Bound">i</a> <a id="14006" class="Symbol">(</a><a id="14007" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="14009" href="1Lab.Equiv.html#13753" class="Bound">j</a><a id="14010" class="Symbol">))</a>
</pre>
<p>This composition can be visualised as the <em>red</em> (front) face in the diagram below. The back face is <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mtext> </mtext><mi>i</mi><mtext> </mtext><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><mtext> </mtext><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\theta\ i\ (\neg\ j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace"> </span><span class="mord mathnormal">i</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord">¬</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>,</span> i.e. <code>(θ i (~ j))</code> in the code. Similarly, the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">j = \mathrm{i1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i1</span></span></span></span></span> (bottom) face is <code>g y</code>, the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">j = \mathrm{i0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i0</span></span></span></span></span> (top) face is <code>t (π i) (~ k)</code>, and similarly for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">i = \mathrm{i0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i0</span></span></span></span></span> (left) and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">i = \mathrm{i1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i1</span></span></span></span></span> (right).</p>
<div class="diagram-container">
<img src="3da8b4e48d862d7f780b6c04b6e88e057155ceea.svg" title="commutative diagram" class="diagram quiver tall-2" />
</div>
<p>The fact that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> only appears as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mi>j</mi></mrow><annotation encoding="application/x-tex">\neg j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord">¬</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> can be understood as the diagram above being <em>upside-down</em>. Indeed, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\pi_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> in the boundary of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> (the inner, blue face) are inverted when their types are considered. We’re in the home stretch: Using our assumption <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>:</mo><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mtext> </mtext><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">s : f (g\ x) = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>,</span> we can cancel all of the <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∘</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">f \circ g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>s</span> in the diagram above to get what we wanted: <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_0 ≡ p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span></p>
<pre class="Agda">    <a id="16872" href="1Lab.Equiv.html#16872" class="Function">sq1</a> <a id="16876" class="Symbol">:</a> <a data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" id="16878" href="1Lab.Path.html#9482" class="Function">Square</a> <a id="16885" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="16886" href="1Lab.Path.html#20830" class="Function">ap</a> <a id="16889" href="1Lab.Equiv.html#8453" class="Bound">f</a> <a id="16891" href="1Lab.Equiv.html#12794" class="Function">π</a><a id="16892" class="Symbol">)</a> <a id="16894" href="1Lab.Equiv.html#9394" class="Bound">p0</a> <a id="16897" href="1Lab.Equiv.html#9410" class="Bound">p1</a> <a data-type="x ≡ x" id="16900" href="1Lab.Path.html#3593" class="Function">refl</a>
    <a id="16909" href="1Lab.Equiv.html#16872" class="Function">sq1</a> <a id="16913" href="1Lab.Equiv.html#16913" class="Bound">i</a> <a id="16915" href="1Lab.Equiv.html#16915" class="Bound">j</a> <a id="16917" class="Symbol">=</a> <a id="16919" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="16925" class="Symbol">(λ</a> <a id="16928" href="1Lab.Equiv.html#16928" class="Bound">k</a> <a id="16930" class="Symbol">→</a> <a id="16932" class="Symbol">λ</a> <a id="16934" class="Symbol">{</a> <a id="16936" class="Symbol">(</a><a id="16937" href="1Lab.Equiv.html#16913" class="Bound">i</a> <a id="16939" class="Symbol">=</a> <a id="16941" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="16943" class="Symbol">)</a> <a id="16945" class="Symbol">→</a> <a id="16947" href="1Lab.Equiv.html#8557" class="Field">s</a> <a id="16949" class="Symbol">(</a><a id="16950" href="1Lab.Equiv.html#9394" class="Bound">p0</a> <a id="16953" href="1Lab.Equiv.html#16915" class="Bound">j</a><a id="16954" class="Symbol">)</a> <a id="16956" href="1Lab.Equiv.html#16928" class="Bound">k</a>
                             <a id="16987" class="Symbol">;</a> <a id="16989" class="Symbol">(</a><a id="16990" href="1Lab.Equiv.html#16913" class="Bound">i</a> <a id="16992" class="Symbol">=</a> <a id="16994" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="16996" class="Symbol">)</a> <a id="16998" class="Symbol">→</a> <a id="17000" href="1Lab.Equiv.html#8557" class="Field">s</a> <a id="17002" class="Symbol">(</a><a id="17003" href="1Lab.Equiv.html#9410" class="Bound">p1</a> <a id="17006" href="1Lab.Equiv.html#16915" class="Bound">j</a><a id="17007" class="Symbol">)</a> <a id="17009" href="1Lab.Equiv.html#16928" class="Bound">k</a>
                             <a id="17040" class="Symbol">;</a> <a id="17042" class="Symbol">(</a><a id="17043" href="1Lab.Equiv.html#16915" class="Bound">j</a> <a id="17045" class="Symbol">=</a> <a id="17047" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="17049" class="Symbol">)</a> <a id="17051" class="Symbol">→</a> <a id="17053" href="1Lab.Equiv.html#8557" class="Field">s</a> <a id="17055" class="Symbol">(</a><a id="17056" href="1Lab.Equiv.html#8453" class="Bound">f</a> <a id="17058" class="Symbol">(</a><a id="17059" href="1Lab.Equiv.html#12794" class="Function">π</a> <a id="17061" href="1Lab.Equiv.html#16913" class="Bound">i</a><a id="17062" class="Symbol">))</a> <a id="17065" href="1Lab.Equiv.html#16928" class="Bound">k</a>
                             <a id="17096" class="Symbol">;</a> <a id="17098" class="Symbol">(</a><a id="17099" href="1Lab.Equiv.html#16915" class="Bound">j</a> <a id="17101" class="Symbol">=</a> <a id="17103" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="17105" class="Symbol">)</a> <a id="17107" class="Symbol">→</a> <a id="17109" href="1Lab.Equiv.html#8557" class="Field">s</a> <a id="17111" href="1Lab.Equiv.html#9374" class="Bound">y</a> <a id="17113" href="1Lab.Equiv.html#16928" class="Bound">k</a>
                             <a id="17144" class="Symbol">})</a>
                    <a id="17167" class="Symbol">(</a><a id="17168" href="1Lab.Equiv.html#8453" class="Bound">f</a> <a id="17170" class="Symbol">(</a><a id="17171" href="1Lab.Equiv.html#13694" class="Function">ι</a> <a id="17173" href="1Lab.Equiv.html#16913" class="Bound">i</a> <a id="17175" href="1Lab.Equiv.html#16915" class="Bound">j</a><a id="17176" class="Symbol">))</a>
</pre>
<p>The composition above can be visualised as the front (red) face in the cubical diagram below. Once more, left is <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">i = \mathrm{i0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i0</span></span></span></span></span>,</span> right is <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">i = \mathrm{i1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i1</span></span></span></span></span>,</span> up is <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">j = \mathrm{i0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i0</span></span></span></span></span>,</span> and down is <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">j = \mathrm{i1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i1</span></span></span></span></span>.</span></p>
<div class="diagram-container">
<img src="d1c933642181adc04fdc23a3fcfe2a7fc5fd8a77.svg" title="commutative diagram" class="diagram quiver tall-2" />
</div>
<p>Putting all of this together, we get that <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>p</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>≡</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>p</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_0, p_0) ≡ (x_1, p_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</span> Since there were no assumptions on any of the variables under consideration, this indeed says that the fibre over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> is a proposition for any choice of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>.</span></p>
<pre class="Agda">    <a id="19659" href="1Lab.Equiv.html#19659" class="Function">is-iso→fibre-is-prop</a> <a id="19680" class="Symbol">:</a> <a id="19682" class="Symbol">(</a><a id="19683" href="1Lab.Equiv.html#9382" class="Bound">x0</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="19686" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="19688" href="1Lab.Equiv.html#9394" class="Bound">p0</a><a id="19690" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="19692" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="19694" class="Symbol">(</a><a id="19695" href="1Lab.Equiv.html#9385" class="Bound">x1</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="19698" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="19700" href="1Lab.Equiv.html#9410" class="Bound">p1</a><a id="19702" class="Symbol">)</a>
    <a id="19708" href="1Lab.Equiv.html#19659" class="Function">is-iso→fibre-is-prop</a> <a id="19729" href="1Lab.Equiv.html#19729" class="Bound">i</a> <a id="19731" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="19732" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="19736" class="Symbol">=</a> <a id="19738" href="1Lab.Equiv.html#12794" class="Function">π</a> <a id="19740" href="1Lab.Equiv.html#19729" class="Bound">i</a>
    <a id="19746" href="1Lab.Equiv.html#19659" class="Function">is-iso→fibre-is-prop</a> <a id="19767" href="1Lab.Equiv.html#19767" class="Bound">i</a> <a id="19769" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="19770" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="19774" class="Symbol">=</a> <a id="19776" href="1Lab.Equiv.html#16872" class="Function">sq1</a> <a id="19780" href="1Lab.Equiv.html#19767" class="Bound">i</a>
</pre>
<p>Since the fibre over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> is inhabited by <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>g</mi><mtext> </mtext><mi>y</mi><mo separator="true">,</mo><mi>s</mi><mtext> </mtext><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(g\ y, s\ y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>,</span> we get that any isomorphism has contractible fibres:</p>
<pre class="Agda">  <a data-type="(i : is-iso f) → is-equiv f" id="19908" href="1Lab.Equiv.html#19908" class="Function">is-iso→is-equiv</a> <a id="19924" class="Symbol">:</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="19926" href="1Lab.Equiv.html#2306" class="Record">is-equiv</a> <a id="19935" href="1Lab.Equiv.html#8453" class="Bound">f</a>
  <a data-type="(i : is-iso f) → is-equiv f" id="19939" href="1Lab.Equiv.html#19908" class="Function">is-iso→is-equiv</a> <a id="19955" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="19956" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="19963" href="1Lab.Equiv.html#19963" class="Bound">y</a> <a id="19965" class="Symbol">.</a><a data-type="is-contr A → A" id="19966" href="1Lab.HLevel.html#1401" class="Field">centre</a> <a id="19973" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="19974" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="19978" class="Symbol">=</a> <a id="19980" href="1Lab.Equiv.html#8520" class="Field">g</a> <a id="19982" href="1Lab.Equiv.html#19963" class="Bound">y</a>
  <a data-type="(i : is-iso f) → is-equiv f" id="19986" href="1Lab.Equiv.html#19908" class="Function">is-iso→is-equiv</a> <a id="20002" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="20003" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="20010" href="1Lab.Equiv.html#20010" class="Bound">y</a> <a id="20012" class="Symbol">.</a><a data-type="is-contr A → A" id="20013" href="1Lab.HLevel.html#1401" class="Field">centre</a> <a id="20020" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="20021" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="20025" class="Symbol">=</a> <a id="20027" href="1Lab.Equiv.html#8557" class="Field">s</a> <a id="20029" href="1Lab.Equiv.html#20010" class="Bound">y</a>
  <a data-type="(i : is-iso f) → is-equiv f" id="20033" href="1Lab.Equiv.html#19908" class="Function">is-iso→is-equiv</a> <a id="20049" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="20050" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="20057" href="1Lab.Equiv.html#20057" class="Bound">y</a> <a id="20059" class="Symbol">.</a><a data-type="(r : is-contr A) (x : A) → r .centre ≡ x" id="20060" href="1Lab.HLevel.html#1416" class="Field">paths</a> <a id="20066" href="1Lab.Equiv.html#20066" class="Bound">z</a> <a id="20068" class="Symbol">=</a> 
    <a id="20075" href="1Lab.Equiv.html#19659" class="Function">is-iso→fibre-is-prop</a> <a id="20096" href="1Lab.Equiv.html#20057" class="Bound">y</a> <a id="20098" class="Symbol">(</a><a id="20099" href="1Lab.Equiv.html#8520" class="Field">g</a> <a id="20101" href="1Lab.Equiv.html#20057" class="Bound">y</a><a id="20102" class="Symbol">)</a> <a id="20104" class="Symbol">(</a><a data-type="∑ A B₁ → A" id="20105" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="20109" href="1Lab.Equiv.html#20066" class="Bound">z</a><a id="20110" class="Symbol">)</a> <a id="20112" class="Symbol">(</a><a id="20113" href="1Lab.Equiv.html#8557" class="Field">s</a> <a id="20115" href="1Lab.Equiv.html#20057" class="Bound">y</a><a id="20116" class="Symbol">)</a> <a id="20118" class="Symbol">(</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="20119" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="20123" href="1Lab.Equiv.html#20066" class="Bound">z</a><a id="20124" class="Symbol">)</a>
</pre>
<p>Applying this to the <span class="Agda"><a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" href="1Lab.Equiv.html#6321" class="Function">Iso</a></span> and <span class="Agda"><a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" href="1Lab.Equiv.html#2459" class="Function Operator">_≃_</a></span> pairs, we can turn any isomorphism into a coherent equivalence.</p>
<pre class="Agda"><a id="Iso→Equiv"></a><a data-type="Iso A B₁ → A ≃ B₁" id="20255" href="1Lab.Equiv.html#20255" class="Function">Iso→Equiv</a> <a id="20265" class="Symbol">:</a> <a id="20267" class="Symbol">∀</a> <a id="20269" class="Symbol">{</a><a id="20270" href="1Lab.Equiv.html#20270" class="Bound">ℓ₁</a> <a id="20273" href="1Lab.Equiv.html#20273" class="Bound">ℓ₂</a><a id="20275" class="Symbol">}</a> <a id="20277" class="Symbol">{</a><a id="20278" href="1Lab.Equiv.html#20278" class="Bound">A</a> <a id="20280" class="Symbol">:</a> <a id="20282" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20287" href="1Lab.Equiv.html#20270" class="Bound">ℓ₁</a><a id="20289" class="Symbol">}</a> <a id="20291" class="Symbol">{</a><a id="20292" href="1Lab.Equiv.html#20292" class="Bound">B</a> <a id="20294" class="Symbol">:</a> <a id="20296" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20301" href="1Lab.Equiv.html#20273" class="Bound">ℓ₂</a><a id="20303" class="Symbol">}</a>
          <a id="20315" class="Symbol">→</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="20317" href="1Lab.Equiv.html#6321" class="Function">Iso</a> <a id="20321" href="1Lab.Equiv.html#20278" class="Bound">A</a> <a id="20323" href="1Lab.Equiv.html#20292" class="Bound">B</a>
          <a id="20335" class="Symbol">→</a> <a id="20337" href="1Lab.Equiv.html#20278" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="20339" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="20341" href="1Lab.Equiv.html#20292" class="Bound">B</a>
<a data-type="Iso A B₁ → A ≃ B₁" id="20343" href="1Lab.Equiv.html#20255" class="Function">Iso→Equiv</a> <a id="20353" class="Symbol">(</a><a id="20354" href="1Lab.Equiv.html#20354" class="Bound">f</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="20356" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="20358" href="1Lab.Equiv.html#20358" class="Bound">is-iso</a><a id="20364" class="Symbol">)</a> <a id="20366" class="Symbol">=</a> <a id="20368" href="1Lab.Equiv.html#20354" class="Bound">f</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="20370" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="(i : is-iso f) → is-equiv f" id="20372" href="1Lab.Equiv.html#19908" class="Function">is-iso→is-equiv</a> <a id="20388" href="1Lab.Equiv.html#20358" class="Bound">is-iso</a>
</pre>
<p>A helpful lemma: Any function between contractible types is an equivalence:</p>
<pre class="Agda"><a id="is-contr→is-equiv"></a><a data-type="is-contr A → is-contr B₁ → is-equiv f" id="20485" href="1Lab.Equiv.html#20485" class="Function">is-contr→is-equiv</a> <a id="20503" class="Symbol">:</a> <a id="20505" class="Symbol">∀</a> <a id="20507" class="Symbol">{</a><a id="20508" href="1Lab.Equiv.html#20508" class="Bound">ℓ₁</a> <a id="20511" href="1Lab.Equiv.html#20511" class="Bound">ℓ₂</a><a id="20513" class="Symbol">}</a> <a id="20515" class="Symbol">{</a><a id="20516" href="1Lab.Equiv.html#20516" class="Bound">A</a> <a id="20518" class="Symbol">:</a> <a id="20520" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20525" href="1Lab.Equiv.html#20508" class="Bound">ℓ₁</a><a id="20527" class="Symbol">}</a> <a id="20529" class="Symbol">{</a><a id="20530" href="1Lab.Equiv.html#20530" class="Bound">B</a> <a id="20532" class="Symbol">:</a> <a id="20534" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20539" href="1Lab.Equiv.html#20511" class="Bound">ℓ₂</a><a id="20541" class="Symbol">}</a>
                  <a id="20561" class="Symbol">→</a> <a data-type="(A : Type ℓ) → Type ℓ" id="20563" href="1Lab.HLevel.html#1328" class="Record">is-contr</a> <a id="20572" href="1Lab.Equiv.html#20516" class="Bound">A</a> <a id="20574" class="Symbol">→</a> <a data-type="(A : Type ℓ) → Type ℓ" id="20576" href="1Lab.HLevel.html#1328" class="Record">is-contr</a> <a id="20585" href="1Lab.Equiv.html#20530" class="Bound">B</a> <a id="20587" class="Symbol">→</a> <a id="20589" class="Symbol">{</a><a id="20590" href="1Lab.Equiv.html#20590" class="Bound">f</a> <a id="20592" class="Symbol">:</a> <a id="20594" href="1Lab.Equiv.html#20516" class="Bound">A</a> <a id="20596" class="Symbol">→</a> <a id="20598" href="1Lab.Equiv.html#20530" class="Bound">B</a><a id="20599" class="Symbol">}</a>
                  <a id="20619" class="Symbol">→</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="20621" href="1Lab.Equiv.html#2306" class="Record">is-equiv</a> <a id="20630" href="1Lab.Equiv.html#20590" class="Bound">f</a>
<a data-type="is-contr A → is-contr B₁ → is-equiv f" id="20632" href="1Lab.Equiv.html#20485" class="Function">is-contr→is-equiv</a> <a id="20650" href="1Lab.Equiv.html#20650" class="Bound">cA</a> <a id="20653" href="1Lab.Equiv.html#20653" class="Bound">cB</a> <a id="20656" class="Symbol">=</a> <a data-type="(i : is-iso f) → is-equiv f" id="20658" href="1Lab.Equiv.html#19908" class="Function">is-iso→is-equiv</a> <a id="20674" href="1Lab.Equiv.html#20691" class="Function">f-is-iso</a> <a id="20683" class="Keyword">where</a>
  <a id="20691" href="1Lab.Equiv.html#20691" class="Function">f-is-iso</a> <a id="20700" class="Symbol">:</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="20702" href="1Lab.Equiv.html#6049" class="Record">is-iso</a> <a id="20709" class="Symbol">_</a>
  <a data-type="is-iso f → B₁ → A" id="20713" href="1Lab.Equiv.html#6155" class="Field">is-iso.inv</a> <a id="20724" href="1Lab.Equiv.html#20691" class="Function">f-is-iso</a> <a id="20733" class="Symbol">_</a> <a id="20735" class="Symbol">=</a> <a id="20737" href="1Lab.Equiv.html#20650" class="Bound">cA</a> <a id="20740" class="Symbol">.</a><a data-type="is-contr A → A" id="20741" href="1Lab.HLevel.html#1401" class="Field">centre</a>
  <a data-type="(r : is-iso f) → is-right-inverse (r .inv) f" id="20750" href="1Lab.Equiv.html#6171" class="Field">is-iso.rinv</a> <a id="20762" href="1Lab.Equiv.html#20691" class="Function">f-is-iso</a> <a id="20771" class="Symbol">_</a> <a id="20773" class="Symbol">=</a> <a data-type="is-contr A → is-prop A" id="20775" href="1Lab.HLevel.html#3966" class="Function">is-contr→is-prop</a> <a id="20792" href="1Lab.Equiv.html#20653" class="Bound">cB</a> <a id="20795" class="Symbol">_</a> <a id="20797" class="Symbol">_</a>
  <a data-type="(r : is-iso f) → is-left-inverse (r .inv) f" id="20801" href="1Lab.Equiv.html#6205" class="Field">is-iso.linv</a> <a id="20813" href="1Lab.Equiv.html#20691" class="Function">f-is-iso</a> <a id="20822" class="Symbol">_</a> <a id="20824" class="Symbol">=</a> <a data-type="is-contr A → is-prop A" id="20826" href="1Lab.HLevel.html#3966" class="Function">is-contr→is-prop</a> <a id="20843" href="1Lab.Equiv.html#20650" class="Bound">cA</a> <a id="20846" class="Symbol">_</a> <a id="20848" class="Symbol">_</a>

<a id="is-contr→≃"></a><a data-type="is-contr A → is-contr B₁ → A ≃ B₁" id="20851" href="1Lab.Equiv.html#20851" class="Function">is-contr→≃</a> <a id="20862" class="Symbol">:</a> <a id="20864" class="Symbol">∀</a> <a id="20866" class="Symbol">{</a><a id="20867" href="1Lab.Equiv.html#20867" class="Bound">ℓ₁</a> <a id="20870" href="1Lab.Equiv.html#20870" class="Bound">ℓ₂</a><a id="20872" class="Symbol">}</a> <a id="20874" class="Symbol">{</a><a id="20875" href="1Lab.Equiv.html#20875" class="Bound">A</a> <a id="20877" class="Symbol">:</a> <a id="20879" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20884" href="1Lab.Equiv.html#20867" class="Bound">ℓ₁</a><a id="20886" class="Symbol">}</a> <a id="20888" class="Symbol">{</a><a id="20889" href="1Lab.Equiv.html#20889" class="Bound">B</a> <a id="20891" class="Symbol">:</a> <a id="20893" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20898" href="1Lab.Equiv.html#20870" class="Bound">ℓ₂</a><a id="20900" class="Symbol">}</a>
           <a id="20913" class="Symbol">→</a> <a data-type="(A : Type ℓ) → Type ℓ" id="20915" href="1Lab.HLevel.html#1328" class="Record">is-contr</a> <a id="20924" href="1Lab.Equiv.html#20875" class="Bound">A</a> <a id="20926" class="Symbol">→</a> <a data-type="(A : Type ℓ) → Type ℓ" id="20928" href="1Lab.HLevel.html#1328" class="Record">is-contr</a> <a id="20937" href="1Lab.Equiv.html#20889" class="Bound">B</a> <a id="20939" class="Symbol">→</a> <a id="20941" href="1Lab.Equiv.html#20875" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="20943" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="20945" href="1Lab.Equiv.html#20889" class="Bound">B</a>
<a data-type="is-contr A → is-contr B₁ → A ≃ B₁" id="20947" href="1Lab.Equiv.html#20851" class="Function">is-contr→≃</a> <a id="20958" href="1Lab.Equiv.html#20958" class="Bound">cA</a> <a id="20961" href="1Lab.Equiv.html#20961" class="Bound">cB</a> <a id="20964" class="Symbol">=</a> <a id="20966" class="Symbol">(λ</a> <a id="20969" href="1Lab.Equiv.html#20969" class="Bound">_</a> <a id="20971" class="Symbol">→</a> <a id="20973" href="1Lab.Equiv.html#20961" class="Bound">cB</a> <a id="20976" class="Symbol">.</a><a data-type="is-contr A → A" id="20977" href="1Lab.HLevel.html#1401" class="Field">centre</a><a id="20983" class="Symbol">)</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="20985" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="(i : is-iso f) → is-equiv f" id="20987" href="1Lab.Equiv.html#19908" class="Function">is-iso→is-equiv</a> <a id="21003" href="1Lab.Equiv.html#21020" class="Function">f-is-iso</a> <a id="21012" class="Keyword">where</a>
  <a id="21020" href="1Lab.Equiv.html#21020" class="Function">f-is-iso</a> <a id="21029" class="Symbol">:</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="21031" href="1Lab.Equiv.html#6049" class="Record">is-iso</a> <a id="21038" class="Symbol">_</a>
  <a data-type="is-iso f → B₁ → A" id="21042" href="1Lab.Equiv.html#6155" class="Field">is-iso.inv</a> <a id="21053" href="1Lab.Equiv.html#21020" class="Function">f-is-iso</a> <a id="21062" class="Symbol">_</a> <a id="21064" class="Symbol">=</a> <a id="21066" href="1Lab.Equiv.html#20958" class="Bound">cA</a> <a id="21069" class="Symbol">.</a><a data-type="is-contr A → A" id="21070" href="1Lab.HLevel.html#1401" class="Field">centre</a>
  <a data-type="(r : is-iso f) → is-right-inverse (r .inv) f" id="21079" href="1Lab.Equiv.html#6171" class="Field">is-iso.rinv</a> <a id="21091" href="1Lab.Equiv.html#21020" class="Function">f-is-iso</a> <a id="21100" class="Symbol">_</a> <a id="21102" class="Symbol">=</a> <a data-type="is-contr A → is-prop A" id="21104" href="1Lab.HLevel.html#3966" class="Function">is-contr→is-prop</a> <a id="21121" href="1Lab.Equiv.html#20961" class="Bound">cB</a> <a id="21124" class="Symbol">_</a> <a id="21126" class="Symbol">_</a>
  <a data-type="(r : is-iso f) → is-left-inverse (r .inv) f" id="21130" href="1Lab.Equiv.html#6205" class="Field">is-iso.linv</a> <a id="21142" href="1Lab.Equiv.html#21020" class="Function">f-is-iso</a> <a id="21151" class="Symbol">_</a> <a id="21153" class="Symbol">=</a> <a data-type="is-contr A → is-prop A" id="21155" href="1Lab.HLevel.html#3966" class="Function">is-contr→is-prop</a> <a id="21172" href="1Lab.Equiv.html#20958" class="Bound">cA</a> <a id="21175" class="Symbol">_</a> <a id="21177" class="Symbol">_</a>
</pre>
<h1 id="equivalence-reasoning"><a href="#equivalence-reasoning" class="header-link">Equivalence Reasoning<span class="header-link-emoji">🔗</span></a></h1>
<p>To make composing equivalences more intuitive, we implement operators to do equivalence reasoning in the same style as equational reasoning.</p>
<pre class="Agda"><a id="_∙e_"></a><a data-type="A ≃ B₁ → B₁ ≃ C → A ≃ C" id="21359" href="1Lab.Equiv.html#21359" class="Function Operator">_∙e_</a> <a id="21364" class="Symbol">:</a> <a id="21366" class="Symbol">∀</a> <a id="21368" class="Symbol">{</a><a id="21369" href="1Lab.Equiv.html#21369" class="Bound">ℓ</a> <a id="21371" href="1Lab.Equiv.html#21371" class="Bound">ℓ₁</a> <a id="21374" href="1Lab.Equiv.html#21374" class="Bound">ℓ₂</a><a id="21376" class="Symbol">}</a> <a id="21378" class="Symbol">{</a><a id="21379" href="1Lab.Equiv.html#21379" class="Bound">A</a> <a id="21381" class="Symbol">:</a> <a id="21383" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="21388" href="1Lab.Equiv.html#21369" class="Bound">ℓ</a><a id="21389" class="Symbol">}</a> <a id="21391" class="Symbol">{</a><a id="21392" href="1Lab.Equiv.html#21392" class="Bound">B</a> <a id="21394" class="Symbol">:</a> <a id="21396" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="21401" href="1Lab.Equiv.html#21371" class="Bound">ℓ₁</a><a id="21403" class="Symbol">}</a> <a id="21405" class="Symbol">{</a><a id="21406" href="1Lab.Equiv.html#21406" class="Bound">C</a> <a id="21408" class="Symbol">:</a> <a id="21410" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="21415" href="1Lab.Equiv.html#21374" class="Bound">ℓ₂</a><a id="21417" class="Symbol">}</a>
     <a id="21424" class="Symbol">→</a> <a id="21426" href="1Lab.Equiv.html#21379" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="21428" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="21430" href="1Lab.Equiv.html#21392" class="Bound">B</a> <a id="21432" class="Symbol">→</a> <a id="21434" href="1Lab.Equiv.html#21392" class="Bound">B</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="21436" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="21438" href="1Lab.Equiv.html#21406" class="Bound">C</a> <a id="21440" class="Symbol">→</a> <a id="21442" href="1Lab.Equiv.html#21379" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="21444" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="21446" href="1Lab.Equiv.html#21406" class="Bound">C</a>

<a id="_e⁻¹"></a><a data-type="A ≃ B₁ → B₁ ≃ A" id="21449" href="1Lab.Equiv.html#21449" class="Function Operator">_e⁻¹</a> <a id="21454" class="Symbol">:</a> <a id="21456" class="Symbol">∀</a> <a id="21458" class="Symbol">{</a><a id="21459" href="1Lab.Equiv.html#21459" class="Bound">ℓ</a> <a id="21461" href="1Lab.Equiv.html#21461" class="Bound">ℓ₁</a><a id="21463" class="Symbol">}</a> <a id="21465" class="Symbol">{</a><a id="21466" href="1Lab.Equiv.html#21466" class="Bound">A</a> <a id="21468" class="Symbol">:</a> <a id="21470" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="21475" href="1Lab.Equiv.html#21459" class="Bound">ℓ</a><a id="21476" class="Symbol">}</a> <a id="21478" class="Symbol">{</a><a id="21479" href="1Lab.Equiv.html#21479" class="Bound">B</a> <a id="21481" class="Symbol">:</a> <a id="21483" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="21488" href="1Lab.Equiv.html#21461" class="Bound">ℓ₁</a><a id="21490" class="Symbol">}</a>
     <a id="21497" class="Symbol">→</a> <a id="21499" href="1Lab.Equiv.html#21466" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="21501" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="21503" href="1Lab.Equiv.html#21479" class="Bound">B</a> <a id="21505" class="Symbol">→</a> <a id="21507" href="1Lab.Equiv.html#21479" class="Bound">B</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="21509" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="21511" href="1Lab.Equiv.html#21466" class="Bound">A</a>
<a data-type="A ≃ B₁ → B₁ ≃ A" id="21513" href="1Lab.Equiv.html#21449" class="Function Operator">_e⁻¹</a> <a id="21518" href="1Lab.Equiv.html#21518" class="Bound">eqv</a> <a id="21522" class="Symbol">=</a> <a data-type="Iso A B₁ → A ≃ B₁" id="21524" href="1Lab.Equiv.html#20255" class="Function">Iso→Equiv</a> <a id="21534" class="Symbol">(</a> <a data-type="is-equiv f → B₁ → A" id="21536" href="1Lab.Equiv.html#6472" class="Function">equiv→inverse</a> <a id="21550" class="Symbol">(</a><a id="21551" href="1Lab.Equiv.html#21518" class="Bound">eqv</a> <a id="21555" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="21556" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="21559" class="Symbol">)</a>
                     <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="21582" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="21584" class="Keyword">record</a> <a id="21591" class="Symbol">{</a> <a data-type="is-iso f → B₁ → A" id="21593" href="1Lab.Equiv.html#6155" class="Field">inv</a>  <a id="21598" class="Symbol">=</a> <a id="21600" href="1Lab.Equiv.html#21518" class="Bound">eqv</a> <a id="21604" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="21605" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a>
                              <a id="21639" class="Symbol">;</a> <a data-type="(r : is-iso f) → is-right-inverse (r .inv) f" id="21641" href="1Lab.Equiv.html#6171" class="Field">rinv</a> <a id="21646" class="Symbol">=</a> <a data-type="(eqv : is-equiv f) → is-left-inverse (equiv→inverse eqv) f" id="21648" href="1Lab.Equiv.html#6712" class="Function">equiv→retraction</a> <a id="21665" class="Symbol">(</a><a id="21666" href="1Lab.Equiv.html#21518" class="Bound">eqv</a> <a id="21670" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="21671" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="21674" class="Symbol">)</a>
                              <a id="21706" class="Symbol">;</a> <a data-type="(r : is-iso f) → is-left-inverse (r .inv) f" id="21708" href="1Lab.Equiv.html#6205" class="Field">linv</a> <a id="21713" class="Symbol">=</a> <a data-type="(eqv : is-equiv f) → is-right-inverse (equiv→inverse eqv) f" id="21715" href="1Lab.Equiv.html#6571" class="Function">equiv→section</a> <a id="21729" class="Symbol">(</a><a id="21730" href="1Lab.Equiv.html#21518" class="Bound">eqv</a> <a id="21734" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="21735" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="21738" class="Symbol">)</a>
                              <a id="21770" class="Symbol">})</a>
</pre>
<!--
<pre class="Agda"><a id="21786" href="1Lab.Equiv.html#21359" class="Function Operator">_∙e_</a> <a id="21791" class="Symbol">(</a><a id="21792" href="1Lab.Equiv.html#21792" class="Bound">f</a> <a id="21794" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="21796" href="1Lab.Equiv.html#21796" class="Bound">e</a><a id="21797" class="Symbol">)</a> <a id="21799" class="Symbol">(</a><a id="21800" href="1Lab.Equiv.html#21800" class="Bound">g</a> <a id="21802" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="21804" href="1Lab.Equiv.html#21804" class="Bound">e&#39;</a><a id="21806" class="Symbol">)</a> <a id="21808" class="Symbol">=</a> <a id="21810" class="Symbol">(λ</a> <a id="21813" href="1Lab.Equiv.html#21813" class="Bound">x</a> <a id="21815" class="Symbol">→</a> <a id="21817" href="1Lab.Equiv.html#21800" class="Bound">g</a> <a id="21819" class="Symbol">(</a><a id="21820" href="1Lab.Equiv.html#21792" class="Bound">f</a> <a id="21822" href="1Lab.Equiv.html#21813" class="Bound">x</a><a id="21823" class="Symbol">))</a> <a id="21826" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="21828" href="1Lab.Equiv.html#22557" class="Function">eqv</a> <a id="21832" class="Keyword">where</a>
  <a id="21840" href="1Lab.Equiv.html#21840" class="Function">g⁻¹</a> <a id="21844" class="Symbol">:</a> <a id="21846" href="1Lab.Equiv.html#6049" class="Record">is-iso</a> <a id="21853" href="1Lab.Equiv.html#21800" class="Bound">g</a>
  <a id="21857" href="1Lab.Equiv.html#21840" class="Function">g⁻¹</a> <a id="21861" class="Symbol">=</a> <a id="21863" href="1Lab.Equiv.html#6884" class="Function">is-equiv→is-iso</a> <a id="21879" href="1Lab.Equiv.html#21804" class="Bound">e&#39;</a>

  <a id="21885" href="1Lab.Equiv.html#21885" class="Function">f⁻¹</a> <a id="21889" class="Symbol">:</a> <a id="21891" href="1Lab.Equiv.html#6049" class="Record">is-iso</a> <a id="21898" href="1Lab.Equiv.html#21792" class="Bound">f</a>
  <a id="21902" href="1Lab.Equiv.html#21885" class="Function">f⁻¹</a> <a id="21906" class="Symbol">=</a> <a id="21908" href="1Lab.Equiv.html#6884" class="Function">is-equiv→is-iso</a> <a id="21924" href="1Lab.Equiv.html#21796" class="Bound">e</a>

  <a id="21929" href="1Lab.Equiv.html#21929" class="Function">inv</a> <a id="21933" class="Symbol">:</a> <a id="21935" class="Symbol">_</a> <a id="21937" class="Symbol">→</a> <a id="21939" class="Symbol">_</a>
  <a id="21943" href="1Lab.Equiv.html#21929" class="Function">inv</a> <a id="21947" href="1Lab.Equiv.html#21947" class="Bound">x</a> <a id="21949" class="Symbol">=</a> <a id="21951" href="1Lab.Equiv.html#21885" class="Function">f⁻¹</a> <a id="21955" class="Symbol">.</a><a id="21956" href="1Lab.Equiv.html#6155" class="Field">is-iso.inv</a> <a id="21967" class="Symbol">(</a><a id="21968" href="1Lab.Equiv.html#21840" class="Function">g⁻¹</a> <a id="21972" class="Symbol">.</a><a id="21973" href="1Lab.Equiv.html#6155" class="Field">is-iso.inv</a> <a id="21984" href="1Lab.Equiv.html#21947" class="Bound">x</a><a id="21985" class="Symbol">)</a>

  <a id="21990" class="Keyword">abstract</a>
    <a id="22003" href="1Lab.Equiv.html#22003" class="Function">right</a> <a id="22009" class="Symbol">:</a> <a id="22011" href="1Lab.Equiv.html#5762" class="Function">is-right-inverse</a> <a id="22028" href="1Lab.Equiv.html#21929" class="Function">inv</a> <a id="22032" class="Symbol">(λ</a> <a id="22035" href="1Lab.Equiv.html#22035" class="Bound">x</a> <a id="22037" class="Symbol">→</a> <a id="22039" href="1Lab.Equiv.html#21800" class="Bound">g</a> <a id="22041" class="Symbol">(</a><a id="22042" href="1Lab.Equiv.html#21792" class="Bound">f</a> <a id="22044" href="1Lab.Equiv.html#22035" class="Bound">x</a><a id="22045" class="Symbol">))</a>
    <a id="22052" href="1Lab.Equiv.html#22003" class="Function">right</a> <a id="22058" href="1Lab.Equiv.html#22058" class="Bound">z</a> <a id="22060" class="Symbol">=</a>
      <a id="22068" href="1Lab.Equiv.html#21800" class="Bound">g</a> <a id="22070" class="Symbol">(</a><a id="22071" href="1Lab.Equiv.html#21792" class="Bound">f</a> <a id="22073" class="Symbol">(</a><a id="22074" href="1Lab.Equiv.html#21885" class="Function">f⁻¹</a> <a id="22078" class="Symbol">.</a><a id="22079" href="1Lab.Equiv.html#6155" class="Field">is-iso.inv</a> <a id="22090" class="Symbol">(</a><a id="22091" href="1Lab.Equiv.html#21840" class="Function">g⁻¹</a> <a id="22095" class="Symbol">.</a><a id="22096" href="1Lab.Equiv.html#6155" class="Field">is-iso.inv</a> <a id="22107" href="1Lab.Equiv.html#22058" class="Bound">z</a><a id="22108" class="Symbol">)))</a> <a id="22112" href="1Lab.Path.html#46793" class="Function">≡⟨</a> <a id="22115" href="1Lab.Path.html#20830" class="Function">ap</a> <a id="22118" href="1Lab.Equiv.html#21800" class="Bound">g</a> <a id="22120" class="Symbol">(</a><a id="22121" href="1Lab.Equiv.html#21885" class="Function">f⁻¹</a> <a id="22125" class="Symbol">.</a><a id="22126" href="1Lab.Equiv.html#6171" class="Field">is-iso.rinv</a> <a id="22138" class="Symbol">_)</a> <a id="22141" href="1Lab.Path.html#46793" class="Function">⟩</a>
      <a id="22149" href="1Lab.Equiv.html#21800" class="Bound">g</a> <a id="22151" class="Symbol">(</a><a id="22152" href="1Lab.Equiv.html#21840" class="Function">g⁻¹</a> <a id="22156" class="Symbol">.</a><a id="22157" href="1Lab.Equiv.html#6155" class="Field">is-iso.inv</a> <a id="22168" href="1Lab.Equiv.html#22058" class="Bound">z</a><a id="22169" class="Symbol">)</a>                       <a id="22193" href="1Lab.Path.html#46793" class="Function">≡⟨</a> <a id="22196" href="1Lab.Equiv.html#21840" class="Function">g⁻¹</a> <a id="22200" class="Symbol">.</a><a id="22201" href="1Lab.Equiv.html#6171" class="Field">is-iso.rinv</a> <a id="22213" class="Symbol">_</a> <a id="22215" href="1Lab.Path.html#46793" class="Function">⟩</a>
      <a id="22223" href="1Lab.Equiv.html#22058" class="Bound">z</a>                                           <a id="22267" href="1Lab.Path.html#47121" class="Function Operator">∎</a>

    <a id="22274" href="1Lab.Equiv.html#22274" class="Function">left</a> <a id="22279" class="Symbol">:</a> <a id="22281" href="1Lab.Equiv.html#5672" class="Function">is-left-inverse</a> <a id="22297" href="1Lab.Equiv.html#21929" class="Function">inv</a> <a id="22301" class="Symbol">(λ</a> <a id="22304" href="1Lab.Equiv.html#22304" class="Bound">x</a> <a id="22306" class="Symbol">→</a> <a id="22308" href="1Lab.Equiv.html#21800" class="Bound">g</a> <a id="22310" class="Symbol">(</a><a id="22311" href="1Lab.Equiv.html#21792" class="Bound">f</a> <a id="22313" href="1Lab.Equiv.html#22304" class="Bound">x</a><a id="22314" class="Symbol">))</a>
    <a id="22321" href="1Lab.Equiv.html#22274" class="Function">left</a> <a id="22326" href="1Lab.Equiv.html#22326" class="Bound">z</a> <a id="22328" class="Symbol">=</a>
      <a id="22336" href="1Lab.Equiv.html#21885" class="Function">f⁻¹</a> <a id="22340" class="Symbol">.</a><a id="22341" href="1Lab.Equiv.html#6155" class="Field">is-iso.inv</a> <a id="22352" class="Symbol">(</a><a id="22353" href="1Lab.Equiv.html#21840" class="Function">g⁻¹</a> <a id="22357" class="Symbol">.</a><a id="22358" href="1Lab.Equiv.html#6155" class="Field">is-iso.inv</a> <a id="22369" class="Symbol">(</a><a id="22370" href="1Lab.Equiv.html#21800" class="Bound">g</a> <a id="22372" class="Symbol">(</a><a id="22373" href="1Lab.Equiv.html#21792" class="Bound">f</a> <a id="22375" href="1Lab.Equiv.html#22326" class="Bound">z</a><a id="22376" class="Symbol">)))</a> <a id="22380" href="1Lab.Path.html#46793" class="Function">≡⟨</a> <a id="22383" href="1Lab.Path.html#20830" class="Function">ap</a> <a id="22386" class="Symbol">(</a><a id="22387" href="1Lab.Equiv.html#21885" class="Function">f⁻¹</a> <a id="22391" class="Symbol">.</a><a id="22392" href="1Lab.Equiv.html#6155" class="Field">is-iso.inv</a><a id="22402" class="Symbol">)</a> <a id="22404" class="Symbol">(</a><a id="22405" href="1Lab.Equiv.html#21840" class="Function">g⁻¹</a> <a id="22409" class="Symbol">.</a><a id="22410" href="1Lab.Equiv.html#6205" class="Field">is-iso.linv</a> <a id="22422" class="Symbol">_)</a> <a id="22425" href="1Lab.Path.html#46793" class="Function">⟩</a>
      <a id="22433" href="1Lab.Equiv.html#21885" class="Function">f⁻¹</a> <a id="22437" class="Symbol">.</a><a id="22438" href="1Lab.Equiv.html#6155" class="Field">is-iso.inv</a> <a id="22449" class="Symbol">(</a><a id="22450" href="1Lab.Equiv.html#21792" class="Bound">f</a> <a id="22452" href="1Lab.Equiv.html#22326" class="Bound">z</a><a id="22453" class="Symbol">)</a>                       <a id="22477" href="1Lab.Path.html#46793" class="Function">≡⟨</a> <a id="22480" href="1Lab.Equiv.html#21885" class="Function">f⁻¹</a> <a id="22484" class="Symbol">.</a><a id="22485" href="1Lab.Equiv.html#6205" class="Field">is-iso.linv</a> <a id="22497" class="Symbol">_</a> <a id="22499" href="1Lab.Path.html#46793" class="Function">⟩</a>
      <a id="22507" href="1Lab.Equiv.html#22326" class="Bound">z</a>                                           <a id="22551" href="1Lab.Path.html#47121" class="Function Operator">∎</a>
    <a id="22557" href="1Lab.Equiv.html#22557" class="Function">eqv</a> <a id="22561" class="Symbol">:</a> <a id="22563" href="1Lab.Equiv.html#2306" class="Record">is-equiv</a> <a id="22572" class="Symbol">(λ</a> <a id="22575" href="1Lab.Equiv.html#22575" class="Bound">x</a> <a id="22577" class="Symbol">→</a> <a id="22579" href="1Lab.Equiv.html#21800" class="Bound">g</a> <a id="22581" class="Symbol">(</a><a id="22582" href="1Lab.Equiv.html#21792" class="Bound">f</a> <a id="22584" href="1Lab.Equiv.html#22575" class="Bound">x</a><a id="22585" class="Symbol">))</a>
    <a id="22592" href="1Lab.Equiv.html#22557" class="Function">eqv</a> <a id="22596" class="Symbol">=</a> <a id="22598" href="1Lab.Equiv.html#19908" class="Function">is-iso→is-equiv</a> <a id="22614" class="Symbol">(</a><a id="22615" href="1Lab.Equiv.html#6139" class="InductiveConstructor">iso</a> <a id="22619" class="Symbol">(λ</a> <a id="22622" href="1Lab.Equiv.html#22622" class="Bound">x</a> <a id="22624" class="Symbol">→</a> <a id="22626" href="1Lab.Equiv.html#21885" class="Function">f⁻¹</a> <a id="22630" class="Symbol">.</a><a id="22631" href="1Lab.Equiv.html#6155" class="Field">is-iso.inv</a> <a id="22642" class="Symbol">(</a><a id="22643" href="1Lab.Equiv.html#21840" class="Function">g⁻¹</a> <a id="22647" class="Symbol">.</a><a id="22648" href="1Lab.Equiv.html#6155" class="Field">is-iso.inv</a> <a id="22659" href="1Lab.Equiv.html#22622" class="Bound">x</a><a id="22660" class="Symbol">))</a> <a id="22663" href="1Lab.Equiv.html#22003" class="Function">right</a> <a id="22669" href="1Lab.Equiv.html#22274" class="Function">left</a><a id="22673" class="Symbol">)</a>

<a id="∙-is-equiv"></a><a id="22676" href="1Lab.Equiv.html#22676" class="Function">∙-is-equiv</a> <a id="22687" class="Symbol">:</a> <a id="22689" class="Symbol">∀</a> <a id="22691" class="Symbol">{</a><a id="22692" href="1Lab.Equiv.html#22692" class="Bound">ℓ</a> <a id="22694" href="1Lab.Equiv.html#22694" class="Bound">ℓ₁</a> <a id="22697" href="1Lab.Equiv.html#22697" class="Bound">ℓ₂</a><a id="22699" class="Symbol">}</a> <a id="22701" class="Symbol">{</a><a id="22702" href="1Lab.Equiv.html#22702" class="Bound">A</a> <a id="22704" class="Symbol">:</a> <a id="22706" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="22711" href="1Lab.Equiv.html#22692" class="Bound">ℓ</a><a id="22712" class="Symbol">}</a> <a id="22714" class="Symbol">{</a><a id="22715" href="1Lab.Equiv.html#22715" class="Bound">B</a> <a id="22717" class="Symbol">:</a> <a id="22719" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="22724" href="1Lab.Equiv.html#22694" class="Bound">ℓ₁</a><a id="22726" class="Symbol">}</a> <a id="22728" class="Symbol">{</a><a id="22729" href="1Lab.Equiv.html#22729" class="Bound">C</a> <a id="22731" class="Symbol">:</a> <a id="22733" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="22738" href="1Lab.Equiv.html#22697" class="Bound">ℓ₂</a><a id="22740" class="Symbol">}</a>
           <a id="22753" class="Symbol">→</a> <a id="22755" class="Symbol">{</a><a id="22756" href="1Lab.Equiv.html#22756" class="Bound">f</a> <a id="22758" class="Symbol">:</a> <a id="22760" href="1Lab.Equiv.html#22702" class="Bound">A</a> <a id="22762" class="Symbol">→</a> <a id="22764" href="1Lab.Equiv.html#22715" class="Bound">B</a><a id="22765" class="Symbol">}</a> <a id="22767" class="Symbol">{</a><a id="22768" href="1Lab.Equiv.html#22768" class="Bound">g</a> <a id="22770" class="Symbol">:</a> <a id="22772" href="1Lab.Equiv.html#22715" class="Bound">B</a> <a id="22774" class="Symbol">→</a> <a id="22776" href="1Lab.Equiv.html#22729" class="Bound">C</a><a id="22777" class="Symbol">}</a>
           <a id="22790" class="Symbol">→</a> <a id="22792" href="1Lab.Equiv.html#2306" class="Record">is-equiv</a> <a id="22801" href="1Lab.Equiv.html#22756" class="Bound">f</a>
           <a id="22814" class="Symbol">→</a> <a id="22816" href="1Lab.Equiv.html#2306" class="Record">is-equiv</a> <a id="22825" href="1Lab.Equiv.html#22768" class="Bound">g</a>
           <a id="22838" class="Symbol">→</a> <a id="22840" href="1Lab.Equiv.html#2306" class="Record">is-equiv</a> <a id="22849" class="Symbol">(λ</a> <a id="22852" href="1Lab.Equiv.html#22852" class="Bound">x</a> <a id="22854" class="Symbol">→</a> <a id="22856" href="1Lab.Equiv.html#22768" class="Bound">g</a> <a id="22858" class="Symbol">(</a><a id="22859" href="1Lab.Equiv.html#22756" class="Bound">f</a> <a id="22861" href="1Lab.Equiv.html#22852" class="Bound">x</a><a id="22862" class="Symbol">))</a>
<a id="22865" href="1Lab.Equiv.html#22676" class="Function">∙-is-equiv</a> <a id="22876" class="Symbol">{</a><a id="22877" class="Argument">f</a> <a id="22879" class="Symbol">=</a> <a id="22881" href="1Lab.Equiv.html#22881" class="Bound">f</a><a id="22882" class="Symbol">}</a> <a id="22884" class="Symbol">{</a><a id="22885" class="Argument">g</a> <a id="22887" class="Symbol">=</a> <a id="22889" href="1Lab.Equiv.html#22889" class="Bound">g</a><a id="22890" class="Symbol">}</a> <a id="22892" href="1Lab.Equiv.html#22892" class="Bound">e</a> <a id="22894" href="1Lab.Equiv.html#22894" class="Bound">e&#39;</a> <a id="22897" class="Symbol">=</a> <a id="22899" class="Symbol">((</a><a id="22901" href="1Lab.Equiv.html#22881" class="Bound">f</a> <a id="22903" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="22905" href="1Lab.Equiv.html#22892" class="Bound">e</a><a id="22906" class="Symbol">)</a> <a id="22908" href="1Lab.Equiv.html#21359" class="Function Operator">∙e</a> <a id="22911" class="Symbol">(</a><a id="22912" href="1Lab.Equiv.html#22889" class="Bound">g</a> <a id="22914" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="22916" href="1Lab.Equiv.html#22894" class="Bound">e&#39;</a><a id="22918" class="Symbol">))</a> <a id="22921" class="Symbol">.</a><a id="22922" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a>
</pre>-->
<p>The proofs that equivalences are closed under composition assemble nicely into transitivity operators resembling equational reasoning:</p>
<pre class="Agda"><a id="_≃⟨_⟩_"></a><a data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" id="23079" href="1Lab.Equiv.html#23079" class="Function Operator">_≃⟨_⟩_</a> <a id="23086" class="Symbol">:</a> <a id="23088" class="Symbol">∀</a> <a id="23090" class="Symbol">{</a><a id="23091" href="1Lab.Equiv.html#23091" class="Bound">ℓ</a> <a id="23093" href="1Lab.Equiv.html#23093" class="Bound">ℓ₁</a> <a id="23096" href="1Lab.Equiv.html#23096" class="Bound">ℓ₂</a><a id="23098" class="Symbol">}</a> <a id="23100" class="Symbol">(</a><a id="23101" href="1Lab.Equiv.html#23101" class="Bound">A</a> <a id="23103" class="Symbol">:</a> <a id="23105" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23110" href="1Lab.Equiv.html#23091" class="Bound">ℓ</a><a id="23111" class="Symbol">)</a> <a id="23113" class="Symbol">{</a><a id="23114" href="1Lab.Equiv.html#23114" class="Bound">B</a> <a id="23116" class="Symbol">:</a> <a id="23118" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23123" href="1Lab.Equiv.html#23093" class="Bound">ℓ₁</a><a id="23125" class="Symbol">}</a> <a id="23127" class="Symbol">{</a><a id="23128" href="1Lab.Equiv.html#23128" class="Bound">C</a> <a id="23130" class="Symbol">:</a> <a id="23132" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23137" href="1Lab.Equiv.html#23096" class="Bound">ℓ₂</a><a id="23139" class="Symbol">}</a>
       <a id="23148" class="Symbol">→</a> <a id="23150" href="1Lab.Equiv.html#23101" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="23152" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="23154" href="1Lab.Equiv.html#23114" class="Bound">B</a> <a id="23156" class="Symbol">→</a> <a id="23158" href="1Lab.Equiv.html#23114" class="Bound">B</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="23160" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="23162" href="1Lab.Equiv.html#23128" class="Bound">C</a> <a id="23164" class="Symbol">→</a> <a id="23166" href="1Lab.Equiv.html#23101" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="23168" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="23170" href="1Lab.Equiv.html#23128" class="Bound">C</a>
<a id="23172" href="1Lab.Equiv.html#23172" class="Bound">A</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" id="23174" href="1Lab.Equiv.html#23079" class="Function Operator">≃⟨</a> <a id="23177" href="1Lab.Equiv.html#23177" class="Bound">f</a> <a data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" id="23179" href="1Lab.Equiv.html#23079" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span> <a id="23181" href="1Lab.Equiv.html#23181" class="Bound">g</a> <a id="23183" class="Symbol">=</a> <a id="23185" href="1Lab.Equiv.html#23177" class="Bound">f</a> <a data-type="A ≃ B₁ → B₁ ≃ C → A ≃ C" id="23187" href="1Lab.Equiv.html#21359" class="Function Operator">∙e</a> <a id="23190" href="1Lab.Equiv.html#23181" class="Bound">g</a>

<a id="_≃⟨⟩_"></a><a data-type="(A : Type ℓ) → A ≃ B₁ → A ≃ B₁" id="23193" href="1Lab.Equiv.html#23193" class="Function Operator">_≃⟨⟩_</a> <a id="23199" class="Symbol">:</a> <a id="23201" class="Symbol">∀</a> <a id="23203" class="Symbol">{</a><a id="23204" href="1Lab.Equiv.html#23204" class="Bound">ℓ</a> <a id="23206" href="1Lab.Equiv.html#23206" class="Bound">ℓ₁</a><a id="23208" class="Symbol">}</a> <a id="23210" class="Symbol">(</a><a id="23211" href="1Lab.Equiv.html#23211" class="Bound">A</a> <a id="23213" class="Symbol">:</a> <a id="23215" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23220" href="1Lab.Equiv.html#23204" class="Bound">ℓ</a><a id="23221" class="Symbol">)</a> <a id="23223" class="Symbol">{</a><a id="23224" href="1Lab.Equiv.html#23224" class="Bound">B</a> <a id="23226" class="Symbol">:</a> <a id="23228" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23233" href="1Lab.Equiv.html#23206" class="Bound">ℓ₁</a><a id="23235" class="Symbol">}</a> <a id="23237" class="Symbol">→</a> <a id="23239" href="1Lab.Equiv.html#23211" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="23241" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="23243" href="1Lab.Equiv.html#23224" class="Bound">B</a> <a id="23245" class="Symbol">→</a> <a id="23247" href="1Lab.Equiv.html#23211" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="23249" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="23251" href="1Lab.Equiv.html#23224" class="Bound">B</a>
<a id="23253" href="1Lab.Equiv.html#23253" class="Bound">x</a> <a data-type="(A : Type ℓ) → A ≃ B₁ → A ≃ B₁" id="23255" href="1Lab.Equiv.html#23193" class="Function Operator">≃⟨⟩</a> <a id="23259" href="1Lab.Equiv.html#23259" class="Bound">x≡y</a> <a id="23263" class="Symbol">=</a> <a id="23265" href="1Lab.Equiv.html#23259" class="Bound">x≡y</a>

<a id="_≃∎"></a><a data-type="(A : Type ℓ) → A ≃ A" id="23270" href="1Lab.Equiv.html#23270" class="Function Operator">_≃∎</a> <a id="23274" class="Symbol">:</a> <a id="23276" class="Symbol">∀</a> <a id="23278" class="Symbol">{</a><a id="23279" href="1Lab.Equiv.html#23279" class="Bound">ℓ</a><a id="23280" class="Symbol">}</a> <a id="23282" class="Symbol">(</a><a id="23283" href="1Lab.Equiv.html#23283" class="Bound">A</a> <a id="23285" class="Symbol">:</a> <a id="23287" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23292" href="1Lab.Equiv.html#23279" class="Bound">ℓ</a><a id="23293" class="Symbol">)</a> <a id="23295" class="Symbol">→</a> <a id="23297" href="1Lab.Equiv.html#23283" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="23299" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="23301" href="1Lab.Equiv.html#23283" class="Bound">A</a>
<a id="23303" href="1Lab.Equiv.html#23303" class="Bound">x</a> <a data-type="(A : Type ℓ) → A ≃ A" id="23305" href="1Lab.Equiv.html#23270" class="Function Operator">≃∎</a> <a id="23308" class="Symbol">=</a> <a id="23310" class="Symbol">_</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="23312" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="is-equiv (λ x → x)" id="23314" href="1Lab.Equiv.html#2544" class="Function">id-equiv</a>

<a id="23324" class="Keyword">infixr</a> <a id="23331" class="Number">30</a> <a data-type="A ≃ B₁ → B₁ ≃ C → A ≃ C" id="23334" href="1Lab.Equiv.html#21359" class="Function Operator">_∙e_</a>
<a id="23339" class="Keyword">infixr</a> <a id="23346" class="Number">2</a> <a data-type="(A : Type ℓ) → A ≃ B₁ → A ≃ B₁" id="23348" href="1Lab.Equiv.html#23193" class="Function Operator">_≃⟨⟩_</a> <a data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" id="23354" href="1Lab.Equiv.html#23079" class="Function Operator">_≃⟨_⟩_</a>
<a id="23361" class="Keyword">infix</a>  <a id="23368" class="Number">3</a> <a data-type="(A : Type ℓ) → A ≃ A" id="23370" href="1Lab.Equiv.html#23270" class="Function Operator">_≃∎</a>
</pre>
<h1 id="propositional-extensionality"><a href="#propositional-extensionality" class="header-link">Propositional Extensionality<span class="header-link-emoji">🔗</span></a></h1>
<p>The following observation is not very complex, but it is incredibly useful: Equivalence of propositions is the same as biimplication.</p>
<pre class="Agda"><a id="prop-ext"></a><a data-type="is-prop P → is-prop Q → (P → Q) → (Q → P) → P ≃ Q" id="23554" href="1Lab.Equiv.html#23554" class="Function">prop-ext</a> <a id="23563" class="Symbol">:</a> <a id="23565" class="Symbol">∀</a> <a id="23567" class="Symbol">{</a><a id="23568" href="1Lab.Equiv.html#23568" class="Bound">ℓ</a> <a id="23570" href="1Lab.Equiv.html#23570" class="Bound">ℓ&#39;</a><a id="23572" class="Symbol">}</a> <a id="23574" class="Symbol">{</a><a id="23575" href="1Lab.Equiv.html#23575" class="Bound">P</a> <a id="23577" class="Symbol">:</a> <a id="23579" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23584" href="1Lab.Equiv.html#23568" class="Bound">ℓ</a><a id="23585" class="Symbol">}</a> <a id="23587" class="Symbol">{</a><a id="23588" href="1Lab.Equiv.html#23588" class="Bound">Q</a> <a id="23590" class="Symbol">:</a> <a id="23592" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23597" href="1Lab.Equiv.html#23570" class="Bound">ℓ&#39;</a><a id="23599" class="Symbol">}</a>
         <a id="23610" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="23612" href="1Lab.HLevel.html#2597" class="Function">is-prop</a> <a id="23620" href="1Lab.Equiv.html#23575" class="Bound">P</a> <a id="23622" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="23624" href="1Lab.HLevel.html#2597" class="Function">is-prop</a> <a id="23632" href="1Lab.Equiv.html#23588" class="Bound">Q</a>
         <a id="23643" class="Symbol">→</a> <a id="23645" class="Symbol">(</a><a id="23646" href="1Lab.Equiv.html#23575" class="Bound">P</a> <a id="23648" class="Symbol">→</a> <a id="23650" href="1Lab.Equiv.html#23588" class="Bound">Q</a><a id="23651" class="Symbol">)</a> <a id="23653" class="Symbol">→</a> <a id="23655" class="Symbol">(</a><a id="23656" href="1Lab.Equiv.html#23588" class="Bound">Q</a> <a id="23658" class="Symbol">→</a> <a id="23660" href="1Lab.Equiv.html#23575" class="Bound">P</a><a id="23661" class="Symbol">)</a>
         <a id="23672" class="Symbol">→</a> <a id="23674" href="1Lab.Equiv.html#23575" class="Bound">P</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="23676" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="23678" href="1Lab.Equiv.html#23588" class="Bound">Q</a>
<a data-type="is-prop P → is-prop Q → (P → Q) → (Q → P) → P ≃ Q" id="23680" href="1Lab.Equiv.html#23554" class="Function">prop-ext</a> <a id="23689" href="1Lab.Equiv.html#23689" class="Bound">pprop</a> <a id="23695" href="1Lab.Equiv.html#23695" class="Bound">qprop</a> <a id="23701" href="1Lab.Equiv.html#23701" class="Bound">p→q</a> <a id="23705" href="1Lab.Equiv.html#23705" class="Bound">q→p</a> <a id="23709" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="23710" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="23714" class="Symbol">=</a> <a id="23716" href="1Lab.Equiv.html#23701" class="Bound">p→q</a>
<a data-type="is-prop P → is-prop Q → (P → Q) → (Q → P) → P ≃ Q" id="23720" href="1Lab.Equiv.html#23554" class="Function">prop-ext</a> <a id="23729" href="1Lab.Equiv.html#23729" class="Bound">pprop</a> <a id="23735" href="1Lab.Equiv.html#23735" class="Bound">qprop</a> <a id="23741" href="1Lab.Equiv.html#23741" class="Bound">p→q</a> <a id="23745" href="1Lab.Equiv.html#23745" class="Bound">q→p</a> <a id="23749" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="23750" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="23754" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="23755" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="23762" href="1Lab.Equiv.html#23762" class="Bound">y</a> <a id="23764" class="Symbol">.</a><a data-type="is-contr A → A" id="23765" href="1Lab.HLevel.html#1401" class="Field">centre</a> <a id="23772" class="Symbol">=</a> <a id="23774" href="1Lab.Equiv.html#23745" class="Bound">q→p</a> <a id="23778" href="1Lab.Equiv.html#23762" class="Bound">y</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="23780" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23782" href="1Lab.Equiv.html#23735" class="Bound">qprop</a> <a id="23788" class="Symbol">_</a> <a id="23790" class="Symbol">_</a>
<a data-type="is-prop P → is-prop Q → (P → Q) → (Q → P) → P ≃ Q" id="23792" href="1Lab.Equiv.html#23554" class="Function">prop-ext</a> <a id="23801" href="1Lab.Equiv.html#23801" class="Bound">pprop</a> <a id="23807" href="1Lab.Equiv.html#23807" class="Bound">qprop</a> <a id="23813" href="1Lab.Equiv.html#23813" class="Bound">p→q</a> <a id="23817" href="1Lab.Equiv.html#23817" class="Bound">q→p</a> <a id="23821" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="23822" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="23826" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="23827" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="23834" href="1Lab.Equiv.html#23834" class="Bound">y</a> <a id="23836" class="Symbol">.</a><a data-type="(r : is-contr A) (x : A) → r .centre ≡ x" id="23837" href="1Lab.HLevel.html#1416" class="Field">paths</a> <a id="23843" class="Symbol">(</a><a id="23844" href="1Lab.Equiv.html#23844" class="Bound">p&#39;</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="23847" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23849" href="1Lab.Equiv.html#23849" class="Bound">path</a><a id="23853" class="Symbol">)</a> <a id="23855" class="Symbol">=</a>
  <a data-type="(p : x .fst ≡ y .fst) → subst B₁ p (x .snd) ≡ y .snd → x ≡ y" id="23859" href="1Lab.Path.html#57797" class="Function">Σ-path</a> <a id="23866" class="Symbol">(</a><a id="23867" href="1Lab.Equiv.html#23801" class="Bound">pprop</a> <a id="23873" class="Symbol">_</a> <a id="23875" class="Symbol">_)</a> <a id="23878" class="Symbol">(</a><a data-type="is-prop A → is-set A" id="23879" href="1Lab.HLevel.html#5722" class="Function">is-prop→is-set</a> <a id="23894" href="1Lab.Equiv.html#23807" class="Bound">qprop</a> <a id="23900" class="Symbol">_</a> <a id="23902" class="Symbol">_</a> <a id="23904" class="Symbol">_</a> <a id="23906" class="Symbol">_)</a>
</pre>
  </article>
</div>

</main>
</body>
</html>
