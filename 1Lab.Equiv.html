<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>1Lab.Equiv - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />
  <link rel="stylesheet" href="/css/agda-cats.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="1Lab.Equiv - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="1Lab.Equiv - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script src="/equations.js"></script>
  <script src="/highlight-hover.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>
</head>

<body>
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">1Lab.Equiv</a>
              </h3>

      <!-- Cube logo -->
      <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#equivalences"><a href="#equivalences" class="header-link">Equivalences<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#is-equiv-is-propositional"><a href="#is-equiv-is-propositional" class="header-link">is-equiv is propositional<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#isomorphisms-from-equivalences"><a href="#isomorphisms-from-equivalences" class="header-link">Isomorphisms from equivalences<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#equivalences-from-isomorphisms"><a href="#equivalences-from-isomorphisms" class="header-link">Equivalences from isomorphisms<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#equivalence-reasoning"><a href="#equivalence-reasoning" class="header-link">Equivalence Reasoning<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#propositional-extensionality"><a href="#propositional-extensionality" class="header-link">Propositional Extensionality<span class="header-link-emoji">🔗</span></a></a></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
              <a href="index.html">️back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/3692f31f0a881d38d1fafbefaa1fa260eb9963e3/src/1Lab/Equiv.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="index.html">️back to index</a>
      </div>
      
      <!-- Font toggle checkbox -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="1Lab.HLevel.html" class="Module">1Lab.HLevel</a>
<a id="33" class="Keyword">open</a> <a id="38" class="Keyword">import</a> <a id="45" href="1Lab.Path.html" class="Module">1Lab.Path</a>
<a id="55" class="Keyword">open</a> <a id="60" class="Keyword">import</a> <a id="67" href="1Lab.Type.html" class="Module">1Lab.Type</a>

<a id="78" class="Keyword">open</a> <a data-type="(A : Type ℓ) → Type ℓ" id="83" href="1Lab.HLevel.html#1328" class="Module">is-contr</a>

<a id="93" class="Keyword">module</a> <a id="100" href="1Lab.Equiv.html" class="Module">1Lab.Equiv</a> <a id="111" class="Keyword">where</a>
</pre>
<h1 id="equivalences"><a href="#equivalences" class="header-link">Equivalences<span class="header-link-emoji">🔗</span></a></h1>
<p>The big idea of homotopy type theory is that isomorphic types can be identified: the <a href="1Lab.Univalence.html">univalence axiom</a>. However, the notion of <span class="Agda"><a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" href="1Lab.Equiv.html#6046" class="Record">isomorphism</a></span>, is, in a sense, not “coherent” enough to be used in the definition. For that, we need a coherent definition of <em>equivalence</em>, where “being an equivalence” is <a data-type="Type ℓ → Type ℓ" href="1Lab.HLevel.html#2597">a proposition</a>.</p>
<p>To be more specific, what we need for a notion of equivalence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mo>−</mo><mi mathvariant="normal">e</mi><mi mathvariant="normal">q</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">v</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{is-equiv}(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">is</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm" style="margin-right:0.01389em;">equiv</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span> to be “coherent” is:</p>
<ul>
<li><p>Being an <span class="Agda"><a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" href="1Lab.Equiv.html#6046" class="Record">isomorphism</a></span> implies being an <span class="Agda"><a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" href="1Lab.Equiv.html#2306" class="Record">equivalence</a></span> (<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mo>−</mo><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">o</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>→</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mo>−</mo><mi mathvariant="normal">e</mi><mi mathvariant="normal">q</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">v</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{is-iso}(f) \to \mathrm{is-equiv}(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">is</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm">iso</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">is</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm" style="margin-right:0.01389em;">equiv</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>)</span></p></li>
<li><p>Being an equivalence implies being an isomorphism (<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mo>−</mo><mi mathvariant="normal">e</mi><mi mathvariant="normal">q</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">v</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo><mo>→</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mo>−</mo><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">o</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{is-equiv}(f) \to \mathrm{is-iso}(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">is</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm" style="margin-right:0.01389em;">equiv</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">is</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathrm">iso</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>);</span> Taken together with the first point we may summarise: “Being an equivalence and being an isomorphism are logically equivalent.”</p></li>
<li><p>Most importantly, being an equivalence <em>must</em> be a proposition.</p></li>
</ul>
<p>The notion we adopt is due to Voevodsky: An equivalence is one that has <span class="Agda"><a data-type="(A : Type ℓ) → Type ℓ" href="1Lab.HLevel.html#1328" class="Module">contractible</a></span> <span class="Agda"><a data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" href="1Lab.Equiv.html#1893" class="Function">fibres</a></span>. Other definitions are possible (e.g.: <a href="1Lab.Equiv.Biinv.html">bi-inverible maps</a>) — but contractible fibres are “privileged” in Cubical Agda because for <a href="1Lab.Univalence.html#Glue">glueing</a> to work, we need a proof that <span class="Agda"><a data-type="(A : Type a) (B₁ : Type b) (w : A ≃ B₁) (a : B₁) (ψ : I) →
Partial ψ (fibre (w .fst) a) → fibre (w .fst) a" href="1Lab.Equiv.html#3691" class="Function">equivalences have contractible fibres</a></span> anyway.</p>
<pre class="Agda"><a id="1567" class="Keyword">private</a>
  <a id="1577" class="Keyword">variable</a>
    <a id="1590" href="1Lab.Equiv.html#1590" class="Generalizable">ℓ₁</a> <a id="1593" href="1Lab.Equiv.html#1593" class="Generalizable">ℓ₂</a> <a id="1596" class="Symbol">:</a> <a data-type="Type" id="1598" href="Agda.Primitive.html#597" class="Postulate">Level</a>
    <a id="1608" href="1Lab.Equiv.html#1608" class="Generalizable">A</a> <a id="1610" href="1Lab.Equiv.html#1610" class="Generalizable">B</a> <a id="1612" class="Symbol">:</a> <a id="1614" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="1619" href="1Lab.Equiv.html#1590" class="Generalizable">ℓ₁</a>
</pre>
<p>A <em>homotopy fibre</em>, <em>fibre</em> or <em>preimage</em> of a function <code>f</code> at a point <code>y : B</code> is the collection of all elements of <code>A</code> that <code>f</code> maps to <code>y</code>. Since many choices of name are possible, we settle on the one that is shortest and most aesthetic: <span class="Agda"><a data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" href="1Lab.Equiv.html#1893" class="Function">fibre</a></span>.</p>
<pre class="Agda"><a id="fibre"></a><a data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="1893" href="1Lab.Equiv.html#1893" class="Function">fibre</a> <a id="1899" class="Symbol">:</a> <a id="1901" class="Symbol">(</a><a id="1902" href="1Lab.Equiv.html#1608" class="Generalizable">A</a> <a id="1904" class="Symbol">→</a> <a id="1906" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="1907" class="Symbol">)</a> <a id="1909" class="Symbol">→</a> <a id="1911" href="1Lab.Equiv.html#1610" class="Generalizable">B</a> <a id="1913" class="Symbol">→</a> <a id="1915" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="1920" class="Symbol">_</a>
<a data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="1922" href="1Lab.Equiv.html#1893" class="Function">fibre</a> <a id="1928" href="1Lab.Equiv.html#1928" class="Bound">f</a> <a id="1930" href="1Lab.Equiv.html#1930" class="Bound">y</a> <a id="1932" class="Symbol">=</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="1934" href="1Lab.Type.html#1573" class="Function">Σ</a> <a id="1936" class="Symbol">λ</a> <a id="1938" href="1Lab.Equiv.html#1938" class="Bound">x</a> <a id="1940" class="Symbol">→</a> <a id="1942" href="1Lab.Equiv.html#1928" class="Bound">f</a> <a id="1944" href="1Lab.Equiv.html#1938" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="1946" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="1948" href="1Lab.Equiv.html#1930" class="Bound">y</a>
</pre>
<p>A function <code>f</code> is an equivalence if every one of its fibres is <a data-type="(A : Type ℓ) → Type ℓ" href="1Lab.HLevel.html#1328">contractible</a> - that is, for any element <code>y</code> in the range, there is exactly one element in the domain which <code>f</code> maps to <code>y</code>. Using set-theoretic language, <code>f</code> is an equivalence if the preimage of every element of the codomain is a singleton.</p>
<pre class="Agda"><a id="2299" class="Keyword">record</a> <a id="is-equiv"></a><a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="2306" href="1Lab.Equiv.html#2306" class="Record">is-equiv</a> <a id="2315" class="Symbol">(</a><a id="2316" href="1Lab.Equiv.html#2316" class="Bound">f</a> <a id="2318" class="Symbol">:</a> <a id="2320" href="1Lab.Equiv.html#1608" class="Generalizable">A</a> <a id="2322" class="Symbol">→</a> <a id="2324" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="2325" class="Symbol">)</a> <a id="2327" class="Symbol">:</a> <a id="2329" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2334" class="Symbol">(</a><a data-type="Type ℓ → Level" id="2335" href="1Lab.Type.html#921" class="Function">level-of</a> <a id="2344" href="1Lab.Equiv.html#2320" class="Bound">A</a> <a data-type="Level → Level → Level" id="2346" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a data-type="Type ℓ → Level" id="2348" href="1Lab.Type.html#921" class="Function">level-of</a> <a id="2357" href="1Lab.Equiv.html#2324" class="Bound">B</a><a id="2358" class="Symbol">)</a> <a id="2360" class="Keyword">where</a>
  <a id="2368" class="Keyword">no-eta-equality</a>
  <a id="2386" class="Keyword">field</a>
    <a id="is-equiv.is-eqv"></a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="2396" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="2403" class="Symbol">:</a> <a id="2405" class="Symbol">(</a><a id="2406" href="1Lab.Equiv.html#2406" class="Bound">y</a> <a id="2408" class="Symbol">:</a> <a id="2410" href="1Lab.Equiv.html#2324" class="Bound">B</a><a id="2411" class="Symbol">)</a> <a id="2413" class="Symbol">→</a> <a data-type="(A : Type ℓ) → Type ℓ" id="2415" href="1Lab.HLevel.html#1328" class="Record">is-contr</a> <a id="2424" class="Symbol">(</a><a data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="2425" href="1Lab.Equiv.html#1893" class="Function">fibre</a> <a id="2431" href="1Lab.Equiv.html#2316" class="Bound">f</a> <a id="2433" href="1Lab.Equiv.html#2406" class="Bound">y</a><a id="2434" class="Symbol">)</a>

<a id="2437" class="Keyword">open</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="2442" href="1Lab.Equiv.html#2306" class="Module">is-equiv</a> <a id="2451" class="Keyword">public</a>

<a id="_≃_"></a><a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="2459" href="1Lab.Equiv.html#2459" class="Function Operator">_≃_</a> <a id="2463" class="Symbol">:</a> <a id="2465" class="Symbol">∀</a> <a id="2467" class="Symbol">{</a><a id="2468" href="1Lab.Equiv.html#2468" class="Bound">ℓ₁</a> <a id="2471" href="1Lab.Equiv.html#2471" class="Bound">ℓ₂</a><a id="2473" class="Symbol">}</a> <a id="2475" class="Symbol">→</a> <a id="2477" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2482" href="1Lab.Equiv.html#2468" class="Bound">ℓ₁</a> <a id="2485" class="Symbol">→</a> <a id="2487" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2492" href="1Lab.Equiv.html#2471" class="Bound">ℓ₂</a> <a id="2495" class="Symbol">→</a> <a id="2497" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2502" class="Symbol">_</a>
<a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="2504" href="1Lab.Equiv.html#2459" class="Function Operator">_≃_</a> <a id="2508" href="1Lab.Equiv.html#2508" class="Bound">A</a> <a id="2510" href="1Lab.Equiv.html#2510" class="Bound">B</a> <a id="2512" class="Symbol">=</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="2514" href="1Lab.Type.html#1573" class="Function">Σ</a> <a id="2516" class="Symbol">(</a><a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="2517" href="1Lab.Equiv.html#2306" class="Record">is-equiv</a> <a id="2526" class="Symbol">{</a><a id="2527" class="Argument">A</a> <a id="2529" class="Symbol">=</a> <a id="2531" href="1Lab.Equiv.html#2508" class="Bound">A</a><a id="2532" class="Symbol">}</a> <a id="2534" class="Symbol">{</a><a id="2535" class="Argument">B</a> <a id="2537" class="Symbol">=</a> <a id="2539" href="1Lab.Equiv.html#2510" class="Bound">B</a><a id="2540" class="Symbol">})</a>

<a id="id-equiv"></a><a data-type="is-equiv (λ x → x)" id="2544" href="1Lab.Equiv.html#2544" class="Function">id-equiv</a> <a id="2553" class="Symbol">:</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="2555" href="1Lab.Equiv.html#2306" class="Record">is-equiv</a> <a id="2564" class="Symbol">{</a><a id="2565" class="Argument">A</a> <a id="2567" class="Symbol">=</a> <a id="2569" href="1Lab.Equiv.html#1608" class="Generalizable">A</a><a id="2570" class="Symbol">}</a> <a id="2572" class="Symbol">(λ</a> <a id="2575" href="1Lab.Equiv.html#2575" class="Bound">x</a> <a id="2577" class="Symbol">→</a> <a id="2579" href="1Lab.Equiv.html#2575" class="Bound">x</a><a id="2580" class="Symbol">)</a>
<a data-type="is-equiv (λ x → x)" id="2582" href="1Lab.Equiv.html#2544" class="Function">id-equiv</a> <a id="2591" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="2592" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="2599" href="1Lab.Equiv.html#2599" class="Bound">y</a> <a id="2601" class="Symbol">=</a>
  <a data-type="(centre₁ : A) (paths₁ : (x : A) → centre₁ ≡ x) → is-contr A" id="2605" href="1Lab.HLevel.html#1383" class="InductiveConstructor">contr</a> <a id="2611" class="Symbol">(</a><a id="2612" href="1Lab.Equiv.html#2599" class="Bound">y</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="2614" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2616" class="Symbol">λ</a> <a id="2618" href="1Lab.Equiv.html#2618" class="Bound">i</a> <a id="2620" class="Symbol">→</a> <a id="2622" href="1Lab.Equiv.html#2599" class="Bound">y</a><a id="2623" class="Symbol">)</a>
    <a id="2629" class="Symbol">λ</a> <a id="2631" class="Symbol">{</a> <a id="2633" class="Symbol">(</a><a id="2634" href="1Lab.Equiv.html#2634" class="Bound">y&#39;</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="2637" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2639" href="1Lab.Equiv.html#2639" class="Bound">p</a><a id="2640" class="Symbol">)</a> <a id="2642" href="1Lab.Equiv.html#2642" class="Bound">i</a> <a id="2644" class="Symbol">→</a> <a id="2646" href="1Lab.Equiv.html#2639" class="Bound">p</a> <a id="2648" class="Symbol">(</a><a id="2649" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="2651" href="1Lab.Equiv.html#2642" class="Bound">i</a><a id="2652" class="Symbol">)</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="2654" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2656" class="Symbol">λ</a> <a id="2658" href="1Lab.Equiv.html#2658" class="Bound">j</a> <a id="2660" class="Symbol">→</a> <a id="2662" href="1Lab.Equiv.html#2639" class="Bound">p</a> <a id="2664" class="Symbol">(</a><a id="2665" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="2667" href="1Lab.Equiv.html#2642" class="Bound">i</a> <a id="2669" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="2671" href="1Lab.Equiv.html#2658" class="Bound">j</a><a id="2672" class="Symbol">)</a> <a id="2674" class="Symbol">}</a>
</pre>
<!--
<pre class="Agda"><a id="2690" class="Comment">-- This helper is for functions f, g that cancel eachother, up to</a>
<a id="2756" class="Comment">-- definitional equality, without any case analysis on the argument:</a>

<a id="strict-fibres"></a><a id="2826" href="1Lab.Equiv.html#2826" class="Function">strict-fibres</a> <a id="2840" class="Symbol">:</a> <a id="2842" class="Symbol">∀</a> <a id="2844" class="Symbol">{</a><a id="2845" href="1Lab.Equiv.html#2845" class="Bound">ℓ</a> <a id="2847" href="1Lab.Equiv.html#2847" class="Bound">ℓ&#39;</a><a id="2849" class="Symbol">}</a> <a id="2851" class="Symbol">{</a><a id="2852" href="1Lab.Equiv.html#2852" class="Bound">A</a> <a id="2854" class="Symbol">:</a> <a id="2856" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2861" href="1Lab.Equiv.html#2845" class="Bound">ℓ</a><a id="2862" class="Symbol">}</a> <a id="2864" class="Symbol">{</a><a id="2865" href="1Lab.Equiv.html#2865" class="Bound">B</a> <a id="2867" class="Symbol">:</a> <a id="2869" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2874" href="1Lab.Equiv.html#2847" class="Bound">ℓ&#39;</a><a id="2876" class="Symbol">}</a> <a id="2878" class="Symbol">{</a><a id="2879" href="1Lab.Equiv.html#2879" class="Bound">f</a> <a id="2881" class="Symbol">:</a> <a id="2883" href="1Lab.Equiv.html#2852" class="Bound">A</a> <a id="2885" class="Symbol">→</a> <a id="2887" href="1Lab.Equiv.html#2865" class="Bound">B</a><a id="2888" class="Symbol">}</a> <a id="2890" class="Symbol">(</a><a id="2891" href="1Lab.Equiv.html#2891" class="Bound">g</a> <a id="2893" class="Symbol">:</a> <a id="2895" href="1Lab.Equiv.html#2865" class="Bound">B</a> <a id="2897" class="Symbol">→</a> <a id="2899" href="1Lab.Equiv.html#2852" class="Bound">A</a><a id="2900" class="Symbol">)</a> <a id="2902" class="Symbol">(</a><a id="2903" href="1Lab.Equiv.html#2903" class="Bound">b</a> <a id="2905" class="Symbol">:</a> <a id="2907" href="1Lab.Equiv.html#2865" class="Bound">B</a><a id="2908" class="Symbol">)</a>
  <a id="2912" class="Symbol">→</a> <a id="2914" href="1Lab.Type.html#1573" class="Function">Σ[</a> <a id="2917" href="1Lab.Equiv.html#2917" class="Bound">t</a> <a id="2919" href="1Lab.Type.html#1573" class="Function">∈</a> <a id="2921" href="1Lab.Equiv.html#1893" class="Function">fibre</a> <a id="2927" href="1Lab.Equiv.html#2879" class="Bound">f</a> <a id="2929" class="Symbol">(</a><a id="2930" href="1Lab.Equiv.html#2879" class="Bound">f</a> <a id="2932" class="Symbol">(</a><a id="2933" href="1Lab.Equiv.html#2891" class="Bound">g</a> <a id="2935" href="1Lab.Equiv.html#2903" class="Bound">b</a><a id="2936" class="Symbol">))</a> <a id="2939" href="1Lab.Type.html#1573" class="Function">]</a>
    <a id="2945" class="Symbol">((</a><a id="2947" href="1Lab.Equiv.html#2947" class="Bound">t&#39;</a> <a id="2950" class="Symbol">:</a> <a id="2952" href="1Lab.Equiv.html#1893" class="Function">fibre</a> <a id="2958" href="1Lab.Equiv.html#2879" class="Bound">f</a> <a id="2960" href="1Lab.Equiv.html#2903" class="Bound">b</a><a id="2961" class="Symbol">)</a> <a id="2963" class="Symbol">→</a> <a id="2965" href="1Lab.Path.html#2466" class="Function">Path</a> <a id="2970" class="Symbol">(</a><a id="2971" href="1Lab.Equiv.html#1893" class="Function">fibre</a> <a id="2977" href="1Lab.Equiv.html#2879" class="Bound">f</a> <a id="2979" class="Symbol">(</a><a id="2980" href="1Lab.Equiv.html#2879" class="Bound">f</a> <a id="2982" class="Symbol">(</a><a id="2983" href="1Lab.Equiv.html#2891" class="Bound">g</a> <a id="2985" href="1Lab.Equiv.html#2903" class="Bound">b</a><a id="2986" class="Symbol">)))</a> <a id="2990" href="1Lab.Equiv.html#2917" class="Bound">t</a>
                          <a id="3018" class="Symbol">(</a><a id="3019" href="1Lab.Equiv.html#2891" class="Bound">g</a> <a id="3021" class="Symbol">(</a><a id="3022" href="1Lab.Equiv.html#2879" class="Bound">f</a> <a id="3024" class="Symbol">(</a><a id="3025" href="1Lab.Equiv.html#2947" class="Bound">t&#39;</a> <a id="3028" class="Symbol">.</a><a id="3029" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="3032" class="Symbol">))</a> <a id="3035" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3037" href="1Lab.Path.html#20828" class="Function">ap</a> <a id="3040" class="Symbol">(</a><a id="3041" href="1Lab.Equiv.html#2879" class="Bound">f</a> <a id="3043" href="1Lab.Type.html#2227" class="Function Operator">∘</a> <a id="3045" href="1Lab.Equiv.html#2891" class="Bound">g</a><a id="3046" class="Symbol">)</a> <a id="3048" class="Symbol">(</a><a id="3049" href="1Lab.Equiv.html#2947" class="Bound">t&#39;</a> <a id="3052" class="Symbol">.</a><a id="3053" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="3056" class="Symbol">)))</a>
<a id="3060" href="1Lab.Equiv.html#2826" class="Function">strict-fibres</a> <a id="3074" class="Symbol">{</a><a id="3075" class="Argument">f</a> <a id="3077" class="Symbol">=</a> <a id="3079" href="1Lab.Equiv.html#3079" class="Bound">f</a><a id="3080" class="Symbol">}</a> <a id="3082" href="1Lab.Equiv.html#3082" class="Bound">g</a> <a id="3084" href="1Lab.Equiv.html#3084" class="Bound">b</a> <a id="3086" class="Symbol">.</a><a id="3087" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="3091" class="Symbol">=</a> <a id="3093" class="Symbol">(</a><a id="3094" href="1Lab.Equiv.html#3082" class="Bound">g</a> <a id="3096" href="1Lab.Equiv.html#3084" class="Bound">b</a> <a id="3098" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3100" href="1Lab.Path.html#3593" class="Function">refl</a><a id="3104" class="Symbol">)</a>
<a id="3106" href="1Lab.Equiv.html#2826" class="Function">strict-fibres</a> <a id="3120" class="Symbol">{</a><a id="3121" class="Argument">f</a> <a id="3123" class="Symbol">=</a> <a id="3125" href="1Lab.Equiv.html#3125" class="Bound">f</a><a id="3126" class="Symbol">}</a> <a id="3128" href="1Lab.Equiv.html#3128" class="Bound">g</a> <a id="3130" href="1Lab.Equiv.html#3130" class="Bound">b</a> <a id="3132" class="Symbol">.</a><a id="3133" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="3137" class="Symbol">(</a><a id="3138" href="1Lab.Equiv.html#3138" class="Bound">a</a> <a id="3140" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3142" href="1Lab.Equiv.html#3142" class="Bound">p</a><a id="3143" class="Symbol">)</a> <a id="3145" href="1Lab.Equiv.html#3145" class="Bound">i</a> <a id="3147" class="Symbol">=</a> <a id="3149" class="Symbol">(</a><a id="3150" href="1Lab.Equiv.html#3128" class="Bound">g</a> <a id="3152" class="Symbol">(</a><a id="3153" href="1Lab.Equiv.html#3142" class="Bound">p</a> <a id="3155" class="Symbol">(</a><a id="3156" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="3158" href="1Lab.Equiv.html#3145" class="Bound">i</a><a id="3159" class="Symbol">))</a> <a id="3162" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3164" class="Symbol">λ</a> <a id="3166" href="1Lab.Equiv.html#3166" class="Bound">j</a> <a id="3168" class="Symbol">→</a> <a id="3170" href="1Lab.Equiv.html#3125" class="Bound">f</a> <a id="3172" class="Symbol">(</a><a id="3173" href="1Lab.Equiv.html#3128" class="Bound">g</a> <a id="3175" class="Symbol">(</a><a id="3176" href="1Lab.Equiv.html#3142" class="Bound">p</a> <a id="3178" class="Symbol">(</a><a id="3179" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="3181" href="1Lab.Equiv.html#3145" class="Bound">i</a> <a id="3183" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="3185" href="1Lab.Equiv.html#3166" class="Bound">j</a><a id="3186" class="Symbol">))))</a>

<a id="3192" class="Comment">-- This is more efficient than using Iso→Equiv. When f (g x) is definitionally x,</a>
<a id="3274" class="Comment">-- the type reduces to essentially is-contr (fibre f b).</a>
</pre>-->
<p>For Cubical Agda, the type of equivalences is distinguished, so we have to make a small wrapper to match the interface Agda expects. This is the geometric definition of contractibility, in terms of <a href="1Lab.Path.html#extensibility">partial elements</a> and extensibility.</p>
<pre class="Agda"><a id="3635" class="Symbol">{-#</a> <a id="3639" class="Keyword">BUILTIN</a> <a id="3647" class="Keyword">EQUIV</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="3653" href="1Lab.Equiv.html#2459" class="Function Operator">_≃_</a> <a id="3657" class="Symbol">#-}</a>
<a id="3661" class="Symbol">{-#</a> <a id="3665" class="Keyword">BUILTIN</a> <a id="3673" class="Keyword">EQUIVFUN</a> <a data-type="∑ A B₁ → A" id="3682" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="3686" class="Symbol">#-}</a>

<a id="is-eqv&#39;"></a><a data-type="(A : Type a) (B₁ : Type b) (w : A ≃ B₁) (a : B₁) (ψ : I) →
Partial ψ (fibre (w .fst) a) → fibre (w .fst) a" id="3691" href="1Lab.Equiv.html#3691" class="Function">is-eqv&#39;</a> <a id="3699" class="Symbol">:</a> <a id="3701" class="Symbol">∀</a> <a id="3703" class="Symbol">{</a><a id="3704" href="1Lab.Equiv.html#3704" class="Bound">a</a> <a id="3706" href="1Lab.Equiv.html#3706" class="Bound">b</a><a id="3707" class="Symbol">}</a> <a id="3709" class="Symbol">(</a><a id="3710" href="1Lab.Equiv.html#3710" class="Bound">A</a> <a id="3712" class="Symbol">:</a> <a id="3714" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="3719" href="1Lab.Equiv.html#3704" class="Bound">a</a><a id="3720" class="Symbol">)</a> <a id="3722" class="Symbol">(</a><a id="3723" href="1Lab.Equiv.html#3723" class="Bound">B</a> <a id="3725" class="Symbol">:</a> <a id="3727" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="3732" href="1Lab.Equiv.html#3706" class="Bound">b</a><a id="3733" class="Symbol">)</a>
        <a id="3743" class="Symbol">→</a> <a id="3745" class="Symbol">(</a><a id="3746" href="1Lab.Equiv.html#3746" class="Bound">w</a> <a id="3748" class="Symbol">:</a> <a id="3750" href="1Lab.Equiv.html#3710" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="3752" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="3754" href="1Lab.Equiv.html#3723" class="Bound">B</a><a id="3755" class="Symbol">)</a> <a id="3757" class="Symbol">(</a><a id="3758" href="1Lab.Equiv.html#3758" class="Bound">a</a> <a id="3760" class="Symbol">:</a> <a id="3762" href="1Lab.Equiv.html#3723" class="Bound">B</a><a id="3763" class="Symbol">)</a>
        <a id="3773" class="Symbol">→</a> <a id="3775" class="Symbol">(</a><a id="3776" href="1Lab.Equiv.html#3776" class="Bound">ψ</a> <a id="3778" class="Symbol">:</a> <a id="3780" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="3781" class="Symbol">)</a>
        <a id="3791" class="Symbol">→</a> <a id="3793" href="Agda.Primitive.Cubical.html#1065" class="Primitive">Partial</a> <a id="3801" href="1Lab.Equiv.html#3776" class="Bound">ψ</a> <a id="3803" class="Symbol">(</a><a data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="3804" href="1Lab.Equiv.html#1893" class="Function">fibre</a> <a id="3810" class="Symbol">(</a><a id="3811" href="1Lab.Equiv.html#3746" class="Bound">w</a> <a id="3813" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="3814" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="3817" class="Symbol">)</a> <a id="3819" href="1Lab.Equiv.html#3758" class="Bound">a</a><a id="3820" class="Symbol">)</a>
        <a id="3830" class="Symbol">→</a> <a data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="3832" href="1Lab.Equiv.html#1893" class="Function">fibre</a> <a id="3838" class="Symbol">(</a><a id="3839" href="1Lab.Equiv.html#3746" class="Bound">w</a> <a id="3841" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="3842" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="3845" class="Symbol">)</a> <a id="3847" href="1Lab.Equiv.html#3758" class="Bound">a</a>
<a data-type="(A : Type a) (B₁ : Type b) (w : A ≃ B₁) (a : B₁) (ψ : I) →
Partial ψ (fibre (w .fst) a) → fibre (w .fst) a" id="3849" href="1Lab.Equiv.html#3691" class="Function">is-eqv&#39;</a> <a id="3857" href="1Lab.Equiv.html#3857" class="Bound">A</a> <a id="3859" href="1Lab.Equiv.html#3859" class="Bound">B</a> <a id="3861" class="Symbol">(</a><a id="3862" href="1Lab.Equiv.html#3862" class="Bound">f</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="3864" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3866" href="1Lab.Equiv.html#3866" class="Bound">is-equiv</a><a id="3874" class="Symbol">)</a> <a id="3876" href="1Lab.Equiv.html#3876" class="Bound">a</a> <a id="3878" href="1Lab.Equiv.html#3878" class="Bound">ψ</a> <a id="3880" href="1Lab.Equiv.html#3880" class="Bound">u0</a> <a id="3883" class="Symbol">=</a>
  <a id="3887" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="3893" class="Symbol">(λ</a> <a id="3896" href="1Lab.Equiv.html#3896" class="Bound">i</a> <a id="3898" class="Symbol">→</a> <a id="3900" class="Symbol">λ</a> <a id="3902" class="Symbol">{</a> <a id="3904" class="Symbol">(</a><a id="3905" href="1Lab.Equiv.html#3878" class="Bound">ψ</a> <a id="3907" class="Symbol">=</a> <a id="3909" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="3911" class="Symbol">)</a> <a id="3913" class="Symbol">→</a> <a id="3915" href="1Lab.Equiv.html#4023" class="Function">c</a> <a id="3917" class="Symbol">.</a><a data-type="is-contr A → A" id="3918" href="1Lab.HLevel.html#1401" class="Field">centre</a>
                 <a id="3942" class="Symbol">;</a> <a id="3944" class="Symbol">(</a><a id="3945" href="1Lab.Equiv.html#3878" class="Bound">ψ</a> <a id="3947" class="Symbol">=</a> <a id="3949" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="3951" class="Symbol">)</a> <a id="3953" class="Symbol">→</a> <a id="3955" href="1Lab.Equiv.html#4023" class="Function">c</a> <a id="3957" class="Symbol">.</a><a data-type="(r : is-contr A) (x : A) → r .centre ≡ x" id="3958" href="1Lab.HLevel.html#1416" class="Field">paths</a> <a id="3964" class="Symbol">(</a><a id="3965" href="1Lab.Equiv.html#3880" class="Bound">u0</a> <a id="3968" href="1Lab.Path.html#2443" class="Postulate">1=1</a><a id="3971" class="Symbol">)</a> <a id="3973" href="1Lab.Equiv.html#3896" class="Bound">i</a>
                 <a id="3992" class="Symbol">})</a>
        <a id="4003" class="Symbol">(</a><a id="4004" href="1Lab.Equiv.html#4023" class="Function">c</a> <a id="4006" class="Symbol">.</a><a data-type="is-contr A → A" id="4007" href="1Lab.HLevel.html#1401" class="Field">centre</a><a id="4013" class="Symbol">)</a>
  <a id="4017" class="Keyword">where</a> <a id="4023" href="1Lab.Equiv.html#4023" class="Function">c</a> <a id="4025" class="Symbol">=</a> <a id="4027" href="1Lab.Equiv.html#3866" class="Bound">is-equiv</a> <a id="4036" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="4037" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="4044" href="1Lab.Equiv.html#3876" class="Bound">a</a>

<a id="4047" class="Symbol">{-#</a> <a id="4051" class="Keyword">BUILTIN</a> <a id="4059" class="Keyword">EQUIVPROOF</a> <a data-type="(A : Type a) (B₁ : Type b) (w : A ≃ B₁) (a : B₁) (ψ : I) →
Partial ψ (fibre (w .fst) a) → fibre (w .fst) a" id="4070" href="1Lab.Equiv.html#3691" class="Function">is-eqv&#39;</a> <a id="4078" class="Symbol">#-}</a>
</pre>
<!--
<pre class="Agda"><a id="equiv-centre"></a><a id="4096" href="1Lab.Equiv.html#4096" class="Function">equiv-centre</a> <a id="4109" class="Symbol">:</a> <a id="4111" class="Symbol">(</a><a id="4112" href="1Lab.Equiv.html#4112" class="Bound">e</a> <a id="4114" class="Symbol">:</a> <a id="4116" href="1Lab.Equiv.html#1608" class="Generalizable">A</a> <a id="4118" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="4120" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="4121" class="Symbol">)</a> <a id="4123" class="Symbol">(</a><a id="4124" href="1Lab.Equiv.html#4124" class="Bound">y</a> <a id="4126" class="Symbol">:</a> <a id="4128" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="4129" class="Symbol">)</a> <a id="4131" class="Symbol">→</a> <a id="4133" href="1Lab.Equiv.html#1893" class="Function">fibre</a> <a id="4139" class="Symbol">(</a><a id="4140" href="1Lab.Equiv.html#4112" class="Bound">e</a> <a id="4142" class="Symbol">.</a><a id="4143" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="4146" class="Symbol">)</a> <a id="4148" href="1Lab.Equiv.html#4124" class="Bound">y</a>
<a id="4150" href="1Lab.Equiv.html#4096" class="Function">equiv-centre</a> <a id="4163" href="1Lab.Equiv.html#4163" class="Bound">e</a> <a id="4165" href="1Lab.Equiv.html#4165" class="Bound">y</a> <a id="4167" class="Symbol">=</a> <a id="4169" href="1Lab.Equiv.html#4163" class="Bound">e</a> <a id="4171" class="Symbol">.</a><a id="4172" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="4176" class="Symbol">.</a><a id="4177" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="4184" href="1Lab.Equiv.html#4165" class="Bound">y</a> <a id="4186" class="Symbol">.</a><a id="4187" href="1Lab.HLevel.html#1401" class="Field">centre</a>

<a id="equiv-path"></a><a id="4195" href="1Lab.Equiv.html#4195" class="Function">equiv-path</a> <a id="4206" class="Symbol">:</a> <a id="4208" class="Symbol">(</a><a id="4209" href="1Lab.Equiv.html#4209" class="Bound">e</a> <a id="4211" class="Symbol">:</a> <a id="4213" href="1Lab.Equiv.html#1608" class="Generalizable">A</a> <a id="4215" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="4217" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="4218" class="Symbol">)</a> <a id="4220" class="Symbol">(</a><a id="4221" href="1Lab.Equiv.html#4221" class="Bound">y</a> <a id="4223" class="Symbol">:</a> <a id="4225" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="4226" class="Symbol">)</a> <a id="4228" class="Symbol">→</a>
  <a id="4232" class="Symbol">(</a><a id="4233" href="1Lab.Equiv.html#4233" class="Bound">v</a> <a id="4235" class="Symbol">:</a> <a id="4237" href="1Lab.Equiv.html#1893" class="Function">fibre</a> <a id="4243" class="Symbol">(</a><a id="4244" href="1Lab.Equiv.html#4209" class="Bound">e</a> <a id="4246" class="Symbol">.</a><a id="4247" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="4250" class="Symbol">)</a> <a id="4252" href="1Lab.Equiv.html#4221" class="Bound">y</a><a id="4253" class="Symbol">)</a> <a id="4255" class="Symbol">→</a> <a id="4257" href="1Lab.Path.html#2466" class="Function">Path</a> <a id="4262" class="Symbol">_</a> <a id="4264" class="Symbol">(</a><a id="4265" href="1Lab.Equiv.html#4096" class="Function">equiv-centre</a> <a id="4278" href="1Lab.Equiv.html#4209" class="Bound">e</a> <a id="4280" href="1Lab.Equiv.html#4221" class="Bound">y</a><a id="4281" class="Symbol">)</a> <a id="4283" href="1Lab.Equiv.html#4233" class="Bound">v</a>
<a id="4285" href="1Lab.Equiv.html#4195" class="Function">equiv-path</a> <a id="4296" href="1Lab.Equiv.html#4296" class="Bound">e</a> <a id="4298" href="1Lab.Equiv.html#4298" class="Bound">y</a> <a id="4300" class="Symbol">=</a> <a id="4302" href="1Lab.Equiv.html#4296" class="Bound">e</a> <a id="4304" class="Symbol">.</a><a id="4305" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="4309" class="Symbol">.</a><a id="4310" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="4317" href="1Lab.Equiv.html#4298" class="Bound">y</a> <a id="4319" class="Symbol">.</a><a id="4320" href="1Lab.HLevel.html#1416" class="Field">paths</a>
</pre>-->
<h2 id="is-equiv-is-propositional"><a href="#is-equiv-is-propositional" class="header-link">is-equiv is propositional<span class="header-link-emoji">🔗</span></a></h2>
<p>A function can be an equivalence in at most one way. This follows from propositions being closed under dependent products, and <span class="Agda"><a data-type="(A : Type ℓ) → Type ℓ" href="1Lab.HLevel.html#1328" class="Module">is-contr</a></span> being a proposition.</p>
<pre class="Agda"><a id="4540" class="Keyword">module</a> <a id="4547" href="1Lab.Equiv.html#4547" class="Module">_</a> <a id="4549" class="Keyword">where</a> <a id="4555" class="Keyword">private</a>
  <a id="4565" href="1Lab.Equiv.html#4565" class="Function">is-equiv-is-prop</a> <a id="4582" class="Symbol">:</a> <a id="4584" class="Symbol">(</a><a id="4585" href="1Lab.Equiv.html#4585" class="Bound">f</a> <a id="4587" class="Symbol">:</a> <a id="4589" href="1Lab.Equiv.html#1608" class="Generalizable">A</a> <a id="4591" class="Symbol">→</a> <a id="4593" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="4594" class="Symbol">)</a> <a id="4596" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="4598" href="1Lab.HLevel.html#2597" class="Function">is-prop</a> <a id="4606" class="Symbol">(</a><a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="4607" href="1Lab.Equiv.html#2306" class="Record">is-equiv</a> <a id="4616" href="1Lab.Equiv.html#4585" class="Bound">f</a><a id="4617" class="Symbol">)</a>
  <a id="4621" href="1Lab.Equiv.html#4565" class="Function">is-equiv-is-prop</a> <a id="4638" href="1Lab.Equiv.html#4638" class="Bound">f</a> <a id="4640" href="1Lab.Equiv.html#4640" class="Bound">x</a> <a id="4642" href="1Lab.Equiv.html#4642" class="Bound">y</a> <a id="4644" href="1Lab.Equiv.html#4644" class="Bound">i</a> <a id="4646" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="4647" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="4654" href="1Lab.Equiv.html#4654" class="Bound">p</a> <a id="4656" class="Symbol">=</a> <a data-type="is-prop (is-contr A)" id="4658" href="1Lab.HLevel.html#11558" class="Function">is-contr-is-prop</a> <a id="4675" class="Symbol">(</a><a id="4676" href="1Lab.Equiv.html#4640" class="Bound">x</a> <a id="4678" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="4679" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="4686" href="1Lab.Equiv.html#4654" class="Bound">p</a><a id="4687" class="Symbol">)</a> <a id="4689" class="Symbol">(</a><a id="4690" href="1Lab.Equiv.html#4642" class="Bound">y</a> <a id="4692" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="4693" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="4700" href="1Lab.Equiv.html#4654" class="Bound">p</a><a id="4701" class="Symbol">)</a> <a id="4703" href="1Lab.Equiv.html#4644" class="Bound">i</a>
</pre>
<details>
<summary>
Even though the proof above works, we use the direct cubical proof in this <code>&lt;details&gt;</code> tag (lifted from the Cubical Agda library) in the rest of the development for efficiency concerns.
</summary>
<pre class="Agda"><a id="is-equiv-is-prop"></a><a data-type="(f : A → B₁) → is-prop (is-equiv f)" id="4936" href="1Lab.Equiv.html#4936" class="Function">is-equiv-is-prop</a> <a id="4953" class="Symbol">:</a> <a id="4955" class="Symbol">(</a><a id="4956" href="1Lab.Equiv.html#4956" class="Bound">f</a> <a id="4958" class="Symbol">:</a> <a id="4960" href="1Lab.Equiv.html#1608" class="Generalizable">A</a> <a id="4962" class="Symbol">→</a> <a id="4964" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="4965" class="Symbol">)</a> <a id="4967" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="4969" href="1Lab.HLevel.html#2597" class="Function">is-prop</a> <a id="4977" class="Symbol">(</a><a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="4978" href="1Lab.Equiv.html#2306" class="Record">is-equiv</a> <a id="4987" href="1Lab.Equiv.html#4956" class="Bound">f</a><a id="4988" class="Symbol">)</a>
<a data-type="(f : A → B₁) → is-prop (is-equiv f)" id="4990" href="1Lab.Equiv.html#4936" class="Function">is-equiv-is-prop</a> <a id="5007" href="1Lab.Equiv.html#5007" class="Bound">f</a> <a id="5009" href="1Lab.Equiv.html#5009" class="Bound">p</a> <a id="5011" href="1Lab.Equiv.html#5011" class="Bound">q</a> <a id="5013" href="1Lab.Equiv.html#5013" class="Bound">i</a> <a id="5015" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="5016" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="5023" href="1Lab.Equiv.html#5023" class="Bound">y</a> <a id="5025" class="Symbol">=</a>
  <a id="5029" class="Keyword">let</a> <a id="5033" href="1Lab.Equiv.html#5033" class="Bound">p2</a> <a id="5036" class="Symbol">=</a> <a id="5038" href="1Lab.Equiv.html#5009" class="Bound">p</a> <a id="5040" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="5041" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="5048" href="1Lab.Equiv.html#5023" class="Bound">y</a> <a id="5050" class="Symbol">.</a><a data-type="(r : is-contr A) (x : A) → r .centre ≡ x" id="5051" href="1Lab.HLevel.html#1416" class="Field">paths</a>
      <a id="5063" href="1Lab.Equiv.html#5063" class="Bound">q2</a> <a id="5066" class="Symbol">=</a> <a id="5068" href="1Lab.Equiv.html#5011" class="Bound">q</a> <a id="5070" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="5071" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="5078" href="1Lab.Equiv.html#5023" class="Bound">y</a> <a id="5080" class="Symbol">.</a><a data-type="(r : is-contr A) (x : A) → r .centre ≡ x" id="5081" href="1Lab.HLevel.html#1416" class="Field">paths</a>
  <a id="5089" class="Keyword">in</a> <a data-type="(centre₁ : A) (paths₁ : (x : A) → centre₁ ≡ x) → is-contr A" id="5092" href="1Lab.HLevel.html#1383" class="InductiveConstructor">contr</a> <a id="5098" class="Symbol">(</a><a id="5099" href="1Lab.Equiv.html#5033" class="Bound">p2</a> <a id="5102" class="Symbol">(</a><a id="5103" href="1Lab.Equiv.html#5011" class="Bound">q</a> <a id="5105" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="5106" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="5113" href="1Lab.Equiv.html#5023" class="Bound">y</a> <a id="5115" class="Symbol">.</a><a data-type="is-contr A → A" id="5116" href="1Lab.HLevel.html#1401" class="Field">centre</a><a id="5122" class="Symbol">)</a> <a id="5124" href="1Lab.Equiv.html#5013" class="Bound">i</a><a id="5125" class="Symbol">)</a>
      <a id="5133" class="Symbol">λ</a> <a id="5135" href="1Lab.Equiv.html#5135" class="Bound">w</a> <a id="5137" href="1Lab.Equiv.html#5137" class="Bound">j</a> <a id="5139" class="Symbol">→</a> <a id="5141" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="5147" class="Symbol">(λ</a> <a id="5150" href="1Lab.Equiv.html#5150" class="Bound">k</a> <a id="5152" class="Symbol">→</a> <a id="5154" class="Symbol">λ</a> <a id="5156" class="Symbol">{</a> <a id="5158" class="Symbol">(</a><a id="5159" href="1Lab.Equiv.html#5013" class="Bound">i</a> <a id="5161" class="Symbol">=</a> <a id="5163" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="5165" class="Symbol">)</a> <a id="5167" class="Symbol">→</a> <a id="5169" href="1Lab.Equiv.html#5033" class="Bound">p2</a> <a id="5172" href="1Lab.Equiv.html#5135" class="Bound">w</a> <a id="5174" href="1Lab.Equiv.html#5137" class="Bound">j</a>
                             <a id="5205" class="Symbol">;</a> <a id="5207" class="Symbol">(</a><a id="5208" href="1Lab.Equiv.html#5013" class="Bound">i</a> <a id="5210" class="Symbol">=</a> <a id="5212" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="5214" class="Symbol">)</a> <a id="5216" class="Symbol">→</a> <a id="5218" href="1Lab.Equiv.html#5063" class="Bound">q2</a> <a id="5221" href="1Lab.Equiv.html#5135" class="Bound">w</a> <a id="5223" class="Symbol">(</a><a id="5224" href="1Lab.Equiv.html#5137" class="Bound">j</a> <a id="5226" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="5228" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="5230" href="1Lab.Equiv.html#5150" class="Bound">k</a><a id="5231" class="Symbol">)</a>
                             <a id="5262" class="Symbol">;</a> <a id="5264" class="Symbol">(</a><a id="5265" href="1Lab.Equiv.html#5137" class="Bound">j</a> <a id="5267" class="Symbol">=</a> <a id="5269" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="5271" class="Symbol">)</a> <a id="5273" class="Symbol">→</a> <a id="5275" href="1Lab.Equiv.html#5033" class="Bound">p2</a> <a id="5278" class="Symbol">(</a><a id="5279" href="1Lab.Equiv.html#5063" class="Bound">q2</a> <a id="5282" href="1Lab.Equiv.html#5135" class="Bound">w</a> <a id="5284" class="Symbol">(</a><a id="5285" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="5287" href="1Lab.Equiv.html#5150" class="Bound">k</a><a id="5288" class="Symbol">))</a> <a id="5291" href="1Lab.Equiv.html#5013" class="Bound">i</a>
                             <a id="5322" class="Symbol">;</a> <a id="5324" class="Symbol">(</a><a id="5325" href="1Lab.Equiv.html#5137" class="Bound">j</a> <a id="5327" class="Symbol">=</a> <a id="5329" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="5331" class="Symbol">)</a> <a id="5333" class="Symbol">→</a> <a id="5335" href="1Lab.Equiv.html#5135" class="Bound">w</a> <a id="5337" class="Symbol">})</a>
                    <a id="5360" class="Symbol">(</a><a id="5361" href="1Lab.Equiv.html#5033" class="Bound">p2</a> <a id="5364" href="1Lab.Equiv.html#5135" class="Bound">w</a> <a id="5366" class="Symbol">(</a><a id="5367" href="1Lab.Equiv.html#5013" class="Bound">i</a> <a id="5369" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="5371" href="1Lab.Equiv.html#5137" class="Bound">j</a><a id="5372" class="Symbol">))</a>
</pre>
</details>
<h1 id="isomorphisms-from-equivalences"><a href="#isomorphisms-from-equivalences" class="header-link">Isomorphisms from equivalences<span class="header-link-emoji">🔗</span></a></h1>
<p>For this section, we need a definition of <em>isomorphism</em>. This is the same as ever! An isomorphism is a function that has a two-sided inverse. We first define what it means for a function to invert another on the left and on the right:</p>
<pre class="Agda"><a id="is-left-inverse"></a><a data-type="(B₁ → A) → (A → B₁) → Type A.ℓ₁" id="5669" href="1Lab.Equiv.html#5669" class="Function">is-left-inverse</a> <a id="5685" class="Symbol">:</a> <a id="5687" class="Symbol">(</a><a id="5688" href="1Lab.Equiv.html#1610" class="Generalizable">B</a> <a id="5690" class="Symbol">→</a> <a id="5692" href="1Lab.Equiv.html#1608" class="Generalizable">A</a><a id="5693" class="Symbol">)</a> <a id="5695" class="Symbol">→</a> <a id="5697" class="Symbol">(</a><a id="5698" href="1Lab.Equiv.html#1608" class="Generalizable">A</a> <a id="5700" class="Symbol">→</a> <a id="5702" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="5703" class="Symbol">)</a> <a id="5705" class="Symbol">→</a> <a id="5707" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="5712" class="Symbol">_</a>
<a data-type="(B₁ → A) → (A → B₁) → Type A.ℓ₁" id="5714" href="1Lab.Equiv.html#5669" class="Function">is-left-inverse</a> <a id="5730" href="1Lab.Equiv.html#5730" class="Bound">g</a> <a id="5732" href="1Lab.Equiv.html#5732" class="Bound">f</a> <a id="5734" class="Symbol">=</a> <a id="5736" class="Symbol">(</a><a id="5737" href="1Lab.Equiv.html#5737" class="Bound">x</a> <a id="5739" class="Symbol">:</a> <a id="5741" class="Symbol">_)</a> <a id="5744" class="Symbol">→</a> <a id="5746" href="1Lab.Equiv.html#5730" class="Bound">g</a> <a id="5748" class="Symbol">(</a><a id="5749" href="1Lab.Equiv.html#5732" class="Bound">f</a> <a id="5751" href="1Lab.Equiv.html#5737" class="Bound">x</a><a id="5752" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="5754" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="5756" href="1Lab.Equiv.html#5737" class="Bound">x</a>

<a id="is-right-inverse"></a><a data-type="(B₁ → A) → (A → B₁) → Type B.ℓ₁" id="5759" href="1Lab.Equiv.html#5759" class="Function">is-right-inverse</a> <a id="5776" class="Symbol">:</a> <a id="5778" class="Symbol">(</a><a id="5779" href="1Lab.Equiv.html#1610" class="Generalizable">B</a> <a id="5781" class="Symbol">→</a> <a id="5783" href="1Lab.Equiv.html#1608" class="Generalizable">A</a><a id="5784" class="Symbol">)</a> <a id="5786" class="Symbol">→</a> <a id="5788" class="Symbol">(</a><a id="5789" href="1Lab.Equiv.html#1608" class="Generalizable">A</a> <a id="5791" class="Symbol">→</a> <a id="5793" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="5794" class="Symbol">)</a> <a id="5796" class="Symbol">→</a> <a id="5798" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="5803" class="Symbol">_</a>
<a data-type="(B₁ → A) → (A → B₁) → Type B.ℓ₁" id="5805" href="1Lab.Equiv.html#5759" class="Function">is-right-inverse</a> <a id="5822" href="1Lab.Equiv.html#5822" class="Bound">g</a> <a id="5824" href="1Lab.Equiv.html#5824" class="Bound">f</a> <a id="5826" class="Symbol">=</a> <a id="5828" class="Symbol">(</a><a id="5829" href="1Lab.Equiv.html#5829" class="Bound">x</a> <a id="5831" class="Symbol">:</a> <a id="5833" class="Symbol">_)</a> <a id="5836" class="Symbol">→</a> <a id="5838" href="1Lab.Equiv.html#5824" class="Bound">f</a> <a id="5840" class="Symbol">(</a><a id="5841" href="1Lab.Equiv.html#5822" class="Bound">g</a> <a id="5843" href="1Lab.Equiv.html#5829" class="Bound">x</a><a id="5844" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="5846" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="5848" href="1Lab.Equiv.html#5829" class="Bound">x</a>
</pre>
<p>A proof that a function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> is an isomorphism consists of a function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> in the other direction, together with homotopies exhibiting <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> as a left- and right- inverse to <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>.</span></p>
<pre class="Agda"><a id="6039" class="Keyword">record</a> <a id="is-iso"></a><a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="6046" href="1Lab.Equiv.html#6046" class="Record">is-iso</a> <a id="6053" class="Symbol">(</a><a id="6054" href="1Lab.Equiv.html#6054" class="Bound">f</a> <a id="6056" class="Symbol">:</a> <a id="6058" href="1Lab.Equiv.html#1608" class="Generalizable">A</a> <a id="6060" class="Symbol">→</a> <a id="6062" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="6063" class="Symbol">)</a> <a id="6065" class="Symbol">:</a> <a id="6067" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="6072" class="Symbol">(</a><a data-type="Type ℓ → Level" id="6073" href="1Lab.Type.html#921" class="Function">level-of</a> <a id="6082" href="1Lab.Equiv.html#6058" class="Bound">A</a> <a data-type="Level → Level → Level" id="6084" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a data-type="Type ℓ → Level" id="6086" href="1Lab.Type.html#921" class="Function">level-of</a> <a id="6095" href="1Lab.Equiv.html#6062" class="Bound">B</a><a id="6096" class="Symbol">)</a> <a id="6098" class="Keyword">where</a>
  <a id="6106" class="Keyword">no-eta-equality</a>
  <a id="6124" class="Keyword">constructor</a> <a id="iso"></a><a data-type="(inv₁ : B₁ → A) (rinv₁ : is-right-inverse inv₁ f)
(linv₁ : is-left-inverse inv₁ f) →
is-iso f" id="6136" href="1Lab.Equiv.html#6136" class="InductiveConstructor">iso</a>
  <a id="6142" class="Keyword">field</a>
    <a id="is-iso.inv"></a><a data-type="is-iso f → B₁ → A" id="6152" href="1Lab.Equiv.html#6152" class="Field">inv</a> <a id="6156" class="Symbol">:</a> <a id="6158" href="1Lab.Equiv.html#6062" class="Bound">B</a> <a id="6160" class="Symbol">→</a> <a id="6162" href="1Lab.Equiv.html#6058" class="Bound">A</a>
    <a id="is-iso.rinv"></a><a data-type="(r : is-iso f) → is-right-inverse (r .inv) f" id="6168" href="1Lab.Equiv.html#6168" class="Field">rinv</a> <a id="6173" class="Symbol">:</a> <a data-type="(B₁ → A) → (A → B₁) → Type B.ℓ₁" id="6175" href="1Lab.Equiv.html#5759" class="Function">is-right-inverse</a> <a data-type="is-iso f → B₁ → A" id="6192" href="1Lab.Equiv.html#6152" class="Field">inv</a> <a id="6196" href="1Lab.Equiv.html#6054" class="Bound">f</a>
    <a id="is-iso.linv"></a><a data-type="(r : is-iso f) → is-left-inverse (r .inv) f" id="6202" href="1Lab.Equiv.html#6202" class="Field">linv</a> <a id="6207" class="Symbol">:</a> <a data-type="(B₁ → A) → (A → B₁) → Type A.ℓ₁" id="6209" href="1Lab.Equiv.html#5669" class="Function">is-left-inverse</a> <a data-type="is-iso f → B₁ → A" id="6225" href="1Lab.Equiv.html#6152" class="Field">inv</a> <a id="6229" href="1Lab.Equiv.html#6054" class="Bound">f</a>

  <a id="is-iso.inverse"></a><a data-type="(r : is-iso f) → is-iso (inv r)" id="6234" href="1Lab.Equiv.html#6234" class="Function">inverse</a> <a id="6242" class="Symbol">:</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="6244" href="1Lab.Equiv.html#6046" class="Record">is-iso</a> <a data-type="is-iso f → B₁ → A" id="6251" href="1Lab.Equiv.html#6152" class="Field">inv</a>
  <a data-type="is-iso f → B₁ → A" id="6257" href="1Lab.Equiv.html#6152" class="Field">inv</a> <a data-type="(r : is-iso f) → is-iso (inv r)" id="6261" href="1Lab.Equiv.html#6234" class="Function">inverse</a> <a id="6269" class="Symbol">=</a> <a id="6271" href="1Lab.Equiv.html#6054" class="Bound">f</a>
  <a data-type="(r : is-iso f) → is-right-inverse (r .inv) f" id="6275" href="1Lab.Equiv.html#6168" class="Field">rinv</a> <a data-type="(r : is-iso f) → is-iso (inv r)" id="6280" href="1Lab.Equiv.html#6234" class="Function">inverse</a> <a id="6288" class="Symbol">=</a> <a data-type="(r : is-iso f) → is-left-inverse (r .inv) f" id="6290" href="1Lab.Equiv.html#6202" class="Field">linv</a>
  <a data-type="(r : is-iso f) → is-left-inverse (r .inv) f" id="6297" href="1Lab.Equiv.html#6202" class="Field">linv</a> <a data-type="(r : is-iso f) → is-iso (inv r)" id="6302" href="1Lab.Equiv.html#6234" class="Function">inverse</a> <a id="6310" class="Symbol">=</a> <a data-type="(r : is-iso f) → is-right-inverse (r .inv) f" id="6312" href="1Lab.Equiv.html#6168" class="Field">rinv</a>

<a id="Iso"></a><a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="6318" href="1Lab.Equiv.html#6318" class="Function">Iso</a> <a id="6322" class="Symbol">:</a> <a id="6324" class="Symbol">∀</a> <a id="6326" class="Symbol">{</a><a id="6327" href="1Lab.Equiv.html#6327" class="Bound">ℓ₁</a> <a id="6330" href="1Lab.Equiv.html#6330" class="Bound">ℓ₂</a><a id="6332" class="Symbol">}</a> <a id="6334" class="Symbol">→</a> <a id="6336" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="6341" href="1Lab.Equiv.html#6327" class="Bound">ℓ₁</a> <a id="6344" class="Symbol">→</a> <a id="6346" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="6351" href="1Lab.Equiv.html#6330" class="Bound">ℓ₂</a> <a id="6354" class="Symbol">→</a> <a id="6356" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="6361" class="Symbol">_</a>
<a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="6363" href="1Lab.Equiv.html#6318" class="Function">Iso</a> <a id="6367" href="1Lab.Equiv.html#6367" class="Bound">A</a> <a id="6369" href="1Lab.Equiv.html#6369" class="Bound">B</a> <a id="6371" class="Symbol">=</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="6373" href="1Lab.Type.html#1573" class="Function">Σ</a> <a id="6375" class="Symbol">(</a><a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="6376" href="1Lab.Equiv.html#6046" class="Record">is-iso</a> <a id="6383" class="Symbol">{</a><a id="6384" class="Argument">A</a> <a id="6386" class="Symbol">=</a> <a id="6388" href="1Lab.Equiv.html#6367" class="Bound">A</a><a id="6389" class="Symbol">}</a> <a id="6391" class="Symbol">{</a><a id="6392" class="Argument">B</a> <a id="6394" class="Symbol">=</a> <a id="6396" href="1Lab.Equiv.html#6369" class="Bound">B</a><a id="6397" class="Symbol">})</a>
</pre>
<p>Any function that is an equivalence is an isomorphism:</p>
<pre class="Agda"><a id="equiv→inverse"></a><a data-type="is-equiv f → B₁ → A" id="6469" href="1Lab.Equiv.html#6469" class="Function">equiv→inverse</a> <a id="6483" class="Symbol">:</a> <a id="6485" class="Symbol">{</a><a id="6486" href="1Lab.Equiv.html#6486" class="Bound">f</a> <a id="6488" class="Symbol">:</a> <a id="6490" href="1Lab.Equiv.html#1608" class="Generalizable">A</a> <a id="6492" class="Symbol">→</a> <a id="6494" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="6495" class="Symbol">}</a> <a id="6497" class="Symbol">→</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="6499" href="1Lab.Equiv.html#2306" class="Record">is-equiv</a> <a id="6508" href="1Lab.Equiv.html#6486" class="Bound">f</a> <a id="6510" class="Symbol">→</a> <a id="6512" href="1Lab.Equiv.html#1610" class="Generalizable">B</a> <a id="6514" class="Symbol">→</a> <a id="6516" href="1Lab.Equiv.html#1608" class="Generalizable">A</a>
<a data-type="is-equiv f → B₁ → A" id="6518" href="1Lab.Equiv.html#6469" class="Function">equiv→inverse</a> <a id="6532" href="1Lab.Equiv.html#6532" class="Bound">eqv</a> <a id="6536" href="1Lab.Equiv.html#6536" class="Bound">y</a> <a id="6538" class="Symbol">=</a> <a id="6540" href="1Lab.Equiv.html#6532" class="Bound">eqv</a> <a id="6544" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="6545" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="6552" href="1Lab.Equiv.html#6536" class="Bound">y</a> <a id="6554" class="Symbol">.</a><a data-type="is-contr A → A" id="6555" href="1Lab.HLevel.html#1401" class="Field">centre</a> <a id="6562" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="6563" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a>

<a id="equiv→section"></a><a data-type="(eqv : is-equiv f) → is-right-inverse (equiv→inverse eqv) f" id="6568" href="1Lab.Equiv.html#6568" class="Function">equiv→section</a>
  <a id="6584" class="Symbol">:</a> <a id="6586" class="Symbol">{</a><a id="6587" href="1Lab.Equiv.html#6587" class="Bound">f</a> <a id="6589" class="Symbol">:</a> <a id="6591" href="1Lab.Equiv.html#1608" class="Generalizable">A</a> <a id="6593" class="Symbol">→</a> <a id="6595" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="6596" class="Symbol">}</a> <a id="6598" class="Symbol">(</a><a id="6599" href="1Lab.Equiv.html#6599" class="Bound">eqv</a> <a id="6603" class="Symbol">:</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="6605" href="1Lab.Equiv.html#2306" class="Record">is-equiv</a> <a id="6614" href="1Lab.Equiv.html#6587" class="Bound">f</a><a id="6615" class="Symbol">)</a> <a id="6617" class="Symbol">→</a> <a data-type="(B₁ → A) → (A → B₁) → Type B.ℓ₁" id="6619" href="1Lab.Equiv.html#5759" class="Function">is-right-inverse</a> <a id="6636" class="Symbol">(</a><a data-type="is-equiv f → B₁ → A" id="6637" href="1Lab.Equiv.html#6469" class="Function">equiv→inverse</a> <a id="6651" href="1Lab.Equiv.html#6599" class="Bound">eqv</a><a id="6654" class="Symbol">)</a> <a id="6656" href="1Lab.Equiv.html#6587" class="Bound">f</a>
<a data-type="(eqv : is-equiv f) → is-right-inverse (equiv→inverse eqv) f" id="6658" href="1Lab.Equiv.html#6568" class="Function">equiv→section</a> <a id="6672" href="1Lab.Equiv.html#6672" class="Bound">eqv</a> <a id="6676" href="1Lab.Equiv.html#6676" class="Bound">y</a> <a id="6678" class="Symbol">=</a> <a id="6680" href="1Lab.Equiv.html#6672" class="Bound">eqv</a> <a id="6684" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="6685" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="6692" href="1Lab.Equiv.html#6676" class="Bound">y</a> <a id="6694" class="Symbol">.</a><a data-type="is-contr A → A" id="6695" href="1Lab.HLevel.html#1401" class="Field">centre</a> <a id="6702" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="6703" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a>

<a id="equiv→retraction"></a><a data-type="(eqv : is-equiv f) → is-left-inverse (equiv→inverse eqv) f" id="6708" href="1Lab.Equiv.html#6708" class="Function">equiv→retraction</a>
  <a id="6727" class="Symbol">:</a> <a id="6729" class="Symbol">{</a><a id="6730" href="1Lab.Equiv.html#6730" class="Bound">f</a> <a id="6732" class="Symbol">:</a> <a id="6734" href="1Lab.Equiv.html#1608" class="Generalizable">A</a> <a id="6736" class="Symbol">→</a> <a id="6738" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="6739" class="Symbol">}</a> <a id="6741" class="Symbol">(</a><a id="6742" href="1Lab.Equiv.html#6742" class="Bound">eqv</a> <a id="6746" class="Symbol">:</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="6748" href="1Lab.Equiv.html#2306" class="Record">is-equiv</a> <a id="6757" href="1Lab.Equiv.html#6730" class="Bound">f</a><a id="6758" class="Symbol">)</a> <a id="6760" class="Symbol">→</a> <a data-type="(B₁ → A) → (A → B₁) → Type A.ℓ₁" id="6762" href="1Lab.Equiv.html#5669" class="Function">is-left-inverse</a> <a id="6778" class="Symbol">(</a><a data-type="is-equiv f → B₁ → A" id="6779" href="1Lab.Equiv.html#6469" class="Function">equiv→inverse</a> <a id="6793" href="1Lab.Equiv.html#6742" class="Bound">eqv</a><a id="6796" class="Symbol">)</a> <a id="6798" href="1Lab.Equiv.html#6730" class="Bound">f</a>
<a data-type="(eqv : is-equiv f) → is-left-inverse (equiv→inverse eqv) f" id="6800" href="1Lab.Equiv.html#6708" class="Function">equiv→retraction</a> <a id="6817" class="Symbol">{</a><a id="6818" class="Argument">f</a> <a id="6820" class="Symbol">=</a> <a id="6822" href="1Lab.Equiv.html#6822" class="Bound">f</a><a id="6823" class="Symbol">}</a> <a id="6825" href="1Lab.Equiv.html#6825" class="Bound">eqv</a> <a id="6829" href="1Lab.Equiv.html#6829" class="Bound">x</a> <a id="6831" href="1Lab.Equiv.html#6831" class="Bound">i</a> <a id="6833" class="Symbol">=</a> <a id="6835" href="1Lab.Equiv.html#6825" class="Bound">eqv</a> <a id="6839" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="6840" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="6847" class="Symbol">(</a><a id="6848" href="1Lab.Equiv.html#6822" class="Bound">f</a> <a id="6850" href="1Lab.Equiv.html#6829" class="Bound">x</a><a id="6851" class="Symbol">)</a> <a id="6853" class="Symbol">.</a><a data-type="(r : is-contr A) (x : A) → r .centre ≡ x" id="6854" href="1Lab.HLevel.html#1416" class="Field">paths</a> <a id="6860" class="Symbol">(</a><a id="6861" href="1Lab.Equiv.html#6829" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="6863" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="x ≡ x" id="6865" href="1Lab.Path.html#3593" class="Function">refl</a><a id="6869" class="Symbol">)</a> <a id="6871" href="1Lab.Equiv.html#6831" class="Bound">i</a> <a id="6873" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="6874" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a>

<a id="is-equiv→is-iso"></a><a data-type="is-equiv f → is-iso f" id="6879" href="1Lab.Equiv.html#6879" class="Function">is-equiv→is-iso</a> <a id="6895" class="Symbol">:</a> <a id="6897" class="Symbol">{</a><a id="6898" href="1Lab.Equiv.html#6898" class="Bound">f</a> <a id="6900" class="Symbol">:</a> <a id="6902" href="1Lab.Equiv.html#1608" class="Generalizable">A</a> <a id="6904" class="Symbol">→</a> <a id="6906" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="6907" class="Symbol">}</a> <a id="6909" class="Symbol">→</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="6911" href="1Lab.Equiv.html#2306" class="Record">is-equiv</a> <a id="6920" href="1Lab.Equiv.html#6898" class="Bound">f</a> <a id="6922" class="Symbol">→</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="6924" href="1Lab.Equiv.html#6046" class="Record">is-iso</a> <a id="6931" href="1Lab.Equiv.html#6898" class="Bound">f</a>
<a data-type="is-iso f → B₁ → A" id="6933" href="1Lab.Equiv.html#6152" class="Field">is-iso.inv</a> <a id="6944" class="Symbol">(</a><a data-type="is-equiv f → is-iso f" id="6945" href="1Lab.Equiv.html#6879" class="Function">is-equiv→is-iso</a> <a id="6961" href="1Lab.Equiv.html#6961" class="Bound">eqv</a><a id="6964" class="Symbol">)</a> <a id="6966" class="Symbol">=</a> <a data-type="is-equiv f → B₁ → A" id="6968" href="1Lab.Equiv.html#6469" class="Function">equiv→inverse</a> <a id="6982" href="1Lab.Equiv.html#6961" class="Bound">eqv</a>
</pre>
<p>We can get an element of <code>x</code> from the proof that <code>f</code> is an equivalence - it’s the point of <code>A</code> mapped to <code>y</code>, which we get from centre of contraction for the fibres of <code>f</code> over <code>y</code>.</p>
<pre class="Agda"><a data-type="(r : is-iso f) → is-right-inverse (r .inv) f" id="7182" href="1Lab.Equiv.html#6168" class="Field">is-iso.rinv</a> <a id="7194" class="Symbol">(</a><a data-type="is-equiv f → is-iso f" id="7195" href="1Lab.Equiv.html#6879" class="Function">is-equiv→is-iso</a> <a id="7211" href="1Lab.Equiv.html#7211" class="Bound">eqv</a><a id="7214" class="Symbol">)</a> <a id="7216" href="1Lab.Equiv.html#7216" class="Bound">y</a> <a id="7218" class="Symbol">=</a>
  <a id="7222" href="1Lab.Equiv.html#7211" class="Bound">eqv</a> <a id="7226" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="7227" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="7234" href="1Lab.Equiv.html#7216" class="Bound">y</a> <a id="7236" class="Symbol">.</a><a data-type="is-contr A → A" id="7237" href="1Lab.HLevel.html#1401" class="Field">centre</a> <a id="7244" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="7245" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a>
</pre>
<p>Similarly, that one fibre gives us a proof that the function above is a right inverse to <code>f</code>.</p>
<pre class="Agda"><a data-type="(r : is-iso f) → is-left-inverse (r .inv) f" id="7357" href="1Lab.Equiv.html#6202" class="Field">is-iso.linv</a> <a id="7369" class="Symbol">(</a><a data-type="is-equiv f → is-iso f" id="7370" href="1Lab.Equiv.html#6879" class="Function">is-equiv→is-iso</a> <a id="7386" class="Symbol">{</a><a id="7387" class="Argument">f</a> <a id="7389" class="Symbol">=</a> <a id="7391" href="1Lab.Equiv.html#7391" class="Bound">f</a><a id="7392" class="Symbol">}</a> <a id="7394" href="1Lab.Equiv.html#7394" class="Bound">eqv</a><a id="7397" class="Symbol">)</a> <a id="7399" href="1Lab.Equiv.html#7399" class="Bound">x</a> <a id="7401" href="1Lab.Equiv.html#7401" class="Bound">i</a> <a id="7403" class="Symbol">=</a>
  <a id="7407" href="1Lab.Equiv.html#7394" class="Bound">eqv</a> <a id="7411" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="7412" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="7419" class="Symbol">(</a><a id="7420" href="1Lab.Equiv.html#7391" class="Bound">f</a> <a id="7422" href="1Lab.Equiv.html#7399" class="Bound">x</a><a id="7423" class="Symbol">)</a> <a id="7425" class="Symbol">.</a><a data-type="(r : is-contr A) (x : A) → r .centre ≡ x" id="7426" href="1Lab.HLevel.html#1416" class="Field">paths</a> <a id="7432" class="Symbol">(</a><a id="7433" href="1Lab.Equiv.html#7399" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="7435" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="x ≡ x" id="7437" href="1Lab.Path.html#3593" class="Function">refl</a><a id="7441" class="Symbol">)</a> <a id="7443" href="1Lab.Equiv.html#7401" class="Bound">i</a> <a id="7445" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="7446" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a>
</pre>
<p>The proof that the function is a <em>left</em> inverse comes from the fibres of <code>f</code> over <code>y</code> being contractible. Since we have a fibre - namely, <code>f</code> maps <code>x</code> to <code>f x</code> by <span class="Agda"><a data-type="x ≡ x" href="1Lab.Path.html#3593" class="Function">refl</a></span> - we can get any other we want!</p>
<h1 id="equivalences-from-isomorphisms"><a href="#equivalences-from-isomorphisms" class="header-link">Equivalences from isomorphisms<span class="header-link-emoji">🔗</span></a></h1>
<p>Any isomorphism can be upgraded into an equivalence, in a way that preserves the function <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>,</span> its inverse <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>,</span> <em>and</em> the proof <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> is a right inverse to <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>.</span> We can not preserve <em>everything</em>, though, as is usual when making something “more coherent”. Furthermore, if everything was preserved, <span class="Agda"><a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" href="1Lab.Equiv.html#6046" class="Record">is-iso</a></span> would be a proposition, and this is <a href="1Lab.Counterexamples.IsIso.html">provably not the case</a>.</p>
<p>The argument presented here is done directly in cubical style, but a less direct proof is also available, by showing that every isomorphism is a <a href="1Lab.Equiv.HalfAdjoint.html">half-adjoint equivalence</a>, and that half-adjoint equivalences have contractible fibres.</p>
<pre class="Agda"><a id="8438" class="Keyword">module</a> <a id="8445" href="1Lab.Equiv.html#8445" class="Module">_</a> <a id="8447" class="Symbol">{</a><a id="8448" href="1Lab.Equiv.html#8448" class="Bound">f</a> <a id="8450" class="Symbol">:</a> <a id="8452" href="1Lab.Equiv.html#1608" class="Generalizable">A</a> <a id="8454" class="Symbol">→</a> <a id="8456" href="1Lab.Equiv.html#1610" class="Generalizable">B</a><a id="8457" class="Symbol">}</a> <a id="8459" class="Symbol">(</a><a id="8460" href="1Lab.Equiv.html#8460" class="Bound">i</a> <a id="8462" class="Symbol">:</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="8464" href="1Lab.Equiv.html#6046" class="Record">is-iso</a> <a id="8471" href="1Lab.Equiv.html#8448" class="Bound">f</a><a id="8472" class="Symbol">)</a> <a id="8474" class="Keyword">where</a>

  <a id="8483" class="Keyword">open</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="8488" href="1Lab.Equiv.html#6046" class="Module">is-iso</a> <a id="8495" href="1Lab.Equiv.html#8460" class="Bound">i</a> <a id="8497" class="Keyword">renaming</a> <a id="8506" class="Symbol">(</a> <a data-type="is-iso f → B₁ → A" id="8508" href="1Lab.Equiv.html#6152" class="Field">inv</a> <a id="8512" class="Symbol">to</a> <a id="8515" class="Field">g</a>
                         <a id="8542" class="Symbol">;</a> <a data-type="(r : is-iso f) → is-right-inverse (r .inv) f" id="8544" href="1Lab.Equiv.html#6168" class="Field">rinv</a> <a id="8549" class="Symbol">to</a> <a id="8552" class="Field">s</a>
                         <a id="8579" class="Symbol">;</a> <a data-type="(r : is-iso f) → is-left-inverse (r .inv) f" id="8581" href="1Lab.Equiv.html#6202" class="Field">linv</a> <a id="8586" class="Symbol">to</a> <a id="8589" class="Field">t</a>
                         <a id="8616" class="Symbol">)</a>
</pre>
<p>Suppose, then, that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f : A \to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> and <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>:</mo><mi>B</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">g : B \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>,</span> and we’re given witnesses <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>:</mo><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mtext> </mtext><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">s : f (g\ x) = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>:</mo><mi>g</mi><mo stretchy="false">(</mo><mi>f</mi><mtext> </mtext><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">t : g (f\ x) = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> (named for <strong>s</strong>ection and re<strong>t</strong>raction) that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> are inverses. We want to show that, for any <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>,</span> the <span class="Agda"><a data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" href="1Lab.Equiv.html#1893" class="Function">fibre</a></span> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> is contractible. It suffices to show that the fibre is propositional, and that it is inhabited.</p>
<p>We begin with showing that the fibre over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> is propositional, since that’s the harder of the two arguments. Suppose that we have <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>,</span> <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,</span> <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,</span> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">p_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> as below; Note that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>p</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_0, p_0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>p</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_1, p_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> are fibres of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> over <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>.</span> What we need to show is that we have some <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>:</mo><msub><mi>x</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi : x_0 ≡ x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6138em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_0 ≡ p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> <em><code class="sourceCode agda" data-ident="PathP">over</code></em> <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>.</span></p>
<pre class="Agda">  <a id="9351" class="Keyword">private</a> <a id="9359" class="Keyword">module</a> <a id="9366" href="1Lab.Equiv.html#9366" class="Module">_</a> <a id="9368" class="Symbol">(</a><a id="9369" href="1Lab.Equiv.html#9369" class="Bound">y</a> <a id="9371" class="Symbol">:</a> <a id="9373" href="1Lab.Equiv.html#8456" class="Bound">B</a><a id="9374" class="Symbol">)</a> <a id="9376" class="Symbol">(</a><a id="9377" href="1Lab.Equiv.html#9377" class="Bound">x0</a> <a id="9380" href="1Lab.Equiv.html#9380" class="Bound">x1</a> <a id="9383" class="Symbol">:</a> <a id="9385" href="1Lab.Equiv.html#8452" class="Bound">A</a><a id="9386" class="Symbol">)</a> <a id="9388" class="Symbol">(</a><a id="9389" href="1Lab.Equiv.html#9389" class="Bound">p0</a> <a id="9392" class="Symbol">:</a> <a id="9394" href="1Lab.Equiv.html#8448" class="Bound">f</a> <a id="9396" href="1Lab.Equiv.html#9377" class="Bound">x0</a> <a data-type="A → A → Type ℓ" id="9399" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="9401" href="1Lab.Equiv.html#9369" class="Bound">y</a><a id="9402" class="Symbol">)</a> <a id="9404" class="Symbol">(</a><a id="9405" href="1Lab.Equiv.html#9405" class="Bound">p1</a> <a id="9408" class="Symbol">:</a> <a id="9410" href="1Lab.Equiv.html#8448" class="Bound">f</a> <a id="9412" href="1Lab.Equiv.html#9380" class="Bound">x1</a> <a data-type="A → A → Type ℓ" id="9415" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="9417" href="1Lab.Equiv.html#9369" class="Bound">y</a><a id="9418" class="Symbol">)</a> <a id="9420" class="Keyword">where</a>
</pre>
<p>As an intermediate step in proving that <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_0 ≡ p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,</span> we <em>must</em> show that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_0 ≡ x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6138em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> - without this, we can’t even <em>state</em> that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">p_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> are identified, since they live in different types! To this end, we will build <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>:</mo><msub><mi>p</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi : p_0 ≡ p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,</span> parts of which will be required to assemble the overall proof that <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_0 ≡ p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span></p>
<p>We’ll detail the construction of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\pi_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>;</span> for <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,</span> the same method is used. We want to construct a <em>line</em>, which we can do by exhibiting that line as the missing face in a <em>square</em>. We have equations <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mtext> </mtext><mi>y</mi><mo>≡</mo><mi>g</mi><mtext> </mtext><mi>y</mi></mrow><annotation encoding="application/x-tex">g\ y ≡ g\ y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> (<span class="Agda"><a data-type="x ≡ x" href="1Lab.Path.html#3593" class="Function">refl</a></span>), <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>f</mi><mtext> </mtext><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>≡</mo><mi>g</mi><mtext> </mtext><mi>y</mi></mrow><annotation encoding="application/x-tex">g\ (f\ x_0) ≡ g\ y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> (the action of <code>g</code> on <code>p0</code>), and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>f</mi><mtext> </mtext><msub><mi>x</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>=</mo><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">g\ (f\ x_0) = x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> by the assumption that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> is a right inverse to <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>.</span> Diagramatically, these fit together into a square:</p>
<div class="diagram-container">
<img src="193afca482e4eaf959452d27288a9c224bb0eaf2.svg" title="commutative diagram" class="diagram quiver" />
</div>
<p>The missing line in this square is <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\pi_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span> Since the <em>inside</em> (the <span class="Agda"><a data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ]) →
outS u0 ≡ hcomp u (outS u0)" href="1Lab.Path.html#35617" class="Function">filler</a></span>) will be useful to us later, we also give it a name: <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span>.</span></p>
<pre class="Agda">    <a id="10774" href="1Lab.Equiv.html#10774" class="Function">π₀</a> <a id="10777" class="Symbol">:</a> <a id="10779" href="1Lab.Equiv.html#8515" class="Field">g</a> <a id="10781" href="1Lab.Equiv.html#9369" class="Bound">y</a> <a data-type="A → A → Type ℓ" id="10783" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10785" href="1Lab.Equiv.html#9377" class="Bound">x0</a>
    <a id="10792" href="1Lab.Equiv.html#10774" class="Function">π₀</a> <a id="10795" href="1Lab.Equiv.html#10795" class="Bound">i</a> <a id="10797" class="Symbol">=</a> <a id="10799" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="10805" class="Symbol">(λ</a> <a id="10808" href="1Lab.Equiv.html#10808" class="Bound">k</a> <a id="10810" class="Symbol">→</a> <a id="10812" class="Symbol">λ</a> <a id="10814" class="Symbol">{</a> <a id="10816" class="Symbol">(</a><a id="10817" href="1Lab.Equiv.html#10795" class="Bound">i</a> <a id="10819" class="Symbol">=</a> <a id="10821" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="10823" class="Symbol">)</a> <a id="10825" class="Symbol">→</a> <a id="10827" href="1Lab.Equiv.html#8515" class="Field">g</a> <a id="10829" href="1Lab.Equiv.html#9369" class="Bound">y</a>
                          <a id="10857" class="Symbol">;</a> <a id="10859" class="Symbol">(</a><a id="10860" href="1Lab.Equiv.html#10795" class="Bound">i</a> <a id="10862" class="Symbol">=</a> <a id="10864" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="10866" class="Symbol">)</a> <a id="10868" class="Symbol">→</a> <a id="10870" href="1Lab.Equiv.html#8589" class="Field">t</a> <a id="10872" href="1Lab.Equiv.html#9377" class="Bound">x0</a> <a id="10875" href="1Lab.Equiv.html#10808" class="Bound">k</a>
                          <a id="10903" class="Symbol">})</a>
                    <a id="10926" class="Symbol">(</a><a id="10927" href="1Lab.Equiv.html#8515" class="Field">g</a> <a id="10929" class="Symbol">(</a><a id="10930" href="1Lab.Equiv.html#9389" class="Bound">p0</a> <a id="10933" class="Symbol">(</a><a id="10934" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="10936" href="1Lab.Equiv.html#10795" class="Bound">i</a><a id="10937" class="Symbol">)))</a>

    <a id="10946" href="1Lab.Equiv.html#10946" class="Function">θ₀</a> <a id="10949" class="Symbol">:</a> <a data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" id="10951" href="1Lab.Path.html#9481" class="Function">Square</a> <a id="10958" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="10959" href="1Lab.Path.html#20828" class="Function">ap</a> <a id="10962" href="1Lab.Equiv.html#8515" class="Field">g</a> <a id="10964" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="10965" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="10969" href="1Lab.Equiv.html#9389" class="Bound">p0</a><a id="10971" class="Symbol">))</a> <a data-type="x ≡ x" id="10974" href="1Lab.Path.html#3593" class="Function">refl</a> <a id="10979" class="Symbol">(</a><a id="10980" href="1Lab.Equiv.html#8589" class="Field">t</a> <a id="10982" href="1Lab.Equiv.html#9377" class="Bound">x0</a><a id="10984" class="Symbol">)</a> <a id="10986" href="1Lab.Equiv.html#10774" class="Function">π₀</a>
    <a id="10993" href="1Lab.Equiv.html#10946" class="Function">θ₀</a> <a id="10996" href="1Lab.Equiv.html#10996" class="Bound">i</a> <a id="10998" href="1Lab.Equiv.html#10998" class="Bound">j</a> <a id="11000" class="Symbol">=</a> <a data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ]) →
outS u0 ≡ hcomp u (outS u0)" id="11002" href="1Lab.Path.html#35617" class="Function">hfill</a> <a id="11008" class="Symbol">(λ</a> <a id="11011" href="1Lab.Equiv.html#11011" class="Bound">k</a> <a id="11013" class="Symbol">→</a> <a id="11015" class="Symbol">λ</a> <a id="11017" class="Symbol">{</a> <a id="11019" class="Symbol">(</a><a id="11020" href="1Lab.Equiv.html#10996" class="Bound">i</a> <a id="11022" class="Symbol">=</a> <a id="11024" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="11026" class="Symbol">)</a> <a id="11028" class="Symbol">→</a> <a id="11030" href="1Lab.Equiv.html#8515" class="Field">g</a> <a id="11032" href="1Lab.Equiv.html#9369" class="Bound">y</a>
                            <a id="11062" class="Symbol">;</a> <a id="11064" class="Symbol">(</a><a id="11065" href="1Lab.Equiv.html#10996" class="Bound">i</a> <a id="11067" class="Symbol">=</a> <a id="11069" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="11071" class="Symbol">)</a> <a id="11073" class="Symbol">→</a> <a id="11075" href="1Lab.Equiv.html#8589" class="Field">t</a> <a id="11077" href="1Lab.Equiv.html#9377" class="Bound">x0</a> <a id="11080" href="1Lab.Equiv.html#11011" class="Bound">k</a>
                            <a id="11110" class="Symbol">})</a>
                   <a id="11132" class="Symbol">(</a><a id="11133" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="11137" class="Symbol">(</a><a id="11138" href="1Lab.Equiv.html#8515" class="Field">g</a> <a id="11140" class="Symbol">(</a><a id="11141" href="1Lab.Equiv.html#9389" class="Bound">p0</a> <a id="11144" class="Symbol">(</a><a id="11145" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="11147" href="1Lab.Equiv.html#10996" class="Bound">i</a><a id="11148" class="Symbol">))))</a> <a id="11153" href="1Lab.Equiv.html#10998" class="Bound">j</a>
</pre>
<p>Since the construction of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is analogous, I’ll simply present the square. We correspondingly name the missing face <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and the filler <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\theta_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span></p>
<div class="mathpar">
<div class="diagram-container">
<img src="7b944591e80866a5b04179d5ec65b925a6e46ba7.svg" title="commutative diagram" class="diagram quiver" />
</div>
<pre class="Agda">    <a id="11781" href="1Lab.Equiv.html#11781" class="Function">π₁</a> <a id="11784" class="Symbol">:</a> <a id="11786" href="1Lab.Equiv.html#8515" class="Field">g</a> <a id="11788" href="1Lab.Equiv.html#9369" class="Bound">y</a> <a data-type="A → A → Type ℓ" id="11790" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="11792" href="1Lab.Equiv.html#9380" class="Bound">x1</a>
    <a id="11799" href="1Lab.Equiv.html#11781" class="Function">π₁</a> <a id="11802" href="1Lab.Equiv.html#11802" class="Bound">i</a> <a id="11804" class="Symbol">=</a> <a id="11806" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="11812" class="Symbol">(λ</a> <a id="11815" href="1Lab.Equiv.html#11815" class="Bound">k</a> <a id="11817" class="Symbol">→</a> <a id="11819" class="Symbol">λ</a> <a id="11821" class="Symbol">{</a> <a id="11823" class="Symbol">(</a><a id="11824" href="1Lab.Equiv.html#11802" class="Bound">i</a> <a id="11826" class="Symbol">=</a> <a id="11828" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="11830" class="Symbol">)</a> <a id="11832" class="Symbol">→</a> <a id="11834" href="1Lab.Equiv.html#8515" class="Field">g</a> <a id="11836" href="1Lab.Equiv.html#9369" class="Bound">y</a>
                          <a id="11864" class="Symbol">;</a> <a id="11866" class="Symbol">(</a><a id="11867" href="1Lab.Equiv.html#11802" class="Bound">i</a> <a id="11869" class="Symbol">=</a> <a id="11871" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="11873" class="Symbol">)</a> <a id="11875" class="Symbol">→</a> <a id="11877" href="1Lab.Equiv.html#8589" class="Field">t</a> <a id="11879" href="1Lab.Equiv.html#9380" class="Bound">x1</a> <a id="11882" href="1Lab.Equiv.html#11815" class="Bound">k</a>
                          <a id="11910" class="Symbol">})</a>
                    <a id="11933" class="Symbol">(</a><a id="11934" href="1Lab.Equiv.html#8515" class="Field">g</a> <a id="11936" class="Symbol">(</a><a id="11937" href="1Lab.Equiv.html#9405" class="Bound">p1</a> <a id="11940" class="Symbol">(</a><a id="11941" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="11943" href="1Lab.Equiv.html#11802" class="Bound">i</a><a id="11944" class="Symbol">)))</a>

    <a id="11953" href="1Lab.Equiv.html#11953" class="Function">θ₁</a> <a id="11956" class="Symbol">:</a> <a data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" id="11958" href="1Lab.Path.html#9481" class="Function">Square</a> <a id="11965" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="11966" href="1Lab.Path.html#20828" class="Function">ap</a> <a id="11969" href="1Lab.Equiv.html#8515" class="Field">g</a> <a id="11971" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="11972" href="1Lab.Path.html#10630" class="Function">sym</a> <a id="11976" href="1Lab.Equiv.html#9405" class="Bound">p1</a><a id="11978" class="Symbol">))</a> <a data-type="x ≡ x" id="11981" href="1Lab.Path.html#3593" class="Function">refl</a> <a id="11986" class="Symbol">(</a><a id="11987" href="1Lab.Equiv.html#8589" class="Field">t</a> <a id="11989" href="1Lab.Equiv.html#9380" class="Bound">x1</a><a id="11991" class="Symbol">)</a> <a id="11993" href="1Lab.Equiv.html#11781" class="Function">π₁</a>
    <a id="12000" href="1Lab.Equiv.html#11953" class="Function">θ₁</a> <a id="12003" href="1Lab.Equiv.html#12003" class="Bound">i</a> <a id="12005" href="1Lab.Equiv.html#12005" class="Bound">j</a> <a id="12007" class="Symbol">=</a> <a data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ]) →
outS u0 ≡ hcomp u (outS u0)" id="12009" href="1Lab.Path.html#35617" class="Function">hfill</a> <a id="12015" class="Symbol">(λ</a> <a id="12018" href="1Lab.Equiv.html#12018" class="Bound">k</a> <a id="12020" class="Symbol">→</a> <a id="12022" class="Symbol">λ</a> <a id="12024" class="Symbol">{</a> <a id="12026" class="Symbol">(</a><a id="12027" href="1Lab.Equiv.html#12003" class="Bound">i</a> <a id="12029" class="Symbol">=</a> <a id="12031" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="12033" class="Symbol">)</a> <a id="12035" class="Symbol">→</a> <a id="12037" href="1Lab.Equiv.html#8515" class="Field">g</a> <a id="12039" href="1Lab.Equiv.html#9369" class="Bound">y</a>
                            <a id="12069" class="Symbol">;</a> <a id="12071" class="Symbol">(</a><a id="12072" href="1Lab.Equiv.html#12003" class="Bound">i</a> <a id="12074" class="Symbol">=</a> <a id="12076" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="12078" class="Symbol">)</a> <a id="12080" class="Symbol">→</a> <a id="12082" href="1Lab.Equiv.html#8589" class="Field">t</a> <a id="12084" href="1Lab.Equiv.html#9380" class="Bound">x1</a> <a id="12087" href="1Lab.Equiv.html#12018" class="Bound">k</a>
                            <a id="12117" class="Symbol">})</a>
                      <a id="12142" class="Symbol">(</a><a id="12143" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="12147" class="Symbol">(</a><a id="12148" href="1Lab.Equiv.html#8515" class="Field">g</a> <a id="12150" class="Symbol">(</a><a id="12151" href="1Lab.Equiv.html#9405" class="Bound">p1</a> <a id="12154" class="Symbol">(</a><a id="12155" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="12157" href="1Lab.Equiv.html#12003" class="Bound">i</a><a id="12158" class="Symbol">))))</a> <a id="12163" href="1Lab.Equiv.html#12005" class="Bound">j</a>
</pre>
</div>
<p>Joining these paths by their common <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mtext> </mtext><mi>y</mi></mrow><annotation encoding="application/x-tex">g\ y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> face, we obtain <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>:</mo><msub><mi>x</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi : x_0 ≡ x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6138em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span> This square <em>also</em> has a filler, connecting <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\pi_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> over the line <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mtext> </mtext><mi>y</mi><mo>≡</mo><mi>π</mi><mtext> </mtext><mi>i</mi></mrow><annotation encoding="application/x-tex">g\ y ≡ \pi\ i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace"> </span><span class="mord mathnormal">i</span></span></span></span>.</span></p>
<div class="mathpar">
<div class="diagram-container">
<img src="696d9aa257c82c2ac2da8bebd91fc997e3206334.svg" title="commutative diagram" class="diagram quiver" />
</div>
<pre class="Agda">    <a id="12789" href="1Lab.Equiv.html#12789" class="Function">π</a> <a id="12791" class="Symbol">:</a> <a id="12793" href="1Lab.Equiv.html#9377" class="Bound">x0</a> <a data-type="A → A → Type ℓ" id="12796" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="12798" href="1Lab.Equiv.html#9380" class="Bound">x1</a>
    <a id="12805" href="1Lab.Equiv.html#12789" class="Function">π</a> <a id="12807" href="1Lab.Equiv.html#12807" class="Bound">i</a> <a id="12809" class="Symbol">=</a> <a id="12811" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="12817" class="Symbol">(λ</a> <a id="12820" href="1Lab.Equiv.html#12820" class="Bound">k</a> <a id="12822" class="Symbol">→</a> <a id="12824" class="Symbol">λ</a> <a id="12826" class="Symbol">{</a> <a id="12828" class="Symbol">(</a><a id="12829" href="1Lab.Equiv.html#12807" class="Bound">i</a> <a id="12831" class="Symbol">=</a> <a id="12833" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="12835" class="Symbol">)</a> <a id="12837" class="Symbol">→</a> <a id="12839" href="1Lab.Equiv.html#10774" class="Function">π₀</a> <a id="12842" href="1Lab.Equiv.html#12820" class="Bound">k</a>
                         <a id="12869" class="Symbol">;</a> <a id="12871" class="Symbol">(</a><a id="12872" href="1Lab.Equiv.html#12807" class="Bound">i</a> <a id="12874" class="Symbol">=</a> <a id="12876" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="12878" class="Symbol">)</a> <a id="12880" class="Symbol">→</a> <a id="12882" href="1Lab.Equiv.html#11781" class="Function">π₁</a> <a id="12885" href="1Lab.Equiv.html#12820" class="Bound">k</a>
                         <a id="12912" class="Symbol">})</a>
                <a id="12931" class="Symbol">(</a><a id="12932" href="1Lab.Equiv.html#8515" class="Field">g</a> <a id="12934" href="1Lab.Equiv.html#9369" class="Bound">y</a><a id="12935" class="Symbol">)</a>
</pre>
</div>
<p>This concludes the construction of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>,</span> and thus, the 2D part of the proof. Now, we want to show that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_0 ≡ p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> over a path induced by <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>.</span> This is a <em>square</em> with a specific boundary, which can be built by constructing an appropriate <em>open cube</em>, where the missing face is that square. As an intermediate step, we define <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> to be the filler for the square above.</p>
<pre class="Agda">    <a id="13338" href="1Lab.Equiv.html#13338" class="Function">θ</a> <a id="13340" class="Symbol">:</a> <a data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" id="13342" href="1Lab.Path.html#9481" class="Function">Square</a> <a data-type="x ≡ x" id="13349" href="1Lab.Path.html#3593" class="Function">refl</a> <a id="13354" href="1Lab.Equiv.html#10774" class="Function">π₀</a> <a id="13357" href="1Lab.Equiv.html#11781" class="Function">π₁</a> <a id="13360" href="1Lab.Equiv.html#12789" class="Function">π</a>
    <a id="13366" href="1Lab.Equiv.html#13338" class="Function">θ</a> <a id="13368" href="1Lab.Equiv.html#13368" class="Bound">i</a> <a id="13370" href="1Lab.Equiv.html#13370" class="Bound">j</a> <a id="13372" class="Symbol">=</a> <a data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ]) →
outS u0 ≡ hcomp u (outS u0)" id="13374" href="1Lab.Path.html#35617" class="Function">hfill</a> <a id="13380" class="Symbol">(λ</a> <a id="13383" href="1Lab.Equiv.html#13383" class="Bound">k</a> <a id="13385" class="Symbol">→</a> <a id="13387" class="Symbol">λ</a> <a id="13389" class="Symbol">{</a> <a id="13391" class="Symbol">(</a><a id="13392" href="1Lab.Equiv.html#13368" class="Bound">i</a> <a id="13394" class="Symbol">=</a> <a id="13396" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="13398" class="Symbol">)</a> <a id="13400" class="Symbol">→</a> <a id="13402" href="1Lab.Equiv.html#11781" class="Function">π₁</a> <a id="13405" href="1Lab.Equiv.html#13383" class="Bound">k</a>
                           <a id="13434" class="Symbol">;</a> <a id="13436" class="Symbol">(</a><a id="13437" href="1Lab.Equiv.html#13368" class="Bound">i</a> <a id="13439" class="Symbol">=</a> <a id="13441" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="13443" class="Symbol">)</a> <a id="13445" class="Symbol">→</a> <a id="13447" href="1Lab.Equiv.html#10774" class="Function">π₀</a> <a id="13450" href="1Lab.Equiv.html#13383" class="Bound">k</a>
                           <a id="13479" class="Symbol">})</a>
                      <a id="13504" class="Symbol">(</a><a id="13505" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="13509" class="Symbol">(</a><a id="13510" href="1Lab.Equiv.html#8515" class="Field">g</a> <a id="13512" href="1Lab.Equiv.html#9369" class="Bound">y</a><a id="13513" class="Symbol">))</a> <a id="13516" href="1Lab.Equiv.html#13370" class="Bound">j</a>
</pre>
<p>Observe that we can coherently alter <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> to get <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ι</mi></mrow><annotation encoding="application/x-tex">\iota</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ι</span></span></span></span> below, which expresses that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi></mrow><mtext> </mtext><mi>g</mi><mtext> </mtext><msub><mi>p</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\mathrm{ap}\ g\ p_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">ap</span></span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi></mrow><mtext> </mtext><mi>g</mi><mtext> </mtext><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\mathrm{ap}\ g\ p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">ap</span></span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> are identified.</p>
<pre class="Agda">    <a id="13689" href="1Lab.Equiv.html#13689" class="Function">ι</a> <a id="13691" class="Symbol">:</a> <a data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" id="13693" href="1Lab.Path.html#9481" class="Function">Square</a> <a id="13700" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="13701" href="1Lab.Path.html#20828" class="Function">ap</a> <a id="13704" class="Symbol">(</a><a id="13705" href="1Lab.Equiv.html#8515" class="Field">g</a> <a data-type="((y : B₁ x) → C x y) → (f : (x : A) → B₁ x) (x : A) → C x (f x)" id="13707" href="1Lab.Type.html#2227" class="Function Operator">∘</a> <a id="13709" href="1Lab.Equiv.html#8448" class="Bound">f</a><a id="13710" class="Symbol">)</a> <a id="13712" href="1Lab.Equiv.html#12789" class="Function">π</a><a id="13713" class="Symbol">)</a> <a id="13715" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="13716" href="1Lab.Path.html#20828" class="Function">ap</a> <a id="13719" href="1Lab.Equiv.html#8515" class="Field">g</a> <a id="13721" href="1Lab.Equiv.html#9389" class="Bound">p0</a><a id="13723" class="Symbol">)</a> <a id="13725" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="13726" href="1Lab.Path.html#20828" class="Function">ap</a> <a id="13729" href="1Lab.Equiv.html#8515" class="Field">g</a> <a id="13731" href="1Lab.Equiv.html#9405" class="Bound">p1</a><a id="13733" class="Symbol">)</a> <a data-type="x ≡ x" id="13735" href="1Lab.Path.html#3593" class="Function">refl</a>
    <a id="13744" href="1Lab.Equiv.html#13689" class="Function">ι</a> <a id="13746" href="1Lab.Equiv.html#13746" class="Bound">i</a> <a id="13748" href="1Lab.Equiv.html#13748" class="Bound">j</a> <a id="13750" class="Symbol">=</a> <a id="13752" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="13758" class="Symbol">(λ</a> <a id="13761" href="1Lab.Equiv.html#13761" class="Bound">k</a> <a id="13763" class="Symbol">→</a> <a id="13765" class="Symbol">λ</a> <a id="13767" class="Symbol">{</a> <a id="13769" class="Symbol">(</a><a id="13770" href="1Lab.Equiv.html#13746" class="Bound">i</a> <a id="13772" class="Symbol">=</a> <a id="13774" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="13776" class="Symbol">)</a> <a id="13778" class="Symbol">→</a> <a id="13780" href="1Lab.Equiv.html#10946" class="Function">θ₀</a> <a id="13783" class="Symbol">(</a><a id="13784" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="13786" href="1Lab.Equiv.html#13748" class="Bound">j</a><a id="13787" class="Symbol">)</a> <a id="13789" class="Symbol">(</a><a id="13790" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="13792" href="1Lab.Equiv.html#13761" class="Bound">k</a><a id="13793" class="Symbol">)</a>
                           <a id="13822" class="Symbol">;</a> <a id="13824" class="Symbol">(</a><a id="13825" href="1Lab.Equiv.html#13746" class="Bound">i</a> <a id="13827" class="Symbol">=</a> <a id="13829" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="13831" class="Symbol">)</a> <a id="13833" class="Symbol">→</a> <a id="13835" href="1Lab.Equiv.html#11953" class="Function">θ₁</a> <a id="13838" class="Symbol">(</a><a id="13839" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="13841" href="1Lab.Equiv.html#13748" class="Bound">j</a><a id="13842" class="Symbol">)</a> <a id="13844" class="Symbol">(</a><a id="13845" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="13847" href="1Lab.Equiv.html#13761" class="Bound">k</a><a id="13848" class="Symbol">)</a>
                           <a id="13877" class="Symbol">;</a> <a id="13879" class="Symbol">(</a><a id="13880" href="1Lab.Equiv.html#13748" class="Bound">j</a> <a id="13882" class="Symbol">=</a> <a id="13884" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="13886" class="Symbol">)</a> <a id="13888" class="Symbol">→</a> <a id="13890" href="1Lab.Equiv.html#8589" class="Field">t</a> <a id="13892" class="Symbol">(</a><a id="13893" href="1Lab.Equiv.html#12789" class="Function">π</a> <a id="13895" href="1Lab.Equiv.html#13746" class="Bound">i</a><a id="13896" class="Symbol">)</a> <a id="13898" class="Symbol">(</a><a id="13899" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="13901" href="1Lab.Equiv.html#13761" class="Bound">k</a><a id="13902" class="Symbol">)</a>
                           <a id="13931" class="Symbol">;</a> <a id="13933" class="Symbol">(</a><a id="13934" href="1Lab.Equiv.html#13748" class="Bound">j</a> <a id="13936" class="Symbol">=</a> <a id="13938" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="13940" class="Symbol">)</a> <a id="13942" class="Symbol">→</a> <a id="13944" href="1Lab.Equiv.html#8515" class="Field">g</a> <a id="13946" href="1Lab.Equiv.html#9369" class="Bound">y</a>
                           <a id="13975" class="Symbol">})</a>
                  <a id="13996" class="Symbol">(</a><a id="13997" href="1Lab.Equiv.html#13338" class="Function">θ</a> <a id="13999" href="1Lab.Equiv.html#13746" class="Bound">i</a> <a id="14001" class="Symbol">(</a><a id="14002" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="14004" href="1Lab.Equiv.html#13748" class="Bound">j</a><a id="14005" class="Symbol">))</a>
</pre>
<p>This composition can be visualised as the <em>red</em> (front) face in the diagram below. The back face is <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mtext> </mtext><mi>i</mi><mtext> </mtext><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><mtext> </mtext><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\theta\ i\ (\neg\ j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace"> </span><span class="mord mathnormal">i</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord">¬</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>,</span> i.e. <code>(θ i (~ j))</code> in the code. Similarly, the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">j = \mathrm{i1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i1</span></span></span></span></span> (bottom) face is <code>g y</code>, the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">j = \mathrm{i0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i0</span></span></span></span></span> (top) face is <code>t (π i) (~ k)</code>, and similarly for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">i = \mathrm{i0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i0</span></span></span></span></span> (left) and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">i = \mathrm{i1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i1</span></span></span></span></span> (right).</p>
<div class="diagram-container">
<img src="3da8b4e48d862d7f780b6c04b6e88e057155ceea.svg" title="commutative diagram" class="diagram quiver tall-2" />
</div>
<p>The fact that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> only appears as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mi>j</mi></mrow><annotation encoding="application/x-tex">\neg j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord">¬</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> can be understood as the diagram above being <em>upside-down</em>. Indeed, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\pi_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> in the boundary of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> (the inner, blue face) are inverted when their types are considered. We’re in the home stretch: Using our assumption <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>:</mo><mi>f</mi><mo stretchy="false">(</mo><mi>g</mi><mtext> </mtext><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">s : f (g\ x) = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>,</span> we can cancel all of the <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∘</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">f \circ g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>s</span> in the diagram above to get what we wanted: <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mn>0</mn></msub><mo>≡</mo><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_0 ≡ p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6582em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span></p>
<pre class="Agda">    <a id="16867" href="1Lab.Equiv.html#16867" class="Function">sq1</a> <a id="16871" class="Symbol">:</a> <a data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" id="16873" href="1Lab.Path.html#9481" class="Function">Square</a> <a id="16880" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="16881" href="1Lab.Path.html#20828" class="Function">ap</a> <a id="16884" href="1Lab.Equiv.html#8448" class="Bound">f</a> <a id="16886" href="1Lab.Equiv.html#12789" class="Function">π</a><a id="16887" class="Symbol">)</a> <a id="16889" href="1Lab.Equiv.html#9389" class="Bound">p0</a> <a id="16892" href="1Lab.Equiv.html#9405" class="Bound">p1</a> <a data-type="x ≡ x" id="16895" href="1Lab.Path.html#3593" class="Function">refl</a>
    <a id="16904" href="1Lab.Equiv.html#16867" class="Function">sq1</a> <a id="16908" href="1Lab.Equiv.html#16908" class="Bound">i</a> <a id="16910" href="1Lab.Equiv.html#16910" class="Bound">j</a> <a id="16912" class="Symbol">=</a> <a id="16914" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="16920" class="Symbol">(λ</a> <a id="16923" href="1Lab.Equiv.html#16923" class="Bound">k</a> <a id="16925" class="Symbol">→</a> <a id="16927" class="Symbol">λ</a> <a id="16929" class="Symbol">{</a> <a id="16931" class="Symbol">(</a><a id="16932" href="1Lab.Equiv.html#16908" class="Bound">i</a> <a id="16934" class="Symbol">=</a> <a id="16936" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="16938" class="Symbol">)</a> <a id="16940" class="Symbol">→</a> <a id="16942" href="1Lab.Equiv.html#8552" class="Field">s</a> <a id="16944" class="Symbol">(</a><a id="16945" href="1Lab.Equiv.html#9389" class="Bound">p0</a> <a id="16948" href="1Lab.Equiv.html#16910" class="Bound">j</a><a id="16949" class="Symbol">)</a> <a id="16951" href="1Lab.Equiv.html#16923" class="Bound">k</a>
                             <a id="16982" class="Symbol">;</a> <a id="16984" class="Symbol">(</a><a id="16985" href="1Lab.Equiv.html#16908" class="Bound">i</a> <a id="16987" class="Symbol">=</a> <a id="16989" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="16991" class="Symbol">)</a> <a id="16993" class="Symbol">→</a> <a id="16995" href="1Lab.Equiv.html#8552" class="Field">s</a> <a id="16997" class="Symbol">(</a><a id="16998" href="1Lab.Equiv.html#9405" class="Bound">p1</a> <a id="17001" href="1Lab.Equiv.html#16910" class="Bound">j</a><a id="17002" class="Symbol">)</a> <a id="17004" href="1Lab.Equiv.html#16923" class="Bound">k</a>
                             <a id="17035" class="Symbol">;</a> <a id="17037" class="Symbol">(</a><a id="17038" href="1Lab.Equiv.html#16910" class="Bound">j</a> <a id="17040" class="Symbol">=</a> <a id="17042" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="17044" class="Symbol">)</a> <a id="17046" class="Symbol">→</a> <a id="17048" href="1Lab.Equiv.html#8552" class="Field">s</a> <a id="17050" class="Symbol">(</a><a id="17051" href="1Lab.Equiv.html#8448" class="Bound">f</a> <a id="17053" class="Symbol">(</a><a id="17054" href="1Lab.Equiv.html#12789" class="Function">π</a> <a id="17056" href="1Lab.Equiv.html#16908" class="Bound">i</a><a id="17057" class="Symbol">))</a> <a id="17060" href="1Lab.Equiv.html#16923" class="Bound">k</a>
                             <a id="17091" class="Symbol">;</a> <a id="17093" class="Symbol">(</a><a id="17094" href="1Lab.Equiv.html#16910" class="Bound">j</a> <a id="17096" class="Symbol">=</a> <a id="17098" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="17100" class="Symbol">)</a> <a id="17102" class="Symbol">→</a> <a id="17104" href="1Lab.Equiv.html#8552" class="Field">s</a> <a id="17106" href="1Lab.Equiv.html#9369" class="Bound">y</a> <a id="17108" href="1Lab.Equiv.html#16923" class="Bound">k</a>
                             <a id="17139" class="Symbol">})</a>
                    <a id="17162" class="Symbol">(</a><a id="17163" href="1Lab.Equiv.html#8448" class="Bound">f</a> <a id="17165" class="Symbol">(</a><a id="17166" href="1Lab.Equiv.html#13689" class="Function">ι</a> <a id="17168" href="1Lab.Equiv.html#16908" class="Bound">i</a> <a id="17170" href="1Lab.Equiv.html#16910" class="Bound">j</a><a id="17171" class="Symbol">))</a>
</pre>
<p>The composition above can be visualised as the front (red) face in the cubical diagram below. Once more, left is <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">i = \mathrm{i0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i0</span></span></span></span></span>,</span> right is <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">i = \mathrm{i1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i1</span></span></span></span></span>,</span> up is <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">j = \mathrm{i0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i0</span></span></span></span></span>,</span> and down is <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>1</mn></mrow></mrow><annotation encoding="application/x-tex">j = \mathrm{i1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i1</span></span></span></span></span>.</span></p>
<div class="diagram-container">
<img src="d1c933642181adc04fdc23a3fcfe2a7fc5fd8a77.svg" title="commutative diagram" class="diagram quiver tall-2" />
</div>
<p>Putting all of this together, we get that <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>p</mi><mn>0</mn></msub><mo stretchy="false">)</mo><mo>≡</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>p</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_0, p_0) ≡ (x_1, p_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>.</span> Since there were no assumptions on any of the variables under consideration, this indeed says that the fibre over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> is a proposition for any choice of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>.</span></p>
<pre class="Agda">    <a id="19654" href="1Lab.Equiv.html#19654" class="Function">is-iso→fibre-is-prop</a> <a id="19675" class="Symbol">:</a> <a id="19677" class="Symbol">(</a><a id="19678" href="1Lab.Equiv.html#9377" class="Bound">x0</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="19681" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="19683" href="1Lab.Equiv.html#9389" class="Bound">p0</a><a id="19685" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="19687" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="19689" class="Symbol">(</a><a id="19690" href="1Lab.Equiv.html#9380" class="Bound">x1</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="19693" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="19695" href="1Lab.Equiv.html#9405" class="Bound">p1</a><a id="19697" class="Symbol">)</a>
    <a id="19703" href="1Lab.Equiv.html#19654" class="Function">is-iso→fibre-is-prop</a> <a id="19724" href="1Lab.Equiv.html#19724" class="Bound">i</a> <a id="19726" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="19727" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="19731" class="Symbol">=</a> <a id="19733" href="1Lab.Equiv.html#12789" class="Function">π</a> <a id="19735" href="1Lab.Equiv.html#19724" class="Bound">i</a>
    <a id="19741" href="1Lab.Equiv.html#19654" class="Function">is-iso→fibre-is-prop</a> <a id="19762" href="1Lab.Equiv.html#19762" class="Bound">i</a> <a id="19764" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="19765" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="19769" class="Symbol">=</a> <a id="19771" href="1Lab.Equiv.html#16867" class="Function">sq1</a> <a id="19775" href="1Lab.Equiv.html#19762" class="Bound">i</a>
</pre>
<p>Since the fibre over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> is inhabited by <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>g</mi><mtext> </mtext><mi>y</mi><mo separator="true">,</mo><mi>s</mi><mtext> </mtext><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(g\ y, s\ y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>,</span> we get that any isomorphism has contractible fibres:</p>
<pre class="Agda">  <a data-type="(i : is-iso f) → is-equiv f" id="19903" href="1Lab.Equiv.html#19903" class="Function">is-iso→is-equiv</a> <a id="19919" class="Symbol">:</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="19921" href="1Lab.Equiv.html#2306" class="Record">is-equiv</a> <a id="19930" href="1Lab.Equiv.html#8448" class="Bound">f</a>
  <a data-type="(i : is-iso f) → is-equiv f" id="19934" href="1Lab.Equiv.html#19903" class="Function">is-iso→is-equiv</a> <a id="19950" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="19951" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="19958" href="1Lab.Equiv.html#19958" class="Bound">y</a> <a id="19960" class="Symbol">.</a><a data-type="is-contr A → A" id="19961" href="1Lab.HLevel.html#1401" class="Field">centre</a> <a id="19968" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="19969" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="19973" class="Symbol">=</a> <a id="19975" href="1Lab.Equiv.html#8515" class="Field">g</a> <a id="19977" href="1Lab.Equiv.html#19958" class="Bound">y</a>
  <a data-type="(i : is-iso f) → is-equiv f" id="19981" href="1Lab.Equiv.html#19903" class="Function">is-iso→is-equiv</a> <a id="19997" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="19998" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="20005" href="1Lab.Equiv.html#20005" class="Bound">y</a> <a id="20007" class="Symbol">.</a><a data-type="is-contr A → A" id="20008" href="1Lab.HLevel.html#1401" class="Field">centre</a> <a id="20015" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="20016" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="20020" class="Symbol">=</a> <a id="20022" href="1Lab.Equiv.html#8552" class="Field">s</a> <a id="20024" href="1Lab.Equiv.html#20005" class="Bound">y</a>
  <a data-type="(i : is-iso f) → is-equiv f" id="20028" href="1Lab.Equiv.html#19903" class="Function">is-iso→is-equiv</a> <a id="20044" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="20045" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="20052" href="1Lab.Equiv.html#20052" class="Bound">y</a> <a id="20054" class="Symbol">.</a><a data-type="(r : is-contr A) (x : A) → r .centre ≡ x" id="20055" href="1Lab.HLevel.html#1416" class="Field">paths</a> <a id="20061" href="1Lab.Equiv.html#20061" class="Bound">z</a> <a id="20063" class="Symbol">=</a>
    <a id="20069" href="1Lab.Equiv.html#19654" class="Function">is-iso→fibre-is-prop</a> <a id="20090" href="1Lab.Equiv.html#20052" class="Bound">y</a> <a id="20092" class="Symbol">(</a><a id="20093" href="1Lab.Equiv.html#8515" class="Field">g</a> <a id="20095" href="1Lab.Equiv.html#20052" class="Bound">y</a><a id="20096" class="Symbol">)</a> <a id="20098" class="Symbol">(</a><a data-type="∑ A B₁ → A" id="20099" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="20103" href="1Lab.Equiv.html#20061" class="Bound">z</a><a id="20104" class="Symbol">)</a> <a id="20106" class="Symbol">(</a><a id="20107" href="1Lab.Equiv.html#8552" class="Field">s</a> <a id="20109" href="1Lab.Equiv.html#20052" class="Bound">y</a><a id="20110" class="Symbol">)</a> <a id="20112" class="Symbol">(</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="20113" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="20117" href="1Lab.Equiv.html#20061" class="Bound">z</a><a id="20118" class="Symbol">)</a>
</pre>
<p>Applying this to the <span class="Agda"><a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" href="1Lab.Equiv.html#6318" class="Function">Iso</a></span> and <span class="Agda"><a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" href="1Lab.Equiv.html#2459" class="Function Operator">_≃_</a></span> pairs, we can turn any isomorphism into a coherent equivalence.</p>
<pre class="Agda"><a id="Iso→Equiv"></a><a data-type="Iso A B₁ → A ≃ B₁" id="20249" href="1Lab.Equiv.html#20249" class="Function">Iso→Equiv</a> <a id="20259" class="Symbol">:</a> <a id="20261" class="Symbol">∀</a> <a id="20263" class="Symbol">{</a><a id="20264" href="1Lab.Equiv.html#20264" class="Bound">ℓ₁</a> <a id="20267" href="1Lab.Equiv.html#20267" class="Bound">ℓ₂</a><a id="20269" class="Symbol">}</a> <a id="20271" class="Symbol">{</a><a id="20272" href="1Lab.Equiv.html#20272" class="Bound">A</a> <a id="20274" class="Symbol">:</a> <a id="20276" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20281" href="1Lab.Equiv.html#20264" class="Bound">ℓ₁</a><a id="20283" class="Symbol">}</a> <a id="20285" class="Symbol">{</a><a id="20286" href="1Lab.Equiv.html#20286" class="Bound">B</a> <a id="20288" class="Symbol">:</a> <a id="20290" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20295" href="1Lab.Equiv.html#20267" class="Bound">ℓ₂</a><a id="20297" class="Symbol">}</a>
          <a id="20309" class="Symbol">→</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="20311" href="1Lab.Equiv.html#6318" class="Function">Iso</a> <a id="20315" href="1Lab.Equiv.html#20272" class="Bound">A</a> <a id="20317" href="1Lab.Equiv.html#20286" class="Bound">B</a>
          <a id="20329" class="Symbol">→</a> <a id="20331" href="1Lab.Equiv.html#20272" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="20333" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="20335" href="1Lab.Equiv.html#20286" class="Bound">B</a>
<a data-type="Iso A B₁ → A ≃ B₁" id="20337" href="1Lab.Equiv.html#20249" class="Function">Iso→Equiv</a> <a id="20347" class="Symbol">(</a><a id="20348" href="1Lab.Equiv.html#20348" class="Bound">f</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="20350" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="20352" href="1Lab.Equiv.html#20352" class="Bound">is-iso</a><a id="20358" class="Symbol">)</a> <a id="20360" class="Symbol">=</a> <a id="20362" href="1Lab.Equiv.html#20348" class="Bound">f</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="20364" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="(i : is-iso f) → is-equiv f" id="20366" href="1Lab.Equiv.html#19903" class="Function">is-iso→is-equiv</a> <a id="20382" href="1Lab.Equiv.html#20352" class="Bound">is-iso</a>
</pre>
<p>A helpful lemma: Any function between contractible types is an equivalence:</p>
<pre class="Agda"><a id="is-contr→is-equiv"></a><a data-type="is-contr A → is-contr B₁ → is-equiv f" id="20479" href="1Lab.Equiv.html#20479" class="Function">is-contr→is-equiv</a> <a id="20497" class="Symbol">:</a> <a id="20499" class="Symbol">∀</a> <a id="20501" class="Symbol">{</a><a id="20502" href="1Lab.Equiv.html#20502" class="Bound">ℓ₁</a> <a id="20505" href="1Lab.Equiv.html#20505" class="Bound">ℓ₂</a><a id="20507" class="Symbol">}</a> <a id="20509" class="Symbol">{</a><a id="20510" href="1Lab.Equiv.html#20510" class="Bound">A</a> <a id="20512" class="Symbol">:</a> <a id="20514" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20519" href="1Lab.Equiv.html#20502" class="Bound">ℓ₁</a><a id="20521" class="Symbol">}</a> <a id="20523" class="Symbol">{</a><a id="20524" href="1Lab.Equiv.html#20524" class="Bound">B</a> <a id="20526" class="Symbol">:</a> <a id="20528" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20533" href="1Lab.Equiv.html#20505" class="Bound">ℓ₂</a><a id="20535" class="Symbol">}</a>
                  <a id="20555" class="Symbol">→</a> <a data-type="(A : Type ℓ) → Type ℓ" id="20557" href="1Lab.HLevel.html#1328" class="Record">is-contr</a> <a id="20566" href="1Lab.Equiv.html#20510" class="Bound">A</a> <a id="20568" class="Symbol">→</a> <a data-type="(A : Type ℓ) → Type ℓ" id="20570" href="1Lab.HLevel.html#1328" class="Record">is-contr</a> <a id="20579" href="1Lab.Equiv.html#20524" class="Bound">B</a> <a id="20581" class="Symbol">→</a> <a id="20583" class="Symbol">{</a><a id="20584" href="1Lab.Equiv.html#20584" class="Bound">f</a> <a id="20586" class="Symbol">:</a> <a id="20588" href="1Lab.Equiv.html#20510" class="Bound">A</a> <a id="20590" class="Symbol">→</a> <a id="20592" href="1Lab.Equiv.html#20524" class="Bound">B</a><a id="20593" class="Symbol">}</a>
                  <a id="20613" class="Symbol">→</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="20615" href="1Lab.Equiv.html#2306" class="Record">is-equiv</a> <a id="20624" href="1Lab.Equiv.html#20584" class="Bound">f</a>
<a data-type="is-contr A → is-contr B₁ → is-equiv f" id="20626" href="1Lab.Equiv.html#20479" class="Function">is-contr→is-equiv</a> <a id="20644" href="1Lab.Equiv.html#20644" class="Bound">cA</a> <a id="20647" href="1Lab.Equiv.html#20647" class="Bound">cB</a> <a id="20650" class="Symbol">=</a> <a data-type="(i : is-iso f) → is-equiv f" id="20652" href="1Lab.Equiv.html#19903" class="Function">is-iso→is-equiv</a> <a id="20668" href="1Lab.Equiv.html#20685" class="Function">f-is-iso</a> <a id="20677" class="Keyword">where</a>
  <a id="20685" href="1Lab.Equiv.html#20685" class="Function">f-is-iso</a> <a id="20694" class="Symbol">:</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="20696" href="1Lab.Equiv.html#6046" class="Record">is-iso</a> <a id="20703" class="Symbol">_</a>
  <a data-type="is-iso f → B₁ → A" id="20707" href="1Lab.Equiv.html#6152" class="Field">is-iso.inv</a> <a id="20718" href="1Lab.Equiv.html#20685" class="Function">f-is-iso</a> <a id="20727" class="Symbol">_</a> <a id="20729" class="Symbol">=</a> <a id="20731" href="1Lab.Equiv.html#20644" class="Bound">cA</a> <a id="20734" class="Symbol">.</a><a data-type="is-contr A → A" id="20735" href="1Lab.HLevel.html#1401" class="Field">centre</a>
  <a data-type="(r : is-iso f) → is-right-inverse (r .inv) f" id="20744" href="1Lab.Equiv.html#6168" class="Field">is-iso.rinv</a> <a id="20756" href="1Lab.Equiv.html#20685" class="Function">f-is-iso</a> <a id="20765" class="Symbol">_</a> <a id="20767" class="Symbol">=</a> <a data-type="is-contr A → is-prop A" id="20769" href="1Lab.HLevel.html#3818" class="Function">is-contr→is-prop</a> <a id="20786" href="1Lab.Equiv.html#20647" class="Bound">cB</a> <a id="20789" class="Symbol">_</a> <a id="20791" class="Symbol">_</a>
  <a data-type="(r : is-iso f) → is-left-inverse (r .inv) f" id="20795" href="1Lab.Equiv.html#6202" class="Field">is-iso.linv</a> <a id="20807" href="1Lab.Equiv.html#20685" class="Function">f-is-iso</a> <a id="20816" class="Symbol">_</a> <a id="20818" class="Symbol">=</a> <a data-type="is-contr A → is-prop A" id="20820" href="1Lab.HLevel.html#3818" class="Function">is-contr→is-prop</a> <a id="20837" href="1Lab.Equiv.html#20644" class="Bound">cA</a> <a id="20840" class="Symbol">_</a> <a id="20842" class="Symbol">_</a>

<a id="is-contr→≃"></a><a data-type="is-contr A → is-contr B₁ → A ≃ B₁" id="20845" href="1Lab.Equiv.html#20845" class="Function">is-contr→≃</a> <a id="20856" class="Symbol">:</a> <a id="20858" class="Symbol">∀</a> <a id="20860" class="Symbol">{</a><a id="20861" href="1Lab.Equiv.html#20861" class="Bound">ℓ₁</a> <a id="20864" href="1Lab.Equiv.html#20864" class="Bound">ℓ₂</a><a id="20866" class="Symbol">}</a> <a id="20868" class="Symbol">{</a><a id="20869" href="1Lab.Equiv.html#20869" class="Bound">A</a> <a id="20871" class="Symbol">:</a> <a id="20873" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20878" href="1Lab.Equiv.html#20861" class="Bound">ℓ₁</a><a id="20880" class="Symbol">}</a> <a id="20882" class="Symbol">{</a><a id="20883" href="1Lab.Equiv.html#20883" class="Bound">B</a> <a id="20885" class="Symbol">:</a> <a id="20887" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="20892" href="1Lab.Equiv.html#20864" class="Bound">ℓ₂</a><a id="20894" class="Symbol">}</a>
           <a id="20907" class="Symbol">→</a> <a data-type="(A : Type ℓ) → Type ℓ" id="20909" href="1Lab.HLevel.html#1328" class="Record">is-contr</a> <a id="20918" href="1Lab.Equiv.html#20869" class="Bound">A</a> <a id="20920" class="Symbol">→</a> <a data-type="(A : Type ℓ) → Type ℓ" id="20922" href="1Lab.HLevel.html#1328" class="Record">is-contr</a> <a id="20931" href="1Lab.Equiv.html#20883" class="Bound">B</a> <a id="20933" class="Symbol">→</a> <a id="20935" href="1Lab.Equiv.html#20869" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="20937" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="20939" href="1Lab.Equiv.html#20883" class="Bound">B</a>
<a data-type="is-contr A → is-contr B₁ → A ≃ B₁" id="20941" href="1Lab.Equiv.html#20845" class="Function">is-contr→≃</a> <a id="20952" href="1Lab.Equiv.html#20952" class="Bound">cA</a> <a id="20955" href="1Lab.Equiv.html#20955" class="Bound">cB</a> <a id="20958" class="Symbol">=</a> <a id="20960" class="Symbol">(λ</a> <a id="20963" href="1Lab.Equiv.html#20963" class="Bound">_</a> <a id="20965" class="Symbol">→</a> <a id="20967" href="1Lab.Equiv.html#20955" class="Bound">cB</a> <a id="20970" class="Symbol">.</a><a data-type="is-contr A → A" id="20971" href="1Lab.HLevel.html#1401" class="Field">centre</a><a id="20977" class="Symbol">)</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="20979" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="(i : is-iso f) → is-equiv f" id="20981" href="1Lab.Equiv.html#19903" class="Function">is-iso→is-equiv</a> <a id="20997" href="1Lab.Equiv.html#21014" class="Function">f-is-iso</a> <a id="21006" class="Keyword">where</a>
  <a id="21014" href="1Lab.Equiv.html#21014" class="Function">f-is-iso</a> <a id="21023" class="Symbol">:</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="21025" href="1Lab.Equiv.html#6046" class="Record">is-iso</a> <a id="21032" class="Symbol">_</a>
  <a data-type="is-iso f → B₁ → A" id="21036" href="1Lab.Equiv.html#6152" class="Field">is-iso.inv</a> <a id="21047" href="1Lab.Equiv.html#21014" class="Function">f-is-iso</a> <a id="21056" class="Symbol">_</a> <a id="21058" class="Symbol">=</a> <a id="21060" href="1Lab.Equiv.html#20952" class="Bound">cA</a> <a id="21063" class="Symbol">.</a><a data-type="is-contr A → A" id="21064" href="1Lab.HLevel.html#1401" class="Field">centre</a>
  <a data-type="(r : is-iso f) → is-right-inverse (r .inv) f" id="21073" href="1Lab.Equiv.html#6168" class="Field">is-iso.rinv</a> <a id="21085" href="1Lab.Equiv.html#21014" class="Function">f-is-iso</a> <a id="21094" class="Symbol">_</a> <a id="21096" class="Symbol">=</a> <a data-type="is-contr A → is-prop A" id="21098" href="1Lab.HLevel.html#3818" class="Function">is-contr→is-prop</a> <a id="21115" href="1Lab.Equiv.html#20955" class="Bound">cB</a> <a id="21118" class="Symbol">_</a> <a id="21120" class="Symbol">_</a>
  <a data-type="(r : is-iso f) → is-left-inverse (r .inv) f" id="21124" href="1Lab.Equiv.html#6202" class="Field">is-iso.linv</a> <a id="21136" href="1Lab.Equiv.html#21014" class="Function">f-is-iso</a> <a id="21145" class="Symbol">_</a> <a id="21147" class="Symbol">=</a> <a data-type="is-contr A → is-prop A" id="21149" href="1Lab.HLevel.html#3818" class="Function">is-contr→is-prop</a> <a id="21166" href="1Lab.Equiv.html#20952" class="Bound">cA</a> <a id="21169" class="Symbol">_</a> <a id="21171" class="Symbol">_</a>
</pre>
<h1 id="equivalence-reasoning"><a href="#equivalence-reasoning" class="header-link">Equivalence Reasoning<span class="header-link-emoji">🔗</span></a></h1>
<p>To make composing equivalences more intuitive, we implement operators to do equivalence reasoning in the same style as equational reasoning.</p>
<pre class="Agda"><a id="_∙e_"></a><a data-type="A ≃ B₁ → B₁ ≃ C → A ≃ C" id="21353" href="1Lab.Equiv.html#21353" class="Function Operator">_∙e_</a> <a id="21358" class="Symbol">:</a> <a id="21360" class="Symbol">∀</a> <a id="21362" class="Symbol">{</a><a id="21363" href="1Lab.Equiv.html#21363" class="Bound">ℓ</a> <a id="21365" href="1Lab.Equiv.html#21365" class="Bound">ℓ₁</a> <a id="21368" href="1Lab.Equiv.html#21368" class="Bound">ℓ₂</a><a id="21370" class="Symbol">}</a> <a id="21372" class="Symbol">{</a><a id="21373" href="1Lab.Equiv.html#21373" class="Bound">A</a> <a id="21375" class="Symbol">:</a> <a id="21377" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="21382" href="1Lab.Equiv.html#21363" class="Bound">ℓ</a><a id="21383" class="Symbol">}</a> <a id="21385" class="Symbol">{</a><a id="21386" href="1Lab.Equiv.html#21386" class="Bound">B</a> <a id="21388" class="Symbol">:</a> <a id="21390" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="21395" href="1Lab.Equiv.html#21365" class="Bound">ℓ₁</a><a id="21397" class="Symbol">}</a> <a id="21399" class="Symbol">{</a><a id="21400" href="1Lab.Equiv.html#21400" class="Bound">C</a> <a id="21402" class="Symbol">:</a> <a id="21404" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="21409" href="1Lab.Equiv.html#21368" class="Bound">ℓ₂</a><a id="21411" class="Symbol">}</a>
     <a id="21418" class="Symbol">→</a> <a id="21420" href="1Lab.Equiv.html#21373" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="21422" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="21424" href="1Lab.Equiv.html#21386" class="Bound">B</a> <a id="21426" class="Symbol">→</a> <a id="21428" href="1Lab.Equiv.html#21386" class="Bound">B</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="21430" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="21432" href="1Lab.Equiv.html#21400" class="Bound">C</a> <a id="21434" class="Symbol">→</a> <a id="21436" href="1Lab.Equiv.html#21373" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="21438" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="21440" href="1Lab.Equiv.html#21400" class="Bound">C</a>

<a id="_e⁻¹"></a><a data-type="A ≃ B₁ → B₁ ≃ A" id="21443" href="1Lab.Equiv.html#21443" class="Function Operator">_e⁻¹</a> <a id="21448" class="Symbol">:</a> <a id="21450" class="Symbol">∀</a> <a id="21452" class="Symbol">{</a><a id="21453" href="1Lab.Equiv.html#21453" class="Bound">ℓ</a> <a id="21455" href="1Lab.Equiv.html#21455" class="Bound">ℓ₁</a><a id="21457" class="Symbol">}</a> <a id="21459" class="Symbol">{</a><a id="21460" href="1Lab.Equiv.html#21460" class="Bound">A</a> <a id="21462" class="Symbol">:</a> <a id="21464" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="21469" href="1Lab.Equiv.html#21453" class="Bound">ℓ</a><a id="21470" class="Symbol">}</a> <a id="21472" class="Symbol">{</a><a id="21473" href="1Lab.Equiv.html#21473" class="Bound">B</a> <a id="21475" class="Symbol">:</a> <a id="21477" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="21482" href="1Lab.Equiv.html#21455" class="Bound">ℓ₁</a><a id="21484" class="Symbol">}</a>
     <a id="21491" class="Symbol">→</a> <a id="21493" href="1Lab.Equiv.html#21460" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="21495" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="21497" href="1Lab.Equiv.html#21473" class="Bound">B</a> <a id="21499" class="Symbol">→</a> <a id="21501" href="1Lab.Equiv.html#21473" class="Bound">B</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="21503" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="21505" href="1Lab.Equiv.html#21460" class="Bound">A</a>
<a data-type="A ≃ B₁ → B₁ ≃ A" id="21507" href="1Lab.Equiv.html#21443" class="Function Operator">_e⁻¹</a> <a id="21512" href="1Lab.Equiv.html#21512" class="Bound">eqv</a> <a id="21516" class="Symbol">=</a> <a data-type="Iso A B₁ → A ≃ B₁" id="21518" href="1Lab.Equiv.html#20249" class="Function">Iso→Equiv</a> <a id="21528" class="Symbol">(</a> <a data-type="is-equiv f → B₁ → A" id="21530" href="1Lab.Equiv.html#6469" class="Function">equiv→inverse</a> <a id="21544" class="Symbol">(</a><a id="21545" href="1Lab.Equiv.html#21512" class="Bound">eqv</a> <a id="21549" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="21550" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="21553" class="Symbol">)</a>
                     <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="21576" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="21578" class="Keyword">record</a> <a id="21585" class="Symbol">{</a> <a data-type="is-iso f → B₁ → A" id="21587" href="1Lab.Equiv.html#6152" class="Field">inv</a>  <a id="21592" class="Symbol">=</a> <a id="21594" href="1Lab.Equiv.html#21512" class="Bound">eqv</a> <a id="21598" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="21599" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a>
                              <a id="21633" class="Symbol">;</a> <a data-type="(r : is-iso f) → is-right-inverse (r .inv) f" id="21635" href="1Lab.Equiv.html#6168" class="Field">rinv</a> <a id="21640" class="Symbol">=</a> <a data-type="(eqv : is-equiv f) → is-left-inverse (equiv→inverse eqv) f" id="21642" href="1Lab.Equiv.html#6708" class="Function">equiv→retraction</a> <a id="21659" class="Symbol">(</a><a id="21660" href="1Lab.Equiv.html#21512" class="Bound">eqv</a> <a id="21664" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="21665" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="21668" class="Symbol">)</a>
                              <a id="21700" class="Symbol">;</a> <a data-type="(r : is-iso f) → is-left-inverse (r .inv) f" id="21702" href="1Lab.Equiv.html#6202" class="Field">linv</a> <a id="21707" class="Symbol">=</a> <a data-type="(eqv : is-equiv f) → is-right-inverse (equiv→inverse eqv) f" id="21709" href="1Lab.Equiv.html#6568" class="Function">equiv→section</a> <a id="21723" class="Symbol">(</a><a id="21724" href="1Lab.Equiv.html#21512" class="Bound">eqv</a> <a id="21728" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="21729" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="21732" class="Symbol">)</a>
                              <a id="21764" class="Symbol">})</a>
</pre>
<!--
<pre class="Agda"><a id="21780" href="1Lab.Equiv.html#21353" class="Function Operator">_∙e_</a> <a id="21785" class="Symbol">(</a><a id="21786" href="1Lab.Equiv.html#21786" class="Bound">f</a> <a id="21788" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="21790" href="1Lab.Equiv.html#21790" class="Bound">e</a><a id="21791" class="Symbol">)</a> <a id="21793" class="Symbol">(</a><a id="21794" href="1Lab.Equiv.html#21794" class="Bound">g</a> <a id="21796" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="21798" href="1Lab.Equiv.html#21798" class="Bound">e&#39;</a><a id="21800" class="Symbol">)</a> <a id="21802" class="Symbol">=</a> <a id="21804" class="Symbol">(λ</a> <a id="21807" href="1Lab.Equiv.html#21807" class="Bound">x</a> <a id="21809" class="Symbol">→</a> <a id="21811" href="1Lab.Equiv.html#21794" class="Bound">g</a> <a id="21813" class="Symbol">(</a><a id="21814" href="1Lab.Equiv.html#21786" class="Bound">f</a> <a id="21816" href="1Lab.Equiv.html#21807" class="Bound">x</a><a id="21817" class="Symbol">))</a> <a id="21820" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="21822" href="1Lab.Equiv.html#22551" class="Function">eqv</a> <a id="21826" class="Keyword">where</a>
  <a id="21834" href="1Lab.Equiv.html#21834" class="Function">g⁻¹</a> <a id="21838" class="Symbol">:</a> <a id="21840" href="1Lab.Equiv.html#6046" class="Record">is-iso</a> <a id="21847" href="1Lab.Equiv.html#21794" class="Bound">g</a>
  <a id="21851" href="1Lab.Equiv.html#21834" class="Function">g⁻¹</a> <a id="21855" class="Symbol">=</a> <a id="21857" href="1Lab.Equiv.html#6879" class="Function">is-equiv→is-iso</a> <a id="21873" href="1Lab.Equiv.html#21798" class="Bound">e&#39;</a>

  <a id="21879" href="1Lab.Equiv.html#21879" class="Function">f⁻¹</a> <a id="21883" class="Symbol">:</a> <a id="21885" href="1Lab.Equiv.html#6046" class="Record">is-iso</a> <a id="21892" href="1Lab.Equiv.html#21786" class="Bound">f</a>
  <a id="21896" href="1Lab.Equiv.html#21879" class="Function">f⁻¹</a> <a id="21900" class="Symbol">=</a> <a id="21902" href="1Lab.Equiv.html#6879" class="Function">is-equiv→is-iso</a> <a id="21918" href="1Lab.Equiv.html#21790" class="Bound">e</a>

  <a id="21923" href="1Lab.Equiv.html#21923" class="Function">inv</a> <a id="21927" class="Symbol">:</a> <a id="21929" class="Symbol">_</a> <a id="21931" class="Symbol">→</a> <a id="21933" class="Symbol">_</a>
  <a id="21937" href="1Lab.Equiv.html#21923" class="Function">inv</a> <a id="21941" href="1Lab.Equiv.html#21941" class="Bound">x</a> <a id="21943" class="Symbol">=</a> <a id="21945" href="1Lab.Equiv.html#21879" class="Function">f⁻¹</a> <a id="21949" class="Symbol">.</a><a id="21950" href="1Lab.Equiv.html#6152" class="Field">is-iso.inv</a> <a id="21961" class="Symbol">(</a><a id="21962" href="1Lab.Equiv.html#21834" class="Function">g⁻¹</a> <a id="21966" class="Symbol">.</a><a id="21967" href="1Lab.Equiv.html#6152" class="Field">is-iso.inv</a> <a id="21978" href="1Lab.Equiv.html#21941" class="Bound">x</a><a id="21979" class="Symbol">)</a>

  <a id="21984" class="Keyword">abstract</a>
    <a id="21997" href="1Lab.Equiv.html#21997" class="Function">right</a> <a id="22003" class="Symbol">:</a> <a id="22005" href="1Lab.Equiv.html#5759" class="Function">is-right-inverse</a> <a id="22022" href="1Lab.Equiv.html#21923" class="Function">inv</a> <a id="22026" class="Symbol">(λ</a> <a id="22029" href="1Lab.Equiv.html#22029" class="Bound">x</a> <a id="22031" class="Symbol">→</a> <a id="22033" href="1Lab.Equiv.html#21794" class="Bound">g</a> <a id="22035" class="Symbol">(</a><a id="22036" href="1Lab.Equiv.html#21786" class="Bound">f</a> <a id="22038" href="1Lab.Equiv.html#22029" class="Bound">x</a><a id="22039" class="Symbol">))</a>
    <a id="22046" href="1Lab.Equiv.html#21997" class="Function">right</a> <a id="22052" href="1Lab.Equiv.html#22052" class="Bound">z</a> <a id="22054" class="Symbol">=</a>
      <a id="22062" href="1Lab.Equiv.html#21794" class="Bound">g</a> <a id="22064" class="Symbol">(</a><a id="22065" href="1Lab.Equiv.html#21786" class="Bound">f</a> <a id="22067" class="Symbol">(</a><a id="22068" href="1Lab.Equiv.html#21879" class="Function">f⁻¹</a> <a id="22072" class="Symbol">.</a><a id="22073" href="1Lab.Equiv.html#6152" class="Field">is-iso.inv</a> <a id="22084" class="Symbol">(</a><a id="22085" href="1Lab.Equiv.html#21834" class="Function">g⁻¹</a> <a id="22089" class="Symbol">.</a><a id="22090" href="1Lab.Equiv.html#6152" class="Field">is-iso.inv</a> <a id="22101" href="1Lab.Equiv.html#22052" class="Bound">z</a><a id="22102" class="Symbol">)))</a> <a id="22106" href="1Lab.Path.html#46786" class="Function">≡⟨</a> <a id="22109" href="1Lab.Path.html#20828" class="Function">ap</a> <a id="22112" href="1Lab.Equiv.html#21794" class="Bound">g</a> <a id="22114" class="Symbol">(</a><a id="22115" href="1Lab.Equiv.html#21879" class="Function">f⁻¹</a> <a id="22119" class="Symbol">.</a><a id="22120" href="1Lab.Equiv.html#6168" class="Field">is-iso.rinv</a> <a id="22132" class="Symbol">_)</a> <a id="22135" href="1Lab.Path.html#46786" class="Function">⟩</a>
      <a id="22143" href="1Lab.Equiv.html#21794" class="Bound">g</a> <a id="22145" class="Symbol">(</a><a id="22146" href="1Lab.Equiv.html#21834" class="Function">g⁻¹</a> <a id="22150" class="Symbol">.</a><a id="22151" href="1Lab.Equiv.html#6152" class="Field">is-iso.inv</a> <a id="22162" href="1Lab.Equiv.html#22052" class="Bound">z</a><a id="22163" class="Symbol">)</a>                       <a id="22187" href="1Lab.Path.html#46786" class="Function">≡⟨</a> <a id="22190" href="1Lab.Equiv.html#21834" class="Function">g⁻¹</a> <a id="22194" class="Symbol">.</a><a id="22195" href="1Lab.Equiv.html#6168" class="Field">is-iso.rinv</a> <a id="22207" class="Symbol">_</a> <a id="22209" href="1Lab.Path.html#46786" class="Function">⟩</a>
      <a id="22217" href="1Lab.Equiv.html#22052" class="Bound">z</a>                                           <a id="22261" href="1Lab.Path.html#47114" class="Function Operator">∎</a>

    <a id="22268" href="1Lab.Equiv.html#22268" class="Function">left</a> <a id="22273" class="Symbol">:</a> <a id="22275" href="1Lab.Equiv.html#5669" class="Function">is-left-inverse</a> <a id="22291" href="1Lab.Equiv.html#21923" class="Function">inv</a> <a id="22295" class="Symbol">(λ</a> <a id="22298" href="1Lab.Equiv.html#22298" class="Bound">x</a> <a id="22300" class="Symbol">→</a> <a id="22302" href="1Lab.Equiv.html#21794" class="Bound">g</a> <a id="22304" class="Symbol">(</a><a id="22305" href="1Lab.Equiv.html#21786" class="Bound">f</a> <a id="22307" href="1Lab.Equiv.html#22298" class="Bound">x</a><a id="22308" class="Symbol">))</a>
    <a id="22315" href="1Lab.Equiv.html#22268" class="Function">left</a> <a id="22320" href="1Lab.Equiv.html#22320" class="Bound">z</a> <a id="22322" class="Symbol">=</a>
      <a id="22330" href="1Lab.Equiv.html#21879" class="Function">f⁻¹</a> <a id="22334" class="Symbol">.</a><a id="22335" href="1Lab.Equiv.html#6152" class="Field">is-iso.inv</a> <a id="22346" class="Symbol">(</a><a id="22347" href="1Lab.Equiv.html#21834" class="Function">g⁻¹</a> <a id="22351" class="Symbol">.</a><a id="22352" href="1Lab.Equiv.html#6152" class="Field">is-iso.inv</a> <a id="22363" class="Symbol">(</a><a id="22364" href="1Lab.Equiv.html#21794" class="Bound">g</a> <a id="22366" class="Symbol">(</a><a id="22367" href="1Lab.Equiv.html#21786" class="Bound">f</a> <a id="22369" href="1Lab.Equiv.html#22320" class="Bound">z</a><a id="22370" class="Symbol">)))</a> <a id="22374" href="1Lab.Path.html#46786" class="Function">≡⟨</a> <a id="22377" href="1Lab.Path.html#20828" class="Function">ap</a> <a id="22380" class="Symbol">(</a><a id="22381" href="1Lab.Equiv.html#21879" class="Function">f⁻¹</a> <a id="22385" class="Symbol">.</a><a id="22386" href="1Lab.Equiv.html#6152" class="Field">is-iso.inv</a><a id="22396" class="Symbol">)</a> <a id="22398" class="Symbol">(</a><a id="22399" href="1Lab.Equiv.html#21834" class="Function">g⁻¹</a> <a id="22403" class="Symbol">.</a><a id="22404" href="1Lab.Equiv.html#6202" class="Field">is-iso.linv</a> <a id="22416" class="Symbol">_)</a> <a id="22419" href="1Lab.Path.html#46786" class="Function">⟩</a>
      <a id="22427" href="1Lab.Equiv.html#21879" class="Function">f⁻¹</a> <a id="22431" class="Symbol">.</a><a id="22432" href="1Lab.Equiv.html#6152" class="Field">is-iso.inv</a> <a id="22443" class="Symbol">(</a><a id="22444" href="1Lab.Equiv.html#21786" class="Bound">f</a> <a id="22446" href="1Lab.Equiv.html#22320" class="Bound">z</a><a id="22447" class="Symbol">)</a>                       <a id="22471" href="1Lab.Path.html#46786" class="Function">≡⟨</a> <a id="22474" href="1Lab.Equiv.html#21879" class="Function">f⁻¹</a> <a id="22478" class="Symbol">.</a><a id="22479" href="1Lab.Equiv.html#6202" class="Field">is-iso.linv</a> <a id="22491" class="Symbol">_</a> <a id="22493" href="1Lab.Path.html#46786" class="Function">⟩</a>
      <a id="22501" href="1Lab.Equiv.html#22320" class="Bound">z</a>                                           <a id="22545" href="1Lab.Path.html#47114" class="Function Operator">∎</a>
    <a id="22551" href="1Lab.Equiv.html#22551" class="Function">eqv</a> <a id="22555" class="Symbol">:</a> <a id="22557" href="1Lab.Equiv.html#2306" class="Record">is-equiv</a> <a id="22566" class="Symbol">(λ</a> <a id="22569" href="1Lab.Equiv.html#22569" class="Bound">x</a> <a id="22571" class="Symbol">→</a> <a id="22573" href="1Lab.Equiv.html#21794" class="Bound">g</a> <a id="22575" class="Symbol">(</a><a id="22576" href="1Lab.Equiv.html#21786" class="Bound">f</a> <a id="22578" href="1Lab.Equiv.html#22569" class="Bound">x</a><a id="22579" class="Symbol">))</a>
    <a id="22586" href="1Lab.Equiv.html#22551" class="Function">eqv</a> <a id="22590" class="Symbol">=</a> <a id="22592" href="1Lab.Equiv.html#19903" class="Function">is-iso→is-equiv</a> <a id="22608" class="Symbol">(</a><a id="22609" href="1Lab.Equiv.html#6136" class="InductiveConstructor">iso</a> <a id="22613" class="Symbol">(λ</a> <a id="22616" href="1Lab.Equiv.html#22616" class="Bound">x</a> <a id="22618" class="Symbol">→</a> <a id="22620" href="1Lab.Equiv.html#21879" class="Function">f⁻¹</a> <a id="22624" class="Symbol">.</a><a id="22625" href="1Lab.Equiv.html#6152" class="Field">is-iso.inv</a> <a id="22636" class="Symbol">(</a><a id="22637" href="1Lab.Equiv.html#21834" class="Function">g⁻¹</a> <a id="22641" class="Symbol">.</a><a id="22642" href="1Lab.Equiv.html#6152" class="Field">is-iso.inv</a> <a id="22653" href="1Lab.Equiv.html#22616" class="Bound">x</a><a id="22654" class="Symbol">))</a> <a id="22657" href="1Lab.Equiv.html#21997" class="Function">right</a> <a id="22663" href="1Lab.Equiv.html#22268" class="Function">left</a><a id="22667" class="Symbol">)</a>

<a id="∙-is-equiv"></a><a id="22670" href="1Lab.Equiv.html#22670" class="Function">∙-is-equiv</a> <a id="22681" class="Symbol">:</a> <a id="22683" class="Symbol">∀</a> <a id="22685" class="Symbol">{</a><a id="22686" href="1Lab.Equiv.html#22686" class="Bound">ℓ</a> <a id="22688" href="1Lab.Equiv.html#22688" class="Bound">ℓ₁</a> <a id="22691" href="1Lab.Equiv.html#22691" class="Bound">ℓ₂</a><a id="22693" class="Symbol">}</a> <a id="22695" class="Symbol">{</a><a id="22696" href="1Lab.Equiv.html#22696" class="Bound">A</a> <a id="22698" class="Symbol">:</a> <a id="22700" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="22705" href="1Lab.Equiv.html#22686" class="Bound">ℓ</a><a id="22706" class="Symbol">}</a> <a id="22708" class="Symbol">{</a><a id="22709" href="1Lab.Equiv.html#22709" class="Bound">B</a> <a id="22711" class="Symbol">:</a> <a id="22713" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="22718" href="1Lab.Equiv.html#22688" class="Bound">ℓ₁</a><a id="22720" class="Symbol">}</a> <a id="22722" class="Symbol">{</a><a id="22723" href="1Lab.Equiv.html#22723" class="Bound">C</a> <a id="22725" class="Symbol">:</a> <a id="22727" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="22732" href="1Lab.Equiv.html#22691" class="Bound">ℓ₂</a><a id="22734" class="Symbol">}</a>
           <a id="22747" class="Symbol">→</a> <a id="22749" class="Symbol">{</a><a id="22750" href="1Lab.Equiv.html#22750" class="Bound">f</a> <a id="22752" class="Symbol">:</a> <a id="22754" href="1Lab.Equiv.html#22696" class="Bound">A</a> <a id="22756" class="Symbol">→</a> <a id="22758" href="1Lab.Equiv.html#22709" class="Bound">B</a><a id="22759" class="Symbol">}</a> <a id="22761" class="Symbol">{</a><a id="22762" href="1Lab.Equiv.html#22762" class="Bound">g</a> <a id="22764" class="Symbol">:</a> <a id="22766" href="1Lab.Equiv.html#22709" class="Bound">B</a> <a id="22768" class="Symbol">→</a> <a id="22770" href="1Lab.Equiv.html#22723" class="Bound">C</a><a id="22771" class="Symbol">}</a>
           <a id="22784" class="Symbol">→</a> <a id="22786" href="1Lab.Equiv.html#2306" class="Record">is-equiv</a> <a id="22795" href="1Lab.Equiv.html#22750" class="Bound">f</a>
           <a id="22808" class="Symbol">→</a> <a id="22810" href="1Lab.Equiv.html#2306" class="Record">is-equiv</a> <a id="22819" href="1Lab.Equiv.html#22762" class="Bound">g</a>
           <a id="22832" class="Symbol">→</a> <a id="22834" href="1Lab.Equiv.html#2306" class="Record">is-equiv</a> <a id="22843" class="Symbol">(λ</a> <a id="22846" href="1Lab.Equiv.html#22846" class="Bound">x</a> <a id="22848" class="Symbol">→</a> <a id="22850" href="1Lab.Equiv.html#22762" class="Bound">g</a> <a id="22852" class="Symbol">(</a><a id="22853" href="1Lab.Equiv.html#22750" class="Bound">f</a> <a id="22855" href="1Lab.Equiv.html#22846" class="Bound">x</a><a id="22856" class="Symbol">))</a>
<a id="22859" href="1Lab.Equiv.html#22670" class="Function">∙-is-equiv</a> <a id="22870" class="Symbol">{</a><a id="22871" class="Argument">f</a> <a id="22873" class="Symbol">=</a> <a id="22875" href="1Lab.Equiv.html#22875" class="Bound">f</a><a id="22876" class="Symbol">}</a> <a id="22878" class="Symbol">{</a><a id="22879" class="Argument">g</a> <a id="22881" class="Symbol">=</a> <a id="22883" href="1Lab.Equiv.html#22883" class="Bound">g</a><a id="22884" class="Symbol">}</a> <a id="22886" href="1Lab.Equiv.html#22886" class="Bound">e</a> <a id="22888" href="1Lab.Equiv.html#22888" class="Bound">e&#39;</a> <a id="22891" class="Symbol">=</a> <a id="22893" class="Symbol">((</a><a id="22895" href="1Lab.Equiv.html#22875" class="Bound">f</a> <a id="22897" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="22899" href="1Lab.Equiv.html#22886" class="Bound">e</a><a id="22900" class="Symbol">)</a> <a id="22902" href="1Lab.Equiv.html#21353" class="Function Operator">∙e</a> <a id="22905" class="Symbol">(</a><a id="22906" href="1Lab.Equiv.html#22883" class="Bound">g</a> <a id="22908" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="22910" href="1Lab.Equiv.html#22888" class="Bound">e&#39;</a><a id="22912" class="Symbol">))</a> <a id="22915" class="Symbol">.</a><a id="22916" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a>
</pre>-->
<p>The proofs that equivalences are closed under composition assemble nicely into transitivity operators resembling equational reasoning:</p>
<pre class="Agda"><a id="_≃⟨_⟩_"></a><a data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" id="23073" href="1Lab.Equiv.html#23073" class="Function Operator">_≃⟨_⟩_</a> <a id="23080" class="Symbol">:</a> <a id="23082" class="Symbol">∀</a> <a id="23084" class="Symbol">{</a><a id="23085" href="1Lab.Equiv.html#23085" class="Bound">ℓ</a> <a id="23087" href="1Lab.Equiv.html#23087" class="Bound">ℓ₁</a> <a id="23090" href="1Lab.Equiv.html#23090" class="Bound">ℓ₂</a><a id="23092" class="Symbol">}</a> <a id="23094" class="Symbol">(</a><a id="23095" href="1Lab.Equiv.html#23095" class="Bound">A</a> <a id="23097" class="Symbol">:</a> <a id="23099" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23104" href="1Lab.Equiv.html#23085" class="Bound">ℓ</a><a id="23105" class="Symbol">)</a> <a id="23107" class="Symbol">{</a><a id="23108" href="1Lab.Equiv.html#23108" class="Bound">B</a> <a id="23110" class="Symbol">:</a> <a id="23112" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23117" href="1Lab.Equiv.html#23087" class="Bound">ℓ₁</a><a id="23119" class="Symbol">}</a> <a id="23121" class="Symbol">{</a><a id="23122" href="1Lab.Equiv.html#23122" class="Bound">C</a> <a id="23124" class="Symbol">:</a> <a id="23126" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23131" href="1Lab.Equiv.html#23090" class="Bound">ℓ₂</a><a id="23133" class="Symbol">}</a>
       <a id="23142" class="Symbol">→</a> <a id="23144" href="1Lab.Equiv.html#23095" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="23146" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="23148" href="1Lab.Equiv.html#23108" class="Bound">B</a> <a id="23150" class="Symbol">→</a> <a id="23152" href="1Lab.Equiv.html#23108" class="Bound">B</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="23154" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="23156" href="1Lab.Equiv.html#23122" class="Bound">C</a> <a id="23158" class="Symbol">→</a> <a id="23160" href="1Lab.Equiv.html#23095" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="23162" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="23164" href="1Lab.Equiv.html#23122" class="Bound">C</a>
<a id="23166" href="1Lab.Equiv.html#23166" class="Bound">A</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" id="23168" href="1Lab.Equiv.html#23073" class="Function Operator">≃⟨</a> <a id="23171" href="1Lab.Equiv.html#23171" class="Bound">f</a> <a data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" id="23173" href="1Lab.Equiv.html#23073" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span> <a id="23175" href="1Lab.Equiv.html#23175" class="Bound">g</a> <a id="23177" class="Symbol">=</a> <a id="23179" href="1Lab.Equiv.html#23171" class="Bound">f</a> <a data-type="A ≃ B₁ → B₁ ≃ C → A ≃ C" id="23181" href="1Lab.Equiv.html#21353" class="Function Operator">∙e</a> <a id="23184" href="1Lab.Equiv.html#23175" class="Bound">g</a>

<a id="_≃⟨⟩_"></a><a data-type="(A : Type ℓ) → A ≃ B₁ → A ≃ B₁" id="23187" href="1Lab.Equiv.html#23187" class="Function Operator">_≃⟨⟩_</a> <a id="23193" class="Symbol">:</a> <a id="23195" class="Symbol">∀</a> <a id="23197" class="Symbol">{</a><a id="23198" href="1Lab.Equiv.html#23198" class="Bound">ℓ</a> <a id="23200" href="1Lab.Equiv.html#23200" class="Bound">ℓ₁</a><a id="23202" class="Symbol">}</a> <a id="23204" class="Symbol">(</a><a id="23205" href="1Lab.Equiv.html#23205" class="Bound">A</a> <a id="23207" class="Symbol">:</a> <a id="23209" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23214" href="1Lab.Equiv.html#23198" class="Bound">ℓ</a><a id="23215" class="Symbol">)</a> <a id="23217" class="Symbol">{</a><a id="23218" href="1Lab.Equiv.html#23218" class="Bound">B</a> <a id="23220" class="Symbol">:</a> <a id="23222" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23227" href="1Lab.Equiv.html#23200" class="Bound">ℓ₁</a><a id="23229" class="Symbol">}</a> <a id="23231" class="Symbol">→</a> <a id="23233" href="1Lab.Equiv.html#23205" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="23235" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="23237" href="1Lab.Equiv.html#23218" class="Bound">B</a> <a id="23239" class="Symbol">→</a> <a id="23241" href="1Lab.Equiv.html#23205" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="23243" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="23245" href="1Lab.Equiv.html#23218" class="Bound">B</a>
<a id="23247" href="1Lab.Equiv.html#23247" class="Bound">x</a> <a data-type="(A : Type ℓ) → A ≃ B₁ → A ≃ B₁" id="23249" href="1Lab.Equiv.html#23187" class="Function Operator">≃⟨⟩</a> <a id="23253" href="1Lab.Equiv.html#23253" class="Bound">x≡y</a> <a id="23257" class="Symbol">=</a> <a id="23259" href="1Lab.Equiv.html#23253" class="Bound">x≡y</a>

<a id="_≃∎"></a><a data-type="(A : Type ℓ) → A ≃ A" id="23264" href="1Lab.Equiv.html#23264" class="Function Operator">_≃∎</a> <a id="23268" class="Symbol">:</a> <a id="23270" class="Symbol">∀</a> <a id="23272" class="Symbol">{</a><a id="23273" href="1Lab.Equiv.html#23273" class="Bound">ℓ</a><a id="23274" class="Symbol">}</a> <a id="23276" class="Symbol">(</a><a id="23277" href="1Lab.Equiv.html#23277" class="Bound">A</a> <a id="23279" class="Symbol">:</a> <a id="23281" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23286" href="1Lab.Equiv.html#23273" class="Bound">ℓ</a><a id="23287" class="Symbol">)</a> <a id="23289" class="Symbol">→</a> <a id="23291" href="1Lab.Equiv.html#23277" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="23293" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="23295" href="1Lab.Equiv.html#23277" class="Bound">A</a>
<a id="23297" href="1Lab.Equiv.html#23297" class="Bound">x</a> <a data-type="(A : Type ℓ) → A ≃ A" id="23299" href="1Lab.Equiv.html#23264" class="Function Operator">≃∎</a> <a id="23302" class="Symbol">=</a> <a id="23304" class="Symbol">_</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="23306" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="is-equiv (λ x → x)" id="23308" href="1Lab.Equiv.html#2544" class="Function">id-equiv</a>

<a id="23318" class="Keyword">infixr</a> <a id="23325" class="Number">30</a> <a data-type="A ≃ B₁ → B₁ ≃ C → A ≃ C" id="23328" href="1Lab.Equiv.html#21353" class="Function Operator">_∙e_</a>
<a id="23333" class="Keyword">infixr</a> <a id="23340" class="Number">2</a> <a data-type="(A : Type ℓ) → A ≃ B₁ → A ≃ B₁" id="23342" href="1Lab.Equiv.html#23187" class="Function Operator">_≃⟨⟩_</a> <a data-type="(A : Type ℓ) → A ≃ B₁ → B₁ ≃ C → A ≃ C" id="23348" href="1Lab.Equiv.html#23073" class="Function Operator">_≃⟨_⟩_</a>
<a id="23355" class="Keyword">infix</a>  <a id="23362" class="Number">3</a> <a data-type="(A : Type ℓ) → A ≃ A" id="23364" href="1Lab.Equiv.html#23264" class="Function Operator">_≃∎</a>
</pre>
<h1 id="propositional-extensionality"><a href="#propositional-extensionality" class="header-link">Propositional Extensionality<span class="header-link-emoji">🔗</span></a></h1>
<p>The following observation is not very complex, but it is incredibly useful: Equivalence of propositions is the same as biimplication.</p>
<pre class="Agda"><a id="prop-ext"></a><a data-type="is-prop P → is-prop Q → (P → Q) → (Q → P) → P ≃ Q" id="23548" href="1Lab.Equiv.html#23548" class="Function">prop-ext</a> <a id="23557" class="Symbol">:</a> <a id="23559" class="Symbol">∀</a> <a id="23561" class="Symbol">{</a><a id="23562" href="1Lab.Equiv.html#23562" class="Bound">ℓ</a> <a id="23564" href="1Lab.Equiv.html#23564" class="Bound">ℓ&#39;</a><a id="23566" class="Symbol">}</a> <a id="23568" class="Symbol">{</a><a id="23569" href="1Lab.Equiv.html#23569" class="Bound">P</a> <a id="23571" class="Symbol">:</a> <a id="23573" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23578" href="1Lab.Equiv.html#23562" class="Bound">ℓ</a><a id="23579" class="Symbol">}</a> <a id="23581" class="Symbol">{</a><a id="23582" href="1Lab.Equiv.html#23582" class="Bound">Q</a> <a id="23584" class="Symbol">:</a> <a id="23586" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="23591" href="1Lab.Equiv.html#23564" class="Bound">ℓ&#39;</a><a id="23593" class="Symbol">}</a>
         <a id="23604" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="23606" href="1Lab.HLevel.html#2597" class="Function">is-prop</a> <a id="23614" href="1Lab.Equiv.html#23569" class="Bound">P</a> <a id="23616" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="23618" href="1Lab.HLevel.html#2597" class="Function">is-prop</a> <a id="23626" href="1Lab.Equiv.html#23582" class="Bound">Q</a>
         <a id="23637" class="Symbol">→</a> <a id="23639" class="Symbol">(</a><a id="23640" href="1Lab.Equiv.html#23569" class="Bound">P</a> <a id="23642" class="Symbol">→</a> <a id="23644" href="1Lab.Equiv.html#23582" class="Bound">Q</a><a id="23645" class="Symbol">)</a> <a id="23647" class="Symbol">→</a> <a id="23649" class="Symbol">(</a><a id="23650" href="1Lab.Equiv.html#23582" class="Bound">Q</a> <a id="23652" class="Symbol">→</a> <a id="23654" href="1Lab.Equiv.html#23569" class="Bound">P</a><a id="23655" class="Symbol">)</a>
         <a id="23666" class="Symbol">→</a> <a id="23668" href="1Lab.Equiv.html#23569" class="Bound">P</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="23670" href="1Lab.Equiv.html#2459" class="Function Operator">≃</a> <a id="23672" href="1Lab.Equiv.html#23582" class="Bound">Q</a>
<a data-type="is-prop P → is-prop Q → (P → Q) → (Q → P) → P ≃ Q" id="23674" href="1Lab.Equiv.html#23548" class="Function">prop-ext</a> <a id="23683" href="1Lab.Equiv.html#23683" class="Bound">pprop</a> <a id="23689" href="1Lab.Equiv.html#23689" class="Bound">qprop</a> <a id="23695" href="1Lab.Equiv.html#23695" class="Bound">p→q</a> <a id="23699" href="1Lab.Equiv.html#23699" class="Bound">q→p</a> <a id="23703" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="23704" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="23708" class="Symbol">=</a> <a id="23710" href="1Lab.Equiv.html#23695" class="Bound">p→q</a>
<a data-type="is-prop P → is-prop Q → (P → Q) → (Q → P) → P ≃ Q" id="23714" href="1Lab.Equiv.html#23548" class="Function">prop-ext</a> <a id="23723" href="1Lab.Equiv.html#23723" class="Bound">pprop</a> <a id="23729" href="1Lab.Equiv.html#23729" class="Bound">qprop</a> <a id="23735" href="1Lab.Equiv.html#23735" class="Bound">p→q</a> <a id="23739" href="1Lab.Equiv.html#23739" class="Bound">q→p</a> <a id="23743" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="23744" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="23748" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="23749" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="23756" href="1Lab.Equiv.html#23756" class="Bound">y</a> <a id="23758" class="Symbol">.</a><a data-type="is-contr A → A" id="23759" href="1Lab.HLevel.html#1401" class="Field">centre</a> <a id="23766" class="Symbol">=</a> <a id="23768" href="1Lab.Equiv.html#23739" class="Bound">q→p</a> <a id="23772" href="1Lab.Equiv.html#23756" class="Bound">y</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="23774" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23776" href="1Lab.Equiv.html#23729" class="Bound">qprop</a> <a id="23782" class="Symbol">_</a> <a id="23784" class="Symbol">_</a>
<a data-type="is-prop P → is-prop Q → (P → Q) → (Q → P) → P ≃ Q" id="23786" href="1Lab.Equiv.html#23548" class="Function">prop-ext</a> <a id="23795" href="1Lab.Equiv.html#23795" class="Bound">pprop</a> <a id="23801" href="1Lab.Equiv.html#23801" class="Bound">qprop</a> <a id="23807" href="1Lab.Equiv.html#23807" class="Bound">p→q</a> <a id="23811" href="1Lab.Equiv.html#23811" class="Bound">q→p</a> <a id="23815" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="23816" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="23820" class="Symbol">.</a><a data-type="is-equiv f → (y : B₁) → is-contr (fibre f y)" id="23821" href="1Lab.Equiv.html#2396" class="Field">is-eqv</a> <a id="23828" href="1Lab.Equiv.html#23828" class="Bound">y</a> <a id="23830" class="Symbol">.</a><a data-type="(r : is-contr A) (x : A) → r .centre ≡ x" id="23831" href="1Lab.HLevel.html#1416" class="Field">paths</a> <a id="23837" class="Symbol">(</a><a id="23838" href="1Lab.Equiv.html#23838" class="Bound">p&#39;</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="23841" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23843" href="1Lab.Equiv.html#23843" class="Bound">path</a><a id="23847" class="Symbol">)</a> <a id="23849" class="Symbol">=</a>
  <a data-type="(p : x .fst ≡ y .fst) → subst B₁ p (x .snd) ≡ y .snd → x ≡ y" id="23853" href="1Lab.Path.html#57790" class="Function">Σ-path</a> <a id="23860" class="Symbol">(</a><a id="23861" href="1Lab.Equiv.html#23795" class="Bound">pprop</a> <a id="23867" class="Symbol">_</a> <a id="23869" class="Symbol">_)</a> <a id="23872" class="Symbol">(</a><a data-type="is-prop A → is-set A" id="23873" href="1Lab.HLevel.html#5574" class="Function">is-prop→is-set</a> <a id="23888" href="1Lab.Equiv.html#23801" class="Bound">qprop</a> <a id="23894" class="Symbol">_</a> <a id="23896" class="Symbol">_</a> <a id="23898" class="Symbol">_</a> <a id="23900" class="Symbol">_)</a>
</pre>
  </article>
</div>

</main>
</body>
</html>
