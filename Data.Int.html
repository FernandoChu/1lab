<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>Data.Int - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />
  <link rel="stylesheet" href="/css/agda-cats.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Data.Int - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="Data.Int - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script src="/equations.js"></script>
  <script src="/highlight-hover.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

  <!-- Google font embeds -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&amp;family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&amp;display=swap" rel="stylesheet">
</head>

<body>
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">Data.Int</a>
              </h3>

      <!-- Cube logo -->
      <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#integers"><a href="#integers" class="header-link">Integers<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#discreteness"><a href="#discreteness" class="header-link">Discreteness<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#recursion"><a href="#recursion" class="header-link">Recursion<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#algebra"><a href="#algebra" class="header-link">Algebra<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#successors"><a href="#successors" class="header-link">Successors<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#addition"><a href="#addition" class="header-link">Addition<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#inverses"><a href="#inverses" class="header-link">Inverses<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
              <a href="index.html">️back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/765cdeb8104bf8cf9f6181ff506f5a0897409d15/src/Data/Int.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao, Jonathan Coates and uni</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="index.html">️back to index</a>
      </div>
      
      <!-- Font toggle checkbox -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="1Lab.HLevel.Retracts.html" class="Module">1Lab.HLevel.Retracts</a>
<a id="42" class="Keyword">open</a> <a id="47" class="Keyword">import</a> <a id="54" href="1Lab.HLevel.Sets.html" class="Module">1Lab.HLevel.Sets</a>
<a id="71" class="Keyword">open</a> <a id="76" class="Keyword">import</a> <a id="83" href="1Lab.Univalence.html" class="Module">1Lab.Univalence</a>
<a id="99" class="Keyword">open</a> <a id="104" class="Keyword">import</a> <a id="111" href="1Lab.Type.Dec.html" class="Module">1Lab.Type.Dec</a>
<a id="125" class="Keyword">open</a> <a id="130" class="Keyword">import</a> <a id="137" href="1Lab.HLevel.html" class="Module">1Lab.HLevel</a>
<a id="149" class="Keyword">open</a> <a id="154" class="Keyword">import</a> <a id="161" href="1Lab.Equiv.html" class="Module">1Lab.Equiv</a>
<a id="172" class="Keyword">open</a> <a id="177" class="Keyword">import</a> <a id="184" href="1Lab.Path.html" class="Module">1Lab.Path</a>
<a id="194" class="Keyword">open</a> <a id="199" class="Keyword">import</a> <a id="206" href="1Lab.Type.html" class="Module">1Lab.Type</a>

<a id="217" class="Keyword">open</a> <a id="222" class="Keyword">import</a> <a id="229" href="Data.Nat.html" class="Module">Data.Nat</a>

<a id="239" class="Keyword">module</a> <a id="246" href="Data.Int.html" class="Module">Data.Int</a> <a id="255" class="Keyword">where</a>
</pre>
<h1 id="integers"><a href="#integers" class="header-link">Integers<span class="header-link-emoji">🔗</span></a></h1>
<p>The <strong>integers</strong> are what you get when you complete the <a href="Algebra.Monoid.html#ℕ-+">additive monoid structure on the naturals</a> into a <a href="Algebra.Group.html">group</a>. In non-cubical Agda, a representation of the integers as a coproduct <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="double-struck">N</mi><mo>∐</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">\bb{N} \coprod \bb{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathbb">N</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∐</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathbb">N</span></span></span></span> with one of the factors offset (to avoid having two zeroes) is adopted. In Cubical Agda we can adopt a representation much closer to a “classical” construction of the integers:</p>
<pre class="Agda"><a id="771" class="Keyword">data</a> <a id="Int"></a><a data-type="Type" id="776" href="Data.Int.html#776" class="Datatype">Int</a> <a id="780" class="Symbol">:</a> <a id="782" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="787" class="Keyword">where</a>
  <a id="Int.diff"></a><a data-type="Nat → Nat → Int" id="795" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="800" class="Symbol">:</a> <a id="802" class="Symbol">(</a><a id="803" href="Data.Int.html#803" class="Bound">x</a> <a id="805" href="Data.Int.html#805" class="Bound">y</a> <a id="807" class="Symbol">:</a> <a data-type="Type" id="809" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a><a id="812" class="Symbol">)</a> <a id="814" class="Symbol">→</a> <a data-type="Type" id="816" href="Data.Int.html#776" class="Datatype">Int</a>
  <a id="Int.quot"></a><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="822" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="827" class="Symbol">:</a> <a id="829" class="Symbol">(</a><a id="830" href="Data.Int.html#830" class="Bound">m</a> <a id="832" href="Data.Int.html#832" class="Bound">n</a> <a id="834" class="Symbol">:</a> <a data-type="Type" id="836" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a><a id="839" class="Symbol">)</a> <a id="841" class="Symbol">→</a> <a data-type="Nat → Nat → Int" id="843" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="848" href="Data.Int.html#830" class="Bound">m</a> <a id="850" href="Data.Int.html#832" class="Bound">n</a> <a data-type="A → A → Type ℓ" id="852" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Nat → Nat → Int" id="854" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="859" class="Symbol">(</a><a data-type="Nat → Nat" id="860" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="864" href="Data.Int.html#830" class="Bound">m</a><a id="865" class="Symbol">)</a> <a id="867" class="Symbol">(</a><a data-type="Nat → Nat" id="868" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="872" href="Data.Int.html#832" class="Bound">n</a><a id="873" class="Symbol">)</a>
</pre>
<p>This is an alternative representation of the construction of integers as pairs <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mspace></mspace><mspace width="0.1111em"></mspace><mo lspace="0em" rspace="0.17em"></mo><mtext> ⁣</mtext><mo lspace="0em" rspace="0em">:</mo><mspace width="0.3333em"></mspace><msup><mi mathvariant="double-struck">N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">(x , y)\colon \bb{N}^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace nobreak"></span><span class="mspace" style="margin-right:0.1111em;"></span><span class="mpunct"></span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mrel">:</span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord"><span class="mord mathbb">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a,b) = (c, d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span> iff <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>d</mi><mo>=</mo><mi>b</mi><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a + d = b + c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>:</span> An integer is an equivalence class of pairs of naturals, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span> is identified with <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>a</mi><mo separator="true">,</mo><mn>1</mn><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1 + a, 1 + b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>,</span> or, more type-theoretically, the integers are generated by the constructor <span class="Agda"><a data-type="Nat → Nat → Int" href="Data.Int.html#795" class="InductiveConstructor">diff</a></span> which embeds a pair of naturals, and the path constructor <span class="Agda"><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" href="Data.Int.html#822" class="InductiveConstructor">quot</a></span> which expresses that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span> = <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>a</mi><mo separator="true">,</mo><mn>1</mn><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1 + a, 1 + b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>.</span></p>
<p>As an example of using this generating path, we can prove that any pair <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span> has a path from the “canonical zero”, <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0, 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>:</span></p>
<pre class="Agda"><a id="zeroes"></a><a data-type="(n : Nat) → diff 0 0 ≡ diff n n" id="1487" href="Data.Int.html#1487" class="Function">zeroes</a> <a id="1494" class="Symbol">:</a> <a id="1496" class="Symbol">(</a><a id="1497" href="Data.Int.html#1497" class="Bound">n</a> <a id="1499" class="Symbol">:</a> <a data-type="Type" id="1501" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a><a id="1504" class="Symbol">)</a> <a id="1506" class="Symbol">→</a> <a data-type="Nat → Nat → Int" id="1508" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="1513" class="Number">0</a> <a id="1515" class="Number">0</a> <a data-type="A → A → Type ℓ" id="1517" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Nat → Nat → Int" id="1519" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="1524" href="Data.Int.html#1497" class="Bound">n</a> <a id="1526" href="Data.Int.html#1497" class="Bound">n</a>
<a data-type="(n : Nat) → diff 0 0 ≡ diff n n" id="1528" href="Data.Int.html#1487" class="Function">zeroes</a> <a data-type="Nat" id="1535" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="1540" class="Symbol">=</a> <a data-type="x ≡ x" id="1542" href="1Lab.Path.html#3593" class="Function">refl</a>
<a data-type="(n : Nat) → diff 0 0 ≡ diff n n" id="1547" href="Data.Int.html#1487" class="Function">zeroes</a> <a id="1554" class="Symbol">(</a><a data-type="Nat → Nat" id="1555" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="1559" href="Data.Int.html#1559" class="Bound">n</a><a id="1560" class="Symbol">)</a> <a id="1562" class="Symbol">=</a> <a data-type="(n : Nat) → diff 0 0 ≡ diff n n" id="1564" href="Data.Int.html#1487" class="Function">zeroes</a> <a id="1571" href="Data.Int.html#1559" class="Bound">n</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="1573" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="1575" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="1580" class="Symbol">_</a> <a id="1582" class="Symbol">_</a>
</pre>
<p>Furthermore, offsetting both components by the same natural does nothing:</p>
<pre class="Agda"><a id="cancel"></a><a data-type="(a b n : Nat) → diff a b ≡ diff (n + a) (n + b)" id="1672" href="Data.Int.html#1672" class="Function">cancel</a> <a id="1679" class="Symbol">:</a> <a id="1681" class="Symbol">(</a><a id="1682" href="Data.Int.html#1682" class="Bound">a</a> <a id="1684" href="Data.Int.html#1684" class="Bound">b</a> <a id="1686" href="Data.Int.html#1686" class="Bound">n</a> <a id="1688" class="Symbol">:</a> <a data-type="Type" id="1690" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a><a id="1693" class="Symbol">)</a> <a id="1695" class="Symbol">→</a> <a data-type="Nat → Nat → Int" id="1697" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="1702" href="Data.Int.html#1682" class="Bound">a</a> <a id="1704" href="Data.Int.html#1684" class="Bound">b</a> <a data-type="A → A → Type ℓ" id="1706" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Nat → Nat → Int" id="1708" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="1713" class="Symbol">(</a><a id="1714" href="Data.Int.html#1686" class="Bound">n</a> <a data-type="Nat → Nat → Nat" id="1716" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="1718" href="Data.Int.html#1682" class="Bound">a</a><a id="1719" class="Symbol">)</a> <a id="1721" class="Symbol">(</a><a id="1722" href="Data.Int.html#1686" class="Bound">n</a> <a data-type="Nat → Nat → Nat" id="1724" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="1726" href="Data.Int.html#1684" class="Bound">b</a><a id="1727" class="Symbol">)</a>
<a data-type="(a b n : Nat) → diff a b ≡ diff (n + a) (n + b)" id="1729" href="Data.Int.html#1672" class="Function">cancel</a> <a id="1736" href="Data.Int.html#1736" class="Bound">a</a> <a id="1738" href="Data.Int.html#1738" class="Bound">b</a> <a data-type="Nat" id="1740" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="1745" class="Symbol">=</a> <a data-type="x ≡ x" id="1747" href="1Lab.Path.html#3593" class="Function">refl</a>
<a data-type="(a b n : Nat) → diff a b ≡ diff (n + a) (n + b)" id="1752" href="Data.Int.html#1672" class="Function">cancel</a> <a id="1759" href="Data.Int.html#1759" class="Bound">a</a> <a id="1761" href="Data.Int.html#1761" class="Bound">b</a> <a id="1763" class="Symbol">(</a><a data-type="Nat → Nat" id="1764" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="1768" href="Data.Int.html#1768" class="Bound">n</a><a id="1769" class="Symbol">)</a> <a id="1771" class="Symbol">=</a> <a data-type="(a b n : Nat) → diff a b ≡ diff (n + a) (n + b)" id="1773" href="Data.Int.html#1672" class="Function">cancel</a> <a id="1780" href="Data.Int.html#1759" class="Bound">a</a> <a id="1782" href="Data.Int.html#1761" class="Bound">b</a> <a id="1784" href="Data.Int.html#1768" class="Bound">n</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="1786" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="1788" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="1793" class="Symbol">_</a> <a id="1795" class="Symbol">_</a>
</pre>
<p>All equivalence classes have a representative of the form <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span> or <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(b,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>:</span></p>
<pre class="Agda"><a id="offset-negative"></a><a data-type="(a b : Nat) → diff a (a + b) ≡ diff 0 b" id="1889" href="Data.Int.html#1889" class="Function">offset-negative</a> <a id="1905" class="Symbol">:</a> <a id="1907" class="Symbol">(</a><a id="1908" href="Data.Int.html#1908" class="Bound">a</a> <a id="1910" href="Data.Int.html#1910" class="Bound">b</a> <a id="1912" class="Symbol">:</a> <a data-type="Type" id="1914" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a><a id="1917" class="Symbol">)</a> <a id="1919" class="Symbol">→</a> <a data-type="Nat → Nat → Int" id="1921" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="1926" href="Data.Int.html#1908" class="Bound">a</a> <a id="1928" class="Symbol">(</a><a id="1929" href="Data.Int.html#1908" class="Bound">a</a> <a data-type="Nat → Nat → Nat" id="1931" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="1933" href="Data.Int.html#1910" class="Bound">b</a><a id="1934" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="1936" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Nat → Nat → Int" id="1938" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="1943" class="Number">0</a> <a id="1945" href="Data.Int.html#1910" class="Bound">b</a>
<a data-type="(a b : Nat) → diff a (a + b) ≡ diff 0 b" id="1947" href="Data.Int.html#1889" class="Function">offset-negative</a> <a data-type="Nat" id="1963" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="1968" href="Data.Int.html#1968" class="Bound">b</a> <a id="1970" class="Symbol">=</a> <a data-type="x ≡ x" id="1972" href="1Lab.Path.html#3593" class="Function">refl</a>
<a data-type="(a b : Nat) → diff a (a + b) ≡ diff 0 b" id="1977" href="Data.Int.html#1889" class="Function">offset-negative</a> <a id="1993" class="Symbol">(</a><a data-type="Nat → Nat" id="1994" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="1998" href="Data.Int.html#1998" class="Bound">a</a><a id="1999" class="Symbol">)</a> <a id="2001" href="Data.Int.html#2001" class="Bound">b</a> <a id="2003" class="Symbol">=</a>
  <a data-type="Nat → Nat → Int" id="2007" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="2012" class="Symbol">(</a><a data-type="Nat → Nat" id="2013" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2017" href="Data.Int.html#1998" class="Bound">a</a><a id="2018" class="Symbol">)</a> <a id="2020" class="Symbol">(</a><a data-type="Nat → Nat" id="2021" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2025" class="Symbol">(</a><a id="2026" href="Data.Int.html#1998" class="Bound">a</a> <a data-type="Nat → Nat → Nat" id="2028" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="2030" href="Data.Int.html#2001" class="Bound">b</a><a id="2031" class="Symbol">))</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2034" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="x ≡ y → y ≡ x" id="2037" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="2041" class="Symbol">(</a><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="2042" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="2047" class="Symbol">_</a> <a id="2049" class="Symbol">_)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2052" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a data-type="Nat → Nat → Int" id="2056" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="2061" href="Data.Int.html#1998" class="Bound">a</a> <a id="2063" class="Symbol">(</a><a id="2064" href="Data.Int.html#1998" class="Bound">a</a> <a data-type="Nat → Nat → Nat" id="2066" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="2068" href="Data.Int.html#2001" class="Bound">b</a><a id="2069" class="Symbol">)</a>             <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2083" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(a b : Nat) → diff a (a + b) ≡ diff 0 b" id="2086" href="Data.Int.html#1889" class="Function">offset-negative</a> <a id="2102" href="Data.Int.html#1998" class="Bound">a</a> <a id="2104" href="Data.Int.html#2001" class="Bound">b</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2106" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a data-type="Nat → Nat → Int" id="2110" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="2115" class="Number">0</a> <a id="2117" href="Data.Int.html#2001" class="Bound">b</a>                   <a data-type="(x : A) → x ≡ x" id="2137" href="1Lab.Path.html#46957" class="Function Operator">∎</a>

<a id="offset-positive"></a><a data-type="(a b : Nat) → diff (a + b) a ≡ diff b 0" id="2140" href="Data.Int.html#2140" class="Function">offset-positive</a> <a id="2156" class="Symbol">:</a> <a id="2158" class="Symbol">(</a><a id="2159" href="Data.Int.html#2159" class="Bound">a</a> <a id="2161" href="Data.Int.html#2161" class="Bound">b</a> <a id="2163" class="Symbol">:</a> <a data-type="Type" id="2165" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a><a id="2168" class="Symbol">)</a> <a id="2170" class="Symbol">→</a> <a data-type="Nat → Nat → Int" id="2172" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="2177" class="Symbol">(</a><a id="2178" href="Data.Int.html#2159" class="Bound">a</a> <a data-type="Nat → Nat → Nat" id="2180" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="2182" href="Data.Int.html#2161" class="Bound">b</a><a id="2183" class="Symbol">)</a> <a id="2185" href="Data.Int.html#2159" class="Bound">a</a> <a data-type="A → A → Type ℓ" id="2187" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Nat → Nat → Int" id="2189" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="2194" href="Data.Int.html#2161" class="Bound">b</a> <a id="2196" class="Number">0</a>
<a data-type="(a b : Nat) → diff (a + b) a ≡ diff b 0" id="2198" href="Data.Int.html#2140" class="Function">offset-positive</a> <a data-type="Nat" id="2214" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="2219" href="Data.Int.html#2219" class="Bound">b</a> <a id="2221" class="Symbol">=</a> <a data-type="x ≡ x" id="2223" href="1Lab.Path.html#3593" class="Function">refl</a>
<a data-type="(a b : Nat) → diff (a + b) a ≡ diff b 0" id="2228" href="Data.Int.html#2140" class="Function">offset-positive</a> <a id="2244" class="Symbol">(</a><a data-type="Nat → Nat" id="2245" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2249" href="Data.Int.html#2249" class="Bound">a</a><a id="2250" class="Symbol">)</a> <a id="2252" href="Data.Int.html#2252" class="Bound">b</a> <a id="2254" class="Symbol">=</a>
  <a data-type="Nat → Nat → Int" id="2258" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="2263" class="Symbol">(</a><a data-type="Nat → Nat" id="2264" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2268" class="Symbol">(</a><a id="2269" href="Data.Int.html#2249" class="Bound">a</a> <a data-type="Nat → Nat → Nat" id="2271" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="2273" href="Data.Int.html#2252" class="Bound">b</a><a id="2274" class="Symbol">))</a> <a id="2277" class="Symbol">(</a><a data-type="Nat → Nat" id="2278" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2282" href="Data.Int.html#2249" class="Bound">a</a><a id="2283" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2285" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="x ≡ y → y ≡ x" id="2288" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="2292" class="Symbol">(</a><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="2293" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="2298" class="Symbol">_</a> <a id="2300" class="Symbol">_)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2303" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a data-type="Nat → Nat → Int" id="2307" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="2312" class="Symbol">(</a><a id="2313" href="Data.Int.html#2249" class="Bound">a</a> <a data-type="Nat → Nat → Nat" id="2315" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="2317" href="Data.Int.html#2252" class="Bound">b</a><a id="2318" class="Symbol">)</a> <a id="2320" href="Data.Int.html#2249" class="Bound">a</a>             <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2334" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(a b : Nat) → diff (a + b) a ≡ diff b 0" id="2337" href="Data.Int.html#2140" class="Function">offset-positive</a> <a id="2353" href="Data.Int.html#2249" class="Bound">a</a> <a id="2355" href="Data.Int.html#2252" class="Bound">b</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2357" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a data-type="Nat → Nat → Int" id="2361" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="2366" href="Data.Int.html#2252" class="Bound">b</a> <a id="2368" class="Number">0</a>                   <a data-type="(x : A) → x ≡ x" id="2388" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
</pre>
<p>And finally, we can <em>prove</em> that this definition satisfies the more common equality used in the construction of integers as a quotient set: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, b) = (c, d)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span></span></span></span> if <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>d</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a + d) = (b + c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span>.</span></p>
<pre class="Agda"><a id="same-difference"></a><a data-type="a + d ≡ b + c → diff a b ≡ diff c d" id="2586" href="Data.Int.html#2586" class="Function">same-difference</a> <a id="2602" class="Symbol">:</a> <a id="2604" class="Symbol">{</a><a id="2605" href="Data.Int.html#2605" class="Bound">a</a> <a id="2607" href="Data.Int.html#2607" class="Bound">b</a> <a id="2609" href="Data.Int.html#2609" class="Bound">c</a> <a id="2611" href="Data.Int.html#2611" class="Bound">d</a> <a id="2613" class="Symbol">:</a> <a data-type="Type" id="2615" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a><a id="2618" class="Symbol">}</a> <a id="2620" class="Symbol">→</a> <a id="2622" href="Data.Int.html#2605" class="Bound">a</a> <a data-type="Nat → Nat → Nat" id="2624" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="2626" href="Data.Int.html#2611" class="Bound">d</a> <a data-type="A → A → Type ℓ" id="2628" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="2630" href="Data.Int.html#2607" class="Bound">b</a> <a data-type="Nat → Nat → Nat" id="2632" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="2634" href="Data.Int.html#2609" class="Bound">c</a> <a id="2636" class="Symbol">→</a> <a data-type="Nat → Nat → Int" id="2638" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="2643" href="Data.Int.html#2605" class="Bound">a</a> <a id="2645" href="Data.Int.html#2607" class="Bound">b</a> <a data-type="A → A → Type ℓ" id="2647" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Nat → Nat → Int" id="2649" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="2654" href="Data.Int.html#2609" class="Bound">c</a> <a id="2656" href="Data.Int.html#2611" class="Bound">d</a>
<a data-type="a + d ≡ b + c → diff a b ≡ diff c d" id="2658" href="Data.Int.html#2586" class="Function">same-difference</a> <a id="2674" class="Symbol">{</a><a data-type="Nat" id="2675" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="2679" class="Symbol">}</a> <a id="2681" class="Symbol">{</a><a id="2682" href="Data.Int.html#2682" class="Bound">b</a><a id="2683" class="Symbol">}</a> <a id="2685" class="Symbol">{</a><a id="2686" href="Data.Int.html#2686" class="Bound">c</a><a id="2687" class="Symbol">}</a> <a id="2689" class="Symbol">{</a><a id="2690" href="Data.Int.html#2690" class="Bound">d</a><a id="2691" class="Symbol">}</a> <a id="2693" href="Data.Int.html#2693" class="Bound">path</a> <a id="2698" class="Symbol">=</a>
  <a data-type="x ≡ y → y ≡ x" id="2702" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="2706" class="Symbol">(</a> <a data-type="Nat → Nat → Int" id="2708" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="2713" href="Data.Int.html#2686" class="Bound">c</a> <a id="2715" href="Data.Int.html#2690" class="Bound">d</a>       <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2723" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" id="2726" href="1Lab.Path.html#21189" class="Function">ap₂</a> <a data-type="Nat → Nat → Int" id="2730" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a data-type="x ≡ x" id="2735" href="1Lab.Path.html#3593" class="Function">refl</a> <a id="2740" href="Data.Int.html#2693" class="Bound">path</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2745" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a data-type="Nat → Nat → Int" id="2755" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="2760" href="Data.Int.html#2686" class="Bound">c</a> <a id="2762" class="Symbol">(</a><a id="2763" href="Data.Int.html#2682" class="Bound">b</a> <a data-type="Nat → Nat → Nat" id="2765" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="2767" href="Data.Int.html#2686" class="Bound">c</a><a id="2768" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2770" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" id="2773" href="1Lab.Path.html#21189" class="Function">ap₂</a> <a data-type="Nat → Nat → Int" id="2777" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a data-type="x ≡ x" id="2782" href="1Lab.Path.html#3593" class="Function">refl</a> <a id="2787" class="Symbol">(</a><a data-type="(x y : Nat) → x + y ≡ y + x" id="2788" href="Data.Nat.Properties.html#932" class="Function">+-commutative</a> <a id="2802" href="Data.Int.html#2682" class="Bound">b</a> <a id="2804" href="Data.Int.html#2686" class="Bound">c</a><a id="2805" class="Symbol">)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2807" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a data-type="Nat → Nat → Int" id="2817" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="2822" href="Data.Int.html#2686" class="Bound">c</a> <a id="2824" class="Symbol">(</a><a id="2825" href="Data.Int.html#2686" class="Bound">c</a> <a data-type="Nat → Nat → Nat" id="2827" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="2829" href="Data.Int.html#2682" class="Bound">b</a><a id="2830" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2832" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(a b : Nat) → diff a (a + b) ≡ diff 0 b" id="2835" href="Data.Int.html#1889" class="Function">offset-negative</a> <a id="2851" class="Symbol">_</a> <a id="2853" class="Symbol">_</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2855" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a data-type="Nat → Nat → Int" id="2865" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="2870" class="Number">0</a> <a id="2872" href="Data.Int.html#2682" class="Bound">b</a>       <a data-type="(x : A) → x ≡ x" id="2880" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
      <a id="2888" class="Symbol">)</a>
<a data-type="a + d ≡ b + c → diff a b ≡ diff c d" id="2890" href="Data.Int.html#2586" class="Function">same-difference</a> <a id="2906" class="Symbol">{</a><a data-type="Nat → Nat" id="2907" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2911" href="Data.Int.html#2911" class="Bound">a</a><a id="2912" class="Symbol">}</a> <a id="2914" class="Symbol">{</a><a data-type="Nat" id="2915" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="2919" class="Symbol">}</a> <a id="2921" class="Symbol">{</a><a id="2922" href="Data.Int.html#2922" class="Bound">c</a><a id="2923" class="Symbol">}</a> <a id="2925" class="Symbol">{</a><a id="2926" href="Data.Int.html#2926" class="Bound">d</a><a id="2927" class="Symbol">}</a> <a id="2929" href="Data.Int.html#2929" class="Bound">path</a> <a id="2934" class="Symbol">=</a>
  <a data-type="x ≡ y → y ≡ x" id="2938" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="2942" class="Symbol">(</a> <a data-type="Nat → Nat → Int" id="2944" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="2949" href="Data.Int.html#2922" class="Bound">c</a> <a id="2951" href="Data.Int.html#2926" class="Bound">d</a>             <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2965" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" id="2968" href="1Lab.Path.html#21189" class="Function">ap₂</a> <a data-type="Nat → Nat → Int" id="2972" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="2977" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="2978" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="2982" href="Data.Int.html#2929" class="Bound">path</a><a id="2986" class="Symbol">)</a> <a data-type="x ≡ x" id="2988" href="1Lab.Path.html#3593" class="Function">refl</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="2993" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a data-type="Nat → Nat → Int" id="3003" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="3008" class="Symbol">(</a><a data-type="Nat → Nat" id="3009" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="3013" href="Data.Int.html#2911" class="Bound">a</a> <a data-type="Nat → Nat → Nat" id="3015" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="3017" href="Data.Int.html#2926" class="Bound">d</a><a id="3018" class="Symbol">)</a> <a id="3020" href="Data.Int.html#2926" class="Bound">d</a>   <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3024" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" id="3027" href="1Lab.Path.html#21189" class="Function">ap₂</a> <a data-type="Nat → Nat → Int" id="3031" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="3036" class="Symbol">(</a><a data-type="(x y : Nat) → x + y ≡ y + x" id="3037" href="Data.Nat.Properties.html#932" class="Function">+-commutative</a> <a id="3051" class="Symbol">(</a><a data-type="Nat → Nat" id="3052" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="3056" href="Data.Int.html#2911" class="Bound">a</a><a id="3057" class="Symbol">)</a> <a id="3059" href="Data.Int.html#2926" class="Bound">d</a><a id="3060" class="Symbol">)</a> <a data-type="x ≡ x" id="3062" href="1Lab.Path.html#3593" class="Function">refl</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3067" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a data-type="Nat → Nat → Int" id="3077" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="3082" class="Symbol">(</a><a id="3083" href="Data.Int.html#2926" class="Bound">d</a> <a data-type="Nat → Nat → Nat" id="3085" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a data-type="Nat → Nat" id="3087" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="3091" href="Data.Int.html#2911" class="Bound">a</a><a id="3092" class="Symbol">)</a> <a id="3094" href="Data.Int.html#2926" class="Bound">d</a>   <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3098" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(a b : Nat) → diff (a + b) a ≡ diff b 0" id="3101" href="Data.Int.html#2140" class="Function">offset-positive</a> <a id="3117" class="Symbol">_</a> <a id="3119" class="Symbol">_</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3121" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
        <a data-type="Nat → Nat → Int" id="3131" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="3136" class="Symbol">(</a><a data-type="Nat → Nat" id="3137" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="3141" href="Data.Int.html#2911" class="Bound">a</a><a id="3142" class="Symbol">)</a> <a id="3144" class="Number">0</a>       <a data-type="(x : A) → x ≡ x" id="3152" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
      <a id="3160" class="Symbol">)</a>
<a data-type="a + d ≡ b + c → diff a b ≡ diff c d" id="3162" href="Data.Int.html#2586" class="Function">same-difference</a> <a id="3178" class="Symbol">{</a><a data-type="Nat → Nat" id="3179" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="3183" href="Data.Int.html#3183" class="Bound">a</a><a id="3184" class="Symbol">}</a> <a id="3186" class="Symbol">{</a><a data-type="Nat → Nat" id="3187" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="3191" href="Data.Int.html#3191" class="Bound">b</a><a id="3192" class="Symbol">}</a> <a id="3194" class="Symbol">{</a><a id="3195" href="Data.Int.html#3195" class="Bound">c</a><a id="3196" class="Symbol">}</a> <a id="3198" class="Symbol">{</a><a id="3199" href="Data.Int.html#3199" class="Bound">d</a><a id="3200" class="Symbol">}</a> <a id="3202" href="Data.Int.html#3202" class="Bound">path</a> <a id="3207" class="Symbol">=</a>
  <a data-type="Nat → Nat → Int" id="3211" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="3216" class="Symbol">(</a><a data-type="Nat → Nat" id="3217" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="3221" href="Data.Int.html#3183" class="Bound">a</a><a id="3222" class="Symbol">)</a> <a id="3224" class="Symbol">(</a><a data-type="Nat → Nat" id="3225" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="3229" href="Data.Int.html#3191" class="Bound">b</a><a id="3230" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3232" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="x ≡ y → y ≡ x" id="3235" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="3239" class="Symbol">(</a><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="3240" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="3245" class="Symbol">_</a> <a id="3247" class="Symbol">_)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3250" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a data-type="Nat → Nat → Int" id="3254" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="3259" href="Data.Int.html#3183" class="Bound">a</a> <a id="3261" href="Data.Int.html#3191" class="Bound">b</a>             <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3275" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="a + d ≡ b + c → diff a b ≡ diff c d" id="3278" href="Data.Int.html#2586" class="Function">same-difference</a> <a id="3294" class="Symbol">(</a><a data-type="suc x ≡ suc y → x ≡ y" id="3295" href="Data.Nat.Base.html#1635" class="Function">suc-inj</a> <a id="3303" href="Data.Int.html#3202" class="Bound">path</a><a id="3307" class="Symbol">)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="3309" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
  <a data-type="Nat → Nat → Int" id="3313" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="3318" href="Data.Int.html#3195" class="Bound">c</a> <a id="3320" href="Data.Int.html#3199" class="Bound">d</a>             <a data-type="(x : A) → x ≡ x" id="3334" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
</pre>
<p>Furthermore, using a cubical argument, we can prove that the <span class="Agda"><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" href="Data.Int.html#822" class="InductiveConstructor">quot</a></span> constructor satisfies the following two equalities, which are necessary when relating <span class="Agda"><a data-type="Type" href="Data.Int.html#776" class="Datatype">Int</a></span> to a more concrete definition which can be shown to have decidable equality:</p>
<pre class="Agda"><a id="quot-diamond"></a><a data-type="(a b : Nat) →
Square (quot a b) (quot a b) (quot (suc a) (suc b))
(quot (suc a) (suc b))" id="3601" href="Data.Int.html#3601" class="Function">quot-diamond</a> <a id="3614" class="Symbol">:</a> <a id="3616" class="Symbol">(</a><a id="3617" href="Data.Int.html#3617" class="Bound">a</a> <a id="3619" href="Data.Int.html#3619" class="Bound">b</a> <a id="3621" class="Symbol">:</a> <a data-type="Type" id="3623" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a><a id="3626" class="Symbol">)</a>
             <a id="3641" class="Symbol">→</a> <a data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" id="3643" href="1Lab.Path.html#9409" class="Function">Square</a> <a id="3650" class="Symbol">(</a><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="3651" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="3656" href="Data.Int.html#3617" class="Bound">a</a> <a id="3658" href="Data.Int.html#3619" class="Bound">b</a><a id="3659" class="Symbol">)</a> <a id="3661" class="Symbol">(</a><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="3662" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="3667" href="Data.Int.html#3617" class="Bound">a</a> <a id="3669" href="Data.Int.html#3619" class="Bound">b</a><a id="3670" class="Symbol">)</a>
                      <a id="3694" class="Symbol">(</a><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="3695" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="3700" class="Symbol">(</a><a data-type="Nat → Nat" id="3701" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="3705" href="Data.Int.html#3617" class="Bound">a</a><a id="3706" class="Symbol">)</a> <a id="3708" class="Symbol">(</a><a data-type="Nat → Nat" id="3709" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="3713" href="Data.Int.html#3619" class="Bound">b</a><a id="3714" class="Symbol">))</a>
                      <a id="3739" class="Symbol">(</a><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="3740" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="3745" class="Symbol">(</a><a data-type="Nat → Nat" id="3746" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="3750" href="Data.Int.html#3617" class="Bound">a</a><a id="3751" class="Symbol">)</a> <a id="3753" class="Symbol">(</a><a data-type="Nat → Nat" id="3754" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="3758" href="Data.Int.html#3619" class="Bound">b</a><a id="3759" class="Symbol">))</a>
<a data-type="(a b : Nat) →
Square (quot a b) (quot a b) (quot (suc a) (suc b))
(quot (suc a) (suc b))" id="3762" href="Data.Int.html#3601" class="Function">quot-diamond</a> <a id="3775" href="Data.Int.html#3775" class="Bound">a</a> <a id="3777" href="Data.Int.html#3777" class="Bound">b</a> <a id="3779" href="Data.Int.html#3779" class="Bound">i</a> <a id="3781" href="Data.Int.html#3781" class="Bound">j</a> <a id="3783" class="Symbol">=</a>
  <a id="3787" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="3793" class="Symbol">(λ</a> <a id="3796" href="Data.Int.html#3796" class="Bound">k</a> <a id="3798" class="Symbol">→</a> <a id="3800" class="Symbol">λ</a> <a id="3802" class="Symbol">{</a> <a id="3804" class="Symbol">(</a><a id="3805" href="Data.Int.html#3779" class="Bound">i</a> <a id="3807" class="Symbol">=</a> <a id="3809" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="3811" class="Symbol">)</a> <a id="3813" class="Symbol">→</a> <a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="3815" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="3820" href="Data.Int.html#3775" class="Bound">a</a> <a id="3822" href="Data.Int.html#3777" class="Bound">b</a> <a id="3824" href="Data.Int.html#3781" class="Bound">j</a>
                 <a id="3843" class="Symbol">;</a> <a id="3845" class="Symbol">(</a><a id="3846" href="Data.Int.html#3779" class="Bound">i</a> <a id="3848" class="Symbol">=</a> <a id="3850" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="3852" class="Symbol">)</a> <a id="3854" class="Symbol">→</a> <a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="3856" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="3861" class="Symbol">(</a><a data-type="Nat → Nat" id="3862" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="3866" href="Data.Int.html#3775" class="Bound">a</a><a id="3867" class="Symbol">)</a> <a id="3869" class="Symbol">(</a><a data-type="Nat → Nat" id="3870" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="3874" href="Data.Int.html#3777" class="Bound">b</a><a id="3875" class="Symbol">)</a> <a id="3877" class="Symbol">(</a><a id="3878" href="Data.Int.html#3781" class="Bound">j</a> <a id="3880" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="3882" href="Data.Int.html#3796" class="Bound">k</a><a id="3883" class="Symbol">)</a>
                 <a id="3902" class="Symbol">;</a> <a id="3904" class="Symbol">(</a><a id="3905" href="Data.Int.html#3781" class="Bound">j</a> <a id="3907" class="Symbol">=</a> <a id="3909" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="3911" class="Symbol">)</a> <a id="3913" class="Symbol">→</a> <a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="3915" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="3920" href="Data.Int.html#3775" class="Bound">a</a> <a id="3922" href="Data.Int.html#3777" class="Bound">b</a> <a id="3924" href="Data.Int.html#3779" class="Bound">i</a>
                 <a id="3943" class="Symbol">;</a> <a id="3945" class="Symbol">(</a><a id="3946" href="Data.Int.html#3781" class="Bound">j</a> <a id="3948" class="Symbol">=</a> <a id="3950" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="3952" class="Symbol">)</a> <a id="3954" class="Symbol">→</a> <a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="3956" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="3961" class="Symbol">(</a><a data-type="Nat → Nat" id="3962" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="3966" href="Data.Int.html#3775" class="Bound">a</a><a id="3967" class="Symbol">)</a> <a id="3969" class="Symbol">(</a><a data-type="Nat → Nat" id="3970" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="3974" href="Data.Int.html#3777" class="Bound">b</a><a id="3975" class="Symbol">)</a> <a id="3977" class="Symbol">(</a><a id="3978" href="Data.Int.html#3779" class="Bound">i</a> <a id="3980" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="3982" href="Data.Int.html#3796" class="Bound">k</a><a id="3983" class="Symbol">)</a>
                 <a id="4002" class="Symbol">})</a>
        <a id="4013" class="Symbol">(</a><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="4014" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="4019" href="Data.Int.html#3775" class="Bound">a</a> <a id="4021" href="Data.Int.html#3777" class="Bound">b</a> <a id="4023" class="Symbol">(</a><a id="4024" href="Data.Int.html#3779" class="Bound">i</a> <a id="4026" href="1Lab.Path.html#2226" class="Primitive Operator">∨</a> <a id="4028" href="Data.Int.html#3781" class="Bound">j</a><a id="4029" class="Symbol">))</a>

<a id="quot-triangle"></a><a data-type="(a b : Nat) (i : I) → diff a b ≡ quot a b i" id="4033" href="Data.Int.html#4033" class="Function">quot-triangle</a> <a id="4047" class="Symbol">:</a> <a id="4049" class="Symbol">(</a><a id="4050" href="Data.Int.html#4050" class="Bound">a</a> <a id="4052" href="Data.Int.html#4052" class="Bound">b</a> <a id="4054" class="Symbol">:</a> <a data-type="Type" id="4056" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a><a id="4059" class="Symbol">)</a> <a id="4061" class="Symbol">(</a><a id="4062" href="Data.Int.html#4062" class="Bound">i</a> <a id="4064" class="Symbol">:</a> <a id="4066" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="4067" class="Symbol">)</a> <a id="4069" class="Symbol">→</a> <a data-type="Nat → Nat → Int" id="4071" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="4076" href="Data.Int.html#4050" class="Bound">a</a> <a id="4078" href="Data.Int.html#4052" class="Bound">b</a> <a data-type="A → A → Type ℓ" id="4080" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="4082" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="4087" href="Data.Int.html#4050" class="Bound">a</a> <a id="4089" href="Data.Int.html#4052" class="Bound">b</a> <a id="4091" href="Data.Int.html#4062" class="Bound">i</a>
<a data-type="(a b : Nat) (i : I) → diff a b ≡ quot a b i" id="4093" href="Data.Int.html#4033" class="Function">quot-triangle</a> <a id="4107" href="Data.Int.html#4107" class="Bound">a</a> <a id="4109" href="Data.Int.html#4109" class="Bound">b</a> <a id="4111" href="Data.Int.html#4111" class="Bound">i</a> <a id="4113" href="Data.Int.html#4113" class="Bound">j</a> <a id="4115" class="Symbol">=</a> <a id="4117" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="4123" class="Symbol">(λ</a> <a id="4126" href="Data.Int.html#4126" class="Bound">k</a> <a id="4128" class="Symbol">→</a> <a id="4130" class="Symbol">λ</a>
  <a id="4134" class="Symbol">{</a> <a id="4136" class="Symbol">(</a><a id="4137" href="Data.Int.html#4111" class="Bound">i</a> <a id="4139" class="Symbol">=</a> <a id="4141" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="4143" class="Symbol">)</a> <a id="4145" class="Symbol">→</a> <a data-type="Nat → Nat → Int" id="4147" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="4152" href="Data.Int.html#4107" class="Bound">a</a> <a id="4154" href="Data.Int.html#4109" class="Bound">b</a>
  <a id="4158" class="Symbol">;</a> <a id="4160" class="Symbol">(</a><a id="4161" href="Data.Int.html#4113" class="Bound">j</a> <a id="4163" class="Symbol">=</a> <a id="4165" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="4167" class="Symbol">)</a> <a id="4169" class="Symbol">→</a> <a data-type="Nat → Nat → Int" id="4171" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="4176" href="Data.Int.html#4107" class="Bound">a</a> <a id="4178" href="Data.Int.html#4109" class="Bound">b</a>
  <a id="4182" class="Symbol">;</a> <a id="4184" class="Symbol">(</a><a id="4185" href="Data.Int.html#4113" class="Bound">j</a> <a id="4187" class="Symbol">=</a> <a id="4189" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="4191" class="Symbol">)</a> <a id="4193" class="Symbol">→</a> <a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="4195" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="4200" href="Data.Int.html#4107" class="Bound">a</a> <a id="4202" href="Data.Int.html#4109" class="Bound">b</a> <a id="4204" class="Symbol">(</a><a id="4205" href="Data.Int.html#4111" class="Bound">i</a> <a id="4207" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="4209" href="Data.Int.html#4126" class="Bound">k</a><a id="4210" class="Symbol">)</a>
  <a id="4214" class="Symbol">})</a> <a id="4217" class="Symbol">(</a><a data-type="Nat → Nat → Int" id="4218" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="4223" href="Data.Int.html#4107" class="Bound">a</a> <a id="4225" href="Data.Int.html#4109" class="Bound">b</a><a id="4226" class="Symbol">)</a>
</pre>
<p>As a finishing touch, we give <code>Int</code> instances for <span class="Agda"><a data-type="(A : Type a) → Type (lsuc a)" href="Agda.Builtin.FromNat.html#197" class="Record">Number</a></span> and <span class="Agda"><a data-type="(A : Type a) → Type (lsuc a)" href="Agda.Builtin.FromNeg.html#197" class="Record">Negative</a></span>, meaning that we can use positive and negative literals with integer type:</p>
<pre class="Agda"><a id="4405" class="Keyword">instance</a>
  <a id="Number-Int"></a><a data-type="Number Int" id="4416" href="Data.Int.html#4416" class="Function">Number-Int</a> <a id="4427" class="Symbol">:</a> <a data-type="(A : Type a) → Type (lsuc a)" id="4429" href="Agda.Builtin.FromNat.html#197" class="Record">Number</a> <a data-type="Type" id="4436" href="Data.Int.html#776" class="Datatype">Int</a>
  <a data-type="Number Int" id="4442" href="Data.Int.html#4416" class="Function">Number-Int</a> <a id="4453" class="Symbol">.</a><a data-type="Number A → Nat → Type a" id="4454" href="Agda.Builtin.FromNat.html#253" class="Field">Number.Constraint</a> <a id="4472" class="Symbol">_</a> <a id="4474" class="Symbol">=</a> <a data-type="Type" id="4476" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
  <a data-type="Number Int" id="4480" href="Data.Int.html#4416" class="Function">Number-Int</a> <a id="4491" class="Symbol">.</a><a data-type="⦃ r : Number A ⦄ (n : Nat) ⦃ _ : r .Constraint n ⦄ → A" id="4492" href="Agda.Builtin.FromNat.html#282" class="Field">Number.fromNat</a> <a id="4507" href="Data.Int.html#4507" class="Bound">n</a> <a id="4509" class="Symbol">=</a> <a data-type="Nat → Nat → Int" id="4511" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="4516" href="Data.Int.html#4507" class="Bound">n</a> <a id="4518" class="Number">0</a>

  <a id="Negative-Int"></a><a data-type="Negative Int" id="4523" href="Data.Int.html#4523" class="Function">Negative-Int</a> <a id="4536" class="Symbol">:</a> <a data-type="(A : Type a) → Type (lsuc a)" id="4538" href="Agda.Builtin.FromNeg.html#197" class="Record">Negative</a> <a data-type="Type" id="4547" href="Data.Int.html#776" class="Datatype">Int</a>
  <a data-type="Negative Int" id="4553" href="Data.Int.html#4523" class="Function">Negative-Int</a> <a id="4566" class="Symbol">.</a><a data-type="Negative A → Nat → Type a" id="4567" href="Agda.Builtin.FromNeg.html#255" class="Field">Negative.Constraint</a> <a id="4587" class="Symbol">_</a> <a id="4589" class="Symbol">=</a> <a data-type="Type" id="4591" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
  <a data-type="Negative Int" id="4595" href="Data.Int.html#4523" class="Function">Negative-Int</a> <a id="4608" class="Symbol">.</a><a data-type="⦃ r : Negative A ⦄ (n : Nat) ⦃ _ : r .Constraint n ⦄ → A" id="4609" href="Agda.Builtin.FromNeg.html#284" class="Field">Negative.fromNeg</a> <a id="4626" href="Data.Int.html#4626" class="Bound">n</a> <a id="4628" class="Symbol">=</a> <a data-type="Nat → Nat → Int" id="4630" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="4635" class="Number">0</a> <a id="4637" href="Data.Int.html#4626" class="Bound">n</a>
</pre>
<h2 id="discreteness"><a href="#discreteness" class="header-link">Discreteness<span class="header-link-emoji">🔗</span></a></h2>
<p>To prove that <span class="Agda"><a data-type="Type" href="Data.Int.html#776" class="Datatype">Int</a></span> is <a data-type="Type ℓ → Type ℓ" href="1Lab.Type.Dec.html#528">discrete</a> (and thus <a data-type="Type ℓ → Type ℓ" href="1Lab.HLevel.html#3356">a set</a>), we prove that it is equivalent to an inductive (rather than higher-inductive) definition of the integers. Since this definition (which we call <span class="Agda"><a href="Data.Int.html#5074" class="Datatype">Int&#39;</a></span>) has decidable equality, it is a set.</p>
<pre class="Agda"><a id="5004" class="Keyword">module</a> <a id="5011" href="Data.Int.html#5011" class="Module">_</a> <a id="5013" class="Keyword">where</a>
  <a id="5021" class="Keyword">open</a> <a id="5026" class="Keyword">import</a> <a id="5033" href="Data.Int.Inductive.html" class="Module">Data.Int.Inductive</a>
    <a id="5056" class="Keyword">renaming</a> <a id="5065" class="Symbol">(</a> <a data-type="Type" id="5067" href="Agda.Builtin.Int.html#246" class="Datatype">Int</a> <a id="5071" class="Symbol">to</a> <a id="5074" class="Datatype">Int&#39;</a>
             <a id="5092" class="Symbol">;</a> <a data-type="Discrete Int" id="5094" href="Data.Int.Inductive.html#1175" class="Function">Discrete-Int</a> <a id="5107" class="Symbol">to</a> <a id="5110" class="Function">Discrete-Int&#39;</a>
             <a id="5137" class="Symbol">)</a>
</pre>
<p>There is a canonical map which takes pairs of naturals to their difference as an <span class="Agda"><a href="Data.Int.html#5074" class="Datatype">Int&#39;</a></span>, which is <span class="Agda"><a data-type="Nat → Nat → Int" href="Data.Int.Inductive.html#856" class="Function Operator">ℕ-</a></span>; It can be shown that this map extends to a function from <span class="Agda"><a data-type="Type" href="Data.Int.html#776" class="Datatype">Int</a></span>, since it respects the generating equation <span class="Agda"><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" href="Data.Int.html#822" class="InductiveConstructor">quot</a></span> definitionally:</p>
<pre class="Agda">  <a id="5416" class="Keyword">private</a>
    <a id="5428" href="Data.Int.html#5428" class="Function">toInt&#39;</a> <a id="5435" class="Symbol">:</a> <a data-type="Type" id="5437" href="Data.Int.html#776" class="Datatype">Int</a> <a id="5441" class="Symbol">→</a> <a id="5443" href="Data.Int.html#5074" class="Datatype">Int&#39;</a>
    <a id="5452" href="Data.Int.html#5428" class="Function">toInt&#39;</a> <a id="5459" class="Symbol">(</a><a data-type="Nat → Nat → Int" id="5460" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="5465" href="Data.Int.html#5465" class="Bound">x</a> <a id="5467" href="Data.Int.html#5467" class="Bound">y</a><a id="5468" class="Symbol">)</a> <a id="5470" class="Symbol">=</a> <a id="5472" href="Data.Int.html#5465" class="Bound">x</a> <a data-type="Nat → Nat → Int" id="5474" href="Data.Int.Inductive.html#856" class="Function Operator">ℕ-</a> <a id="5477" href="Data.Int.html#5467" class="Bound">y</a>
    <a id="5483" href="Data.Int.html#5428" class="Function">toInt&#39;</a> <a id="5490" class="Symbol">(</a><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="5491" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="5496" href="Data.Int.html#5496" class="Bound">m</a> <a id="5498" href="Data.Int.html#5498" class="Bound">n</a> <a id="5500" href="Data.Int.html#5500" class="Bound">i</a><a id="5501" class="Symbol">)</a> <a id="5503" class="Symbol">=</a> <a id="5505" href="Data.Int.html#5496" class="Bound">m</a> <a data-type="Nat → Nat → Int" id="5507" href="Data.Int.Inductive.html#856" class="Function Operator">ℕ-</a> <a id="5510" href="Data.Int.html#5498" class="Bound">n</a>

    <a id="5517" href="Data.Int.html#5517" class="Function">fromInt&#39;</a> <a id="5526" class="Symbol">:</a> <a id="5528" href="Data.Int.html#5074" class="Datatype">Int&#39;</a> <a id="5533" class="Symbol">→</a> <a data-type="Type" id="5535" href="Data.Int.html#776" class="Datatype">Int</a>
    <a id="5543" href="Data.Int.html#5517" class="Function">fromInt&#39;</a> <a id="5552" class="Symbol">(</a><a data-type="Nat → Int" id="5553" href="Agda.Builtin.Int.html#264" class="InductiveConstructor">pos</a> <a id="5557" href="Data.Int.html#5557" class="Bound">x</a><a id="5558" class="Symbol">)</a> <a id="5560" class="Symbol">=</a> <a data-type="Nat → Nat → Int" id="5562" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="5567" href="Data.Int.html#5557" class="Bound">x</a> <a id="5569" class="Number">0</a>
    <a id="5575" href="Data.Int.html#5517" class="Function">fromInt&#39;</a> <a id="5584" class="Symbol">(</a><a data-type="Nat → Int" id="5585" href="Agda.Builtin.Int.html#291" class="InductiveConstructor">negsuc</a> <a id="5592" href="Data.Int.html#5592" class="Bound">x</a><a id="5593" class="Symbol">)</a> <a id="5595" class="Symbol">=</a> <a data-type="Nat → Nat → Int" id="5597" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="5602" class="Number">0</a> <a id="5604" class="Symbol">(</a><a data-type="Nat → Nat" id="5605" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="5609" href="Data.Int.html#5592" class="Bound">x</a><a id="5610" class="Symbol">)</a>
</pre>
<p>Mapping from <span class="Agda"><a href="Data.Int.html#5074" class="Datatype">Int&#39;</a></span> to <span class="Agda"><a data-type="Type" href="Data.Int.html#776" class="Datatype">Int</a></span> sends the positive numbers to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> and the negative numbers to <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0, x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>.</span></p>
<pre class="Agda">    <a id="5750" href="Data.Int.html#5750" class="Function">toFromInt&#39;</a> <a id="5761" class="Symbol">:</a> <a id="5763" class="Symbol">(</a><a id="5764" href="Data.Int.html#5764" class="Bound">x</a> <a id="5766" class="Symbol">:</a> <a data-type="Type" id="5768" href="Data.Int.html#776" class="Datatype">Int</a><a id="5771" class="Symbol">)</a> <a id="5773" class="Symbol">→</a> <a id="5775" href="Data.Int.html#5517" class="Function">fromInt&#39;</a> <a id="5784" class="Symbol">(</a><a id="5785" href="Data.Int.html#5428" class="Function">toInt&#39;</a> <a id="5792" href="Data.Int.html#5764" class="Bound">x</a><a id="5793" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="5795" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="5797" href="Data.Int.html#5764" class="Bound">x</a>
    <a id="5803" href="Data.Int.html#5750" class="Function">toFromInt&#39;</a> <a id="5814" class="Symbol">(</a><a data-type="Nat → Nat → Int" id="5815" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="5820" href="Data.Int.html#5820" class="Bound">x</a> <a data-type="Nat" id="5822" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="5826" class="Symbol">)</a>            <a id="5839" class="Symbol">=</a> <a data-type="x ≡ x" id="5841" href="1Lab.Path.html#3593" class="Function">refl</a>
    <a id="5850" href="Data.Int.html#5750" class="Function">toFromInt&#39;</a> <a id="5861" class="Symbol">(</a><a data-type="Nat → Nat → Int" id="5862" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a data-type="Nat" id="5867" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="5872" class="Symbol">(</a><a data-type="Nat → Nat" id="5873" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="5877" href="Data.Int.html#5877" class="Bound">y</a><a id="5878" class="Symbol">))</a>      <a id="5886" class="Symbol">=</a> <a data-type="x ≡ x" id="5888" href="1Lab.Path.html#3593" class="Function">refl</a>
    <a id="5897" href="Data.Int.html#5750" class="Function">toFromInt&#39;</a> <a id="5908" class="Symbol">(</a><a data-type="Nat → Nat → Int" id="5909" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="5914" class="Symbol">(</a><a data-type="Nat → Nat" id="5915" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="5919" href="Data.Int.html#5919" class="Bound">x</a><a id="5920" class="Symbol">)</a> <a id="5922" class="Symbol">(</a><a data-type="Nat → Nat" id="5923" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="5927" href="Data.Int.html#5927" class="Bound">y</a><a id="5928" class="Symbol">))</a>   <a id="5933" class="Symbol">=</a> <a id="5935" href="Data.Int.html#5750" class="Function">toFromInt&#39;</a> <a id="5946" class="Symbol">(</a><a data-type="Nat → Nat → Int" id="5947" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="5952" href="Data.Int.html#5919" class="Bound">x</a> <a id="5954" href="Data.Int.html#5927" class="Bound">y</a><a id="5955" class="Symbol">)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="5957" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="5959" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="5964" class="Symbol">_</a> <a id="5966" class="Symbol">_</a>

    <a id="5973" href="Data.Int.html#5750" class="Function">toFromInt&#39;</a> <a id="5984" class="Symbol">(</a><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="5985" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="5990" href="Data.Int.html#5990" class="Bound">m</a> <a data-type="Nat" id="5992" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="5997" href="Data.Int.html#5997" class="Bound">i</a><a id="5998" class="Symbol">)</a>          <a id="6009" class="Symbol">=</a> <a data-type="(a b : Nat) (i : I) → diff a b ≡ quot a b i" id="6011" href="Data.Int.html#4033" class="Function">quot-triangle</a> <a id="6025" class="Symbol">_</a> <a id="6027" class="Symbol">_</a> <a id="6029" href="Data.Int.html#5997" class="Bound">i</a>
    <a id="6035" href="Data.Int.html#5750" class="Function">toFromInt&#39;</a> <a id="6046" class="Symbol">(</a><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="6047" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a data-type="Nat" id="6052" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="6057" class="Symbol">(</a><a data-type="Nat → Nat" id="6058" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="6062" href="Data.Int.html#6062" class="Bound">n</a><a id="6063" class="Symbol">)</a> <a id="6065" href="Data.Int.html#6065" class="Bound">i</a><a id="6066" class="Symbol">)</a>    <a id="6071" class="Symbol">=</a> <a data-type="(a b : Nat) (i : I) → diff a b ≡ quot a b i" id="6073" href="Data.Int.html#4033" class="Function">quot-triangle</a> <a id="6087" class="Symbol">_</a> <a id="6089" class="Symbol">_</a> <a id="6091" href="Data.Int.html#6065" class="Bound">i</a>
    <a id="6097" href="Data.Int.html#5750" class="Function">toFromInt&#39;</a> <a id="6108" class="Symbol">(</a><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="6109" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="6114" class="Symbol">(</a><a data-type="Nat → Nat" id="6115" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="6119" href="Data.Int.html#6119" class="Bound">m</a><a id="6120" class="Symbol">)</a> <a id="6122" class="Symbol">(</a><a data-type="Nat → Nat" id="6123" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="6127" href="Data.Int.html#6127" class="Bound">n</a><a id="6128" class="Symbol">)</a> <a id="6130" href="Data.Int.html#6130" class="Bound">i</a><a id="6131" class="Symbol">)</a> <a id="6133" class="Symbol">=</a>
      <a id="6141" href="Data.Int.html#5750" class="Function">toFromInt&#39;</a> <a id="6152" class="Symbol">(</a><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="6153" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="6158" class="Symbol">_</a> <a id="6160" class="Symbol">_</a> <a id="6162" href="Data.Int.html#6130" class="Bound">i</a><a id="6163" class="Symbol">)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="6165" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(a b : Nat) →
Square (quot a b) (quot a b) (quot (suc a) (suc b))
(quot (suc a) (suc b))" id="6167" href="Data.Int.html#3601" class="Function">quot-diamond</a> <a id="6180" class="Symbol">_</a> <a id="6182" class="Symbol">_</a> <a id="6184" href="Data.Int.html#6130" class="Bound">i</a>

    <a id="6191" href="Data.Int.html#6191" class="Function">fromToInt&#39;</a> <a id="6202" class="Symbol">:</a> <a id="6204" class="Symbol">(</a><a id="6205" href="Data.Int.html#6205" class="Bound">x</a> <a id="6207" class="Symbol">:</a> <a id="6209" href="Data.Int.html#5074" class="Datatype">Int&#39;</a><a id="6213" class="Symbol">)</a> <a id="6215" class="Symbol">→</a> <a id="6217" href="Data.Int.html#5428" class="Function">toInt&#39;</a> <a id="6224" class="Symbol">(</a><a id="6225" href="Data.Int.html#5517" class="Function">fromInt&#39;</a> <a id="6234" href="Data.Int.html#6205" class="Bound">x</a><a id="6235" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="6237" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="6239" href="Data.Int.html#6205" class="Bound">x</a>
    <a id="6245" href="Data.Int.html#6191" class="Function">fromToInt&#39;</a> <a id="6256" class="Symbol">(</a><a data-type="Nat → Int" id="6257" href="Agda.Builtin.Int.html#264" class="InductiveConstructor">pos</a> <a id="6261" href="Data.Int.html#6261" class="Bound">x</a><a id="6262" class="Symbol">)</a> <a id="6264" class="Symbol">=</a> <a data-type="x ≡ x" id="6266" href="1Lab.Path.html#3593" class="Function">refl</a>
    <a id="6275" href="Data.Int.html#6191" class="Function">fromToInt&#39;</a> <a id="6286" class="Symbol">(</a><a data-type="Nat → Int" id="6287" href="Agda.Builtin.Int.html#291" class="InductiveConstructor">negsuc</a> <a id="6294" href="Data.Int.html#6294" class="Bound">x</a><a id="6295" class="Symbol">)</a> <a id="6297" class="Symbol">=</a> <a data-type="x ≡ x" id="6299" href="1Lab.Path.html#3593" class="Function">refl</a>

    <a id="6309" href="Data.Int.html#6309" class="Function">Int&#39;≡Int</a> <a id="6318" class="Symbol">:</a> <a id="6320" href="Data.Int.html#5074" class="Datatype">Int&#39;</a> <a data-type="A → A → Type ℓ" id="6325" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="Type" id="6327" href="Data.Int.html#776" class="Datatype">Int</a>
    <a id="6335" href="Data.Int.html#6309" class="Function">Int&#39;≡Int</a> <a id="6344" class="Symbol">=</a> <a data-type="Iso A B₁ → A ≡ B₁" id="6346" href="1Lab.Univalence.html#11319" class="Function">Iso→Path</a> <a id="6355" class="Symbol">(</a><a id="6356" href="Data.Int.html#5517" class="Function">fromInt&#39;</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="6365" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="(inv₁ : B₁ → A) (rinv₁ : is-right-inverse inv₁ f)
(linv₁ : is-left-inverse inv₁ f) →
is-iso f" id="6367" href="1Lab.Equiv.html#6116" class="InductiveConstructor">iso</a> <a id="6371" href="Data.Int.html#5428" class="Function">toInt&#39;</a> <a id="6378" href="Data.Int.html#5750" class="Function">toFromInt&#39;</a> <a id="6389" href="Data.Int.html#6191" class="Function">fromToInt&#39;</a><a id="6399" class="Symbol">)</a>
</pre>
<p>With a quick appeal to <span class="Agda"><a data-type="Iso A B₁ → A ≡ B₁" href="1Lab.Univalence.html#11319" class="Function">univalence</a></span>, we get that our desired type of integers is a set:</p>
<pre class="Agda">  <a data-type="Discrete Int" id="6527" href="Data.Int.html#6527" class="Function">Discrete-Int</a> <a id="6540" class="Symbol">:</a> <a data-type="Type ℓ → Type ℓ" id="6542" href="1Lab.Type.Dec.html#528" class="Function">Discrete</a> <a data-type="Type" id="6551" href="Data.Int.html#776" class="Datatype">Int</a>
  <a data-type="Discrete Int" id="6557" href="Data.Int.html#6527" class="Function">Discrete-Int</a> <a id="6570" class="Symbol">=</a> <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="6572" href="1Lab.Path.html#15309" class="Function">subst</a> <a data-type="Type ℓ → Type ℓ" id="6578" href="1Lab.Type.Dec.html#528" class="Function">Discrete</a> <a id="6587" href="Data.Int.html#6309" class="Function">Int&#39;≡Int</a> <a id="6596" href="Data.Int.html#5110" class="Function">Discrete-Int&#39;</a>

  <a data-type="is-set Int" id="6613" href="Data.Int.html#6613" class="Function">Int-is-set</a> <a id="6624" class="Symbol">:</a> <a data-type="Type ℓ → Type ℓ" id="6626" href="1Lab.HLevel.html#3356" class="Function">is-set</a> <a data-type="Type" id="6633" href="Data.Int.html#776" class="Datatype">Int</a>
  <a data-type="is-set Int" id="6639" href="Data.Int.html#6613" class="Function">Int-is-set</a> <a id="6650" class="Symbol">=</a> <a data-type="Discrete A → is-set A" id="6652" href="1Lab.HLevel.Sets.html#3125" class="Function">Discrete→is-set</a> <a data-type="Discrete Int" id="6668" href="Data.Int.html#6527" class="Function">Discrete-Int</a>
</pre>
<h1 id="recursion"><a href="#recursion" class="header-link">Recursion<span class="header-link-emoji">🔗</span></a></h1>
<p>If we want to define a map <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi mathvariant="double-struck">Z</mi><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">f : \bb{Z} \to X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6889em;"></span><span class="mord mathbb">Z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span>,</span> it suffices to give a function <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><msup><mi mathvariant="double-struck">N</mi><mn>2</mn></msup><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">f : \bb{N}^2 \to X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathbb">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> which respects the quotient, in the following sense:</p>
<pre class="Agda"><a id="Int-rec"></a><a data-type="(f : Nat → Nat → X) →
((a b : Nat) → f a b ≡ f (suc a) (suc b)) → Int → X" id="6860" href="Data.Int.html#6860" class="Function">Int-rec</a> <a id="6868" class="Symbol">:</a> <a id="6870" class="Symbol">∀</a> <a id="6872" class="Symbol">{</a><a id="6873" href="Data.Int.html#6873" class="Bound">ℓ</a><a id="6874" class="Symbol">}</a> <a id="6876" class="Symbol">{</a><a id="6877" href="Data.Int.html#6877" class="Bound">X</a> <a id="6879" class="Symbol">:</a> <a id="6881" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="6886" href="Data.Int.html#6873" class="Bound">ℓ</a><a id="6887" class="Symbol">}</a>
        <a id="6897" class="Symbol">→</a> <a id="6899" class="Symbol">(</a><a id="6900" href="Data.Int.html#6900" class="Bound">f</a> <a id="6902" class="Symbol">:</a> <a data-type="Type" id="6904" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a> <a id="6908" class="Symbol">→</a> <a data-type="Type" id="6910" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a> <a id="6914" class="Symbol">→</a> <a id="6916" href="Data.Int.html#6877" class="Bound">X</a><a id="6917" class="Symbol">)</a>
        <a id="6927" class="Symbol">→</a> <a id="6929" class="Symbol">(</a><a id="6930" href="Data.Int.html#6930" class="Bound">q</a> <a id="6932" class="Symbol">:</a> <a id="6934" class="Symbol">(</a><a id="6935" href="Data.Int.html#6935" class="Bound">a</a> <a id="6937" href="Data.Int.html#6937" class="Bound">b</a> <a id="6939" class="Symbol">:</a> <a id="6941" class="Symbol">_)</a> <a id="6944" class="Symbol">→</a> <a id="6946" href="Data.Int.html#6900" class="Bound">f</a> <a id="6948" href="Data.Int.html#6935" class="Bound">a</a> <a id="6950" href="Data.Int.html#6937" class="Bound">b</a> <a data-type="A → A → Type ℓ" id="6952" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="6954" href="Data.Int.html#6900" class="Bound">f</a> <a id="6956" class="Symbol">(</a><a data-type="Nat → Nat" id="6957" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="6961" href="Data.Int.html#6935" class="Bound">a</a><a id="6962" class="Symbol">)</a> <a id="6964" class="Symbol">(</a><a data-type="Nat → Nat" id="6965" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="6969" href="Data.Int.html#6937" class="Bound">b</a><a id="6970" class="Symbol">))</a>
        <a id="6981" class="Symbol">→</a> <a data-type="Type" id="6983" href="Data.Int.html#776" class="Datatype">Int</a> <a id="6987" class="Symbol">→</a> <a id="6989" href="Data.Int.html#6877" class="Bound">X</a>
<a data-type="(f : Nat → Nat → X) →
((a b : Nat) → f a b ≡ f (suc a) (suc b)) → Int → X" id="6991" href="Data.Int.html#6860" class="Function">Int-rec</a> <a id="6999" href="Data.Int.html#6999" class="Bound">f</a> <a id="7001" href="Data.Int.html#7001" class="Bound">q</a> <a id="7003" class="Symbol">(</a><a data-type="Nat → Nat → Int" id="7004" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="7009" href="Data.Int.html#7009" class="Bound">x</a> <a id="7011" href="Data.Int.html#7011" class="Bound">y</a><a id="7012" class="Symbol">)</a> <a id="7014" class="Symbol">=</a> <a id="7016" href="Data.Int.html#6999" class="Bound">f</a> <a id="7018" href="Data.Int.html#7009" class="Bound">x</a> <a id="7020" href="Data.Int.html#7011" class="Bound">y</a>
<a data-type="(f : Nat → Nat → X) →
((a b : Nat) → f a b ≡ f (suc a) (suc b)) → Int → X" id="7022" href="Data.Int.html#6860" class="Function">Int-rec</a> <a id="7030" href="Data.Int.html#7030" class="Bound">f</a> <a id="7032" href="Data.Int.html#7032" class="Bound">q</a> <a id="7034" class="Symbol">(</a><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="7035" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="7040" href="Data.Int.html#7040" class="Bound">m</a> <a id="7042" href="Data.Int.html#7042" class="Bound">n</a> <a id="7044" href="Data.Int.html#7044" class="Bound">i</a><a id="7045" class="Symbol">)</a> <a id="7047" class="Symbol">=</a> <a id="7049" href="Data.Int.html#7032" class="Bound">q</a> <a id="7051" href="Data.Int.html#7040" class="Bound">m</a> <a id="7053" href="Data.Int.html#7042" class="Bound">n</a> <a id="7055" href="Data.Int.html#7044" class="Bound">i</a>
</pre>
<p>However, since <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> can be a more general space, not necessarily a <em>set</em>, defining a <em>binary</em> operation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>:</mo><msup><mi mathvariant="double-struck">Z</mi><mn>2</mn></msup><mo>→</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">f&#39; : \bb{Z}^2 \to X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9463em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathbb">Z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> can be quite involved! It doesn’t suffice to exhibit a function from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="double-struck">N</mi><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">\bb{N}^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathbb">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span> which respects the quotient separately in each argument:</p>
<pre class="Agda"><a id="Int-rec₂"></a><a data-type="(f : Nat × Nat → Nat × Nat → B₁)
(pl
 : (a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y))
(pr
 : (a b x y : Nat) →
   f (a , b) (x , y) ≡ f (a , b) (suc x , suc y)) →
((a b x y : Nat) →
 Square (pl a b x y) (pr a b x y) (pr (suc a) (suc b) x y)
 (pl a b (suc x) (suc y))) →
Int → Int → B₁" id="7333" href="Data.Int.html#7333" class="Function">Int-rec₂</a> <a id="7342" class="Symbol">:</a> <a id="7344" class="Symbol">∀</a> <a id="7346" class="Symbol">{</a><a id="7347" href="Data.Int.html#7347" class="Bound">ℓ</a><a id="7348" class="Symbol">}</a> <a id="7350" class="Symbol">{</a><a id="7351" href="Data.Int.html#7351" class="Bound">B</a> <a id="7353" class="Symbol">:</a> <a id="7355" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="7360" href="Data.Int.html#7347" class="Bound">ℓ</a><a id="7361" class="Symbol">}</a>
         <a id="7372" class="Symbol">→</a> <a id="7374" class="Symbol">(</a><a id="7375" href="Data.Int.html#7375" class="Bound">f</a> <a id="7377" class="Symbol">:</a> <a data-type="Type" id="7379" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="7383" href="1Lab.Type.html#1846" class="Function Operator">×</a> <a data-type="Type" id="7385" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a> <a id="7389" class="Symbol">→</a> <a data-type="Type" id="7391" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="7395" href="1Lab.Type.html#1846" class="Function Operator">×</a> <a data-type="Type" id="7397" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a> <a id="7401" class="Symbol">→</a> <a id="7403" href="Data.Int.html#7351" class="Bound">B</a><a id="7404" class="Symbol">)</a>
         <a id="7415" class="Symbol">→</a> <a id="7417" class="Symbol">(</a><a id="7418" href="Data.Int.html#7418" class="Bound">pl</a>     <a id="7425" class="Symbol">:</a> <a id="7427" class="Symbol">(</a><a id="7428" href="Data.Int.html#7428" class="Bound">a</a> <a id="7430" href="Data.Int.html#7430" class="Bound">b</a> <a id="7432" href="Data.Int.html#7432" class="Bound">x</a> <a id="7434" href="Data.Int.html#7434" class="Bound">y</a> <a id="7436" class="Symbol">:</a> <a id="7438" class="Symbol">_)</a> <a id="7441" class="Symbol">→</a> <a id="7443" href="Data.Int.html#7375" class="Bound">f</a> <a id="7445" class="Symbol">(</a><a id="7446" href="Data.Int.html#7428" class="Bound">a</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="7448" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7450" href="Data.Int.html#7430" class="Bound">b</a><a id="7451" class="Symbol">)</a> <a id="7453" class="Symbol">(</a><a id="7454" href="Data.Int.html#7432" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="7456" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7458" href="Data.Int.html#7434" class="Bound">y</a><a id="7459" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="7461" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="7463" href="Data.Int.html#7375" class="Bound">f</a> <a id="7465" class="Symbol">(</a><a data-type="Nat → Nat" id="7466" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="7470" href="Data.Int.html#7428" class="Bound">a</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="7472" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="Nat → Nat" id="7474" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="7478" href="Data.Int.html#7430" class="Bound">b</a><a id="7479" class="Symbol">)</a> <a id="7481" class="Symbol">(</a><a id="7482" href="Data.Int.html#7432" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="7484" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7486" href="Data.Int.html#7434" class="Bound">y</a><a id="7487" class="Symbol">))</a>
         <a id="7499" class="Symbol">→</a> <a id="7501" class="Symbol">(</a><a id="7502" href="Data.Int.html#7502" class="Bound">pr</a>     <a id="7509" class="Symbol">:</a> <a id="7511" class="Symbol">(</a><a id="7512" href="Data.Int.html#7512" class="Bound">a</a> <a id="7514" href="Data.Int.html#7514" class="Bound">b</a> <a id="7516" href="Data.Int.html#7516" class="Bound">x</a> <a id="7518" href="Data.Int.html#7518" class="Bound">y</a> <a id="7520" class="Symbol">:</a> <a id="7522" class="Symbol">_)</a> <a id="7525" class="Symbol">→</a> <a id="7527" href="Data.Int.html#7375" class="Bound">f</a> <a id="7529" class="Symbol">(</a><a id="7530" href="Data.Int.html#7512" class="Bound">a</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="7532" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7534" href="Data.Int.html#7514" class="Bound">b</a><a id="7535" class="Symbol">)</a> <a id="7537" class="Symbol">(</a><a id="7538" href="Data.Int.html#7516" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="7540" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7542" href="Data.Int.html#7518" class="Bound">y</a><a id="7543" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="7545" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="7547" href="Data.Int.html#7375" class="Bound">f</a> <a id="7549" class="Symbol">(</a><a id="7550" href="Data.Int.html#7512" class="Bound">a</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="7552" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7554" href="Data.Int.html#7514" class="Bound">b</a><a id="7555" class="Symbol">)</a> <a id="7557" class="Symbol">(</a><a data-type="Nat → Nat" id="7558" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="7562" href="Data.Int.html#7516" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="7564" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="Nat → Nat" id="7566" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="7570" href="Data.Int.html#7518" class="Bound">y</a><a id="7571" class="Symbol">))</a>
</pre>
<p>In addition, we must have that these two <em>paths</em> <code>pl</code> and <code>pr</code> are <em>coherent</em>. There are two ways of obtaining an equality <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi mathvariant="normal">S</mi><mi>a</mi><mo separator="true">,</mo><mi mathvariant="normal">S</mi><mi>b</mi><mo separator="true">,</mo><mi mathvariant="normal">S</mi><mi>x</mi><mo separator="true">,</mo><mi mathvariant="normal">S</mi><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(a, b, x, y) = f(\id{S}a,\id{S}b,\id{S}x,\id{S}y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathrm">S</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathrm">S</span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathrm">S</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathrm">S</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> (<code>pl</code> after <code>pr</code> and <code>pr</code> after <code>pl</code>, respectively) and these <em>must</em> be homotopic:</p>
<pre class="Agda">         <a id="7856" class="Symbol">→</a> <a id="7858" class="Symbol">(</a><a id="7859" href="Data.Int.html#7859" class="Bound">square</a> <a id="7866" class="Symbol">:</a> <a id="7868" class="Symbol">(</a><a id="7869" href="Data.Int.html#7869" class="Bound">a</a> <a id="7871" href="Data.Int.html#7871" class="Bound">b</a> <a id="7873" href="Data.Int.html#7873" class="Bound">x</a> <a id="7875" href="Data.Int.html#7875" class="Bound">y</a> <a id="7877" class="Symbol">:</a> <a id="7879" class="Symbol">_)</a> <a id="7882" class="Symbol">→</a>
              <a data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" id="7898" href="1Lab.Path.html#9409" class="Function">Square</a> <a id="7905" class="Symbol">(</a><a id="7906" href="Data.Int.html#7418" class="Bound">pl</a> <a id="7909" href="Data.Int.html#7869" class="Bound">a</a> <a id="7911" href="Data.Int.html#7871" class="Bound">b</a> <a id="7913" href="Data.Int.html#7873" class="Bound">x</a> <a id="7915" href="Data.Int.html#7875" class="Bound">y</a><a id="7916" class="Symbol">)</a> <a id="7918" class="Symbol">(</a><a id="7919" href="Data.Int.html#7502" class="Bound">pr</a> <a id="7922" href="Data.Int.html#7869" class="Bound">a</a> <a id="7924" href="Data.Int.html#7871" class="Bound">b</a> <a id="7926" href="Data.Int.html#7873" class="Bound">x</a> <a id="7928" href="Data.Int.html#7875" class="Bound">y</a><a id="7929" class="Symbol">)</a>
                     <a id="7952" class="Symbol">(</a><a id="7953" href="Data.Int.html#7502" class="Bound">pr</a> <a id="7956" class="Symbol">(</a><a data-type="Nat → Nat" id="7957" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="7961" href="Data.Int.html#7869" class="Bound">a</a><a id="7962" class="Symbol">)</a> <a id="7964" class="Symbol">(</a><a data-type="Nat → Nat" id="7965" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="7969" href="Data.Int.html#7871" class="Bound">b</a><a id="7970" class="Symbol">)</a> <a id="7972" href="Data.Int.html#7873" class="Bound">x</a> <a id="7974" href="Data.Int.html#7875" class="Bound">y</a><a id="7975" class="Symbol">)</a>
                     <a id="7998" class="Symbol">(</a><a id="7999" href="Data.Int.html#7418" class="Bound">pl</a> <a id="8002" href="Data.Int.html#7869" class="Bound">a</a> <a id="8004" href="Data.Int.html#7871" class="Bound">b</a> <a id="8006" class="Symbol">(</a><a data-type="Nat → Nat" id="8007" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="8011" href="Data.Int.html#7873" class="Bound">x</a><a id="8012" class="Symbol">)</a> <a id="8014" class="Symbol">(</a><a data-type="Nat → Nat" id="8015" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="8019" href="Data.Int.html#7875" class="Bound">y</a><a id="8020" class="Symbol">)))</a>
         <a id="8033" class="Symbol">→</a> <a data-type="Type" id="8035" href="Data.Int.html#776" class="Datatype">Int</a> <a id="8039" class="Symbol">→</a> <a data-type="Type" id="8041" href="Data.Int.html#776" class="Datatype">Int</a> <a id="8045" class="Symbol">→</a> <a id="8047" href="Data.Int.html#7351" class="Bound">B</a>
</pre>
<p>The type of <code>square</code> says that we need the following square of paths to commute, which says exactly that <code>pl ∙ pr</code> and <code>pr ∙ pl</code> are homotopic and imposes no further structure on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>:</p>
<div class="diagram-container">
<img src="96b44f04dd57b7493b2bae592d6e93413b7af24d.svg" title="commutative diagram" class="diagram quiver tall-1" />
</div>
<pre class="Agda"><a data-type="(f : Nat × Nat → Nat × Nat → B₁)
(pl
 : (a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y))
(pr
 : (a b x y : Nat) →
   f (a , b) (x , y) ≡ f (a , b) (suc x , suc y)) →
((a b x y : Nat) →
 Square (pl a b x y) (pr a b x y) (pr (suc a) (suc b) x y)
 (pl a b (suc x) (suc y))) →
Int → Int → B₁" id="8686" href="Data.Int.html#7333" class="Function">Int-rec₂</a> <a id="8695" href="Data.Int.html#8695" class="Bound">f</a> <a id="8697" href="Data.Int.html#8697" class="Bound">p-l</a> <a id="8701" href="Data.Int.html#8701" class="Bound">p-r</a> <a id="8705" href="Data.Int.html#8705" class="Bound">sq</a> <a id="8708" class="Symbol">(</a><a data-type="Nat → Nat → Int" id="8709" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="8714" href="Data.Int.html#8714" class="Bound">a</a> <a id="8716" href="Data.Int.html#8716" class="Bound">b</a><a id="8717" class="Symbol">)</a> <a id="8719" class="Symbol">(</a><a data-type="Nat → Nat → Int" id="8720" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="8725" href="Data.Int.html#8725" class="Bound">x</a> <a id="8727" href="Data.Int.html#8727" class="Bound">y</a><a id="8728" class="Symbol">)</a>     <a id="8734" class="Symbol">=</a> <a id="8736" href="Data.Int.html#8695" class="Bound">f</a> <a id="8738" class="Symbol">(</a><a id="8739" href="Data.Int.html#8714" class="Bound">a</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="8741" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8743" href="Data.Int.html#8716" class="Bound">b</a><a id="8744" class="Symbol">)</a> <a id="8746" class="Symbol">(</a><a id="8747" href="Data.Int.html#8725" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="8749" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8751" href="Data.Int.html#8727" class="Bound">y</a><a id="8752" class="Symbol">)</a>
<a data-type="(f : Nat × Nat → Nat × Nat → B₁)
(pl
 : (a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y))
(pr
 : (a b x y : Nat) →
   f (a , b) (x , y) ≡ f (a , b) (suc x , suc y)) →
((a b x y : Nat) →
 Square (pl a b x y) (pr a b x y) (pr (suc a) (suc b) x y)
 (pl a b (suc x) (suc y))) →
Int → Int → B₁" id="8754" href="Data.Int.html#7333" class="Function">Int-rec₂</a> <a id="8763" href="Data.Int.html#8763" class="Bound">f</a> <a id="8765" href="Data.Int.html#8765" class="Bound">p-l</a> <a id="8769" href="Data.Int.html#8769" class="Bound">p-r</a> <a id="8773" href="Data.Int.html#8773" class="Bound">sq</a> <a id="8776" class="Symbol">(</a><a data-type="Nat → Nat → Int" id="8777" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="8782" href="Data.Int.html#8782" class="Bound">a</a> <a id="8784" href="Data.Int.html#8784" class="Bound">b</a><a id="8785" class="Symbol">)</a> <a id="8787" class="Symbol">(</a><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="8788" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="8793" href="Data.Int.html#8793" class="Bound">x</a> <a id="8795" href="Data.Int.html#8795" class="Bound">y</a> <a id="8797" href="Data.Int.html#8797" class="Bound">i</a><a id="8798" class="Symbol">)</a>   <a id="8802" class="Symbol">=</a> <a id="8804" href="Data.Int.html#8769" class="Bound">p-r</a> <a id="8808" href="Data.Int.html#8782" class="Bound">a</a> <a id="8810" href="Data.Int.html#8784" class="Bound">b</a> <a id="8812" href="Data.Int.html#8793" class="Bound">x</a> <a id="8814" href="Data.Int.html#8795" class="Bound">y</a> <a id="8816" href="Data.Int.html#8797" class="Bound">i</a>
<a data-type="(f : Nat × Nat → Nat × Nat → B₁)
(pl
 : (a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y))
(pr
 : (a b x y : Nat) →
   f (a , b) (x , y) ≡ f (a , b) (suc x , suc y)) →
((a b x y : Nat) →
 Square (pl a b x y) (pr a b x y) (pr (suc a) (suc b) x y)
 (pl a b (suc x) (suc y))) →
Int → Int → B₁" id="8818" href="Data.Int.html#7333" class="Function">Int-rec₂</a> <a id="8827" href="Data.Int.html#8827" class="Bound">f</a> <a id="8829" href="Data.Int.html#8829" class="Bound">p-l</a> <a id="8833" href="Data.Int.html#8833" class="Bound">p-r</a> <a id="8837" href="Data.Int.html#8837" class="Bound">sq</a> <a id="8840" class="Symbol">(</a><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="8841" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="8846" href="Data.Int.html#8846" class="Bound">a</a> <a id="8848" href="Data.Int.html#8848" class="Bound">b</a> <a id="8850" href="Data.Int.html#8850" class="Bound">i</a><a id="8851" class="Symbol">)</a> <a id="8853" class="Symbol">(</a><a data-type="Nat → Nat → Int" id="8854" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="8859" href="Data.Int.html#8859" class="Bound">x</a> <a id="8861" href="Data.Int.html#8861" class="Bound">y</a><a id="8862" class="Symbol">)</a>   <a id="8866" class="Symbol">=</a> <a id="8868" href="Data.Int.html#8829" class="Bound">p-l</a> <a id="8872" href="Data.Int.html#8846" class="Bound">a</a> <a id="8874" href="Data.Int.html#8848" class="Bound">b</a> <a id="8876" href="Data.Int.html#8859" class="Bound">x</a> <a id="8878" href="Data.Int.html#8861" class="Bound">y</a> <a id="8880" href="Data.Int.html#8850" class="Bound">i</a>
<a data-type="(f : Nat × Nat → Nat × Nat → B₁)
(pl
 : (a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y))
(pr
 : (a b x y : Nat) →
   f (a , b) (x , y) ≡ f (a , b) (suc x , suc y)) →
((a b x y : Nat) →
 Square (pl a b x y) (pr a b x y) (pr (suc a) (suc b) x y)
 (pl a b (suc x) (suc y))) →
Int → Int → B₁" id="8882" href="Data.Int.html#7333" class="Function">Int-rec₂</a> <a id="8891" href="Data.Int.html#8891" class="Bound">f</a> <a id="8893" href="Data.Int.html#8893" class="Bound">p-l</a> <a id="8897" href="Data.Int.html#8897" class="Bound">p-r</a> <a id="8901" href="Data.Int.html#8901" class="Bound">sq</a> <a id="8904" class="Symbol">(</a><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="8905" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="8910" href="Data.Int.html#8910" class="Bound">a</a> <a id="8912" href="Data.Int.html#8912" class="Bound">b</a> <a id="8914" href="Data.Int.html#8914" class="Bound">i</a><a id="8915" class="Symbol">)</a> <a id="8917" class="Symbol">(</a><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="8918" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="8923" href="Data.Int.html#8923" class="Bound">x</a> <a id="8925" href="Data.Int.html#8925" class="Bound">y</a> <a id="8927" href="Data.Int.html#8927" class="Bound">j</a><a id="8928" class="Symbol">)</a> <a id="8930" class="Symbol">=</a> <a id="8932" href="Data.Int.html#8901" class="Bound">sq</a> <a id="8935" href="Data.Int.html#8910" class="Bound">a</a> <a id="8937" href="Data.Int.html#8912" class="Bound">b</a> <a id="8939" href="Data.Int.html#8923" class="Bound">x</a> <a id="8941" href="Data.Int.html#8925" class="Bound">y</a> <a id="8943" href="Data.Int.html#8914" class="Bound">i</a> <a id="8945" href="Data.Int.html#8927" class="Bound">j</a>
</pre>
<p>However, when the type <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> we are mapping into <span class="Agda"><a data-type="Type ℓ → Type ℓ" href="1Lab.HLevel.html#3356" class="Function">is a set</a></span>, as is the case for the integers themselves, the square is automatically satisfied, so we can give a simplified recursion principle:</p>
<pre class="Agda"><a id="Int-rec₂-set"></a><a data-type="is-set B₁ →
(f : Nat × Nat → Nat × Nat → B₁) →
((a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y)) →
((a b x y : Nat) → f (a , b) (x , y) ≡ f (a , b) (suc x , suc y)) →
Int → Int → B₁" id="9172" href="Data.Int.html#9172" class="Function">Int-rec₂-set</a> <a id="9185" class="Symbol">:</a>
  <a id="9189" class="Symbol">∀</a> <a id="9191" class="Symbol">{</a><a id="9192" href="Data.Int.html#9192" class="Bound">ℓ</a><a id="9193" class="Symbol">}</a> <a id="9195" class="Symbol">{</a><a id="9196" href="Data.Int.html#9196" class="Bound">B</a> <a id="9198" class="Symbol">:</a> <a id="9200" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="9205" href="Data.Int.html#9192" class="Bound">ℓ</a><a id="9206" class="Symbol">}</a>
  <a id="9210" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="9212" href="1Lab.HLevel.html#3356" class="Function">is-set</a> <a id="9219" href="Data.Int.html#9196" class="Bound">B</a>
  <a id="9223" class="Symbol">→</a> <a id="9225" class="Symbol">(</a><a id="9226" href="Data.Int.html#9226" class="Bound">f</a> <a id="9228" class="Symbol">:</a> <a data-type="Type" id="9230" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="9234" href="1Lab.Type.html#1846" class="Function Operator">×</a> <a data-type="Type" id="9236" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a> <a id="9240" class="Symbol">→</a> <a data-type="Type" id="9242" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a> <a data-type="Type a → Type b → Type (a ⊔ b)" id="9246" href="1Lab.Type.html#1846" class="Function Operator">×</a> <a data-type="Type" id="9248" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a> <a id="9252" class="Symbol">→</a> <a id="9254" href="Data.Int.html#9196" class="Bound">B</a><a id="9255" class="Symbol">)</a>
  <a id="9259" class="Symbol">→</a> <a id="9261" class="Symbol">(</a><a id="9262" href="Data.Int.html#9262" class="Bound">pl</a>     <a id="9269" class="Symbol">:</a> <a id="9271" class="Symbol">(</a><a id="9272" href="Data.Int.html#9272" class="Bound">a</a> <a id="9274" href="Data.Int.html#9274" class="Bound">b</a> <a id="9276" href="Data.Int.html#9276" class="Bound">x</a> <a id="9278" href="Data.Int.html#9278" class="Bound">y</a> <a id="9280" class="Symbol">:</a> <a id="9282" class="Symbol">_)</a> <a id="9285" class="Symbol">→</a> <a id="9287" href="Data.Int.html#9226" class="Bound">f</a> <a id="9289" class="Symbol">(</a><a id="9290" href="Data.Int.html#9272" class="Bound">a</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="9292" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="9294" href="Data.Int.html#9274" class="Bound">b</a><a id="9295" class="Symbol">)</a> <a id="9297" class="Symbol">(</a><a id="9298" href="Data.Int.html#9276" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="9300" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="9302" href="Data.Int.html#9278" class="Bound">y</a><a id="9303" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="9305" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="9307" href="Data.Int.html#9226" class="Bound">f</a> <a id="9309" class="Symbol">(</a><a data-type="Nat → Nat" id="9310" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="9314" href="Data.Int.html#9272" class="Bound">a</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="9316" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="Nat → Nat" id="9318" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="9322" href="Data.Int.html#9274" class="Bound">b</a><a id="9323" class="Symbol">)</a> <a id="9325" class="Symbol">(</a><a id="9326" href="Data.Int.html#9276" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="9328" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="9330" href="Data.Int.html#9278" class="Bound">y</a><a id="9331" class="Symbol">))</a>
  <a id="9336" class="Symbol">→</a> <a id="9338" class="Symbol">(</a><a id="9339" href="Data.Int.html#9339" class="Bound">pr</a>     <a id="9346" class="Symbol">:</a> <a id="9348" class="Symbol">(</a><a id="9349" href="Data.Int.html#9349" class="Bound">a</a> <a id="9351" href="Data.Int.html#9351" class="Bound">b</a> <a id="9353" href="Data.Int.html#9353" class="Bound">x</a> <a id="9355" href="Data.Int.html#9355" class="Bound">y</a> <a id="9357" class="Symbol">:</a> <a id="9359" class="Symbol">_)</a> <a id="9362" class="Symbol">→</a> <a id="9364" href="Data.Int.html#9226" class="Bound">f</a> <a id="9366" class="Symbol">(</a><a id="9367" href="Data.Int.html#9349" class="Bound">a</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="9369" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="9371" href="Data.Int.html#9351" class="Bound">b</a><a id="9372" class="Symbol">)</a> <a id="9374" class="Symbol">(</a><a id="9375" href="Data.Int.html#9353" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="9377" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="9379" href="Data.Int.html#9355" class="Bound">y</a><a id="9380" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="9382" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="9384" href="Data.Int.html#9226" class="Bound">f</a> <a id="9386" class="Symbol">(</a><a id="9387" href="Data.Int.html#9349" class="Bound">a</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="9389" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="9391" href="Data.Int.html#9351" class="Bound">b</a><a id="9392" class="Symbol">)</a> <a id="9394" class="Symbol">(</a><a data-type="Nat → Nat" id="9395" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="9399" href="Data.Int.html#9353" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="9401" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="Nat → Nat" id="9403" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="9407" href="Data.Int.html#9355" class="Bound">y</a><a id="9408" class="Symbol">))</a>
  <a id="9413" class="Symbol">→</a> <a data-type="Type" id="9415" href="Data.Int.html#776" class="Datatype">Int</a> <a id="9419" class="Symbol">→</a> <a data-type="Type" id="9421" href="Data.Int.html#776" class="Datatype">Int</a> <a id="9425" class="Symbol">→</a> <a id="9427" href="Data.Int.html#9196" class="Bound">B</a>
<a data-type="is-set B₁ →
(f : Nat × Nat → Nat × Nat → B₁) →
((a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y)) →
((a b x y : Nat) → f (a , b) (x , y) ≡ f (a , b) (suc x , suc y)) →
Int → Int → B₁" id="9429" href="Data.Int.html#9172" class="Function">Int-rec₂-set</a> <a id="9442" href="Data.Int.html#9442" class="Bound">iss-b</a> <a id="9448" href="Data.Int.html#9448" class="Bound">f</a> <a id="9450" href="Data.Int.html#9450" class="Bound">pl</a> <a id="9453" href="Data.Int.html#9453" class="Bound">pr</a> <a id="9456" class="Symbol">=</a> <a data-type="(f : Nat × Nat → Nat × Nat → B₁)
(pl
 : (a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y))
(pr
 : (a b x y : Nat) →
   f (a , b) (x , y) ≡ f (a , b) (suc x , suc y)) →
((a b x y : Nat) →
 Square (pl a b x y) (pr a b x y) (pr (suc a) (suc b) x y)
 (pl a b (suc x) (suc y))) →
Int → Int → B₁" id="9458" href="Data.Int.html#7333" class="Function">Int-rec₂</a> <a id="9467" href="Data.Int.html#9448" class="Bound">f</a> <a id="9469" href="Data.Int.html#9450" class="Bound">pl</a> <a id="9472" href="Data.Int.html#9453" class="Bound">pr</a> <a id="9475" href="Data.Int.html#9490" class="Function">square</a> <a id="9482" class="Keyword">where</a>
  <a id="9490" href="Data.Int.html#9490" class="Function">square</a> <a id="9497" class="Symbol">:</a> <a id="9499" class="Symbol">(</a><a id="9500" href="Data.Int.html#9500" class="Bound">a</a> <a id="9502" href="Data.Int.html#9502" class="Bound">b</a> <a id="9504" href="Data.Int.html#9504" class="Bound">x</a> <a id="9506" href="Data.Int.html#9506" class="Bound">y</a> <a id="9508" class="Symbol">:</a> <a id="9510" class="Symbol">_)</a> <a id="9513" class="Symbol">→</a> <a id="9515" class="Symbol">_</a>
  <a id="9519" href="Data.Int.html#9490" class="Function">square</a> <a id="9526" href="Data.Int.html#9526" class="Bound">a</a> <a id="9528" href="Data.Int.html#9528" class="Bound">b</a> <a id="9530" href="Data.Int.html#9530" class="Bound">x</a> <a id="9532" href="Data.Int.html#9532" class="Bound">y</a> <a id="9534" class="Symbol">=</a>
    <a data-type="A ≡ B₁ → A → B₁" id="9540" href="1Lab.Path.html#11776" class="Function">transport</a> <a id="9550" class="Symbol">(λ</a> <a id="9553" href="Data.Int.html#9553" class="Bound">i</a> <a id="9555" class="Symbol">→</a> <a data-type="(P : I → Type ℓ) (p : P i0) (q : P i1) →
PathP P p q ≡ Path (P i1) (transport P p) q" id="9557" href="1Lab.Path.html#49201" class="Function">PathP≡Path</a> <a id="9568" class="Symbol">(λ</a> <a id="9571" href="Data.Int.html#9571" class="Bound">i</a> <a id="9573" class="Symbol">→</a> <a id="9575" href="Data.Int.html#9450" class="Bound">pl</a> <a id="9578" href="Data.Int.html#9526" class="Bound">a</a> <a id="9580" href="Data.Int.html#9528" class="Bound">b</a> <a id="9582" href="Data.Int.html#9530" class="Bound">x</a> <a id="9584" href="Data.Int.html#9532" class="Bound">y</a> <a id="9586" href="Data.Int.html#9571" class="Bound">i</a> <a data-type="A → A → Type ℓ" id="9588" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="9590" href="Data.Int.html#9450" class="Bound">pl</a> <a id="9593" href="Data.Int.html#9526" class="Bound">a</a> <a id="9595" href="Data.Int.html#9528" class="Bound">b</a> <a id="9597" class="Symbol">(</a><a data-type="Nat → Nat" id="9598" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="9602" href="Data.Int.html#9530" class="Bound">x</a><a id="9603" class="Symbol">)</a> <a id="9605" class="Symbol">(</a><a data-type="Nat → Nat" id="9606" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="9610" href="Data.Int.html#9532" class="Bound">y</a><a id="9611" class="Symbol">)</a> <a id="9613" href="Data.Int.html#9571" class="Bound">i</a><a id="9614" class="Symbol">)</a>
                                <a id="9648" class="Symbol">(</a><a id="9649" href="Data.Int.html#9453" class="Bound">pr</a> <a id="9652" href="Data.Int.html#9526" class="Bound">a</a> <a id="9654" href="Data.Int.html#9528" class="Bound">b</a> <a id="9656" href="Data.Int.html#9530" class="Bound">x</a> <a id="9658" href="Data.Int.html#9532" class="Bound">y</a><a id="9659" class="Symbol">)</a> <a id="9661" class="Symbol">(</a><a id="9662" href="Data.Int.html#9453" class="Bound">pr</a> <a id="9665" class="Symbol">(</a><a data-type="Nat → Nat" id="9666" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="9670" href="Data.Int.html#9526" class="Bound">a</a><a id="9671" class="Symbol">)</a> <a id="9673" class="Symbol">(</a><a data-type="Nat → Nat" id="9674" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="9678" href="Data.Int.html#9528" class="Bound">b</a><a id="9679" class="Symbol">)</a> <a id="9681" href="Data.Int.html#9530" class="Bound">x</a> <a id="9683" href="Data.Int.html#9532" class="Bound">y</a><a id="9684" class="Symbol">)</a>
                                <a id="9718" class="Symbol">(</a><a id="9719" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="9721" href="Data.Int.html#9553" class="Bound">i</a><a id="9722" class="Symbol">))</a>
              <a id="9739" class="Symbol">(</a><a id="9740" href="Data.Int.html#9442" class="Bound">iss-b</a> <a id="9746" class="Symbol">_</a> <a id="9748" class="Symbol">_</a> <a id="9750" class="Symbol">_</a> <a id="9752" class="Symbol">_)</a>
</pre>
<p>Furthermore, when proving <em><span class="Agda"><a data-type="Type ℓ → Type ℓ" href="1Lab.HLevel.html#2597" class="Function">propositions</a></span></em> of the integers, the quotient is automatically respected, so it suffices to give the case for <span class="Agda"><a data-type="Nat → Nat → Int" href="Data.Int.html#795" class="InductiveConstructor">diff</a></span>:</p>
<pre class="Agda"><a id="Int-elim-prop"></a><a data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" id="9942" href="Data.Int.html#9942" class="Function">Int-elim-prop</a> <a id="9956" class="Symbol">:</a> <a id="9958" class="Symbol">∀</a> <a id="9960" class="Symbol">{</a><a id="9961" href="Data.Int.html#9961" class="Bound">ℓ</a><a id="9962" class="Symbol">}</a> <a id="9964" class="Symbol">{</a><a id="9965" href="Data.Int.html#9965" class="Bound">P</a> <a id="9967" class="Symbol">:</a> <a data-type="Type" id="9969" href="Data.Int.html#776" class="Datatype">Int</a> <a id="9973" class="Symbol">→</a> <a id="9975" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="9980" href="Data.Int.html#9961" class="Bound">ℓ</a><a id="9981" class="Symbol">}</a>
              <a id="9997" class="Symbol">→</a> <a id="9999" class="Symbol">((</a><a id="10001" href="Data.Int.html#10001" class="Bound">x</a> <a id="10003" class="Symbol">:</a> <a data-type="Type" id="10005" href="Data.Int.html#776" class="Datatype">Int</a><a id="10008" class="Symbol">)</a> <a id="10010" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="10012" href="1Lab.HLevel.html#2597" class="Function">is-prop</a> <a id="10020" class="Symbol">(</a><a id="10021" href="Data.Int.html#9965" class="Bound">P</a> <a id="10023" href="Data.Int.html#10001" class="Bound">x</a><a id="10024" class="Symbol">))</a>
              <a id="10041" class="Symbol">→</a> <a id="10043" class="Symbol">(</a><a id="10044" href="Data.Int.html#10044" class="Bound">f</a> <a id="10046" class="Symbol">:</a> <a id="10048" class="Symbol">(</a><a id="10049" href="Data.Int.html#10049" class="Bound">a</a> <a id="10051" href="Data.Int.html#10051" class="Bound">b</a> <a id="10053" class="Symbol">:</a> <a data-type="Type" id="10055" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a><a id="10058" class="Symbol">)</a> <a id="10060" class="Symbol">→</a> <a id="10062" href="Data.Int.html#9965" class="Bound">P</a> <a id="10064" class="Symbol">(</a><a data-type="Nat → Nat → Int" id="10065" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="10070" href="Data.Int.html#10049" class="Bound">a</a> <a id="10072" href="Data.Int.html#10051" class="Bound">b</a><a id="10073" class="Symbol">))</a>
              <a id="10090" class="Symbol">→</a> <a id="10092" class="Symbol">(</a><a id="10093" href="Data.Int.html#10093" class="Bound">x</a> <a id="10095" class="Symbol">:</a> <a data-type="Type" id="10097" href="Data.Int.html#776" class="Datatype">Int</a><a id="10100" class="Symbol">)</a> <a id="10102" class="Symbol">→</a> <a id="10104" href="Data.Int.html#9965" class="Bound">P</a> <a id="10106" href="Data.Int.html#10093" class="Bound">x</a>
<a data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" id="10108" href="Data.Int.html#9942" class="Function">Int-elim-prop</a> <a id="10122" href="Data.Int.html#10122" class="Bound">pprop</a> <a id="10128" href="Data.Int.html#10128" class="Bound">f</a> <a id="10130" class="Symbol">(</a><a data-type="Nat → Nat → Int" id="10131" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="10136" href="Data.Int.html#10136" class="Bound">a</a> <a id="10138" href="Data.Int.html#10138" class="Bound">b</a><a id="10139" class="Symbol">)</a> <a id="10141" class="Symbol">=</a> <a id="10143" href="Data.Int.html#10128" class="Bound">f</a> <a id="10145" href="Data.Int.html#10136" class="Bound">a</a> <a id="10147" href="Data.Int.html#10138" class="Bound">b</a>
<a data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" id="10149" href="Data.Int.html#9942" class="Function">Int-elim-prop</a> <a id="10163" href="Data.Int.html#10163" class="Bound">pprop</a> <a id="10169" href="Data.Int.html#10169" class="Bound">f</a> <a id="10171" class="Symbol">(</a><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="10172" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="10177" href="Data.Int.html#10177" class="Bound">m</a> <a id="10179" href="Data.Int.html#10179" class="Bound">n</a> <a id="10181" href="Data.Int.html#10181" class="Bound">i</a><a id="10182" class="Symbol">)</a> <a id="10184" class="Symbol">=</a>
  <a data-type="((i : I) → is-prop (B₁ i)) →
(b0 : B₁ i0) (b1 : B₁ i1) → PathP B₁ b0 b1" id="10188" href="1Lab.HLevel.html#13498" class="Function">is-prop→pathp</a> <a id="10202" class="Symbol">(λ</a> <a id="10205" href="Data.Int.html#10205" class="Bound">i</a> <a id="10207" class="Symbol">→</a> <a id="10209" href="Data.Int.html#10163" class="Bound">pprop</a> <a id="10215" class="Symbol">(</a><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="10216" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="10221" href="Data.Int.html#10177" class="Bound">m</a> <a id="10223" href="Data.Int.html#10179" class="Bound">n</a> <a id="10225" href="Data.Int.html#10205" class="Bound">i</a><a id="10226" class="Symbol">))</a> <a id="10229" class="Symbol">(</a><a id="10230" href="Data.Int.html#10169" class="Bound">f</a> <a id="10232" href="Data.Int.html#10177" class="Bound">m</a> <a id="10234" href="Data.Int.html#10179" class="Bound">n</a><a id="10235" class="Symbol">)</a> <a id="10237" class="Symbol">(</a><a id="10238" href="Data.Int.html#10169" class="Bound">f</a> <a id="10240" class="Symbol">(</a><a data-type="Nat → Nat" id="10241" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="10245" href="Data.Int.html#10177" class="Bound">m</a><a id="10246" class="Symbol">)</a> <a id="10248" class="Symbol">(</a><a data-type="Nat → Nat" id="10249" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="10253" href="Data.Int.html#10179" class="Bound">n</a><a id="10254" class="Symbol">))</a> <a id="10257" href="Data.Int.html#10181" class="Bound">i</a>
</pre>
<details>
<summary>
There are also variants for binary and ternary predicates.
</summary>
<pre class="Agda"><a id="Int-elim₂-prop"></a><a data-type="((x y : Int) → is-prop (P x y)) →
((a b x y : Nat) → P (diff a b) (diff x y)) → (x y : Int) → P x y" id="10360" href="Data.Int.html#10360" class="Function">Int-elim₂-prop</a> <a id="10375" class="Symbol">:</a> <a id="10377" class="Symbol">∀</a> <a id="10379" class="Symbol">{</a><a id="10380" href="Data.Int.html#10380" class="Bound">ℓ</a><a id="10381" class="Symbol">}</a> <a id="10383" class="Symbol">{</a><a id="10384" href="Data.Int.html#10384" class="Bound">P</a> <a id="10386" class="Symbol">:</a> <a data-type="Type" id="10388" href="Data.Int.html#776" class="Datatype">Int</a> <a id="10392" class="Symbol">→</a> <a data-type="Type" id="10394" href="Data.Int.html#776" class="Datatype">Int</a> <a id="10398" class="Symbol">→</a> <a id="10400" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="10405" href="Data.Int.html#10380" class="Bound">ℓ</a><a id="10406" class="Symbol">}</a>
               <a id="10423" class="Symbol">→</a> <a id="10425" class="Symbol">((</a><a id="10427" href="Data.Int.html#10427" class="Bound">x</a> <a id="10429" href="Data.Int.html#10429" class="Bound">y</a> <a id="10431" class="Symbol">:</a> <a data-type="Type" id="10433" href="Data.Int.html#776" class="Datatype">Int</a><a id="10436" class="Symbol">)</a> <a id="10438" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="10440" href="1Lab.HLevel.html#2597" class="Function">is-prop</a> <a id="10448" class="Symbol">(</a><a id="10449" href="Data.Int.html#10384" class="Bound">P</a> <a id="10451" href="Data.Int.html#10427" class="Bound">x</a> <a id="10453" href="Data.Int.html#10429" class="Bound">y</a><a id="10454" class="Symbol">))</a>
               <a id="10472" class="Symbol">→</a> <a id="10474" class="Symbol">(</a><a id="10475" href="Data.Int.html#10475" class="Bound">f</a> <a id="10477" class="Symbol">:</a> <a id="10479" class="Symbol">(</a><a id="10480" href="Data.Int.html#10480" class="Bound">a</a> <a id="10482" href="Data.Int.html#10482" class="Bound">b</a> <a id="10484" href="Data.Int.html#10484" class="Bound">x</a> <a id="10486" href="Data.Int.html#10486" class="Bound">y</a> <a id="10488" class="Symbol">:</a> <a data-type="Type" id="10490" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a><a id="10493" class="Symbol">)</a> <a id="10495" class="Symbol">→</a> <a id="10497" href="Data.Int.html#10384" class="Bound">P</a> <a id="10499" class="Symbol">(</a><a data-type="Nat → Nat → Int" id="10500" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="10505" href="Data.Int.html#10480" class="Bound">a</a> <a id="10507" href="Data.Int.html#10482" class="Bound">b</a><a id="10508" class="Symbol">)</a> <a id="10510" class="Symbol">(</a><a data-type="Nat → Nat → Int" id="10511" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="10516" href="Data.Int.html#10484" class="Bound">x</a> <a id="10518" href="Data.Int.html#10486" class="Bound">y</a><a id="10519" class="Symbol">))</a>
               <a id="10537" class="Symbol">→</a> <a id="10539" class="Symbol">(</a><a id="10540" href="Data.Int.html#10540" class="Bound">x</a> <a id="10542" class="Symbol">:</a> <a data-type="Type" id="10544" href="Data.Int.html#776" class="Datatype">Int</a><a id="10547" class="Symbol">)</a> <a id="10549" class="Symbol">(</a><a id="10550" href="Data.Int.html#10550" class="Bound">y</a> <a id="10552" class="Symbol">:</a> <a data-type="Type" id="10554" href="Data.Int.html#776" class="Datatype">Int</a><a id="10557" class="Symbol">)</a> <a id="10559" class="Symbol">→</a> <a id="10561" href="Data.Int.html#10384" class="Bound">P</a> <a id="10563" href="Data.Int.html#10540" class="Bound">x</a> <a id="10565" href="Data.Int.html#10550" class="Bound">y</a>
<a data-type="((x y : Int) → is-prop (P x y)) →
((a b x y : Nat) → P (diff a b) (diff x y)) → (x y : Int) → P x y" id="10567" href="Data.Int.html#10360" class="Function">Int-elim₂-prop</a> <a id="10582" href="Data.Int.html#10582" class="Bound">pprop</a> <a id="10588" href="Data.Int.html#10588" class="Bound">f</a> <a id="10590" class="Symbol">=</a>
  <a data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" id="10594" href="Data.Int.html#9942" class="Function">Int-elim-prop</a> <a id="10608" class="Symbol">(λ</a> <a id="10611" href="Data.Int.html#10611" class="Bound">x</a> <a id="10613" class="Symbol">→</a> <a data-type="(n : Nat) →
((x : A) → is-hlevel (B₁ x) n) → is-hlevel ((x : A) → B₁ x) n" id="10615" href="1Lab.HLevel.Retracts.html#4226" class="Function">Π-is-hlevel</a> <a id="10627" class="Number">1</a> <a id="10629" class="Symbol">(</a><a id="10630" href="Data.Int.html#10582" class="Bound">pprop</a> <a id="10636" href="Data.Int.html#10611" class="Bound">x</a><a id="10637" class="Symbol">))</a>
    <a id="10644" class="Symbol">λ</a> <a id="10646" href="Data.Int.html#10646" class="Bound">a</a> <a id="10648" href="Data.Int.html#10648" class="Bound">b</a> <a id="10650" href="Data.Int.html#10650" class="Bound">int</a> <a id="10654" class="Symbol">→</a> <a data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" id="10656" href="Data.Int.html#9942" class="Function">Int-elim-prop</a> <a id="10670" class="Symbol">(λ</a> <a id="10673" href="Data.Int.html#10673" class="Bound">x</a> <a id="10675" class="Symbol">→</a> <a id="10677" href="Data.Int.html#10582" class="Bound">pprop</a> <a id="10683" class="Symbol">(</a><a data-type="Nat → Nat → Int" id="10684" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="10689" href="Data.Int.html#10646" class="Bound">a</a> <a id="10691" href="Data.Int.html#10648" class="Bound">b</a><a id="10692" class="Symbol">)</a> <a id="10694" href="Data.Int.html#10673" class="Bound">x</a><a id="10695" class="Symbol">)</a> <a id="10697" class="Symbol">(</a><a id="10698" href="Data.Int.html#10588" class="Bound">f</a> <a id="10700" href="Data.Int.html#10646" class="Bound">a</a> <a id="10702" href="Data.Int.html#10648" class="Bound">b</a><a id="10703" class="Symbol">)</a> <a id="10705" href="Data.Int.html#10650" class="Bound">int</a>

<a id="Int-elim₃-prop"></a><a data-type="((x y z : Int) → is-prop (P x y z)) →
((a b c d e f : Nat) → P (diff a b) (diff c d) (diff e f)) →
(x y z : Int) → P x y z" id="10710" href="Data.Int.html#10710" class="Function">Int-elim₃-prop</a> <a id="10725" class="Symbol">:</a> <a id="10727" class="Symbol">∀</a> <a id="10729" class="Symbol">{</a><a id="10730" href="Data.Int.html#10730" class="Bound">ℓ</a><a id="10731" class="Symbol">}</a> <a id="10733" class="Symbol">{</a><a id="10734" href="Data.Int.html#10734" class="Bound">P</a> <a id="10736" class="Symbol">:</a> <a data-type="Type" id="10738" href="Data.Int.html#776" class="Datatype">Int</a> <a id="10742" class="Symbol">→</a> <a data-type="Type" id="10744" href="Data.Int.html#776" class="Datatype">Int</a> <a id="10748" class="Symbol">→</a> <a data-type="Type" id="10750" href="Data.Int.html#776" class="Datatype">Int</a> <a id="10754" class="Symbol">→</a> <a id="10756" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="10761" href="Data.Int.html#10730" class="Bound">ℓ</a><a id="10762" class="Symbol">}</a>
               <a id="10779" class="Symbol">→</a> <a id="10781" class="Symbol">((</a><a id="10783" href="Data.Int.html#10783" class="Bound">x</a> <a id="10785" href="Data.Int.html#10785" class="Bound">y</a> <a id="10787" href="Data.Int.html#10787" class="Bound">z</a> <a id="10789" class="Symbol">:</a> <a data-type="Type" id="10791" href="Data.Int.html#776" class="Datatype">Int</a><a id="10794" class="Symbol">)</a> <a id="10796" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="10798" href="1Lab.HLevel.html#2597" class="Function">is-prop</a> <a id="10806" class="Symbol">(</a><a id="10807" href="Data.Int.html#10734" class="Bound">P</a> <a id="10809" href="Data.Int.html#10783" class="Bound">x</a> <a id="10811" href="Data.Int.html#10785" class="Bound">y</a> <a id="10813" href="Data.Int.html#10787" class="Bound">z</a><a id="10814" class="Symbol">))</a>
               <a id="10832" class="Symbol">→</a> <a id="10834" class="Symbol">(</a><a id="10835" href="Data.Int.html#10835" class="Bound">f</a> <a id="10837" class="Symbol">:</a> <a id="10839" class="Symbol">(</a><a id="10840" href="Data.Int.html#10840" class="Bound">a</a> <a id="10842" href="Data.Int.html#10842" class="Bound">b</a> <a id="10844" href="Data.Int.html#10844" class="Bound">c</a> <a id="10846" href="Data.Int.html#10846" class="Bound">d</a> <a id="10848" href="Data.Int.html#10848" class="Bound">e</a> <a id="10850" href="Data.Int.html#10850" class="Bound">f</a> <a id="10852" class="Symbol">:</a> <a data-type="Type" id="10854" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a><a id="10857" class="Symbol">)</a> <a id="10859" class="Symbol">→</a> <a id="10861" href="Data.Int.html#10734" class="Bound">P</a> <a id="10863" class="Symbol">(</a><a data-type="Nat → Nat → Int" id="10864" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="10869" href="Data.Int.html#10840" class="Bound">a</a> <a id="10871" href="Data.Int.html#10842" class="Bound">b</a><a id="10872" class="Symbol">)</a> <a id="10874" class="Symbol">(</a><a data-type="Nat → Nat → Int" id="10875" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="10880" href="Data.Int.html#10844" class="Bound">c</a> <a id="10882" href="Data.Int.html#10846" class="Bound">d</a><a id="10883" class="Symbol">)</a> <a id="10885" class="Symbol">(</a><a data-type="Nat → Nat → Int" id="10886" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="10891" href="Data.Int.html#10848" class="Bound">e</a> <a id="10893" href="Data.Int.html#10850" class="Bound">f</a><a id="10894" class="Symbol">))</a>
               <a id="10912" class="Symbol">→</a> <a id="10914" class="Symbol">(</a><a id="10915" href="Data.Int.html#10915" class="Bound">x</a> <a id="10917" class="Symbol">:</a> <a data-type="Type" id="10919" href="Data.Int.html#776" class="Datatype">Int</a><a id="10922" class="Symbol">)</a> <a id="10924" class="Symbol">(</a><a id="10925" href="Data.Int.html#10925" class="Bound">y</a> <a id="10927" class="Symbol">:</a> <a data-type="Type" id="10929" href="Data.Int.html#776" class="Datatype">Int</a><a id="10932" class="Symbol">)</a> <a id="10934" class="Symbol">(</a><a id="10935" href="Data.Int.html#10935" class="Bound">z</a> <a id="10937" class="Symbol">:</a> <a data-type="Type" id="10939" href="Data.Int.html#776" class="Datatype">Int</a><a id="10942" class="Symbol">)</a> <a id="10944" class="Symbol">→</a> <a id="10946" href="Data.Int.html#10734" class="Bound">P</a> <a id="10948" href="Data.Int.html#10915" class="Bound">x</a> <a id="10950" href="Data.Int.html#10925" class="Bound">y</a> <a id="10952" href="Data.Int.html#10935" class="Bound">z</a>
<a data-type="((x y z : Int) → is-prop (P x y z)) →
((a b c d e f : Nat) → P (diff a b) (diff c d) (diff e f)) →
(x y z : Int) → P x y z" id="10954" href="Data.Int.html#10710" class="Function">Int-elim₃-prop</a> <a id="10969" href="Data.Int.html#10969" class="Bound">pprop</a> <a id="10975" href="Data.Int.html#10975" class="Bound">f</a> <a id="10977" class="Symbol">=</a>
  <a data-type="((x y : Int) → is-prop (P x y)) →
((a b x y : Nat) → P (diff a b) (diff x y)) → (x y : Int) → P x y" id="10981" href="Data.Int.html#10360" class="Function">Int-elim₂-prop</a> <a id="10996" class="Symbol">(λ</a> <a id="10999" href="Data.Int.html#10999" class="Bound">x</a> <a id="11001" href="Data.Int.html#11001" class="Bound">y</a> <a id="11003" class="Symbol">→</a> <a data-type="(n : Nat) →
((x : A) → is-hlevel (B₁ x) n) → is-hlevel ((x : A) → B₁ x) n" id="11005" href="1Lab.HLevel.Retracts.html#4226" class="Function">Π-is-hlevel</a> <a id="11017" class="Number">1</a> <a id="11019" class="Symbol">(</a><a id="11020" href="Data.Int.html#10969" class="Bound">pprop</a> <a id="11026" href="Data.Int.html#10999" class="Bound">x</a> <a id="11028" href="Data.Int.html#11001" class="Bound">y</a><a id="11029" class="Symbol">))</a>
    <a id="11036" class="Symbol">λ</a> <a id="11038" href="Data.Int.html#11038" class="Bound">a</a> <a id="11040" href="Data.Int.html#11040" class="Bound">b</a> <a id="11042" href="Data.Int.html#11042" class="Bound">c</a> <a id="11044" href="Data.Int.html#11044" class="Bound">d</a> <a id="11046" href="Data.Int.html#11046" class="Bound">int</a> <a id="11050" class="Symbol">→</a> <a data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" id="11052" href="Data.Int.html#9942" class="Function">Int-elim-prop</a> <a id="11066" class="Symbol">(λ</a> <a id="11069" href="Data.Int.html#11069" class="Bound">x</a> <a id="11071" class="Symbol">→</a> <a id="11073" href="Data.Int.html#10969" class="Bound">pprop</a> <a id="11079" class="Symbol">(</a><a data-type="Nat → Nat → Int" id="11080" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="11085" href="Data.Int.html#11038" class="Bound">a</a> <a id="11087" href="Data.Int.html#11040" class="Bound">b</a><a id="11088" class="Symbol">)</a> <a id="11090" class="Symbol">(</a><a data-type="Nat → Nat → Int" id="11091" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="11096" href="Data.Int.html#11042" class="Bound">c</a> <a id="11098" href="Data.Int.html#11044" class="Bound">d</a><a id="11099" class="Symbol">)</a> <a id="11101" href="Data.Int.html#11069" class="Bound">x</a><a id="11102" class="Symbol">)</a>
                                  <a id="11138" class="Symbol">(</a><a id="11139" href="Data.Int.html#10975" class="Bound">f</a> <a id="11141" href="Data.Int.html#11038" class="Bound">a</a> <a id="11143" href="Data.Int.html#11040" class="Bound">b</a> <a id="11145" href="Data.Int.html#11042" class="Bound">c</a> <a id="11147" href="Data.Int.html#11044" class="Bound">d</a><a id="11148" class="Symbol">)</a>
                                  <a id="11184" href="Data.Int.html#11046" class="Bound">int</a>
</pre>
</details>
<h1 id="algebra"><a href="#algebra" class="header-link">Algebra<span class="header-link-emoji">🔗</span></a></h1>
<p>With these recursion and elimination helpers, it becomes routine to lift the algebraic operations from naturals to integers:</p>
<h2 id="successors"><a href="#successors" class="header-link">Successors<span class="header-link-emoji">🔗</span></a></h2>
<p>The simplest “algebraic operation” on an integer is taking its successor. In fact, the integers are characterised by being the free type with an equivalence - that equivalence being “successor”.</p>
<pre class="Agda"><a id="sucℤ"></a><a data-type="Int → Int" id="11560" href="Data.Int.html#11560" class="Function">sucℤ</a> <a id="11565" class="Symbol">:</a> <a data-type="Type" id="11567" href="Data.Int.html#776" class="Datatype">Int</a> <a id="11571" class="Symbol">→</a> <a data-type="Type" id="11573" href="Data.Int.html#776" class="Datatype">Int</a>
<a data-type="Int → Int" id="11577" href="Data.Int.html#11560" class="Function">sucℤ</a> <a id="11582" class="Symbol">(</a><a data-type="Nat → Nat → Int" id="11583" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="11588" href="Data.Int.html#11588" class="Bound">x</a> <a id="11590" href="Data.Int.html#11590" class="Bound">y</a><a id="11591" class="Symbol">)</a> <a id="11593" class="Symbol">=</a> <a data-type="Nat → Nat → Int" id="11595" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="11600" class="Symbol">(</a><a data-type="Nat → Nat" id="11601" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="11605" href="Data.Int.html#11588" class="Bound">x</a><a id="11606" class="Symbol">)</a> <a id="11608" href="Data.Int.html#11590" class="Bound">y</a>
<a data-type="Int → Int" id="11610" href="Data.Int.html#11560" class="Function">sucℤ</a> <a id="11615" class="Symbol">(</a><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="11616" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="11621" href="Data.Int.html#11621" class="Bound">m</a> <a id="11623" href="Data.Int.html#11623" class="Bound">n</a> <a id="11625" href="Data.Int.html#11625" class="Bound">i</a><a id="11626" class="Symbol">)</a> <a id="11628" class="Symbol">=</a> <a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="11630" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="11635" class="Symbol">(</a><a data-type="Nat → Nat" id="11636" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="11640" href="Data.Int.html#11621" class="Bound">m</a><a id="11641" class="Symbol">)</a> <a id="11643" href="Data.Int.html#11623" class="Bound">n</a> <a id="11645" href="Data.Int.html#11625" class="Bound">i</a>

<a id="predℤ"></a><a data-type="Int → Int" id="11648" href="Data.Int.html#11648" class="Function">predℤ</a> <a id="11654" class="Symbol">:</a> <a data-type="Type" id="11656" href="Data.Int.html#776" class="Datatype">Int</a> <a id="11660" class="Symbol">→</a> <a data-type="Type" id="11662" href="Data.Int.html#776" class="Datatype">Int</a>
<a data-type="Int → Int" id="11666" href="Data.Int.html#11648" class="Function">predℤ</a> <a id="11672" class="Symbol">(</a><a data-type="Nat → Nat → Int" id="11673" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="11678" href="Data.Int.html#11678" class="Bound">x</a> <a id="11680" href="Data.Int.html#11680" class="Bound">y</a><a id="11681" class="Symbol">)</a> <a id="11683" class="Symbol">=</a> <a data-type="Nat → Nat → Int" id="11685" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="11690" href="Data.Int.html#11678" class="Bound">x</a> <a id="11692" class="Symbol">(</a><a data-type="Nat → Nat" id="11693" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="11697" href="Data.Int.html#11680" class="Bound">y</a><a id="11698" class="Symbol">)</a>
<a data-type="Int → Int" id="11700" href="Data.Int.html#11648" class="Function">predℤ</a> <a id="11706" class="Symbol">(</a><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="11707" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="11712" href="Data.Int.html#11712" class="Bound">m</a> <a id="11714" href="Data.Int.html#11714" class="Bound">n</a> <a id="11716" href="Data.Int.html#11716" class="Bound">i</a><a id="11717" class="Symbol">)</a> <a id="11719" class="Symbol">=</a> <a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="11721" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="11726" href="Data.Int.html#11712" class="Bound">m</a> <a id="11728" class="Symbol">(</a><a data-type="Nat → Nat" id="11729" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="11733" href="Data.Int.html#11714" class="Bound">n</a><a id="11734" class="Symbol">)</a> <a id="11736" href="Data.Int.html#11716" class="Bound">i</a>
</pre>
<p>The successor of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span> is <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1 + a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>.</span> Similarly, the predecessor of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span> is <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mn>1</mn><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, 1 + b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>.</span> By the generating equality <span class="Agda"><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" href="Data.Int.html#822" class="InductiveConstructor">quot</a></span>, we have that predecessor and successor are inverses, since applying both (in either order) takes <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span> to <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>a</mi><mo separator="true">,</mo><mn>1</mn><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1 + a, 1 + b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span>.</span></p>
<pre class="Agda"><a id="pred-sucℤ"></a><a data-type="(x : Int) → predℤ (sucℤ x) ≡ x" id="12020" href="Data.Int.html#12020" class="Function">pred-sucℤ</a> <a id="12030" class="Symbol">:</a> <a id="12032" class="Symbol">(</a><a id="12033" href="Data.Int.html#12033" class="Bound">x</a> <a id="12035" class="Symbol">:</a> <a data-type="Type" id="12037" href="Data.Int.html#776" class="Datatype">Int</a><a id="12040" class="Symbol">)</a> <a id="12042" class="Symbol">→</a> <a data-type="Int → Int" id="12044" href="Data.Int.html#11648" class="Function">predℤ</a> <a id="12050" class="Symbol">(</a><a data-type="Int → Int" id="12051" href="Data.Int.html#11560" class="Function">sucℤ</a> <a id="12056" href="Data.Int.html#12033" class="Bound">x</a><a id="12057" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="12059" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="12061" href="Data.Int.html#12033" class="Bound">x</a>
<a data-type="(x : Int) → predℤ (sucℤ x) ≡ x" id="12063" href="Data.Int.html#12020" class="Function">pred-sucℤ</a> <a id="12073" class="Symbol">(</a><a data-type="Nat → Nat → Int" id="12074" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="12079" href="Data.Int.html#12079" class="Bound">x</a> <a id="12081" href="Data.Int.html#12081" class="Bound">y</a><a id="12082" class="Symbol">)</a> <a id="12084" class="Symbol">=</a> <a data-type="x ≡ y → y ≡ x" id="12086" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="12090" class="Symbol">(</a><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="12091" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="12096" href="Data.Int.html#12079" class="Bound">x</a> <a id="12098" href="Data.Int.html#12081" class="Bound">y</a><a id="12099" class="Symbol">)</a>
<a data-type="(x : Int) → predℤ (sucℤ x) ≡ x" id="12101" href="Data.Int.html#12020" class="Function">pred-sucℤ</a> <a id="12111" class="Symbol">(</a><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="12112" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="12117" href="Data.Int.html#12117" class="Bound">m</a> <a id="12119" href="Data.Int.html#12119" class="Bound">n</a> <a id="12121" href="Data.Int.html#12121" class="Bound">i</a><a id="12122" class="Symbol">)</a> <a id="12124" href="Data.Int.html#12124" class="Bound">j</a> <a id="12126" class="Symbol">=</a> <a data-type="(a b : Nat) →
Square (quot a b) (quot a b) (quot (suc a) (suc b))
(quot (suc a) (suc b))" id="12128" href="Data.Int.html#3601" class="Function">quot-diamond</a> <a id="12141" href="Data.Int.html#12117" class="Bound">m</a> <a id="12143" href="Data.Int.html#12119" class="Bound">n</a> <a id="12145" href="Data.Int.html#12121" class="Bound">i</a> <a id="12147" class="Symbol">(</a><a id="12148" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="12150" href="Data.Int.html#12124" class="Bound">j</a><a id="12151" class="Symbol">)</a>

<a id="suc-predℤ"></a><a data-type="(x : Int) → sucℤ (predℤ x) ≡ x" id="12154" href="Data.Int.html#12154" class="Function">suc-predℤ</a> <a id="12164" class="Symbol">:</a> <a id="12166" class="Symbol">(</a><a id="12167" href="Data.Int.html#12167" class="Bound">x</a> <a id="12169" class="Symbol">:</a> <a data-type="Type" id="12171" href="Data.Int.html#776" class="Datatype">Int</a><a id="12174" class="Symbol">)</a> <a id="12176" class="Symbol">→</a> <a data-type="Int → Int" id="12178" href="Data.Int.html#11560" class="Function">sucℤ</a> <a id="12183" class="Symbol">(</a><a data-type="Int → Int" id="12184" href="Data.Int.html#11648" class="Function">predℤ</a> <a id="12190" href="Data.Int.html#12167" class="Bound">x</a><a id="12191" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="12193" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="12195" href="Data.Int.html#12167" class="Bound">x</a>
<a data-type="(x : Int) → sucℤ (predℤ x) ≡ x" id="12197" href="Data.Int.html#12154" class="Function">suc-predℤ</a> <a id="12207" class="Symbol">(</a><a data-type="Nat → Nat → Int" id="12208" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="12213" href="Data.Int.html#12213" class="Bound">x</a> <a id="12215" href="Data.Int.html#12215" class="Bound">y</a><a id="12216" class="Symbol">)</a> <a id="12218" class="Symbol">=</a> <a data-type="x ≡ y → y ≡ x" id="12220" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="12224" class="Symbol">(</a><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="12225" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="12230" href="Data.Int.html#12213" class="Bound">x</a> <a id="12232" href="Data.Int.html#12215" class="Bound">y</a><a id="12233" class="Symbol">)</a>
<a data-type="(x : Int) → sucℤ (predℤ x) ≡ x" id="12235" href="Data.Int.html#12154" class="Function">suc-predℤ</a> <a id="12245" class="Symbol">(</a><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="12246" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="12251" href="Data.Int.html#12251" class="Bound">m</a> <a id="12253" href="Data.Int.html#12253" class="Bound">n</a> <a id="12255" href="Data.Int.html#12255" class="Bound">i</a><a id="12256" class="Symbol">)</a> <a id="12258" href="Data.Int.html#12258" class="Bound">j</a> <a id="12260" class="Symbol">=</a> <a data-type="(a b : Nat) →
Square (quot a b) (quot a b) (quot (suc a) (suc b))
(quot (suc a) (suc b))" id="12262" href="Data.Int.html#3601" class="Function">quot-diamond</a> <a id="12275" href="Data.Int.html#12251" class="Bound">m</a> <a id="12277" href="Data.Int.html#12253" class="Bound">n</a> <a id="12279" href="Data.Int.html#12255" class="Bound">i</a> <a id="12281" class="Symbol">(</a><a id="12282" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="12284" href="Data.Int.html#12258" class="Bound">j</a><a id="12285" class="Symbol">)</a>

<a id="sucℤ-is-equiv"></a><a data-type="is-equiv sucℤ" id="12288" href="Data.Int.html#12288" class="Function">sucℤ-is-equiv</a> <a id="12302" class="Symbol">:</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="12304" href="1Lab.Equiv.html#2286" class="Record">is-equiv</a> <a data-type="Int → Int" id="12313" href="Data.Int.html#11560" class="Function">sucℤ</a>
<a data-type="is-equiv sucℤ" id="12318" href="Data.Int.html#12288" class="Function">sucℤ-is-equiv</a> <a id="12332" class="Symbol">=</a> <a data-type="(i : is-iso f) → is-equiv f" id="12334" href="1Lab.Equiv.html#19815" class="Function">is-iso→is-equiv</a> <a id="12350" class="Symbol">(</a><a data-type="(inv₁ : B₁ → A) (rinv₁ : is-right-inverse inv₁ f)
(linv₁ : is-left-inverse inv₁ f) →
is-iso f" id="12351" href="1Lab.Equiv.html#6116" class="InductiveConstructor">iso</a> <a data-type="Int → Int" id="12355" href="Data.Int.html#11648" class="Function">predℤ</a> <a data-type="(x : Int) → sucℤ (predℤ x) ≡ x" id="12361" href="Data.Int.html#12154" class="Function">suc-predℤ</a> <a data-type="(x : Int) → predℤ (sucℤ x) ≡ x" id="12371" href="Data.Int.html#12020" class="Function">pred-sucℤ</a><a id="12380" class="Symbol">)</a>

<a id="predℤ-is-equiv"></a><a data-type="is-equiv predℤ" id="12383" href="Data.Int.html#12383" class="Function">predℤ-is-equiv</a> <a id="12398" class="Symbol">:</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="12400" href="1Lab.Equiv.html#2286" class="Record">is-equiv</a> <a data-type="Int → Int" id="12409" href="Data.Int.html#11648" class="Function">predℤ</a>
<a data-type="is-equiv predℤ" id="12415" href="Data.Int.html#12383" class="Function">predℤ-is-equiv</a> <a id="12430" class="Symbol">=</a> <a data-type="(i : is-iso f) → is-equiv f" id="12432" href="1Lab.Equiv.html#19815" class="Function">is-iso→is-equiv</a> <a id="12448" class="Symbol">(</a><a data-type="(inv₁ : B₁ → A) (rinv₁ : is-right-inverse inv₁ f)
(linv₁ : is-left-inverse inv₁ f) →
is-iso f" id="12449" href="1Lab.Equiv.html#6116" class="InductiveConstructor">iso</a> <a data-type="Int → Int" id="12453" href="Data.Int.html#11560" class="Function">sucℤ</a> <a data-type="(x : Int) → predℤ (sucℤ x) ≡ x" id="12458" href="Data.Int.html#12020" class="Function">pred-sucℤ</a> <a data-type="(x : Int) → sucℤ (predℤ x) ≡ x" id="12468" href="Data.Int.html#12154" class="Function">suc-predℤ</a><a id="12477" class="Symbol">)</a>
</pre>
<h2 id="addition"><a href="#addition" class="header-link">Addition<span class="header-link-emoji">🔗</span></a></h2>
<pre class="Agda"><a id="_+ℤ_"></a><a data-type="Int → Int → Int" id="12505" href="Data.Int.html#12505" class="Function Operator">_+ℤ_</a> <a id="12510" class="Symbol">:</a> <a data-type="Type" id="12512" href="Data.Int.html#776" class="Datatype">Int</a> <a id="12516" class="Symbol">→</a> <a data-type="Type" id="12518" href="Data.Int.html#776" class="Datatype">Int</a> <a id="12522" class="Symbol">→</a> <a data-type="Type" id="12524" href="Data.Int.html#776" class="Datatype">Int</a>
<a data-type="Int → Int → Int" id="12528" href="Data.Int.html#12505" class="Function Operator">_+ℤ_</a> <a id="12533" class="Symbol">=</a>
  <a data-type="is-set B₁ →
(f : Nat × Nat → Nat × Nat → B₁) →
((a b x y : Nat) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y)) →
((a b x y : Nat) → f (a , b) (x , y) ≡ f (a , b) (suc x , suc y)) →
Int → Int → B₁" id="12537" href="Data.Int.html#9172" class="Function">Int-rec₂-set</a>
    <a data-type="is-set Int" id="12554" href="Data.Int.html#6613" class="Function">Int-is-set</a>
    <a id="12569" class="Symbol">(λ</a> <a id="12572" class="Symbol">{</a> <a id="12574" class="Symbol">(</a><a id="12575" href="Data.Int.html#12575" class="Bound">a</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="12577" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="12579" href="Data.Int.html#12579" class="Bound">b</a><a id="12580" class="Symbol">)</a> <a id="12582" class="Symbol">(</a><a id="12583" href="Data.Int.html#12583" class="Bound">c</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="12585" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="12587" href="Data.Int.html#12587" class="Bound">d</a><a id="12588" class="Symbol">)</a> <a id="12590" class="Symbol">→</a> <a data-type="Nat → Nat → Int" id="12592" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="12597" class="Symbol">(</a><a id="12598" href="Data.Int.html#12575" class="Bound">a</a> <a data-type="Nat → Nat → Nat" id="12600" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="12602" href="Data.Int.html#12583" class="Bound">c</a><a id="12603" class="Symbol">)</a> <a id="12605" class="Symbol">(</a><a id="12606" href="Data.Int.html#12579" class="Bound">b</a> <a data-type="Nat → Nat → Nat" id="12608" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="12610" href="Data.Int.html#12587" class="Bound">d</a><a id="12611" class="Symbol">)})</a>
    <a id="12619" class="Symbol">(λ</a> <a id="12622" href="Data.Int.html#12622" class="Bound">a</a> <a id="12624" href="Data.Int.html#12624" class="Bound">b</a> <a id="12626" href="Data.Int.html#12626" class="Bound">x</a> <a id="12628" href="Data.Int.html#12628" class="Bound">y</a> <a id="12630" class="Symbol">→</a> <a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="12632" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="12637" class="Symbol">_</a> <a id="12639" class="Symbol">_)</a>
    <a id="12646" class="Symbol">(λ</a> <a id="12649" href="Data.Int.html#12649" class="Bound">a</a> <a id="12651" href="Data.Int.html#12651" class="Bound">b</a> <a id="12653" href="Data.Int.html#12653" class="Bound">x</a> <a id="12655" href="Data.Int.html#12655" class="Bound">y</a> <a id="12657" class="Symbol">→</a> <a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="12659" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="12664" class="Symbol">_</a> <a id="12666" class="Symbol">_</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="12668" href="1Lab.Path.html#39472" class="Function Operator">∙</a> <a data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" id="12670" href="1Lab.Path.html#21189" class="Function">ap₂</a> <a data-type="Nat → Nat → Int" id="12674" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="12679" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="12680" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="12684" class="Symbol">(</a><a data-type="(x y : Nat) → x + suc y ≡ suc (x + y)" id="12685" href="Data.Nat.Properties.html#824" class="Function">+-sucr</a> <a id="12692" class="Symbol">_</a> <a id="12694" class="Symbol">_))</a> <a id="12698" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="12699" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="12703" class="Symbol">(</a><a data-type="(x y : Nat) → x + suc y ≡ suc (x + y)" id="12704" href="Data.Nat.Properties.html#824" class="Function">+-sucr</a> <a id="12711" class="Symbol">_</a> <a id="12713" class="Symbol">_)))</a>
</pre>
<p>Since addition of integers is (essentially!) addition of pairs of naturals, the algebraic properties of <span class="Agda"><a data-type="Nat → Nat → Nat" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a></span> on the natural numbers automatically lift to properties about <span class="Agda"><a data-type="Int → Int → Int" href="Data.Int.html#12505" class="Function Operator">_+ℤ_</a></span>, using the recursion helpers for props (<span class="Agda"><a data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" href="Data.Int.html#9942" class="Function">Int-elim-prop</a></span>) and the fact that <span class="Agda"><a data-type="is-set Int" href="Data.Int.html#6613" class="Function">equality of integers is a proposition</a></span>.</p>
<pre class="Agda"><a id="+ℤ-associative"></a><a data-type="(x y z : Int) → ((x +ℤ y) +ℤ z) ≡ (x +ℤ (y +ℤ z))" id="13070" href="Data.Int.html#13070" class="Function">+ℤ-associative</a> <a id="13085" class="Symbol">:</a> <a id="13087" class="Symbol">(</a><a id="13088" href="Data.Int.html#13088" class="Bound">x</a> <a id="13090" href="Data.Int.html#13090" class="Bound">y</a> <a id="13092" href="Data.Int.html#13092" class="Bound">z</a> <a id="13094" class="Symbol">:</a> <a data-type="Type" id="13096" href="Data.Int.html#776" class="Datatype">Int</a><a id="13099" class="Symbol">)</a> <a id="13101" class="Symbol">→</a> <a id="13103" class="Symbol">(</a><a id="13104" href="Data.Int.html#13088" class="Bound">x</a> <a data-type="Int → Int → Int" id="13106" href="Data.Int.html#12505" class="Function Operator">+ℤ</a> <a id="13109" href="Data.Int.html#13090" class="Bound">y</a><a id="13110" class="Symbol">)</a> <a data-type="Int → Int → Int" id="13112" href="Data.Int.html#12505" class="Function Operator">+ℤ</a> <a id="13115" href="Data.Int.html#13092" class="Bound">z</a> <a data-type="A → A → Type ℓ" id="13117" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="13119" href="Data.Int.html#13088" class="Bound">x</a> <a data-type="Int → Int → Int" id="13121" href="Data.Int.html#12505" class="Function Operator">+ℤ</a> <a id="13124" class="Symbol">(</a><a id="13125" href="Data.Int.html#13090" class="Bound">y</a> <a data-type="Int → Int → Int" id="13127" href="Data.Int.html#12505" class="Function Operator">+ℤ</a> <a id="13130" href="Data.Int.html#13092" class="Bound">z</a><a id="13131" class="Symbol">)</a>
<a data-type="(x y z : Int) → ((x +ℤ y) +ℤ z) ≡ (x +ℤ (y +ℤ z))" id="13133" href="Data.Int.html#13070" class="Function">+ℤ-associative</a> <a id="13148" class="Symbol">=</a>
  <a data-type="((x y z : Int) → is-prop (P x y z)) →
((a b c d e f : Nat) → P (diff a b) (diff c d) (diff e f)) →
(x y z : Int) → P x y z" id="13152" href="Data.Int.html#10710" class="Function">Int-elim₃-prop</a>
    <a id="13171" class="Symbol">(λ</a> <a id="13174" href="Data.Int.html#13174" class="Bound">x</a> <a id="13176" href="Data.Int.html#13176" class="Bound">y</a> <a id="13178" href="Data.Int.html#13178" class="Bound">z</a> <a id="13180" class="Symbol">→</a> <a data-type="is-set Int" id="13182" href="Data.Int.html#6613" class="Function">Int-is-set</a> <a id="13193" class="Symbol">_</a> <a id="13195" class="Symbol">_)</a>
    <a id="13202" class="Symbol">(λ</a> <a id="13205" href="Data.Int.html#13205" class="Bound">a</a> <a id="13207" href="Data.Int.html#13207" class="Bound">b</a> <a id="13209" href="Data.Int.html#13209" class="Bound">c</a> <a id="13211" href="Data.Int.html#13211" class="Bound">d</a> <a id="13213" href="Data.Int.html#13213" class="Bound">e</a> <a id="13215" href="Data.Int.html#13215" class="Bound">f</a> <a id="13217" class="Symbol">→</a> <a data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" id="13219" href="1Lab.Path.html#21189" class="Function">ap₂</a> <a data-type="Nat → Nat → Int" id="13223" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="13228" class="Symbol">(</a><a data-type="(x y z : Nat) → x + y + z ≡ x + (y + z)" id="13229" href="Data.Nat.Properties.html#506" class="Function">+-associative</a> <a id="13243" href="Data.Int.html#13205" class="Bound">a</a> <a id="13245" href="Data.Int.html#13209" class="Bound">c</a> <a id="13247" href="Data.Int.html#13213" class="Bound">e</a><a id="13248" class="Symbol">)</a> <a id="13250" class="Symbol">(</a><a data-type="(x y z : Nat) → x + y + z ≡ x + (y + z)" id="13251" href="Data.Nat.Properties.html#506" class="Function">+-associative</a> <a id="13265" href="Data.Int.html#13207" class="Bound">b</a> <a id="13267" href="Data.Int.html#13211" class="Bound">d</a> <a id="13269" href="Data.Int.html#13215" class="Bound">f</a><a id="13270" class="Symbol">))</a>

<a id="+ℤ-zerol"></a><a data-type="(x : Int) → (0 +ℤ x) ≡ x" id="13274" href="Data.Int.html#13274" class="Function">+ℤ-zerol</a> <a id="13283" class="Symbol">:</a> <a id="13285" class="Symbol">(</a><a id="13286" href="Data.Int.html#13286" class="Bound">x</a> <a id="13288" class="Symbol">:</a> <a data-type="Type" id="13290" href="Data.Int.html#776" class="Datatype">Int</a><a id="13293" class="Symbol">)</a> <a id="13295" class="Symbol">→</a> <a id="13297" class="Number">0</a> <a data-type="Int → Int → Int" id="13299" href="Data.Int.html#12505" class="Function Operator">+ℤ</a> <a id="13302" href="Data.Int.html#13286" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="13304" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="13306" href="Data.Int.html#13286" class="Bound">x</a>
<a data-type="(x : Int) → (0 +ℤ x) ≡ x" id="13308" href="Data.Int.html#13274" class="Function">+ℤ-zerol</a> <a id="13317" class="Symbol">=</a> <a data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" id="13319" href="Data.Int.html#9942" class="Function">Int-elim-prop</a> <a id="13333" class="Symbol">(λ</a> <a id="13336" href="Data.Int.html#13336" class="Bound">x</a> <a id="13338" class="Symbol">→</a> <a data-type="is-set Int" id="13340" href="Data.Int.html#6613" class="Function">Int-is-set</a> <a id="13351" class="Symbol">_</a> <a id="13353" class="Symbol">_)</a> <a id="13356" class="Symbol">(λ</a> <a id="13359" href="Data.Int.html#13359" class="Bound">a</a> <a id="13361" href="Data.Int.html#13361" class="Bound">b</a> <a id="13363" class="Symbol">→</a> <a data-type="x ≡ x" id="13365" href="1Lab.Path.html#3593" class="Function">refl</a><a id="13369" class="Symbol">)</a>

<a id="+ℤ-zeror"></a><a data-type="(x : Int) → (x +ℤ 0) ≡ x" id="13372" href="Data.Int.html#13372" class="Function">+ℤ-zeror</a> <a id="13381" class="Symbol">:</a> <a id="13383" class="Symbol">(</a><a id="13384" href="Data.Int.html#13384" class="Bound">x</a> <a id="13386" class="Symbol">:</a> <a data-type="Type" id="13388" href="Data.Int.html#776" class="Datatype">Int</a><a id="13391" class="Symbol">)</a> <a id="13393" class="Symbol">→</a> <a id="13395" href="Data.Int.html#13384" class="Bound">x</a> <a data-type="Int → Int → Int" id="13397" href="Data.Int.html#12505" class="Function Operator">+ℤ</a> <a id="13400" class="Number">0</a> <a data-type="A → A → Type ℓ" id="13402" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="13404" href="Data.Int.html#13384" class="Bound">x</a>
<a data-type="(x : Int) → (x +ℤ 0) ≡ x" id="13406" href="Data.Int.html#13372" class="Function">+ℤ-zeror</a> <a id="13415" class="Symbol">=</a>
  <a data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" id="13419" href="Data.Int.html#9942" class="Function">Int-elim-prop</a> <a id="13433" class="Symbol">(λ</a> <a id="13436" href="Data.Int.html#13436" class="Bound">x</a> <a id="13438" class="Symbol">→</a> <a data-type="is-set Int" id="13440" href="Data.Int.html#6613" class="Function">Int-is-set</a> <a id="13451" class="Symbol">_</a> <a id="13453" class="Symbol">_)</a> <a id="13456" class="Symbol">(λ</a> <a id="13459" href="Data.Int.html#13459" class="Bound">a</a> <a id="13461" href="Data.Int.html#13461" class="Bound">b</a> <a id="13463" class="Symbol">→</a> <a data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" id="13465" href="1Lab.Path.html#21189" class="Function">ap₂</a> <a data-type="Nat → Nat → Int" id="13469" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="13474" class="Symbol">(</a><a data-type="(x : Nat) → x + 0 ≡ x" id="13475" href="Data.Nat.Properties.html#699" class="Function">+-zeror</a> <a id="13483" href="Data.Int.html#13459" class="Bound">a</a><a id="13484" class="Symbol">)</a> <a id="13486" class="Symbol">(</a><a data-type="(x : Nat) → x + 0 ≡ x" id="13487" href="Data.Nat.Properties.html#699" class="Function">+-zeror</a> <a id="13495" href="Data.Int.html#13461" class="Bound">b</a><a id="13496" class="Symbol">))</a>

<a id="+ℤ-commutative"></a><a data-type="(x y : Int) → (x +ℤ y) ≡ (y +ℤ x)" id="13500" href="Data.Int.html#13500" class="Function">+ℤ-commutative</a> <a id="13515" class="Symbol">:</a> <a id="13517" class="Symbol">(</a><a id="13518" href="Data.Int.html#13518" class="Bound">x</a> <a id="13520" href="Data.Int.html#13520" class="Bound">y</a> <a id="13522" class="Symbol">:</a> <a data-type="Type" id="13524" href="Data.Int.html#776" class="Datatype">Int</a><a id="13527" class="Symbol">)</a> <a id="13529" class="Symbol">→</a> <a id="13531" href="Data.Int.html#13518" class="Bound">x</a> <a data-type="Int → Int → Int" id="13533" href="Data.Int.html#12505" class="Function Operator">+ℤ</a> <a id="13536" href="Data.Int.html#13520" class="Bound">y</a> <a data-type="A → A → Type ℓ" id="13538" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="13540" href="Data.Int.html#13520" class="Bound">y</a> <a data-type="Int → Int → Int" id="13542" href="Data.Int.html#12505" class="Function Operator">+ℤ</a> <a id="13545" href="Data.Int.html#13518" class="Bound">x</a>
<a data-type="(x y : Int) → (x +ℤ y) ≡ (y +ℤ x)" id="13547" href="Data.Int.html#13500" class="Function">+ℤ-commutative</a> <a id="13562" class="Symbol">=</a>
  <a data-type="((x y : Int) → is-prop (P x y)) →
((a b x y : Nat) → P (diff a b) (diff x y)) → (x y : Int) → P x y" id="13566" href="Data.Int.html#10360" class="Function">Int-elim₂-prop</a> <a id="13581" class="Symbol">(λ</a> <a id="13584" href="Data.Int.html#13584" class="Bound">x</a> <a id="13586" href="Data.Int.html#13586" class="Bound">y</a> <a id="13588" class="Symbol">→</a> <a data-type="is-set Int" id="13590" href="Data.Int.html#6613" class="Function">Int-is-set</a> <a id="13601" class="Symbol">_</a> <a id="13603" class="Symbol">_)</a>
    <a id="13610" class="Symbol">(λ</a> <a id="13613" href="Data.Int.html#13613" class="Bound">a</a> <a id="13615" href="Data.Int.html#13615" class="Bound">b</a> <a id="13617" href="Data.Int.html#13617" class="Bound">c</a> <a id="13619" href="Data.Int.html#13619" class="Bound">d</a> <a id="13621" class="Symbol">→</a> <a data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" id="13623" href="1Lab.Path.html#21189" class="Function">ap₂</a> <a data-type="Nat → Nat → Int" id="13627" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="13632" class="Symbol">(</a><a data-type="(x y : Nat) → x + y ≡ y + x" id="13633" href="Data.Nat.Properties.html#932" class="Function">+-commutative</a> <a id="13647" href="Data.Int.html#13613" class="Bound">a</a> <a id="13649" href="Data.Int.html#13617" class="Bound">c</a><a id="13650" class="Symbol">)</a> <a id="13652" class="Symbol">(</a><a data-type="(x y : Nat) → x + y ≡ y + x" id="13653" href="Data.Nat.Properties.html#932" class="Function">+-commutative</a> <a id="13667" href="Data.Int.html#13615" class="Bound">b</a> <a id="13669" href="Data.Int.html#13619" class="Bound">d</a><a id="13670" class="Symbol">))</a>
</pre>
<h2 id="inverses"><a href="#inverses" class="header-link">Inverses<span class="header-link-emoji">🔗</span></a></h2>
<p>Every integer <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> has an additive inverse, denoted <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">-x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord mathnormal">x</span></span></span></span>,</span> which is obtained by swapping the components of the pair. Since the definition of <span class="Agda"><a data-type="Int → Int" href="Data.Int.html#13934" class="Function">negate</a></span> is very simple, it can be written conveniently without using <span class="Agda"><a data-type="(f : Nat → Nat → X) →
((a b : Nat) → f a b ≡ f (suc a) (suc b)) → Int → X" href="Data.Int.html#6860" class="Function">Int-rec</a></span>:</p>
<pre class="Agda"><a id="negate"></a><a data-type="Int → Int" id="13934" href="Data.Int.html#13934" class="Function">negate</a> <a id="13941" class="Symbol">:</a> <a data-type="Type" id="13943" href="Data.Int.html#776" class="Datatype">Int</a> <a id="13947" class="Symbol">→</a> <a data-type="Type" id="13949" href="Data.Int.html#776" class="Datatype">Int</a>
<a data-type="Int → Int" id="13953" href="Data.Int.html#13934" class="Function">negate</a> <a id="13960" class="Symbol">(</a><a data-type="Nat → Nat → Int" id="13961" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="13966" href="Data.Int.html#13966" class="Bound">x</a> <a id="13968" href="Data.Int.html#13968" class="Bound">y</a><a id="13969" class="Symbol">)</a> <a id="13971" class="Symbol">=</a> <a data-type="Nat → Nat → Int" id="13973" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="13978" href="Data.Int.html#13968" class="Bound">y</a> <a id="13980" href="Data.Int.html#13966" class="Bound">x</a>
<a data-type="Int → Int" id="13982" href="Data.Int.html#13934" class="Function">negate</a> <a id="13989" class="Symbol">(</a><a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="13990" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="13995" href="Data.Int.html#13995" class="Bound">m</a> <a id="13997" href="Data.Int.html#13997" class="Bound">n</a> <a id="13999" href="Data.Int.html#13999" class="Bound">i</a><a id="14000" class="Symbol">)</a> <a id="14002" class="Symbol">=</a> <a data-type="(m n : Nat) → diff m n ≡ diff (suc m) (suc n)" id="14004" href="Data.Int.html#822" class="InductiveConstructor">quot</a> <a id="14009" href="Data.Int.html#13997" class="Bound">n</a> <a id="14011" href="Data.Int.html#13995" class="Bound">m</a> <a id="14013" href="Data.Int.html#13999" class="Bound">i</a>
</pre>
<p>The proof that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">-x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord mathnormal">x</span></span></span></span> is an additive inverse to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> follows, essentially, from commutativity of addition on natural numbers, and the fact that <span class="Agda"><a data-type="(n : Nat) → diff 0 0 ≡ diff n n" href="Data.Int.html#1487" class="Function">all zeroes are identified</a></span>.</p>
<pre class="Agda"><a id="+ℤ-inverser"></a><a data-type="(x : Int) → (x +ℤ negate x) ≡ 0" id="14219" href="Data.Int.html#14219" class="Function">+ℤ-inverser</a> <a id="14231" class="Symbol">:</a> <a id="14233" class="Symbol">(</a><a id="14234" href="Data.Int.html#14234" class="Bound">x</a> <a id="14236" class="Symbol">:</a> <a data-type="Type" id="14238" href="Data.Int.html#776" class="Datatype">Int</a><a id="14241" class="Symbol">)</a> <a id="14243" class="Symbol">→</a> <a id="14245" href="Data.Int.html#14234" class="Bound">x</a> <a data-type="Int → Int → Int" id="14247" href="Data.Int.html#12505" class="Function Operator">+ℤ</a> <a data-type="Int → Int" id="14250" href="Data.Int.html#13934" class="Function">negate</a> <a id="14257" href="Data.Int.html#14234" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="14259" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="14261" class="Number">0</a>
<a data-type="(x : Int) → (x +ℤ negate x) ≡ 0" id="14263" href="Data.Int.html#14219" class="Function">+ℤ-inverser</a> <a id="14275" class="Symbol">=</a>
  <a data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" id="14279" href="Data.Int.html#9942" class="Function">Int-elim-prop</a> <a id="14293" class="Symbol">(λ</a> <a id="14296" href="Data.Int.html#14296" class="Bound">_</a> <a id="14298" class="Symbol">→</a> <a data-type="is-set Int" id="14300" href="Data.Int.html#6613" class="Function">Int-is-set</a> <a id="14311" class="Symbol">_</a> <a id="14313" class="Symbol">_)</a> <a id="14316" class="Symbol">λ</a> <a id="14318" class="Keyword">where</a>
    <a id="14328" href="Data.Int.html#14328" class="Bound">a</a> <a id="14330" href="Data.Int.html#14330" class="Bound">b</a> <a id="14332" class="Symbol">→</a> <a data-type="Nat → Nat → Int" id="14334" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="14339" class="Symbol">(</a><a id="14340" href="Data.Int.html#14328" class="Bound">a</a> <a data-type="Nat → Nat → Nat" id="14342" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="14344" href="Data.Int.html#14330" class="Bound">b</a><a id="14345" class="Symbol">)</a> <a id="14347" class="Symbol">(</a><a id="14348" href="Data.Int.html#14330" class="Bound">b</a> <a data-type="Nat → Nat → Nat" id="14350" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="14352" href="Data.Int.html#14328" class="Bound">a</a><a id="14353" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="14355" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" id="14358" href="1Lab.Path.html#21189" class="Function">ap₂</a> <a data-type="Nat → Nat → Int" id="14362" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a data-type="x ≡ x" id="14367" href="1Lab.Path.html#3593" class="Function">refl</a> <a id="14372" class="Symbol">(</a><a data-type="(x y : Nat) → x + y ≡ y + x" id="14373" href="Data.Nat.Properties.html#932" class="Function">+-commutative</a> <a id="14387" href="Data.Int.html#14330" class="Bound">b</a> <a id="14389" href="Data.Int.html#14328" class="Bound">a</a><a id="14390" class="Symbol">)</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="14392" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a data-type="Nat → Nat → Int" id="14404" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="14409" class="Symbol">(</a><a id="14410" href="Data.Int.html#14328" class="Bound">a</a> <a data-type="Nat → Nat → Nat" id="14412" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="14414" href="Data.Int.html#14330" class="Bound">b</a><a id="14415" class="Symbol">)</a> <a id="14417" class="Symbol">(</a><a id="14418" href="Data.Int.html#14328" class="Bound">a</a> <a data-type="Nat → Nat → Nat" id="14420" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="14422" href="Data.Int.html#14330" class="Bound">b</a><a id="14423" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="14425" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="x ≡ y → y ≡ x" id="14428" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="14432" class="Symbol">(</a><a data-type="(n : Nat) → diff 0 0 ≡ diff n n" id="14433" href="Data.Int.html#1487" class="Function">zeroes</a> <a id="14440" class="Symbol">(</a><a id="14441" href="Data.Int.html#14328" class="Bound">a</a> <a data-type="Nat → Nat → Nat" id="14443" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="14445" href="Data.Int.html#14330" class="Bound">b</a><a id="14446" class="Symbol">))</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="14449" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a data-type="Nat → Nat → Int" id="14461" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="14466" class="Number">0</a> <a id="14468" class="Number">0</a>             <a data-type="(x : A) → x ≡ x" id="14482" href="1Lab.Path.html#46957" class="Function Operator">∎</a>

<a id="+ℤ-inversel"></a><a data-type="(x : Int) → (negate x +ℤ x) ≡ 0" id="14485" href="Data.Int.html#14485" class="Function">+ℤ-inversel</a> <a id="14497" class="Symbol">:</a> <a id="14499" class="Symbol">(</a><a id="14500" href="Data.Int.html#14500" class="Bound">x</a> <a id="14502" class="Symbol">:</a> <a data-type="Type" id="14504" href="Data.Int.html#776" class="Datatype">Int</a><a id="14507" class="Symbol">)</a> <a id="14509" class="Symbol">→</a> <a data-type="Int → Int" id="14511" href="Data.Int.html#13934" class="Function">negate</a> <a id="14518" href="Data.Int.html#14500" class="Bound">x</a> <a data-type="Int → Int → Int" id="14520" href="Data.Int.html#12505" class="Function Operator">+ℤ</a> <a id="14523" href="Data.Int.html#14500" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="14525" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="14527" class="Number">0</a>
<a data-type="(x : Int) → (negate x +ℤ x) ≡ 0" id="14529" href="Data.Int.html#14485" class="Function">+ℤ-inversel</a> <a id="14541" class="Symbol">=</a>
  <a data-type="((x : Int) → is-prop (P x)) →
((a b : Nat) → P (diff a b)) → (x : Int) → P x" id="14545" href="Data.Int.html#9942" class="Function">Int-elim-prop</a> <a id="14559" class="Symbol">(λ</a> <a id="14562" href="Data.Int.html#14562" class="Bound">_</a> <a id="14564" class="Symbol">→</a> <a data-type="is-set Int" id="14566" href="Data.Int.html#6613" class="Function">Int-is-set</a> <a id="14577" class="Symbol">_</a> <a id="14579" class="Symbol">_)</a> <a id="14582" class="Symbol">λ</a> <a id="14584" class="Keyword">where</a>
    <a id="14594" href="Data.Int.html#14594" class="Bound">a</a> <a id="14596" href="Data.Int.html#14596" class="Bound">b</a> <a id="14598" class="Symbol">→</a> <a data-type="Nat → Nat → Int" id="14600" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="14605" class="Symbol">(</a><a id="14606" href="Data.Int.html#14596" class="Bound">b</a> <a data-type="Nat → Nat → Nat" id="14608" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="14610" href="Data.Int.html#14594" class="Bound">a</a><a id="14611" class="Symbol">)</a> <a id="14613" class="Symbol">(</a><a id="14614" href="Data.Int.html#14594" class="Bound">a</a> <a data-type="Nat → Nat → Nat" id="14616" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="14618" href="Data.Int.html#14596" class="Bound">b</a><a id="14619" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="14621" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" id="14624" href="1Lab.Path.html#21189" class="Function">ap₂</a> <a data-type="Nat → Nat → Int" id="14628" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="14633" class="Symbol">(</a><a data-type="(x y : Nat) → x + y ≡ y + x" id="14634" href="Data.Nat.Properties.html#932" class="Function">+-commutative</a> <a id="14648" href="Data.Int.html#14596" class="Bound">b</a> <a id="14650" href="Data.Int.html#14594" class="Bound">a</a><a id="14651" class="Symbol">)</a> <a data-type="x ≡ x" id="14653" href="1Lab.Path.html#3593" class="Function">refl</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="14658" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a data-type="Nat → Nat → Int" id="14670" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="14675" class="Symbol">(</a><a id="14676" href="Data.Int.html#14594" class="Bound">a</a> <a data-type="Nat → Nat → Nat" id="14678" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="14680" href="Data.Int.html#14596" class="Bound">b</a><a id="14681" class="Symbol">)</a> <a id="14683" class="Symbol">(</a><a id="14684" href="Data.Int.html#14594" class="Bound">a</a> <a data-type="Nat → Nat → Nat" id="14686" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="14688" href="Data.Int.html#14596" class="Bound">b</a><a id="14689" class="Symbol">)</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="14691" href="1Lab.Path.html#46629" class="Function">≡⟨</a> <a data-type="x ≡ y → y ≡ x" id="14694" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="14698" class="Symbol">(</a><a data-type="(n : Nat) → diff 0 0 ≡ diff n n" id="14699" href="Data.Int.html#1487" class="Function">zeroes</a> <a id="14706" class="Symbol">(</a><a id="14707" href="Data.Int.html#14594" class="Bound">a</a> <a data-type="Nat → Nat → Nat" id="14709" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="14711" href="Data.Int.html#14596" class="Bound">b</a><a id="14712" class="Symbol">))</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="14715" href="1Lab.Path.html#46629" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a data-type="Nat → Nat → Int" id="14727" href="Data.Int.html#795" class="InductiveConstructor">diff</a> <a id="14732" class="Number">0</a> <a id="14734" class="Number">0</a>             <a data-type="(x : A) → x ≡ x" id="14748" href="1Lab.Path.html#46957" class="Function Operator">∎</a>
</pre>
<p>Since <span class="Agda"><a data-type="Int → Int" href="Data.Int.html#13934" class="Function">negate</a></span> is precisely what’s missing for <span class="Agda"><a data-type="Type" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a></span> to be a group, we <em>can</em> turn <a href="Algebra.Group.html#the-integers">the integers</a> into a group. Subtraction is defined as addition with the inverse, rather than directly on <span class="Agda"><a data-type="Nat → Nat → Int" href="Data.Int.html#795" class="InductiveConstructor">diff</a></span>:</p>
<pre class="Agda"><a id="_-ℤ_"></a><a data-type="Int → Int → Int" id="15030" href="Data.Int.html#15030" class="Function Operator">_-ℤ_</a> <a id="15035" class="Symbol">:</a> <a data-type="Type" id="15037" href="Data.Int.html#776" class="Datatype">Int</a> <a id="15041" class="Symbol">→</a> <a data-type="Type" id="15043" href="Data.Int.html#776" class="Datatype">Int</a> <a id="15047" class="Symbol">→</a> <a data-type="Type" id="15049" href="Data.Int.html#776" class="Datatype">Int</a>
<a id="15053" href="Data.Int.html#15053" class="Bound">x</a> <a data-type="Int → Int → Int" id="15055" href="Data.Int.html#15030" class="Function Operator">-ℤ</a> <a id="15058" href="Data.Int.html#15058" class="Bound">y</a> <a id="15060" class="Symbol">=</a> <a id="15062" href="Data.Int.html#15053" class="Bound">x</a> <a data-type="Int → Int → Int" id="15064" href="Data.Int.html#12505" class="Function Operator">+ℤ</a> <a data-type="Int → Int" id="15067" href="Data.Int.html#13934" class="Function">negate</a> <a id="15074" href="Data.Int.html#15058" class="Bound">y</a>
</pre>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>In the diagram, we write <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">S</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\id{S}x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathrm">S</span><span class="mord mathnormal">x</span></span></span></span> for <code>suc x</code>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
  </article>
</div>

</main>
</body>
</html>
