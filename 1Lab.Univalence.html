<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>

<head>
  <meta charset="utf-8"></meta>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"></meta>
  <meta name="keywords" content="Agda,categories,topos"></meta>

  <title>1Lab.Univalence - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css"></link>
  <link rel="stylesheet" href="/css/katex.min.css"></link>
  <link rel="stylesheet" href="/css/agda-cats.css"></link>

  <meta name="twitter:card" content="summary"></meta>
  <meta name="twitter:title" content="1Lab.Univalence - 1Lab"></meta>
  <meta name="twitter:image" content="https://cubical.1lab.dev/static/cube-128x.png"></meta>

  <meta name="og:title" content="1Lab.Univalence - 1Lab"></meta>
  <meta name="og:image" content="https://cubical.1lab.dev/static/cube-128x.png"></meta>
  <meta name="og:site-name" content="The 1Lab"></meta>
  <meta name="og:type" content="website"></meta>
    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory."></meta>
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory."></meta>
  
  <script src="/equations.js" type="text/javascript"></script> 
  <script src="/highlight-hover.js" type="text/javascript"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>
</head>

<body>
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0;">
                <a class="Module">1Lab.Univalence</a>
              </h3>

      <!-- Cube logo -->
      <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto; height: 32px;"></img>
      
      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr></hr>
      <ul class="incremental">
      <li><a href="#univalence"><a href="#univalence" class="header-link">Univalence<span class="header-link-emoji">🔗</span></a></a>
      <ul class="incremental">
      <li><a href="#glue"><a href="#glue" class="header-link">Glue<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#paths-from-glue"><a href="#paths-from-glue" class="header-link">Paths from Glue<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#paths-over-ua"><a href="#paths-over-ua" class="header-link">Paths over ua<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#the-axiom"><a href="#the-axiom" class="header-link">The “axiom”<span class="header-link-emoji">🔗</span></a></a>
      <ul class="incremental">
      <li><a href="#equivalence-induction"><a href="#equivalence-induction" class="header-link">Equivalence Induction<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#object-classifiers"><a href="#object-classifiers" class="header-link">Object Classifiers<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      </ul>
      <hr></hr>

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>
      </div>

      <hr></hr>

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
              <a href="index.html">️back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/e1d6219e5e4bf2e7dbcc3bef6b8e75da1eaee107/src/1Lab/Univalence.lagda.md">link to source</a> <br />
      </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="index.html">️back to index</a>
      </div>
      
      <!-- Font toggle checkbox -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="1Lab.Type.Sigma.html" class="Module">1Lab.Type.Sigma</a>
<a id="37" class="Keyword">open</a> <a id="42" class="Keyword">import</a> <a id="49" href="1Lab.HLevel.html" class="Module">1Lab.HLevel</a>
<a id="61" class="Keyword">open</a> <a id="66" class="Keyword">import</a> <a id="73" href="1Lab.Equiv.html" class="Module">1Lab.Equiv</a>
<a id="84" class="Keyword">open</a> <a id="89" class="Keyword">import</a> <a id="96" href="1Lab.Path.html" class="Module">1Lab.Path</a>
<a id="106" class="Keyword">open</a> <a id="111" class="Keyword">import</a> <a id="118" href="1Lab.Type.html" class="Module">1Lab.Type</a>

<a id="129" class="Keyword">module</a> <a id="136" href="1Lab.Univalence.html" class="Module">1Lab.Univalence</a> <a id="152" class="Keyword">where</a>
</pre>
<h1 id="univalence"><a href="#univalence" class="header-link">Univalence<span class="header-link-emoji">🔗</span></a></h1>
<p>In Homotopy Type Theory, <strong>univalence</strong> is the principle stating that <a href="1Lab.Equiv.html#_≃_">equivalent</a> types can be <a href="1Lab.Path.html#Path">identified</a>. When <a href="https://homotopytypetheory.org/book">the book</a> first came out, there was no widely-accepted <em>computational</em> interpretation of this principle, so it was added to the theory as an axiom: the <strong>univalence axiom</strong>.</p>
<p>Precisely, the axiom as presented in the book consists of the following data (right under remark §2.10.4):</p>
<ul class="incremental">
<li><p>A map which turns equivalences into propositional equalities of type. This map is called <span class="Agda"><a data-type="A ≃ B → A ≡ B" href="1Lab.Univalence.html#8796" class="Function">ua</a></span>.</p></li>
<li><p>A rule for eliminating equalities of types, by turning them into equivalences: <span class="Agda"><a data-type="A ≡ B → A ≃ B" href="1Lab.Univalence.html#15463" class="Function">pathToEquiv</a></span></p></li>
<li><p>The propositional computation rule, stating that transport along <code>ua(f)</code> is equal to applying <code>f</code>: <span class="Agda"><a data-type="(f : A ≃ B) (x : A) → transport (ua f) x ≡ f .fst x" href="1Lab.Univalence.html#10955" class="Function">uaβ</a></span>.</p></li>
</ul>
<p>In the book, there is an extra postulated datum asserting that <span class="Agda"><a data-type="A ≃ B → A ≡ B" href="1Lab.Univalence.html#8796" class="Function">ua</a></span> is an inverse to <span class="Agda"><a data-type="A ≡ B → A ≃ B" href="1Lab.Univalence.html#15463" class="Function">pathToEquiv</a></span>. This datum does not have a name in this development, because it’s proved in-line in the construction of the term <span class="Agda"><a data-type="isEquiv pathToEquiv" href="1Lab.Univalence.html#16752" class="Function">univalence</a></span>.</p>
<p>The point of cubical type theory is to give these terms constructive interpretations, i.e., make them definable in the theory, in terms of constructions that have computational behaviour. Let’s see how this is done.</p>
<h2 id="glue"><a href="#glue" class="header-link">Glue<span class="header-link-emoji">🔗</span></a></h2>
<p>To even <em>state</em> univalence, we first have to make sure that the concept of “paths between types” makes sense in the first place. In “Book HoTT”, paths between types are a well-formed concept because the path type is uniformly inductively defined for <em>everything</em> — including universes. This is not the case in Cubical type theory, where for paths in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> to be well-behaved, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> must <a href="1Lab.Path.html#fibrant">be <em>fibrant</em></a>.</p>
<p>Since there’s no obvious choice for how to interpret <span class="Agda"><a href="1Lab.Path.html#907" class="Primitive">hcomp</a></span> in <span class="Agda"><a href="1Lab.Type.html#394" class="Primitive">Type</a></span>, a fine solution is to make <span class="Agda"><a href="1Lab.Path.html#907" class="Primitive">hcomp</a></span> its own type former. This is the approach taken by some Cubical type theories in the <a href="https://redprl.org/">RedPRL school</a>. Univalence in those type theories is then achieved by adding a type former, called <code>V</code>, which turns an equivalence into a path.</p>
<p>In <a href="https://arxiv.org/abs/1611.02108">CCHM</a> — and therefore Cubical Agda — a different approach is taken, which combines proving univalence with defining a fibrancy structure for the universe. The core idea is to define a new type former, <span class="Agda"><a data-type="(A : Type ℓ) → Partial φ (Σ (λ T → T ≃ A)) → Type ℓ&#39;" href="1Lab.Univalence.html#3409" class="Function">Glue</a></span>, which “glues” a <a href="1Lab.Path.html#partial-elements">partial type</a>, along an equivalence, to a total type.</p>
<!--
<pre class="Agda"><a id="2814" class="Keyword">private</a>
  <a id="2824" class="Keyword">variable</a>
    <a id="2837" href="1Lab.Univalence.html#2837" class="Generalizable">ℓ</a> <a id="2839" href="1Lab.Univalence.html#2839" class="Generalizable">ℓ&#39;</a> <a id="2842" class="Symbol">:</a> <a id="2844" href="Agda.Primitive.html#597" class="Postulate">Level</a>

  <a id="2853" class="Keyword">primitive</a>
    <a id="primGlue"></a><a id="2867" href="1Lab.Univalence.html#2867" class="Primitive">primGlue</a> <a id="2876" class="Symbol">:</a> <a id="2878" class="Symbol">(</a><a id="2879" href="1Lab.Univalence.html#2879" class="Bound">A</a> <a id="2881" class="Symbol">:</a> <a id="2883" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2888" href="1Lab.Univalence.html#2837" class="Generalizable">ℓ</a><a id="2889" class="Symbol">)</a> <a id="2891" class="Symbol">{</a><a id="2892" href="1Lab.Univalence.html#2892" class="Bound">φ</a> <a id="2894" class="Symbol">:</a> <a id="2896" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="2897" class="Symbol">}</a>
             <a id="2912" class="Symbol">→</a> <a id="2914" class="Symbol">(</a><a id="2915" href="1Lab.Univalence.html#2915" class="Bound">T</a> <a id="2917" class="Symbol">:</a> <a id="2919" href="Agda.Primitive.Cubical.html#1065" class="Primitive">Partial</a> <a id="2927" href="1Lab.Univalence.html#2892" class="Bound">φ</a> <a id="2929" class="Symbol">(</a><a id="2930" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2935" href="1Lab.Univalence.html#2839" class="Generalizable">ℓ&#39;</a><a id="2937" class="Symbol">))</a> <a id="2940" class="Symbol">→</a> <a id="2942" class="Symbol">(</a><a id="2943" href="1Lab.Univalence.html#2943" class="Bound">e</a> <a id="2945" class="Symbol">:</a> <a id="2947" href="Agda.Primitive.Cubical.html#1099" class="Primitive">PartialP</a> <a id="2956" href="1Lab.Univalence.html#2892" class="Bound">φ</a> <a id="2958" class="Symbol">(λ</a> <a id="2961" href="1Lab.Univalence.html#2961" class="Bound">o</a> <a id="2963" class="Symbol">→</a> <a id="2965" href="1Lab.Univalence.html#2915" class="Bound">T</a> <a id="2967" href="1Lab.Univalence.html#2961" class="Bound">o</a> <a id="2969" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="2971" href="1Lab.Univalence.html#2879" class="Bound">A</a><a id="2972" class="Symbol">))</a>
             <a id="2988" class="Symbol">→</a> <a id="2990" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2995" href="1Lab.Univalence.html#2839" class="Generalizable">ℓ&#39;</a>

    <a id="prim^glue"></a><a id="3003" href="1Lab.Univalence.html#3003" class="Primitive">prim^glue</a> <a id="3013" class="Symbol">:</a> <a id="3015" class="Symbol">{</a><a id="3016" href="1Lab.Univalence.html#3016" class="Bound">A</a> <a id="3018" class="Symbol">:</a> <a id="3020" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3025" href="1Lab.Univalence.html#2837" class="Generalizable">ℓ</a><a id="3026" class="Symbol">}</a> <a id="3028" class="Symbol">{</a><a id="3029" href="1Lab.Univalence.html#3029" class="Bound">φ</a> <a id="3031" class="Symbol">:</a> <a id="3033" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="3034" class="Symbol">}</a>
              <a id="3050" class="Symbol">→</a> <a id="3052" class="Symbol">{</a><a id="3053" href="1Lab.Univalence.html#3053" class="Bound">T</a> <a id="3055" class="Symbol">:</a> <a id="3057" href="Agda.Primitive.Cubical.html#1065" class="Primitive">Partial</a> <a id="3065" href="1Lab.Univalence.html#3029" class="Bound">φ</a> <a id="3067" class="Symbol">(</a><a id="3068" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3073" href="1Lab.Univalence.html#2839" class="Generalizable">ℓ&#39;</a><a id="3075" class="Symbol">)}</a> <a id="3078" class="Symbol">→</a> <a id="3080" class="Symbol">{</a><a id="3081" href="1Lab.Univalence.html#3081" class="Bound">e</a> <a id="3083" class="Symbol">:</a> <a id="3085" href="Agda.Primitive.Cubical.html#1099" class="Primitive">PartialP</a> <a id="3094" href="1Lab.Univalence.html#3029" class="Bound">φ</a> <a id="3096" class="Symbol">(λ</a> <a id="3099" href="1Lab.Univalence.html#3099" class="Bound">o</a> <a id="3101" class="Symbol">→</a> <a id="3103" href="1Lab.Univalence.html#3053" class="Bound">T</a> <a id="3105" href="1Lab.Univalence.html#3099" class="Bound">o</a> <a id="3107" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="3109" href="1Lab.Univalence.html#3016" class="Bound">A</a><a id="3110" class="Symbol">)}</a>
              <a id="3127" class="Symbol">→</a> <a id="3129" href="Agda.Primitive.Cubical.html#1099" class="Primitive">PartialP</a> <a id="3138" href="1Lab.Univalence.html#3029" class="Bound">φ</a> <a id="3140" href="1Lab.Univalence.html#3053" class="Bound">T</a> <a id="3142" class="Symbol">→</a> <a id="3144" href="1Lab.Univalence.html#3016" class="Bound">A</a> <a id="3146" class="Symbol">→</a> <a id="3148" href="1Lab.Univalence.html#2867" class="Primitive">primGlue</a> <a id="3157" href="1Lab.Univalence.html#3016" class="Bound">A</a> <a id="3159" href="1Lab.Univalence.html#3053" class="Bound">T</a> <a id="3161" href="1Lab.Univalence.html#3081" class="Bound">e</a>

    <a id="prim^unglue"></a><a id="3168" href="1Lab.Univalence.html#3168" class="Primitive">prim^unglue</a> <a id="3180" class="Symbol">:</a> <a id="3182" class="Symbol">{</a><a id="3183" href="1Lab.Univalence.html#3183" class="Bound">A</a> <a id="3185" class="Symbol">:</a> <a id="3187" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3192" href="1Lab.Univalence.html#2837" class="Generalizable">ℓ</a><a id="3193" class="Symbol">}</a> <a id="3195" class="Symbol">{</a><a id="3196" href="1Lab.Univalence.html#3196" class="Bound">φ</a> <a id="3198" class="Symbol">:</a> <a id="3200" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="3201" class="Symbol">}</a>
                <a id="3219" class="Symbol">→</a> <a id="3221" class="Symbol">{</a><a id="3222" href="1Lab.Univalence.html#3222" class="Bound">T</a> <a id="3224" class="Symbol">:</a> <a id="3226" href="Agda.Primitive.Cubical.html#1065" class="Primitive">Partial</a> <a id="3234" href="1Lab.Univalence.html#3196" class="Bound">φ</a> <a id="3236" class="Symbol">(</a><a id="3237" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3242" href="1Lab.Univalence.html#2839" class="Generalizable">ℓ&#39;</a><a id="3244" class="Symbol">)}</a> <a id="3247" class="Symbol">→</a> <a id="3249" class="Symbol">{</a><a id="3250" href="1Lab.Univalence.html#3250" class="Bound">e</a> <a id="3252" class="Symbol">:</a> <a id="3254" href="Agda.Primitive.Cubical.html#1099" class="Primitive">PartialP</a> <a id="3263" href="1Lab.Univalence.html#3196" class="Bound">φ</a> <a id="3265" class="Symbol">(λ</a> <a id="3268" href="1Lab.Univalence.html#3268" class="Bound">o</a> <a id="3270" class="Symbol">→</a> <a id="3272" href="1Lab.Univalence.html#3222" class="Bound">T</a> <a id="3274" href="1Lab.Univalence.html#3268" class="Bound">o</a> <a id="3276" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="3278" href="1Lab.Univalence.html#3183" class="Bound">A</a><a id="3279" class="Symbol">)}</a>
                <a id="3298" class="Symbol">→</a> <a id="3300" href="1Lab.Univalence.html#2867" class="Primitive">primGlue</a> <a id="3309" href="1Lab.Univalence.html#3183" class="Bound">A</a> <a id="3311" href="1Lab.Univalence.html#3222" class="Bound">T</a> <a id="3313" href="1Lab.Univalence.html#3250" class="Bound">e</a> <a id="3315" class="Symbol">→</a> <a id="3317" href="1Lab.Univalence.html#3183" class="Bound">A</a>

<a id="3320" class="Keyword">open</a> <a id="3325" class="Keyword">import</a> <a id="3332" href="Agda.Builtin.Cubical.HCompU.html" class="Module">Agda.Builtin.Cubical.HCompU</a>
<a id="3360" class="Keyword">open</a> <a id="3365" class="Keyword">import</a> <a id="3372" href="1Lab.Equiv.FromPath.html" class="Module">1Lab.Equiv.FromPath</a>
</pre>-->
<pre class="Agda"><a id="Glue"></a><a data-type="(A : Type ℓ) → Partial φ (Σ (λ T → T ≃ A)) → Type ℓ&#39;" id="3409" href="1Lab.Univalence.html#3409" class="Function">Glue</a> <a id="3414" class="Symbol">:</a> <a id="3416" class="Symbol">(</a><a id="3417" href="1Lab.Univalence.html#3417" class="Bound">A</a> <a id="3419" class="Symbol">:</a> <a id="3421" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3426" href="1Lab.Univalence.html#2837" class="Generalizable">ℓ</a><a id="3427" class="Symbol">)</a>
     <a id="3434" class="Symbol">→</a> <a id="3436" class="Symbol">{</a><a id="3437" href="1Lab.Univalence.html#3437" class="Bound">φ</a> <a id="3439" class="Symbol">:</a> <a data-type="SSet lzero" id="3441" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="3442" class="Symbol">}</a>
     <a id="3449" class="Symbol">→</a> <a id="3451" class="Symbol">(</a><a id="3452" href="1Lab.Univalence.html#3452" class="Bound">Te</a> <a id="3455" class="Symbol">:</a> <a data-type="(φ : I) (A : Type a) → SSet a" id="3457" href="Agda.Primitive.Cubical.html#1065" class="Primitive">Partial</a> <a id="3465" href="1Lab.Univalence.html#3437" class="Bound">φ</a> <a id="3467" class="Symbol">(</a><a data-type="(B : A → Type b) → Type (a ⊔ b)" id="3468" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="3471" href="1Lab.Univalence.html#3471" class="Bound">T</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="3473" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="3475" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3480" href="1Lab.Univalence.html#2839" class="Generalizable">ℓ&#39;</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="3483" href="1Lab.Type.html#1563" class="Function">]</a> <a id="3485" class="Symbol">(</a><a id="3486" href="1Lab.Univalence.html#3471" class="Bound">T</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="3488" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="3490" href="1Lab.Univalence.html#3417" class="Bound">A</a><a id="3491" class="Symbol">)))</a>
     <a id="3500" class="Symbol">→</a> <a id="3502" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3507" href="1Lab.Univalence.html#2839" class="Generalizable">ℓ&#39;</a>
</pre>
<p>The public interface of <span class="Agda"><a data-type="(A : Type ℓ) → Partial φ (Σ (λ T → T ≃ A)) → Type ℓ&#39;" href="1Lab.Univalence.html#3409" class="Function">Glue</a></span> demands a type <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>,</span> called the <em>base type</em>, a formula <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi></mrow><annotation encoding="application/x-tex">\varphi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span></span></span></span>,</span> and a <a href="1Lab.Path.html#partial-elements">partial type</a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> which is equivalent to <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>.</span> Since the equivalence is defined <em>inside</em> the partial element, it can also (potentially) vary over the interval, so in reality we have a <em>family</em> of partial types <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> and a <em>family</em> of partial equivalences <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>≃</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">T \simeq A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>.</span></p>
<p>In the specific case where we set <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo>=</mo><mi mathvariant="normal">¬</mi><mi>i</mi><mo>∨</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">\varphi = \neg i \lor i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord">¬</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>,</span> we can illustrate <code>Glue A (T, f)</code> as the dashed line in the square diagram below. The conceptual idea is that by “gluing” <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span> onto a totally defined type, we get a type which <a href="1Lab.Path.html#extensibility">extends</a> <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>.</span></p>
<div class="diagram-container"> <img title="commutative diagram" src="b6e2356c639f71ad0995a59d7ff4b24e.svg" class="diagram  quiver"></img> </div>
<!--
<pre class="Agda"><a id="4467" href="1Lab.Univalence.html#3409" class="Function">Glue</a> <a id="4472" href="1Lab.Univalence.html#4472" class="Bound">A</a> <a id="4474" href="1Lab.Univalence.html#4474" class="Bound">Te</a> <a id="4477" class="Symbol">=</a> <a id="4479" href="1Lab.Univalence.html#2867" class="Primitive">primGlue</a> <a id="4488" href="1Lab.Univalence.html#4472" class="Bound">A</a> <a id="4490" class="Symbol">(λ</a> <a id="4493" href="1Lab.Univalence.html#4493" class="Bound">x</a> <a id="4495" class="Symbol">→</a> <a id="4497" href="1Lab.Univalence.html#4474" class="Bound">Te</a> <a id="4500" href="1Lab.Univalence.html#4493" class="Bound">x</a> <a id="4502" class="Symbol">.</a><a id="4503" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="4506" class="Symbol">)</a> <a id="4508" class="Symbol">(λ</a> <a id="4511" href="1Lab.Univalence.html#4511" class="Bound">x</a> <a id="4513" class="Symbol">→</a> <a id="4515" href="1Lab.Univalence.html#4474" class="Bound">Te</a> <a id="4518" href="1Lab.Univalence.html#4511" class="Bound">x</a> <a id="4520" class="Symbol">.</a><a id="4521" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="4524" class="Symbol">)</a>

<a id="unglue"></a><a id="4527" href="1Lab.Univalence.html#4527" class="Function">unglue</a> <a id="4534" class="Symbol">:</a> <a id="4536" class="Symbol">{</a><a id="4537" href="1Lab.Univalence.html#4537" class="Bound">A</a> <a id="4539" class="Symbol">:</a> <a id="4541" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="4546" href="1Lab.Univalence.html#2837" class="Generalizable">ℓ</a><a id="4547" class="Symbol">}</a> <a id="4549" class="Symbol">(</a><a id="4550" href="1Lab.Univalence.html#4550" class="Bound">φ</a> <a id="4552" class="Symbol">:</a> <a id="4554" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="4555" class="Symbol">)</a> <a id="4557" class="Symbol">{</a><a id="4558" href="1Lab.Univalence.html#4558" class="Bound">T</a> <a id="4560" class="Symbol">:</a> <a id="4562" href="Agda.Primitive.Cubical.html#1065" class="Primitive">Partial</a> <a id="4570" href="1Lab.Univalence.html#4550" class="Bound">φ</a> <a id="4572" class="Symbol">(</a><a id="4573" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="4578" href="1Lab.Univalence.html#2839" class="Generalizable">ℓ&#39;</a><a id="4580" class="Symbol">)}</a>
         <a id="4592" class="Symbol">{</a><a id="4593" href="1Lab.Univalence.html#4593" class="Bound">e</a> <a id="4595" class="Symbol">:</a> <a id="4597" href="Agda.Primitive.Cubical.html#1099" class="Primitive">PartialP</a> <a id="4606" href="1Lab.Univalence.html#4550" class="Bound">φ</a> <a id="4608" class="Symbol">(λ</a> <a id="4611" href="1Lab.Univalence.html#4611" class="Bound">o</a> <a id="4613" class="Symbol">→</a> <a id="4615" href="1Lab.Univalence.html#4558" class="Bound">T</a> <a id="4617" href="1Lab.Univalence.html#4611" class="Bound">o</a> <a id="4619" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="4621" href="1Lab.Univalence.html#4537" class="Bound">A</a><a id="4622" class="Symbol">)}</a> <a id="4625" class="Symbol">→</a> <a id="4627" href="1Lab.Univalence.html#2867" class="Primitive">primGlue</a> <a id="4636" href="1Lab.Univalence.html#4537" class="Bound">A</a> <a id="4638" href="1Lab.Univalence.html#4558" class="Bound">T</a> <a id="4640" href="1Lab.Univalence.html#4593" class="Bound">e</a> <a id="4642" class="Symbol">→</a> <a id="4644" href="1Lab.Univalence.html#4537" class="Bound">A</a>
<a id="4646" href="1Lab.Univalence.html#4527" class="Function">unglue</a> <a id="4653" href="1Lab.Univalence.html#4653" class="Bound">φ</a> <a id="4655" class="Symbol">=</a> <a id="4657" href="1Lab.Univalence.html#3168" class="Primitive">prim^unglue</a> <a id="4669" class="Symbol">{</a><a id="4670" class="Argument">φ</a> <a id="4672" class="Symbol">=</a> <a id="4674" href="1Lab.Univalence.html#4653" class="Bound">φ</a><a id="4675" class="Symbol">}</a>
</pre>-->
<p>For <span class="Agda"><a data-type="(A : Type ℓ) → Partial φ (Σ (λ T → T ≃ A)) → Type ℓ&#39;" href="1Lab.Univalence.html#3409" class="Function">Glue</a></span> to extend <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>,</span> we add a computation rule which could be called a <strong>boundary condition</strong>, since it specifies how <span class="Agda"><a data-type="(A : Type ℓ) → Partial φ (Σ (λ T → T ≃ A)) → Type ℓ&#39;" href="1Lab.Univalence.html#3409" class="Function">Glue</a></span> behaves on the boundaries of cubes. Concisely, when <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo>=</mo><mi>i</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">\varphi = i1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mord">1</span></span></span></span>,</span> we have that <span class="Agda"><a data-type="(A : Type ℓ) → Partial φ (Σ (λ T → T ≃ A)) → Type ℓ&#39;" href="1Lab.Univalence.html#3409" class="Function">Glue</a></span> evaluates to the partial type. This is exactly what it means for <span class="Agda"><a data-type="(A : Type ℓ) → Partial φ (Σ (λ T → T ≃ A)) → Type ℓ&#39;" href="1Lab.Univalence.html#3409" class="Function">Glue</a></span> to extend <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>!</span></p>
<pre class="Agda"><a id="5088" class="Keyword">module</a> <a id="5095" href="1Lab.Univalence.html#5095" class="Module">_</a> <a id="5097" class="Symbol">{</a><a id="5098" href="1Lab.Univalence.html#5098" class="Bound">A</a> <a id="5100" href="1Lab.Univalence.html#5100" class="Bound">B</a> <a id="5102" class="Symbol">:</a> <a id="5104" href="1Lab.Type.html#394" class="Primitive">Type</a><a id="5108" class="Symbol">}</a> <a id="5110" class="Symbol">{</a><a id="5111" href="1Lab.Univalence.html#5111" class="Bound">e</a> <a id="5113" class="Symbol">:</a> <a id="5115" href="1Lab.Univalence.html#5098" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="5117" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="5119" href="1Lab.Univalence.html#5100" class="Bound">B</a><a id="5120" class="Symbol">}</a> <a id="5122" class="Keyword">where</a>
  <a id="5130" class="Keyword">private</a>
    <a id="5142" href="1Lab.Univalence.html#5142" class="Function">Glue-boundary</a> <a id="5156" class="Symbol">:</a> <a data-type="(A : Type ℓ) → Partial φ (Σ (λ T → T ≃ A)) → Type ℓ&#39;" id="5158" href="1Lab.Univalence.html#3409" class="Function">Glue</a> <a id="5163" href="1Lab.Univalence.html#5100" class="Bound">B</a> <a id="5165" class="Symbol">{</a><a data-type="I" id="5166" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="5168" class="Symbol">}</a> <a id="5170" class="Symbol">(λ</a> <a id="5173" href="1Lab.Univalence.html#5173" class="Bound">x</a> <a id="5175" class="Symbol">→</a> <a id="5177" href="1Lab.Univalence.html#5098" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="5179" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5181" href="1Lab.Univalence.html#5111" class="Bound">e</a><a id="5182" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="5184" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="5186" href="1Lab.Univalence.html#5098" class="Bound">A</a>
    <a id="5192" href="1Lab.Univalence.html#5142" class="Function">Glue-boundary</a> <a id="5206" href="1Lab.Univalence.html#5206" class="Bound">i</a> <a id="5208" class="Symbol">=</a> <a id="5210" href="1Lab.Univalence.html#5098" class="Bound">A</a>
</pre>
<p>Furthermore, since we can turn any family of paths into a family of equivalences, we can use the <span class="Agda"><a data-type="(A : Type ℓ) → Partial φ (Σ (λ T → T ≃ A)) → Type ℓ&#39;" href="1Lab.Univalence.html#3409" class="Function">Glue</a></span> construct to implement something with precisely the same interface as <span class="Agda"><a href="1Lab.Path.html#907" class="Primitive">hcomp</a></span> for <span class="Agda"><a href="1Lab.Type.html#394" class="Primitive">Type</a></span>:</p>
<pre class="Agda"><a id="glue-hfill"></a><a data-type="(φ : I) (u : I → Partial φ (Type ℓ)) (u0 : Type ℓ [ φ ↦ u i0 ])
(i : I) →
Type ℓ [ ~ i ∨ φ ↦
(λ { ((i = i0)) → outS u0 ; ((φ = i1)) → u i _ }) ]" id="5441" href="1Lab.Univalence.html#5441" class="Function">glue-hfill</a>
  <a id="5454" class="Symbol">:</a> <a id="5456" class="Symbol">∀</a> <a id="5458" class="Symbol">{</a><a id="5459" href="1Lab.Univalence.html#5459" class="Bound">ℓ</a><a id="5460" class="Symbol">}</a> <a id="5462" href="1Lab.Univalence.html#5462" class="Bound">φ</a> <a id="5464" class="Symbol">(</a><a id="5465" href="1Lab.Univalence.html#5465" class="Bound">u</a> <a id="5467" class="Symbol">:</a> <a data-type="SSet lzero" id="5469" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="5471" class="Symbol">→</a> <a data-type="(φ : I) (A : Type a) → SSet a" id="5473" href="Agda.Primitive.Cubical.html#1065" class="Primitive">Partial</a> <a id="5481" href="1Lab.Univalence.html#5462" class="Bound">φ</a> <a id="5483" class="Symbol">(</a><a id="5484" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="5489" href="1Lab.Univalence.html#5459" class="Bound">ℓ</a><a id="5490" class="Symbol">))</a> <a id="5493" class="Symbol">(</a><a id="5494" href="1Lab.Univalence.html#5494" class="Bound">u0</a> <a id="5497" class="Symbol">:</a> <a id="5499" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="5504" href="1Lab.Univalence.html#5459" class="Bound">ℓ</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="5506" href="1Lab.Path.html#27116" class="Function Operator">[</a> <a id="5508" href="1Lab.Univalence.html#5462" class="Bound">φ</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="5510" href="1Lab.Path.html#27116" class="Function Operator">↦</a> <a id="5512" href="1Lab.Univalence.html#5465" class="Bound">u</a> <a data-type="I" id="5514" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="5517" href="1Lab.Path.html#27116" class="Function Operator">]</a><a id="5518" class="Symbol">)</a>
  <a id="5522" class="Symbol">→</a> <a id="5524" class="Symbol">∀</a> <a id="5526" href="1Lab.Univalence.html#5526" class="Bound">i</a> <a id="5528" class="Symbol">→</a> <a id="5530" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="5535" href="1Lab.Univalence.html#5459" class="Bound">ℓ</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="5537" href="1Lab.Path.html#27116" class="Function Operator">[</a> <a id="5539" class="Symbol">_</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="5541" href="1Lab.Path.html#27116" class="Function Operator">↦</a> <a id="5543" class="Symbol">(λ</a> <a id="5546" class="Symbol">{</a> <a id="5548" class="Symbol">(</a><a id="5549" href="1Lab.Univalence.html#5526" class="Bound">i</a> <a id="5551" class="Symbol">=</a> <a data-type="I" id="5553" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="5555" class="Symbol">)</a> <a id="5557" class="Symbol">→</a> <a id="5559" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="5564" href="1Lab.Univalence.html#5494" class="Bound">u0</a>
                          <a id="5593" class="Symbol">;</a> <a id="5595" class="Symbol">(</a><a id="5596" href="1Lab.Univalence.html#5462" class="Bound">φ</a> <a id="5598" class="Symbol">=</a> <a data-type="I" id="5600" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="5602" class="Symbol">)</a> <a id="5604" class="Symbol">→</a> <a id="5606" href="1Lab.Univalence.html#5465" class="Bound">u</a> <a id="5608" href="1Lab.Univalence.html#5526" class="Bound">i</a> <a id="5610" href="1Lab.Path.html#982" class="Postulate">1=1</a> <a id="5614" class="Symbol">})</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="5617" href="1Lab.Path.html#27116" class="Function Operator">]</a>
</pre>
<p>The type of <span class="Agda"><a data-type="(φ : I) (u : I → Partial φ (Type ℓ)) (u0 : Type ℓ [ φ ↦ u i0 ])
(i : I) →
Type ℓ [ ~ i ∨ φ ↦
(λ { ((i = i0)) → outS u0 ; ((φ = i1)) → u i _ }) ]" href="1Lab.Univalence.html#5441" class="Function">glue-hfill</a></span> is the same as that of <code class="sourceCode agda">hfill</code>, but the type is stated much more verbosely — so that we may define it without previous reference to a <span class="Agda"><a href="1Lab.Path.html#907" class="Primitive">hcomp</a></span> analogue. Like <code class="sourceCode agda">hfill</code>, <span class="Agda"><a data-type="(φ : I) (u : I → Partial φ (Type ℓ)) (u0 : Type ℓ [ φ ↦ u i0 ])
(i : I) →
Type ℓ [ ~ i ∨ φ ↦
(λ { ((i = i0)) → outS u0 ; ((φ = i1)) → u i _ }) ]" href="1Lab.Univalence.html#5441" class="Function">glue-hfill</a></span> extends an open box of types to a totally-defined cube. The type of <span class="Agda"><a data-type="(φ : I) (u : I → Partial φ (Type ℓ)) (u0 : Type ℓ [ φ ↦ u i0 ])
(i : I) →
Type ℓ [ ~ i ∨ φ ↦
(λ { ((i = i0)) → outS u0 ; ((φ = i1)) → u i _ }) ]" href="1Lab.Univalence.html#5441" class="Function">glue-hfill</a></span> expresses this in terms of extensions: We have a path (that’s the <code>∀ i →</code> binder) of <span class="Agda"><a href="1Lab.Type.html#394" class="Primitive">Type</a></span>s which agrees with <code>outS u0</code> on the left endpoint, and with <code>u</code> everywhere.</p>
<pre class="Agda"><a data-type="(φ : I) (u : I → Partial φ (Type ℓ)) (u0 : Type ℓ [ φ ↦ u i0 ])
(i : I) →
Type ℓ [ ~ i ∨ φ ↦
(λ { ((i = i0)) → outS u0 ; ((φ = i1)) → u i _ }) ]" id="6137" href="1Lab.Univalence.html#5441" class="Function">glue-hfill</a> <a id="6148" href="1Lab.Univalence.html#6148" class="Bound">φ</a> <a id="6150" href="1Lab.Univalence.html#6150" class="Bound">u</a> <a id="6152" href="1Lab.Univalence.html#6152" class="Bound">u0</a> <a id="6155" href="1Lab.Univalence.html#6155" class="Bound">i</a> <a id="6157" class="Symbol">=</a> <a id="6159" href="1Lab.Path.html#608" class="Postulate">inS</a> <a id="6163" class="Symbol">(</a>
  <a data-type="(A : Type ℓ) → Partial φ (Σ (λ T → T ≃ A)) → Type ℓ&#39;" id="6167" href="1Lab.Univalence.html#3409" class="Function">Glue</a> <a id="6172" class="Symbol">(</a><a id="6173" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="6178" href="1Lab.Univalence.html#6152" class="Bound">u0</a><a id="6180" class="Symbol">)</a> <a id="6182" class="Symbol">{</a><a id="6183" class="Argument">φ</a> <a id="6185" class="Symbol">=</a> <a id="6187" href="1Lab.Univalence.html#6148" class="Bound">φ</a> <a id="6189" href="1Lab.Path.html#765" class="Primitive Operator">∨</a> <a id="6191" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="6193" href="1Lab.Univalence.html#6155" class="Bound">i</a><a id="6194" class="Symbol">}</a>
    <a id="6200" class="Symbol">λ</a> <a id="6202" class="Symbol">{</a> <a id="6204" class="Symbol">(</a><a id="6205" href="1Lab.Univalence.html#6148" class="Bound">φ</a> <a id="6207" class="Symbol">=</a> <a data-type="I" id="6209" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="6211" class="Symbol">)</a> <a id="6213" class="Symbol">→</a> <a id="6215" href="1Lab.Univalence.html#6150" class="Bound">u</a> <a id="6217" href="1Lab.Univalence.html#6155" class="Bound">i</a> <a id="6219" href="1Lab.Path.html#982" class="Postulate">1=1</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="6223" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="(P : I → Type ℓ) →
1Lab.Equiv.FromPath.A P ≃ 1Lab.Equiv.FromPath.B P" id="6225" href="1Lab.Equiv.FromPath.html#9222" class="Function">line→equiv</a> <a id="6236" class="Symbol">(λ</a> <a id="6239" href="1Lab.Univalence.html#6239" class="Bound">j</a> <a id="6241" class="Symbol">→</a> <a id="6243" href="1Lab.Univalence.html#6150" class="Bound">u</a> <a id="6245" class="Symbol">(</a><a id="6246" href="1Lab.Univalence.html#6155" class="Bound">i</a> <a id="6248" href="1Lab.Path.html#730" class="Primitive Operator">∧</a> <a id="6250" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="6252" href="1Lab.Univalence.html#6239" class="Bound">j</a><a id="6253" class="Symbol">)</a> <a id="6255" href="1Lab.Path.html#982" class="Postulate">1=1</a><a id="6258" class="Symbol">)</a>
      <a id="6266" class="Symbol">;</a> <a id="6268" class="Symbol">(</a><a id="6269" href="1Lab.Univalence.html#6155" class="Bound">i</a> <a id="6271" class="Symbol">=</a> <a data-type="I" id="6273" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="6275" class="Symbol">)</a> <a id="6277" class="Symbol">→</a> <a id="6279" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="6284" href="1Lab.Univalence.html#6152" class="Bound">u0</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="6287" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="(P : I → Type ℓ) →
1Lab.Equiv.FromPath.A P ≃ 1Lab.Equiv.FromPath.B P" id="6289" href="1Lab.Equiv.FromPath.html#9222" class="Function">line→equiv</a> <a id="6300" class="Symbol">(λ</a> <a id="6303" href="1Lab.Univalence.html#6303" class="Bound">i</a> <a id="6305" class="Symbol">→</a> <a id="6307" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="6312" href="1Lab.Univalence.html#6152" class="Bound">u0</a><a id="6314" class="Symbol">)</a>
      <a id="6322" class="Symbol">})</a>
</pre>
<p>In the case for <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mrow><mi mathvariant="normal">i</mi><mn>0</mn></mrow></mrow><annotation encoding="application/x-tex">i = \mathrm{i0}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord"><span class="mord mathrm">i0</span></span></span></span></span>,</span> we must glue <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">u0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal">u</span><span class="mord">0</span></span></span></span> onto itself using the identity equivalence. This guarantees that the boundary of the stated type for <span class="Agda"><a data-type="(φ : I) (u : I → Partial φ (Type ℓ)) (u0 : Type ℓ [ φ ↦ u i0 ])
(i : I) →
Type ℓ [ ~ i ∨ φ ↦
(λ { ((i = i0)) → outS u0 ; ((φ = i1)) → u i _ }) ]" href="1Lab.Univalence.html#5441" class="Function">glue-hfill</a></span> is satisfied. However, since different faces of partial elements must agree where they are defined, we can not use the identity equivalence directly, since <code>line→equiv refl</code> is not definitionally the identity equivalence.</p>
<p>When <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo>=</mo><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\varphi = \mathrm{\phi}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">ϕ</span></span></span></span>,</span> hence where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span> is defined, we glue the endpoint <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span> onto <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">u0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord mathnormal">u</span><span class="mord">0</span></span></span></span> using the equivalence generated by the path provided by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span> itself! It’s a family of partial paths, after all, and that can be turned into a family of partial equivalences.</p>
<p>To show that <span class="Agda"><a data-type="(φ : I) (u : I → Partial φ (Type ℓ)) (u0 : Type ℓ [ φ ↦ u i0 ])
(i : I) →
Type ℓ [ ~ i ∨ φ ↦
(λ { ((i = i0)) → outS u0 ; ((φ = i1)) → u i _ }) ]" href="1Lab.Univalence.html#5441" class="Function">glue-hfill</a></span> expresses the fibrancy structure of the universe, we prove a theorem that says anything with the same interface as <code class="sourceCode agda">hfill</code> must agree with <span class="Agda"><a href="1Lab.Path.html#907" class="Primitive">hcomp</a></span> on <span class="Agda"><a data-type="I" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a></span>, and from this conclude that <span class="Agda"><a href="1Lab.Path.html#907" class="Primitive">hcomp</a></span> on <span class="Agda"><a href="1Lab.Type.html#394" class="Primitive">Type</a></span> agrees with the definition of <span class="Agda"><a data-type="(φ : I) (u : I → Partial φ (Type ℓ)) (u0 : Type ℓ [ φ ↦ u i0 ])
(i : I) →
Type ℓ [ ~ i ∨ φ ↦
(λ { ((i = i0)) → outS u0 ; ((φ = i1)) → u i _ }) ]" href="1Lab.Univalence.html#5441" class="Function">glue-hfill</a></span>.</p>
<pre class="Agda"><a id="hcomp-unique"></a><a data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ])
(h2
 : (i : I) →
   A [ ~ i ∨ φ ↦ (λ { ((i = i0)) → outS u0 ; ((φ = i1)) → u i _ })
   ]) →
hcomp u (outS u0) ≡ outS (h2 i1)" id="7327" href="1Lab.Univalence.html#7327" class="Function">hcomp-unique</a> <a id="7340" class="Symbol">:</a> <a id="7342" class="Symbol">∀</a> <a id="7344" class="Symbol">{</a><a id="7345" href="1Lab.Univalence.html#7345" class="Bound">ℓ</a><a id="7346" class="Symbol">}</a> <a id="7348" class="Symbol">{</a><a id="7349" href="1Lab.Univalence.html#7349" class="Bound">A</a> <a id="7351" class="Symbol">:</a> <a id="7353" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="7358" href="1Lab.Univalence.html#7345" class="Bound">ℓ</a><a id="7359" class="Symbol">}</a> <a id="7361" class="Symbol">{</a><a id="7362" href="1Lab.Univalence.html#7362" class="Bound">φ</a><a id="7363" class="Symbol">}</a>
               <a id="7380" class="Symbol">(</a><a id="7381" href="1Lab.Univalence.html#7381" class="Bound">u</a> <a id="7383" class="Symbol">:</a> <a data-type="SSet lzero" id="7385" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="7387" class="Symbol">→</a> <a data-type="(φ : I) (A : Type a) → SSet a" id="7389" href="Agda.Primitive.Cubical.html#1065" class="Primitive">Partial</a> <a id="7397" href="1Lab.Univalence.html#7362" class="Bound">φ</a> <a id="7399" href="1Lab.Univalence.html#7349" class="Bound">A</a><a id="7400" class="Symbol">)</a>
               <a id="7417" class="Symbol">(</a><a id="7418" href="1Lab.Univalence.html#7418" class="Bound">u0</a> <a id="7421" class="Symbol">:</a> <a id="7423" href="1Lab.Univalence.html#7349" class="Bound">A</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="7425" href="1Lab.Path.html#27116" class="Function Operator">[</a> <a id="7427" href="1Lab.Univalence.html#7362" class="Bound">φ</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="7429" href="1Lab.Path.html#27116" class="Function Operator">↦</a> <a id="7431" href="1Lab.Univalence.html#7381" class="Bound">u</a> <a data-type="I" id="7433" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="7436" href="1Lab.Path.html#27116" class="Function Operator">]</a><a id="7437" class="Symbol">)</a>
             <a id="7452" class="Symbol">→</a> <a id="7454" class="Symbol">(</a><a id="7455" href="1Lab.Univalence.html#7455" class="Bound">h2</a> <a id="7458" class="Symbol">:</a> <a id="7460" class="Symbol">∀</a> <a id="7462" href="1Lab.Univalence.html#7462" class="Bound">i</a> <a id="7464" class="Symbol">→</a> <a id="7466" href="1Lab.Univalence.html#7349" class="Bound">A</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="7468" href="1Lab.Path.html#27116" class="Function Operator">[</a> <a id="7470" class="Symbol">_</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="7472" href="1Lab.Path.html#27116" class="Function Operator">↦</a> <a id="7474" class="Symbol">(λ</a> <a id="7477" class="Symbol">{</a> <a id="7479" class="Symbol">(</a><a id="7480" href="1Lab.Univalence.html#7462" class="Bound">i</a> <a id="7482" class="Symbol">=</a> <a data-type="I" id="7484" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="7486" class="Symbol">)</a> <a id="7488" class="Symbol">→</a> <a id="7490" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="7495" href="1Lab.Univalence.html#7418" class="Bound">u0</a>
                                      <a id="7536" class="Symbol">;</a> <a id="7538" class="Symbol">(</a><a id="7539" href="1Lab.Univalence.html#7362" class="Bound">φ</a> <a id="7541" class="Symbol">=</a> <a data-type="I" id="7543" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="7545" class="Symbol">)</a> <a id="7547" class="Symbol">→</a> <a id="7549" href="1Lab.Univalence.html#7381" class="Bound">u</a> <a id="7551" href="1Lab.Univalence.html#7462" class="Bound">i</a> <a id="7553" href="1Lab.Path.html#982" class="Postulate">1=1</a> <a id="7557" class="Symbol">})</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="7560" href="1Lab.Path.html#27116" class="Function Operator">]</a><a id="7561" class="Symbol">)</a>
             <a id="7576" class="Symbol">→</a> <a id="7578" href="1Lab.Path.html#907" class="Primitive">hcomp</a> <a id="7584" href="1Lab.Univalence.html#7381" class="Bound">u</a> <a id="7586" class="Symbol">(</a><a id="7587" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="7592" href="1Lab.Univalence.html#7418" class="Bound">u0</a><a id="7594" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="7596" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="7598" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="7603" class="Symbol">(</a><a id="7604" href="1Lab.Univalence.html#7455" class="Bound">h2</a> <a data-type="I" id="7607" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="7609" class="Symbol">)</a>
<a data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ])
(h2
 : (i : I) →
   A [ ~ i ∨ φ ↦ (λ { ((i = i0)) → outS u0 ; ((φ = i1)) → u i _ })
   ]) →
hcomp u (outS u0) ≡ outS (h2 i1)" id="7611" href="1Lab.Univalence.html#7327" class="Function">hcomp-unique</a> <a id="7624" class="Symbol">{</a><a id="7625" class="Argument">φ</a> <a id="7627" class="Symbol">=</a> <a id="7629" href="1Lab.Univalence.html#7629" class="Bound">φ</a><a id="7630" class="Symbol">}</a> <a id="7632" href="1Lab.Univalence.html#7632" class="Bound">u</a> <a id="7634" href="1Lab.Univalence.html#7634" class="Bound">u0</a> <a id="7637" href="1Lab.Univalence.html#7637" class="Bound">h2</a> <a id="7640" href="1Lab.Univalence.html#7640" class="Bound">i</a> <a id="7642" class="Symbol">=</a>
  <a id="7646" href="1Lab.Path.html#907" class="Primitive">hcomp</a> <a id="7652" class="Symbol">(λ</a> <a id="7655" href="1Lab.Univalence.html#7655" class="Bound">k</a> <a id="7657" class="Symbol">→</a> <a id="7659" class="Symbol">λ</a> <a id="7661" class="Symbol">{</a> <a id="7663" class="Symbol">(</a><a id="7664" href="1Lab.Univalence.html#7629" class="Bound">φ</a> <a id="7666" class="Symbol">=</a> <a data-type="I" id="7668" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="7670" class="Symbol">)</a> <a id="7672" class="Symbol">→</a> <a id="7674" href="1Lab.Univalence.html#7632" class="Bound">u</a> <a id="7676" href="1Lab.Univalence.html#7655" class="Bound">k</a> <a id="7678" href="1Lab.Path.html#982" class="Postulate">1=1</a>
                 <a id="7699" class="Symbol">;</a> <a id="7701" class="Symbol">(</a><a id="7702" href="1Lab.Univalence.html#7640" class="Bound">i</a> <a id="7704" class="Symbol">=</a> <a data-type="I" id="7706" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="7708" class="Symbol">)</a> <a id="7710" class="Symbol">→</a> <a id="7712" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="7717" class="Symbol">(</a><a id="7718" href="1Lab.Univalence.html#7637" class="Bound">h2</a> <a id="7721" href="1Lab.Univalence.html#7655" class="Bound">k</a><a id="7722" class="Symbol">)</a> <a id="7724" class="Symbol">})</a>
        <a id="7735" class="Symbol">(</a><a id="7736" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="7741" href="1Lab.Univalence.html#7634" class="Bound">u0</a><a id="7743" class="Symbol">)</a>
</pre>
<p>Using <span class="Agda"><a data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ])
(h2
 : (i : I) →
   A [ ~ i ∨ φ ↦ (λ { ((i = i0)) → outS u0 ; ((φ = i1)) → u i _ })
   ]) →
hcomp u (outS u0) ≡ outS (h2 i1)" href="1Lab.Univalence.html#7327" class="Function">hcomp-unique</a></span> and <span class="Agda"><a data-type="(φ : I) (u : I → Partial φ (Type ℓ)) (u0 : Type ℓ [ φ ↦ u i0 ])
(i : I) →
Type ℓ [ ~ i ∨ φ ↦
(λ { ((i = i0)) → outS u0 ; ((φ = i1)) → u i _ }) ]" href="1Lab.Univalence.html#5441" class="Function">glue-hfill</a></span> together, we get a internal characterisation of the fibrancy structure of the universe. While <span class="Agda"><a data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ])
(h2
 : (i : I) →
   A [ ~ i ∨ φ ↦ (λ { ((i = i0)) → outS u0 ; ((φ = i1)) → u i _ })
   ]) →
hcomp u (outS u0) ≡ outS (h2 i1)" href="1Lab.Univalence.html#7327" class="Function">hcomp-unique</a></span> may appear surprising, it is essentially a generalisation of the uniqueness of path compositions: Any open box has a contractible space of fillers.</p>
<pre class="Agda"><a id="hcomp≡Glue"></a><a data-type="(u : I → Partial φ (Type ℓ)) (u0 : Type ℓ [ φ ↦ u i0 ]) →
hcomp u (outS u0) ≡ Glue (outS u0)
(λ { ((φ = i1)) → u i1 _ , line→equiv (λ j → u (~ j) _) })" id="8075" href="1Lab.Univalence.html#8075" class="Function">hcomp≡Glue</a> <a id="8086" class="Symbol">:</a> <a id="8088" class="Symbol">∀</a> <a id="8090" class="Symbol">{</a><a id="8091" href="1Lab.Univalence.html#8091" class="Bound">ℓ</a><a id="8092" class="Symbol">}</a> <a id="8094" class="Symbol">{</a><a id="8095" href="1Lab.Univalence.html#8095" class="Bound">φ</a><a id="8096" class="Symbol">}</a> <a id="8098" class="Symbol">(</a><a id="8099" href="1Lab.Univalence.html#8099" class="Bound">u</a> <a id="8101" class="Symbol">:</a> <a data-type="SSet lzero" id="8103" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="8105" class="Symbol">→</a> <a data-type="(φ : I) (A : Type a) → SSet a" id="8107" href="Agda.Primitive.Cubical.html#1065" class="Primitive">Partial</a> <a id="8115" href="1Lab.Univalence.html#8095" class="Bound">φ</a> <a id="8117" class="Symbol">(</a><a id="8118" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="8123" href="1Lab.Univalence.html#8091" class="Bound">ℓ</a><a id="8124" class="Symbol">))</a> <a id="8127" class="Symbol">(</a><a id="8128" href="1Lab.Univalence.html#8128" class="Bound">u0</a> <a id="8131" class="Symbol">:</a> <a id="8133" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="8138" href="1Lab.Univalence.html#8091" class="Bound">ℓ</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="8140" href="1Lab.Path.html#27116" class="Function Operator">[</a> <a id="8142" href="1Lab.Univalence.html#8095" class="Bound">φ</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="8144" href="1Lab.Path.html#27116" class="Function Operator">↦</a> <a id="8146" href="1Lab.Univalence.html#8099" class="Bound">u</a> <a data-type="I" id="8148" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="8151" href="1Lab.Path.html#27116" class="Function Operator">]</a><a id="8152" class="Symbol">)</a>
           <a id="8165" class="Symbol">→</a> <a id="8167" href="1Lab.Path.html#907" class="Primitive">hcomp</a> <a id="8173" href="1Lab.Univalence.html#8099" class="Bound">u</a> <a id="8175" class="Symbol">(</a><a id="8176" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="8181" href="1Lab.Univalence.html#8128" class="Bound">u0</a><a id="8183" class="Symbol">)</a>
           <a data-type="A → A → Type ℓ" id="8196" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(A : Type ℓ) → Partial φ (Σ (λ T → T ≃ A)) → Type ℓ&#39;" id="8198" href="1Lab.Univalence.html#3409" class="Function">Glue</a> <a id="8203" class="Symbol">(</a><a id="8204" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="8209" href="1Lab.Univalence.html#8128" class="Bound">u0</a><a id="8211" class="Symbol">)</a>
              <a id="8227" class="Symbol">(λ</a> <a id="8230" class="Symbol">{</a> <a id="8232" class="Symbol">(</a><a id="8233" href="1Lab.Univalence.html#8095" class="Bound">φ</a> <a id="8235" class="Symbol">=</a> <a data-type="I" id="8237" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="8239" class="Symbol">)</a> <a id="8241" class="Symbol">→</a> <a id="8243" href="1Lab.Univalence.html#8099" class="Bound">u</a> <a data-type="I" id="8245" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a> <a id="8248" href="1Lab.Path.html#982" class="Postulate">1=1</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="8252" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="(P : I → Type ℓ) →
1Lab.Equiv.FromPath.A P ≃ 1Lab.Equiv.FromPath.B P" id="8254" href="1Lab.Equiv.FromPath.html#9222" class="Function">line→equiv</a> <a id="8265" class="Symbol">(λ</a> <a id="8268" href="1Lab.Univalence.html#8268" class="Bound">j</a> <a id="8270" class="Symbol">→</a> <a id="8272" href="1Lab.Univalence.html#8099" class="Bound">u</a> <a id="8274" class="Symbol">(</a><a id="8275" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="8277" href="1Lab.Univalence.html#8268" class="Bound">j</a><a id="8278" class="Symbol">)</a> <a id="8280" href="1Lab.Path.html#982" class="Postulate">1=1</a><a id="8283" class="Symbol">)</a> <a id="8285" class="Symbol">})</a>
<a data-type="(u : I → Partial φ (Type ℓ)) (u0 : Type ℓ [ φ ↦ u i0 ]) →
hcomp u (outS u0) ≡ Glue (outS u0)
(λ { ((φ = i1)) → u i1 _ , line→equiv (λ j → u (~ j) _) })" id="8288" href="1Lab.Univalence.html#8075" class="Function">hcomp≡Glue</a> <a id="8299" href="1Lab.Univalence.html#8299" class="Bound">u</a> <a id="8301" href="1Lab.Univalence.html#8301" class="Bound">u0</a> <a id="8304" class="Symbol">=</a> <a data-type="(u : I → Partial φ A) (u0 : A [ φ ↦ u i0 ])
(h2
 : (i : I) →
   A [ ~ i ∨ φ ↦ (λ { ((i = i0)) → outS u0 ; ((φ = i1)) → u i _ })
   ]) →
hcomp u (outS u0) ≡ outS (h2 i1)" id="8306" href="1Lab.Univalence.html#7327" class="Function">hcomp-unique</a> <a id="8319" href="1Lab.Univalence.html#8299" class="Bound">u</a> <a id="8321" href="1Lab.Univalence.html#8301" class="Bound">u0</a> <a id="8324" class="Symbol">(</a><a data-type="(φ : I) (u : I → Partial φ (Type ℓ)) (u0 : Type ℓ [ φ ↦ u i0 ])
(i : I) →
Type ℓ [ ~ i ∨ φ ↦
(λ { ((i = i0)) → outS u0 ; ((φ = i1)) → u i _ }) ]" id="8325" href="1Lab.Univalence.html#5441" class="Function">glue-hfill</a> <a id="8336" class="Symbol">_</a> <a id="8338" href="1Lab.Univalence.html#8299" class="Bound">u</a> <a id="8340" href="1Lab.Univalence.html#8301" class="Bound">u0</a><a id="8342" class="Symbol">)</a>
</pre>
<h2 id="paths-from-glue"><a href="#paths-from-glue" class="header-link">Paths from Glue<span class="header-link-emoji">🔗</span></a></h2>
<p>Since <span class="Agda"><a data-type="(A : Type ℓ) → Partial φ (Σ (λ T → T ≃ A)) → Type ℓ&#39;" href="1Lab.Univalence.html#3409" class="Function">Glue</a></span> generalises <span class="Agda"><a href="1Lab.Path.html#907" class="Primitive">hcomp</a></span> by allowing a partial equivalence as its “tube”, rather than a partial path, it allows us to turn any equivalence into a path, using a sort of “trick”: We consider the <em>line</em> with endpoints <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> as an open cube to be filled. A filler for this line is exactly a path <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>≡</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \equiv B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>.</span> Since <span class="Agda"><a data-type="(A : Type ℓ) → Partial φ (Σ (λ T → T ≃ A)) → Type ℓ&#39;" href="1Lab.Univalence.html#3409" class="Function">Glue</a></span> fills open boxes of types using equivalences, this path exists!</p>
<pre class="Agda"><a id="ua"></a><a data-type="A ≃ B → A ≡ B" id="8796" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="8799" class="Symbol">:</a> <a id="8801" class="Symbol">{</a><a id="8802" href="1Lab.Univalence.html#8802" class="Bound">A</a> <a id="8804" href="1Lab.Univalence.html#8804" class="Bound">B</a> <a id="8806" class="Symbol">:</a> <a id="8808" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="8813" href="1Lab.Univalence.html#2837" class="Generalizable">ℓ</a><a id="8814" class="Symbol">}</a> <a id="8816" class="Symbol">→</a> <a id="8818" href="1Lab.Univalence.html#8802" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="8820" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="8822" href="1Lab.Univalence.html#8804" class="Bound">B</a> <a id="8824" class="Symbol">→</a> <a id="8826" href="1Lab.Univalence.html#8802" class="Bound">A</a> <a data-type="A → A → Type ℓ" id="8828" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="8830" href="1Lab.Univalence.html#8804" class="Bound">B</a>
<a data-type="A ≃ B → A ≡ B" id="8832" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="8835" class="Symbol">{</a><a id="8836" class="Argument">A</a> <a id="8838" class="Symbol">=</a> <a id="8840" href="1Lab.Univalence.html#8840" class="Bound">A</a><a id="8841" class="Symbol">}</a> <a id="8843" class="Symbol">{</a><a id="8844" href="1Lab.Univalence.html#8844" class="Bound">B</a><a id="8845" class="Symbol">}</a> <a id="8847" href="1Lab.Univalence.html#8847" class="Bound">eqv</a> <a id="8851" href="1Lab.Univalence.html#8851" class="Bound">i</a> <a id="8853" class="Symbol">=</a> <a data-type="(A : Type ℓ) → Partial φ (Σ (λ T → T ≃ A)) → Type ℓ&#39;" id="8855" href="1Lab.Univalence.html#3409" class="Function">Glue</a> <a id="8860" href="1Lab.Univalence.html#8844" class="Bound">B</a> <a id="8862" class="Symbol">λ</a> <a id="8864" class="Symbol">{</a> <a id="8866" class="Symbol">(</a><a id="8867" href="1Lab.Univalence.html#8851" class="Bound">i</a> <a id="8869" class="Symbol">=</a> <a data-type="I" id="8871" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="8873" class="Symbol">)</a> <a id="8875" class="Symbol">→</a> <a id="8877" href="1Lab.Univalence.html#8840" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="8879" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8881" href="1Lab.Univalence.html#8847" class="Bound">eqv</a>
                                <a id="8917" class="Symbol">;</a> <a id="8919" class="Symbol">(</a><a id="8920" href="1Lab.Univalence.html#8851" class="Bound">i</a> <a id="8922" class="Symbol">=</a> <a data-type="I" id="8924" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="8926" class="Symbol">)</a> <a id="8928" class="Symbol">→</a> <a id="8930" href="1Lab.Univalence.html#8844" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="8932" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8934" class="Symbol">_</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="8936" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="8938" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a>
                                <a id="8978" class="Symbol">}</a>
</pre>
<p>Semantically, the explanation of <span class="Agda"><a data-type="A ≃ B → A ≡ B" href="1Lab.Univalence.html#8796" class="Function">ua</a></span> as completing a partial line is sufficient. But we can also ask ourselves: Why does this definition go through, <em>syntactically</em>? Because of the boundary condition for Glue: when <code>i = i0</code>, the whole thing evaluates to <code>A</code>, meaning that the left endpoint of the path is correct. The same thing happens with the right endpoint.</p>
<p>The action of <a href="1Lab.Path.html">transporting</a> along <code>ua(f)</code> can be described by chasing an element around the diagram that illustrates Glue in the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>φ</mi><mo>=</mo><mi>i</mi><mo>∨</mo><mi mathvariant="normal">¬</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">\varphi = i \lor \neg i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">φ</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord">¬</span><span class="mord mathnormal">i</span></span></span></span> case, specialising to <span class="Agda"><a data-type="A ≃ B → A ≡ B" href="1Lab.Univalence.html#8796" class="Function">ua</a></span>. Keep in mind that, since the right face of the diagram “points in the wrong direction”, it must be inverted. However, the inverse of the identity equivalence is the identity equivalence, so nothing changes (for this example).</p>
<figure>
<div class="diagram-container"> <img title="commutative diagram" src="096e2fdc0220ef7d1d917abcd6a3827f.svg" class="diagram  quiver"></img> </div>
</figure>
<ol class="incremental" type="1">
<li>The action that corresponds to the left face of the diagram is to apply the underlying function of <code>f</code>. This contributes the <code>f .fst x</code> part of the <span class="Agda"><a data-type="(f : A ≃ B) (x : A) → transport (ua f) x ≡ f .fst x" href="1Lab.Univalence.html#10955" class="Function">uaβ</a></span> term below.</li>
</ol>
<ol class="incremental" start="2" type="1">
<li>For the bottom face, we have a path rather than an equivalence, so we must <span class="Agda"><a data-type="A ≡ B → A → B" href="1Lab.Path.html#10335" class="Function">transport</a></span> along it. In this case, the path is the reflexivity on <code>B</code>, but in a more general <span class="Agda"><a data-type="(A : Type ℓ) → Partial φ (Σ (λ T → T ≃ A)) → Type ℓ&#39;" href="1Lab.Univalence.html#3409" class="Function">Glue</a></span> construction, it might be a non-trivial path.</li>
</ol>
<p>To compensate for this extra transport, we use <span class="Agda"><a data-type="(A : I → Type ℓ) (i : I) → A i1 → A i" href="1Lab.Path.html#49774" class="Function">coe1→i</a></span>, which connects <code>f .fst x</code> and <code>transport (λ i → B) (f .fst x)</code>.</p>
<ol class="incremental" start="3" type="1">
<li>Finally, we apply the inverse of the identity equivalence, corresponding to the right face in the diagram. This immediately computes away, and thus contributes nothing to the <span class="Agda"><a data-type="(f : A ≃ B) (x : A) → transport (ua f) x ≡ f .fst x" href="1Lab.Univalence.html#10955" class="Function">uaβ</a></span> path.</li>
</ol>
<pre class="Agda"><a id="uaβ"></a><a data-type="(f : A ≃ B) (x : A) → transport (ua f) x ≡ f .fst x" id="10955" href="1Lab.Univalence.html#10955" class="Function">uaβ</a> <a id="10959" class="Symbol">:</a> <a id="10961" class="Symbol">{</a><a id="10962" href="1Lab.Univalence.html#10962" class="Bound">A</a> <a id="10964" href="1Lab.Univalence.html#10964" class="Bound">B</a> <a id="10966" class="Symbol">:</a> <a id="10968" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="10973" href="1Lab.Univalence.html#2837" class="Generalizable">ℓ</a><a id="10974" class="Symbol">}</a> <a id="10976" class="Symbol">(</a><a id="10977" href="1Lab.Univalence.html#10977" class="Bound">f</a> <a id="10979" class="Symbol">:</a> <a id="10981" href="1Lab.Univalence.html#10962" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="10983" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="10985" href="1Lab.Univalence.html#10964" class="Bound">B</a><a id="10986" class="Symbol">)</a> <a id="10988" class="Symbol">(</a><a id="10989" href="1Lab.Univalence.html#10989" class="Bound">x</a> <a id="10991" class="Symbol">:</a> <a id="10993" href="1Lab.Univalence.html#10962" class="Bound">A</a><a id="10994" class="Symbol">)</a> <a id="10996" class="Symbol">→</a> <a data-type="A ≡ B → A → B" id="10998" href="1Lab.Path.html#10335" class="Function">transport</a> <a id="11008" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="11009" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="11012" href="1Lab.Univalence.html#10977" class="Bound">f</a><a id="11013" class="Symbol">)</a> <a id="11015" href="1Lab.Univalence.html#10989" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="11017" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="11019" href="1Lab.Univalence.html#10977" class="Bound">f</a> <a id="11021" class="Symbol">.</a><a data-type="∑ A B → A" id="11022" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="11026" href="1Lab.Univalence.html#10989" class="Bound">x</a>
<a data-type="(f : A ≃ B) (x : A) → transport (ua f) x ≡ f .fst x" id="11028" href="1Lab.Univalence.html#10955" class="Function">uaβ</a> <a id="11032" class="Symbol">{</a><a id="11033" class="Argument">A</a> <a id="11035" class="Symbol">=</a> <a id="11037" href="1Lab.Univalence.html#11037" class="Bound">A</a><a id="11038" class="Symbol">}</a> <a id="11040" class="Symbol">{</a><a id="11041" href="1Lab.Univalence.html#11041" class="Bound">B</a><a id="11042" class="Symbol">}</a> <a id="11044" href="1Lab.Univalence.html#11044" class="Bound">f</a> <a id="11046" href="1Lab.Univalence.html#11046" class="Bound">x</a> <a id="11048" href="1Lab.Univalence.html#11048" class="Bound">i</a> <a id="11050" class="Symbol">=</a> <a data-type="(A : I → Type ℓ) (i : I) → A i1 → A i" id="11052" href="1Lab.Path.html#49774" class="Function">coe1→i</a> <a id="11059" class="Symbol">(λ</a> <a id="11062" href="1Lab.Univalence.html#11062" class="Bound">_</a> <a id="11064" class="Symbol">→</a> <a id="11066" href="1Lab.Univalence.html#11041" class="Bound">B</a><a id="11067" class="Symbol">)</a> <a id="11069" href="1Lab.Univalence.html#11048" class="Bound">i</a> <a id="11071" class="Symbol">(</a><a id="11072" href="1Lab.Univalence.html#11044" class="Bound">f</a> <a id="11074" class="Symbol">.</a><a data-type="∑ A B → A" id="11075" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="11079" href="1Lab.Univalence.html#11046" class="Bound">x</a><a id="11080" class="Symbol">)</a>
</pre>
<p>Since <span class="Agda"><a data-type="A ≃ B → A ≡ B" href="1Lab.Univalence.html#8796" class="Function">ua</a></span> is a map that turns equivalences into paths, we can compose it with a function that turns <a href="1Lab.Equiv.html#Iso">isomorphisms</a> into equivalences to get the map <span class="Agda"><a data-type="Iso A B → A ≡ B" href="1Lab.Univalence.html#11308" class="Function">Iso→path</a></span>.</p>
<pre class="Agda"><a id="Iso→path"></a><a data-type="Iso A B → A ≡ B" id="11308" href="1Lab.Univalence.html#11308" class="Function">Iso→path</a> <a id="11317" class="Symbol">:</a> <a id="11319" class="Symbol">{</a><a id="11320" href="1Lab.Univalence.html#11320" class="Bound">A</a> <a id="11322" href="1Lab.Univalence.html#11322" class="Bound">B</a> <a id="11324" class="Symbol">:</a> <a id="11326" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="11331" href="1Lab.Univalence.html#2837" class="Generalizable">ℓ</a><a id="11332" class="Symbol">}</a> <a id="11334" class="Symbol">→</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="11336" href="1Lab.Equiv.html#6241" class="Function">Iso</a> <a id="11340" href="1Lab.Univalence.html#11320" class="Bound">A</a> <a id="11342" href="1Lab.Univalence.html#11322" class="Bound">B</a> <a id="11344" class="Symbol">→</a> <a id="11346" href="1Lab.Univalence.html#11320" class="Bound">A</a> <a data-type="A → A → Type ℓ" id="11348" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="11350" href="1Lab.Univalence.html#11322" class="Bound">B</a>
<a data-type="Iso A B → A ≡ B" id="11352" href="1Lab.Univalence.html#11308" class="Function">Iso→path</a> <a id="11361" class="Symbol">(</a><a id="11362" href="1Lab.Univalence.html#11362" class="Bound">f</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="11364" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="11366" href="1Lab.Univalence.html#11366" class="Bound">iiso</a><a id="11370" class="Symbol">)</a> <a id="11372" class="Symbol">=</a> <a data-type="A ≃ B → A ≡ B" id="11374" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="11377" class="Symbol">(</a><a id="11378" href="1Lab.Univalence.html#11362" class="Bound">f</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="11380" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="(i : isIso f) → isEquiv f" id="11382" href="1Lab.Equiv.html#19765" class="Function">isIso→isEquiv</a> <a id="11396" href="1Lab.Univalence.html#11366" class="Bound">iiso</a><a id="11400" class="Symbol">)</a>
</pre>
<h2 id="paths-over-ua"><a href="#paths-over-ua" class="header-link">Paths over ua<span class="header-link-emoji">🔗</span></a></h2>
<p>The introduction and elimination forms for <span class="Agda"><a data-type="(A : Type ℓ) → Partial φ (Σ (λ T → T ≃ A)) → Type ℓ&#39;" href="1Lab.Univalence.html#3409" class="Function">Glue</a></span> can be specialised to the case of <span class="Agda"><a data-type="A ≃ B → A ≡ B" href="1Lab.Univalence.html#8796" class="Function">ua</a></span>, leading to the definitions of <span class="Agda"><a data-type="(e : A ≃ B) (i : I) (x : Partial (~ i) A)
(y : B [ ~ i ↦ (λ { ((i = i0)) → e .fst (x _) }) ]) →
ua e i [ ~ i ∨ i ↦ (λ { ((i = i0)) → x _ ; ((i = i1)) → outS y }) ]" href="1Lab.Univalence.html#13128" class="Function">ua-glue</a></span> and <span class="Agda"><a data-type="(e : A ≃ B) (i : I) (x : ua e i) →
B [ ~ i ∨ i ↦ (λ { ((i = i0)) → e .fst x ; ((i = i1)) → x }) ]" href="1Lab.Univalence.html#12054" class="Function">ua-unglue</a></span> below. Their types are written in terms of interval variables and <a href="1Lab.Path.html#extensibility">extensions</a>, rather than using <code class="sourceCode agda">Path</code>s, because these typings make the structure of <span class="Agda"><a data-type="(A : Type ℓ) → Partial φ (Σ (λ T → T ≃ A)) → Type ℓ&#39;" href="1Lab.Univalence.html#3409" class="Function">Glue</a></span> more explicit.</p>
<p>The first, <span class="Agda"><a data-type="(e : A ≃ B) (i : I) (x : ua e i) →
B [ ~ i ∨ i ↦ (λ { ((i = i0)) → e .fst x ; ((i = i1)) → x }) ]" href="1Lab.Univalence.html#12054" class="Function">ua-unglue</a></span>, tells us that if we have some <code>x : ua e i</code> (varying over an interval variable <code>i</code>), then we have an element of <code>B</code> which agrees with <code>e .fst x</code> on the left and with <code>x</code> on the right.</p>
<pre class="Agda"><a id="ua-unglue"></a><a data-type="(e : A ≃ B) (i : I) (x : ua e i) →
B [ ~ i ∨ i ↦ (λ { ((i = i0)) → e .fst x ; ((i = i1)) → x }) ]" id="12054" href="1Lab.Univalence.html#12054" class="Function">ua-unglue</a> <a id="12064" class="Symbol">:</a> <a id="12066" class="Symbol">∀</a> <a id="12068" class="Symbol">{</a><a id="12069" href="1Lab.Univalence.html#12069" class="Bound">A</a> <a id="12071" href="1Lab.Univalence.html#12071" class="Bound">B</a> <a id="12073" class="Symbol">:</a> <a id="12075" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="12080" href="1Lab.Univalence.html#2837" class="Generalizable">ℓ</a><a id="12081" class="Symbol">}</a> <a id="12083" class="Symbol">(</a><a id="12084" href="1Lab.Univalence.html#12084" class="Bound">e</a> <a id="12086" class="Symbol">:</a> <a id="12088" href="1Lab.Univalence.html#12069" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="12090" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="12092" href="1Lab.Univalence.html#12071" class="Bound">B</a><a id="12093" class="Symbol">)</a> <a id="12095" class="Symbol">(</a><a id="12096" href="1Lab.Univalence.html#12096" class="Bound">i</a> <a id="12098" class="Symbol">:</a> <a data-type="SSet lzero" id="12100" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="12101" class="Symbol">)</a> <a id="12103" class="Symbol">(</a><a id="12104" href="1Lab.Univalence.html#12104" class="Bound">x</a> <a id="12106" class="Symbol">:</a> <a data-type="A ≃ B → A ≡ B" id="12108" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="12111" href="1Lab.Univalence.html#12084" class="Bound">e</a> <a id="12113" href="1Lab.Univalence.html#12096" class="Bound">i</a><a id="12114" class="Symbol">)</a>
            <a id="12128" class="Symbol">→</a> <a id="12130" href="1Lab.Univalence.html#12071" class="Bound">B</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="12132" href="1Lab.Path.html#27116" class="Function Operator">[</a> <a id="12134" class="Symbol">_</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="12136" href="1Lab.Path.html#27116" class="Function Operator">↦</a> <a id="12138" class="Symbol">(λ</a> <a id="12141" class="Symbol">{</a> <a id="12143" class="Symbol">(</a><a id="12144" href="1Lab.Univalence.html#12096" class="Bound">i</a> <a id="12146" class="Symbol">=</a> <a data-type="I" id="12148" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="12150" class="Symbol">)</a> <a id="12152" class="Symbol">→</a> <a id="12154" href="1Lab.Univalence.html#12084" class="Bound">e</a> <a id="12156" class="Symbol">.</a><a data-type="∑ A B → A" id="12157" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="12161" href="1Lab.Univalence.html#12104" class="Bound">x</a>
                         <a id="12188" class="Symbol">;</a> <a id="12190" class="Symbol">(</a><a id="12191" href="1Lab.Univalence.html#12096" class="Bound">i</a> <a id="12193" class="Symbol">=</a> <a data-type="I" id="12195" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="12197" class="Symbol">)</a> <a id="12199" class="Symbol">→</a> <a id="12201" href="1Lab.Univalence.html#12104" class="Bound">x</a> <a id="12203" class="Symbol">})</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="12206" href="1Lab.Path.html#27116" class="Function Operator">]</a>
<a data-type="(e : A ≃ B) (i : I) (x : ua e i) →
B [ ~ i ∨ i ↦ (λ { ((i = i0)) → e .fst x ; ((i = i1)) → x }) ]" id="12208" href="1Lab.Univalence.html#12054" class="Function">ua-unglue</a> <a id="12218" href="1Lab.Univalence.html#12218" class="Bound">e</a> <a id="12220" href="1Lab.Univalence.html#12220" class="Bound">i</a> <a id="12222" href="1Lab.Univalence.html#12222" class="Bound">x</a> <a id="12224" class="Symbol">=</a> <a id="12226" href="1Lab.Path.html#608" class="Postulate">inS</a> <a id="12230" class="Symbol">(</a><a id="12231" href="1Lab.Univalence.html#4527" class="Function">unglue</a> <a id="12238" class="Symbol">(</a><a id="12239" href="1Lab.Univalence.html#12220" class="Bound">i</a> <a id="12241" href="1Lab.Path.html#765" class="Primitive Operator">∨</a> <a id="12243" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="12245" href="1Lab.Univalence.html#12220" class="Bound">i</a><a id="12246" class="Symbol">)</a> <a id="12248" href="1Lab.Univalence.html#12222" class="Bound">x</a><a id="12249" class="Symbol">)</a>
</pre>
<p>We can factor the interval variable out, to get a type in terms of <span class="Agda"><a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a></span>, leading to an explanation of <code>ua-unglue</code> without mentioning extensions: A path <code>x ≡ y</code> over <code>ua e</code> induces a path <code>e .fst x ≡ y</code>.</p>
<pre class="Agda"><a id="uaPathP→Path"></a><a data-type="(e : A ≃ B) → PathP (λ i → ua e i) x y → e .fst x ≡ y" id="12478" href="1Lab.Univalence.html#12478" class="Function">uaPathP→Path</a> <a id="12491" class="Symbol">:</a> <a id="12493" class="Symbol">∀</a> <a id="12495" class="Symbol">{</a><a id="12496" href="1Lab.Univalence.html#12496" class="Bound">A</a> <a id="12498" href="1Lab.Univalence.html#12498" class="Bound">B</a> <a id="12500" class="Symbol">:</a> <a id="12502" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="12507" href="1Lab.Univalence.html#2837" class="Generalizable">ℓ</a><a id="12508" class="Symbol">}</a> <a id="12510" class="Symbol">(</a><a id="12511" href="1Lab.Univalence.html#12511" class="Bound">e</a> <a id="12513" class="Symbol">:</a> <a id="12515" href="1Lab.Univalence.html#12496" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="12517" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="12519" href="1Lab.Univalence.html#12498" class="Bound">B</a><a id="12520" class="Symbol">)</a> <a id="12522" class="Symbol">{</a><a id="12523" href="1Lab.Univalence.html#12523" class="Bound">x</a> <a id="12525" class="Symbol">:</a> <a id="12527" href="1Lab.Univalence.html#12496" class="Bound">A</a><a id="12528" class="Symbol">}</a> <a id="12530" class="Symbol">{</a><a id="12531" href="1Lab.Univalence.html#12531" class="Bound">y</a> <a id="12533" class="Symbol">:</a> <a id="12535" href="1Lab.Univalence.html#12498" class="Bound">B</a><a id="12536" class="Symbol">}</a>
             <a id="12551" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="12553" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="12559" class="Symbol">(λ</a> <a id="12562" href="1Lab.Univalence.html#12562" class="Bound">i</a> <a id="12564" class="Symbol">→</a> <a data-type="A ≃ B → A ≡ B" id="12566" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="12569" href="1Lab.Univalence.html#12511" class="Bound">e</a> <a id="12571" href="1Lab.Univalence.html#12562" class="Bound">i</a><a id="12572" class="Symbol">)</a> <a id="12574" href="1Lab.Univalence.html#12523" class="Bound">x</a> <a id="12576" href="1Lab.Univalence.html#12531" class="Bound">y</a>
             <a id="12591" class="Symbol">→</a> <a id="12593" href="1Lab.Univalence.html#12511" class="Bound">e</a> <a id="12595" class="Symbol">.</a><a data-type="∑ A B → A" id="12596" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="12600" href="1Lab.Univalence.html#12523" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="12602" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="12604" href="1Lab.Univalence.html#12531" class="Bound">y</a>
<a data-type="(e : A ≃ B) → PathP (λ i → ua e i) x y → e .fst x ≡ y" id="12606" href="1Lab.Univalence.html#12478" class="Function">uaPathP→Path</a> <a id="12619" href="1Lab.Univalence.html#12619" class="Bound">e</a> <a id="12621" href="1Lab.Univalence.html#12621" class="Bound">p</a> <a id="12623" href="1Lab.Univalence.html#12623" class="Bound">i</a> <a id="12625" class="Symbol">=</a> <a id="12627" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="12632" class="Symbol">(</a><a data-type="(e : A ≃ B) (i : I) (x : ua e i) →
B [ ~ i ∨ i ↦ (λ { ((i = i0)) → e .fst x ; ((i = i1)) → x }) ]" id="12633" href="1Lab.Univalence.html#12054" class="Function">ua-unglue</a> <a id="12643" href="1Lab.Univalence.html#12619" class="Bound">e</a> <a id="12645" href="1Lab.Univalence.html#12623" class="Bound">i</a> <a id="12647" class="Symbol">(</a><a id="12648" href="1Lab.Univalence.html#12621" class="Bound">p</a> <a id="12650" href="1Lab.Univalence.html#12623" class="Bound">i</a><a id="12651" class="Symbol">))</a>
</pre>
<p>In the other direction, we have <span class="Agda"><a data-type="(e : A ≃ B) (i : I) (x : Partial (~ i) A)
(y : B [ ~ i ↦ (λ { ((i = i0)) → e .fst (x _) }) ]) →
ua e i [ ~ i ∨ i ↦ (λ { ((i = i0)) → x _ ; ((i = i1)) → outS y }) ]" href="1Lab.Univalence.html#13128" class="Function">ua-glue</a></span>, which expresses that a path <code>e .fst x ≡ y</code> implies that <code>x ≡ y</code> over <code>ua e</code>. For the type of <span class="Agda"><a data-type="(e : A ≃ B) (i : I) (x : Partial (~ i) A)
(y : B [ ~ i ↦ (λ { ((i = i0)) → e .fst (x _) }) ]) →
ua e i [ ~ i ∨ i ↦ (λ { ((i = i0)) → x _ ; ((i = i1)) → outS y }) ]" href="1Lab.Univalence.html#13128" class="Function">ua-glue</a></span>, suppose that we have a partial element <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> defined on the left endpoint of the interval, together with an extension <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">e(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> is defined. What <span class="Agda"><a data-type="(e : A ≃ B) (i : I) (x : Partial (~ i) A)
(y : B [ ~ i ↦ (λ { ((i = i0)) → e .fst (x _) }) ]) →
ua e i [ ~ i ∨ i ↦ (λ { ((i = i0)) → x _ ; ((i = i1)) → outS y }) ]" href="1Lab.Univalence.html#13128" class="Function">ua-glue</a></span> expresses is that we can complete this to a path in <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">u</mi><mi mathvariant="normal">a</mi></mrow><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{ua}(e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">ua</span></span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span>,</span> which agrees with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> where these are defined.</p>
<pre class="Agda"><a id="ua-glue"></a><a data-type="(e : A ≃ B) (i : I) (x : Partial (~ i) A)
(y : B [ ~ i ↦ (λ { ((i = i0)) → e .fst (x _) }) ]) →
ua e i [ ~ i ∨ i ↦ (λ { ((i = i0)) → x _ ; ((i = i1)) → outS y }) ]" id="13128" href="1Lab.Univalence.html#13128" class="Function">ua-glue</a> <a id="13136" class="Symbol">:</a> <a id="13138" class="Symbol">∀</a> <a id="13140" class="Symbol">{</a><a id="13141" href="1Lab.Univalence.html#13141" class="Bound">A</a> <a id="13143" href="1Lab.Univalence.html#13143" class="Bound">B</a> <a id="13145" class="Symbol">:</a> <a id="13147" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13152" href="1Lab.Univalence.html#2837" class="Generalizable">ℓ</a><a id="13153" class="Symbol">}</a> <a id="13155" class="Symbol">(</a><a id="13156" href="1Lab.Univalence.html#13156" class="Bound">e</a> <a id="13158" class="Symbol">:</a> <a id="13160" href="1Lab.Univalence.html#13141" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="13162" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="13164" href="1Lab.Univalence.html#13143" class="Bound">B</a><a id="13165" class="Symbol">)</a> <a id="13167" class="Symbol">(</a><a id="13168" href="1Lab.Univalence.html#13168" class="Bound">i</a> <a id="13170" class="Symbol">:</a> <a data-type="SSet lzero" id="13172" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="13173" class="Symbol">)</a>
            <a id="13187" class="Symbol">(</a><a id="13188" href="1Lab.Univalence.html#13188" class="Bound">x</a> <a id="13190" class="Symbol">:</a> <a data-type="(φ : I) (A : Type a) → SSet a" id="13192" href="Agda.Primitive.Cubical.html#1065" class="Primitive">Partial</a> <a id="13200" class="Symbol">(</a><a id="13201" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="13203" href="1Lab.Univalence.html#13168" class="Bound">i</a><a id="13204" class="Symbol">)</a> <a id="13206" href="1Lab.Univalence.html#13141" class="Bound">A</a><a id="13207" class="Symbol">)</a>
            <a id="13221" class="Symbol">(</a><a id="13222" href="1Lab.Univalence.html#13222" class="Bound">y</a> <a id="13224" class="Symbol">:</a> <a id="13226" href="1Lab.Univalence.html#13143" class="Bound">B</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="13228" href="1Lab.Path.html#27116" class="Function Operator">[</a> <a id="13230" class="Symbol">_</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="13232" href="1Lab.Path.html#27116" class="Function Operator">↦</a> <a id="13234" class="Symbol">(λ</a> <a id="13237" class="Symbol">{</a> <a id="13239" class="Symbol">(</a><a id="13240" href="1Lab.Univalence.html#13168" class="Bound">i</a> <a id="13242" class="Symbol">=</a> <a data-type="I" id="13244" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="13246" class="Symbol">)</a> <a id="13248" class="Symbol">→</a> <a id="13250" href="1Lab.Univalence.html#13156" class="Bound">e</a> <a id="13252" class="Symbol">.</a><a data-type="∑ A B → A" id="13253" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="13257" class="Symbol">(</a><a id="13258" href="1Lab.Univalence.html#13188" class="Bound">x</a> <a id="13260" href="1Lab.Path.html#982" class="Postulate">1=1</a><a id="13263" class="Symbol">)</a> <a id="13265" class="Symbol">})</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="13268" href="1Lab.Path.html#27116" class="Function Operator">]</a><a id="13269" class="Symbol">)</a>
          <a id="13281" class="Symbol">→</a> <a data-type="A ≃ B → A ≡ B" id="13283" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="13286" href="1Lab.Univalence.html#13156" class="Bound">e</a> <a id="13288" href="1Lab.Univalence.html#13168" class="Bound">i</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="13290" href="1Lab.Path.html#27116" class="Function Operator">[</a> <a id="13292" class="Symbol">_</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="13294" href="1Lab.Path.html#27116" class="Function Operator">↦</a> <a id="13296" class="Symbol">(λ</a> <a id="13299" class="Symbol">{</a> <a id="13301" class="Symbol">(</a><a id="13302" href="1Lab.Univalence.html#13168" class="Bound">i</a> <a id="13304" class="Symbol">=</a> <a data-type="I" id="13306" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="13308" class="Symbol">)</a> <a id="13310" class="Symbol">→</a> <a id="13312" href="1Lab.Univalence.html#13188" class="Bound">x</a> <a id="13314" href="1Lab.Path.html#982" class="Postulate">1=1</a>
                            <a id="13346" class="Symbol">;</a> <a id="13348" class="Symbol">(</a><a id="13349" href="1Lab.Univalence.html#13168" class="Bound">i</a> <a id="13351" class="Symbol">=</a> <a data-type="I" id="13353" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="13355" class="Symbol">)</a> <a id="13357" class="Symbol">→</a> <a id="13359" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="13364" href="1Lab.Univalence.html#13222" class="Bound">y</a>
                            <a id="13394" class="Symbol">})</a> <a data-type="(A : Type ℓ) (φ : I) (u : Partial φ A) → SSet ℓ" id="13397" href="1Lab.Path.html#27116" class="Function Operator">]</a>
<a data-type="(e : A ≃ B) (i : I) (x : Partial (~ i) A)
(y : B [ ~ i ↦ (λ { ((i = i0)) → e .fst (x _) }) ]) →
ua e i [ ~ i ∨ i ↦ (λ { ((i = i0)) → x _ ; ((i = i1)) → outS y }) ]" id="13399" href="1Lab.Univalence.html#13128" class="Function">ua-glue</a> <a id="13407" href="1Lab.Univalence.html#13407" class="Bound">e</a> <a id="13409" href="1Lab.Univalence.html#13409" class="Bound">i</a> <a id="13411" href="1Lab.Univalence.html#13411" class="Bound">x</a> <a id="13413" href="1Lab.Univalence.html#13413" class="Bound">y</a> <a id="13415" class="Symbol">=</a> <a id="13417" href="1Lab.Path.html#608" class="Postulate">inS</a> <a id="13421" class="Symbol">(</a><a id="13422" href="1Lab.Univalence.html#3003" class="Primitive">prim^glue</a> <a id="13432" class="Symbol">{</a><a id="13433" class="Argument">φ</a> <a id="13435" class="Symbol">=</a> <a id="13437" href="1Lab.Univalence.html#13409" class="Bound">i</a> <a id="13439" href="1Lab.Path.html#765" class="Primitive Operator">∨</a> <a id="13441" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="13443" href="1Lab.Univalence.html#13409" class="Bound">i</a><a id="13444" class="Symbol">}</a>
                                 <a id="13479" class="Symbol">(λ</a> <a id="13482" class="Symbol">{</a> <a id="13484" class="Symbol">(</a><a id="13485" href="1Lab.Univalence.html#13409" class="Bound">i</a> <a id="13487" class="Symbol">=</a> <a data-type="I" id="13489" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="13491" class="Symbol">)</a> <a id="13493" class="Symbol">→</a> <a id="13495" href="1Lab.Univalence.html#13411" class="Bound">x</a> <a id="13497" href="1Lab.Path.html#982" class="Postulate">1=1</a>
                                    <a id="13537" class="Symbol">;</a> <a id="13539" class="Symbol">(</a><a id="13540" href="1Lab.Univalence.html#13409" class="Bound">i</a> <a id="13542" class="Symbol">=</a> <a data-type="I" id="13544" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="13546" class="Symbol">)</a> <a id="13548" class="Symbol">→</a> <a id="13550" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="13555" href="1Lab.Univalence.html#13413" class="Bound">y</a> <a id="13557" class="Symbol">})</a>
                                 <a id="13593" class="Symbol">(</a><a id="13594" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="13599" href="1Lab.Univalence.html#13413" class="Bound">y</a><a id="13600" class="Symbol">))</a>
</pre>
<p>Observe that, since <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> is partially in the image of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>,</span> this essentially constrains <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> to be a “partial preimage” of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> under the equivalence <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span>.</span> Factoring in the type of the interval, we get the promised map between dependent paths over <span class="Agda"><a data-type="A ≃ B → A ≡ B" href="1Lab.Univalence.html#8796" class="Function">ua</a></span> and paths in B.</p>
<pre class="Agda"><a id="Path→uaPathP"></a><a data-type="(e : A ≃ B) → e .fst x ≡ y → PathP (λ i → ua e i) x y" id="13888" href="1Lab.Univalence.html#13888" class="Function">Path→uaPathP</a> <a id="13901" class="Symbol">:</a> <a id="13903" class="Symbol">∀</a> <a id="13905" class="Symbol">{</a><a id="13906" href="1Lab.Univalence.html#13906" class="Bound">A</a> <a id="13908" href="1Lab.Univalence.html#13908" class="Bound">B</a> <a id="13910" class="Symbol">:</a> <a id="13912" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13917" href="1Lab.Univalence.html#2837" class="Generalizable">ℓ</a><a id="13918" class="Symbol">}</a> <a id="13920" class="Symbol">(</a><a id="13921" href="1Lab.Univalence.html#13921" class="Bound">e</a> <a id="13923" class="Symbol">:</a> <a id="13925" href="1Lab.Univalence.html#13906" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="13927" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="13929" href="1Lab.Univalence.html#13908" class="Bound">B</a><a id="13930" class="Symbol">)</a> <a id="13932" class="Symbol">{</a><a id="13933" href="1Lab.Univalence.html#13933" class="Bound">x</a> <a id="13935" class="Symbol">:</a> <a id="13937" href="1Lab.Univalence.html#13906" class="Bound">A</a><a id="13938" class="Symbol">}</a> <a id="13940" class="Symbol">{</a><a id="13941" href="1Lab.Univalence.html#13941" class="Bound">y</a> <a id="13943" class="Symbol">:</a> <a id="13945" href="1Lab.Univalence.html#13908" class="Bound">B</a><a id="13946" class="Symbol">}</a>
             <a id="13961" class="Symbol">→</a> <a id="13963" href="1Lab.Univalence.html#13921" class="Bound">e</a> <a id="13965" class="Symbol">.</a><a data-type="∑ A B → A" id="13966" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="13970" href="1Lab.Univalence.html#13933" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="13972" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="13974" href="1Lab.Univalence.html#13941" class="Bound">y</a>
             <a id="13989" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="13991" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="13997" class="Symbol">(λ</a> <a id="14000" href="1Lab.Univalence.html#14000" class="Bound">i</a> <a id="14002" class="Symbol">→</a> <a data-type="A ≃ B → A ≡ B" id="14004" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="14007" href="1Lab.Univalence.html#13921" class="Bound">e</a> <a id="14009" href="1Lab.Univalence.html#14000" class="Bound">i</a><a id="14010" class="Symbol">)</a> <a id="14012" href="1Lab.Univalence.html#13933" class="Bound">x</a> <a id="14014" href="1Lab.Univalence.html#13941" class="Bound">y</a>
<a data-type="(e : A ≃ B) → e .fst x ≡ y → PathP (λ i → ua e i) x y" id="14016" href="1Lab.Univalence.html#13888" class="Function">Path→uaPathP</a> <a id="14029" href="1Lab.Univalence.html#14029" class="Bound">e</a> <a id="14031" class="Symbol">{</a><a id="14032" class="Argument">x</a> <a id="14034" class="Symbol">=</a> <a id="14036" href="1Lab.Univalence.html#14036" class="Bound">x</a><a id="14037" class="Symbol">}</a> <a id="14039" href="1Lab.Univalence.html#14039" class="Bound">p</a> <a id="14041" href="1Lab.Univalence.html#14041" class="Bound">i</a> <a id="14043" class="Symbol">=</a> <a id="14045" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="14050" class="Symbol">(</a><a data-type="(e : A ≃ B) (i : I) (x : Partial (~ i) A)
(y : B [ ~ i ↦ (λ { ((i = i0)) → e .fst (x _) }) ]) →
ua e i [ ~ i ∨ i ↦ (λ { ((i = i0)) → x _ ; ((i = i1)) → outS y }) ]" id="14051" href="1Lab.Univalence.html#13128" class="Function">ua-glue</a> <a id="14059" href="1Lab.Univalence.html#14029" class="Bound">e</a> <a id="14061" href="1Lab.Univalence.html#14041" class="Bound">i</a> <a id="14063" class="Symbol">(λ</a> <a id="14066" class="Symbol">{</a> <a id="14068" class="Symbol">(</a><a id="14069" href="1Lab.Univalence.html#14041" class="Bound">i</a> <a id="14071" class="Symbol">=</a> <a data-type="I" id="14073" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="14075" class="Symbol">)</a> <a id="14077" class="Symbol">→</a> <a id="14079" href="1Lab.Univalence.html#14036" class="Bound">x</a> <a id="14081" class="Symbol">})</a> <a id="14084" class="Symbol">(</a><a id="14085" href="1Lab.Path.html#608" class="Postulate">inS</a> <a id="14089" class="Symbol">(</a><a id="14090" href="1Lab.Univalence.html#14039" class="Bound">p</a> <a id="14092" href="1Lab.Univalence.html#14041" class="Bound">i</a><a id="14093" class="Symbol">)))</a>
</pre>
<p>The “pathp to path” versions of the above lemmas are definitionally inverses, so they provide a characterisation of <code>PathP (ua f)</code> in terms of non-dependent paths.</p>
<pre class="Agda"><a id="uaPathP≃Path"></a><a data-type="(e : A ≃ B) → (e .fst x ≡ y) ≃ PathP (λ i → ua e i) x y" id="14275" href="1Lab.Univalence.html#14275" class="Function">uaPathP≃Path</a> <a id="14288" class="Symbol">:</a> <a id="14290" class="Symbol">∀</a> <a id="14292" class="Symbol">{</a><a id="14293" href="1Lab.Univalence.html#14293" class="Bound">A</a> <a id="14295" href="1Lab.Univalence.html#14295" class="Bound">B</a> <a id="14297" class="Symbol">:</a> <a id="14299" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14304" href="1Lab.Univalence.html#2837" class="Generalizable">ℓ</a><a id="14305" class="Symbol">}</a> <a id="14307" class="Symbol">(</a><a id="14308" href="1Lab.Univalence.html#14308" class="Bound">e</a> <a id="14310" class="Symbol">:</a> <a id="14312" href="1Lab.Univalence.html#14293" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="14314" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="14316" href="1Lab.Univalence.html#14295" class="Bound">B</a><a id="14317" class="Symbol">)</a> <a id="14319" class="Symbol">{</a><a id="14320" href="1Lab.Univalence.html#14320" class="Bound">x</a> <a id="14322" class="Symbol">:</a> <a id="14324" href="1Lab.Univalence.html#14293" class="Bound">A</a><a id="14325" class="Symbol">}</a> <a id="14327" class="Symbol">{</a><a id="14328" href="1Lab.Univalence.html#14328" class="Bound">y</a> <a id="14330" class="Symbol">:</a> <a id="14332" href="1Lab.Univalence.html#14295" class="Bound">B</a><a id="14333" class="Symbol">}</a>
             <a id="14348" class="Symbol">→</a> <a id="14350" class="Symbol">(</a><a id="14351" href="1Lab.Univalence.html#14308" class="Bound">e</a> <a id="14353" class="Symbol">.</a><a data-type="∑ A B → A" id="14354" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="14358" href="1Lab.Univalence.html#14320" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="14360" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="14362" href="1Lab.Univalence.html#14328" class="Bound">y</a><a id="14363" class="Symbol">)</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="14365" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="14367" class="Symbol">(</a><a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="14368" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="14374" class="Symbol">(λ</a> <a id="14377" href="1Lab.Univalence.html#14377" class="Bound">i</a> <a id="14379" class="Symbol">→</a> <a data-type="A ≃ B → A ≡ B" id="14381" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="14384" href="1Lab.Univalence.html#14308" class="Bound">e</a> <a id="14386" href="1Lab.Univalence.html#14377" class="Bound">i</a><a id="14387" class="Symbol">)</a> <a id="14389" href="1Lab.Univalence.html#14320" class="Bound">x</a> <a id="14391" href="1Lab.Univalence.html#14328" class="Bound">y</a><a id="14392" class="Symbol">)</a>
<a data-type="(e : A ≃ B) → (e .fst x ≡ y) ≃ PathP (λ i → ua e i) x y" id="14394" href="1Lab.Univalence.html#14275" class="Function">uaPathP≃Path</a> <a id="14407" href="1Lab.Univalence.html#14407" class="Bound">eqv</a> <a id="14411" class="Symbol">.</a><a data-type="∑ A B → A" id="14412" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="14416" class="Symbol">=</a> <a data-type="(e : A ≃ B) → e .fst x ≡ y → PathP (λ i → ua e i) x y" id="14418" href="1Lab.Univalence.html#13888" class="Function">Path→uaPathP</a> <a id="14431" href="1Lab.Univalence.html#14407" class="Bound">eqv</a>
<a data-type="(e : A ≃ B) → (e .fst x ≡ y) ≃ PathP (λ i → ua e i) x y" id="14435" href="1Lab.Univalence.html#14275" class="Function">uaPathP≃Path</a> <a id="14448" href="1Lab.Univalence.html#14448" class="Bound">eqv</a> <a id="14452" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="14453" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="14457" class="Symbol">.</a><a data-type="isEquiv f → (y : B) → isContr (fibre f y)" id="14458" href="1Lab.Equiv.html#2382" class="Field">isEqv</a> <a id="14464" href="1Lab.Univalence.html#14464" class="Bound">y</a> <a id="14466" class="Symbol">.</a><a data-type="isContr A → A" id="14467" href="1Lab.HLevel.html#1400" class="Field">centre</a> <a id="14474" class="Symbol">=</a> <a id="14476" href="1Lab.Equiv.html#2799" class="Function">strict-fibres</a> <a id="14490" class="Symbol">(</a><a data-type="(e : A ≃ B) → PathP (λ i → ua e i) x y → e .fst x ≡ y" id="14491" href="1Lab.Univalence.html#12478" class="Function">uaPathP→Path</a> <a id="14504" href="1Lab.Univalence.html#14448" class="Bound">eqv</a><a id="14507" class="Symbol">)</a> <a id="14509" href="1Lab.Univalence.html#14464" class="Bound">y</a> <a id="14511" class="Symbol">.</a><a data-type="∑ A B → A" id="14512" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a>
<a data-type="(e : A ≃ B) → (e .fst x ≡ y) ≃ PathP (λ i → ua e i) x y" id="14516" href="1Lab.Univalence.html#14275" class="Function">uaPathP≃Path</a> <a id="14529" href="1Lab.Univalence.html#14529" class="Bound">eqv</a> <a id="14533" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="14534" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="14538" class="Symbol">.</a><a data-type="isEquiv f → (y : B) → isContr (fibre f y)" id="14539" href="1Lab.Equiv.html#2382" class="Field">isEqv</a> <a id="14545" href="1Lab.Univalence.html#14545" class="Bound">y</a> <a id="14547" class="Symbol">.</a><a data-type="(r : isContr A) (x : A) → r .centre ≡ x" id="14548" href="1Lab.HLevel.html#1415" class="Field">paths</a> <a id="14554" class="Symbol">=</a> <a id="14556" href="1Lab.Equiv.html#2799" class="Function">strict-fibres</a> <a id="14570" class="Symbol">(</a><a data-type="(e : A ≃ B) → PathP (λ i → ua e i) x y → e .fst x ≡ y" id="14571" href="1Lab.Univalence.html#12478" class="Function">uaPathP→Path</a> <a id="14584" href="1Lab.Univalence.html#14529" class="Bound">eqv</a><a id="14587" class="Symbol">)</a> <a id="14589" href="1Lab.Univalence.html#14545" class="Bound">y</a> <a id="14591" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="14592" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a>
</pre>
<h1 id="the-axiom"><a href="#the-axiom" class="header-link">The “axiom”<span class="header-link-emoji">🔗</span></a></h1>
<p>The actual “univalence axiom”, as stated in the HoTT book, says that the canonical map <code>A ≡ B</code>, defined using <span class="Agda"><a data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" href="1Lab.Path.html#18079" class="Function">J</a></span>, is an equivalence. This map is <span class="Agda"><a href="1Lab.Univalence.html#14975" class="Function">idToEquiv</a></span>, defined right above. In more intuitive terms, it’s “casting” the identity equivalence <code>A ≃ A</code> along a proof that <code>A ≡ B</code> to get an equivalence <code>A ≃ B</code>.</p>
<pre class="Agda"><a id="14950" class="Keyword">module</a> <a id="14957" href="1Lab.Univalence.html#14957" class="Module">_</a> <a id="14959" class="Keyword">where</a> <a id="14965" class="Keyword">private</a>
  <a id="14975" href="1Lab.Univalence.html#14975" class="Function">idToEquiv</a> <a id="14985" class="Symbol">:</a> <a id="14987" class="Symbol">{</a><a id="14988" href="1Lab.Univalence.html#14988" class="Bound">A</a> <a id="14990" href="1Lab.Univalence.html#14990" class="Bound">B</a> <a id="14992" class="Symbol">:</a> <a id="14994" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14999" href="1Lab.Univalence.html#2837" class="Generalizable">ℓ</a><a id="15000" class="Symbol">}</a> <a id="15002" class="Symbol">→</a> <a id="15004" href="1Lab.Univalence.html#14988" class="Bound">A</a> <a data-type="A → A → Type ℓ" id="15006" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="15008" href="1Lab.Univalence.html#14990" class="Bound">B</a> <a id="15010" class="Symbol">→</a> <a id="15012" href="1Lab.Univalence.html#14988" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="15014" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="15016" href="1Lab.Univalence.html#14990" class="Bound">B</a>
  <a id="15020" href="1Lab.Univalence.html#14975" class="Function">idToEquiv</a> <a id="15030" class="Symbol">{</a><a id="15031" class="Argument">A</a> <a id="15033" class="Symbol">=</a> <a id="15035" href="1Lab.Univalence.html#15035" class="Bound">A</a><a id="15036" class="Symbol">}</a> <a id="15038" class="Symbol">{</a><a id="15039" href="1Lab.Univalence.html#15039" class="Bound">B</a><a id="15040" class="Symbol">}</a> <a id="15042" class="Symbol">=</a> <a data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" id="15044" href="1Lab.Path.html#18079" class="Function">J</a> <a id="15046" class="Symbol">(λ</a> <a id="15049" href="1Lab.Univalence.html#15049" class="Bound">x</a> <a id="15051" href="1Lab.Univalence.html#15051" class="Bound">_</a> <a id="15053" class="Symbol">→</a> <a id="15055" href="1Lab.Univalence.html#15035" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="15057" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="15059" href="1Lab.Univalence.html#15049" class="Bound">x</a><a id="15060" class="Symbol">)</a> <a id="15062" class="Symbol">(_</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="15065" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="15067" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="15074" class="Symbol">)</a>

  <a id="15079" href="1Lab.Univalence.html#15079" class="Function">idToEquiv-refl</a> <a id="15094" class="Symbol">:</a> <a id="15096" class="Symbol">{</a><a id="15097" href="1Lab.Univalence.html#15097" class="Bound">A</a> <a id="15099" class="Symbol">:</a> <a id="15101" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="15106" href="1Lab.Univalence.html#2837" class="Generalizable">ℓ</a><a id="15107" class="Symbol">}</a> <a id="15109" class="Symbol">→</a> <a id="15111" href="1Lab.Univalence.html#14975" class="Function">idToEquiv</a> <a id="15121" class="Symbol">(λ</a> <a id="15124" href="1Lab.Univalence.html#15124" class="Bound">i</a> <a id="15126" class="Symbol">→</a> <a id="15128" href="1Lab.Univalence.html#15097" class="Bound">A</a><a id="15129" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="15131" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="15133" class="Symbol">(_</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="15136" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="15138" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="15145" class="Symbol">)</a>
  <a id="15149" href="1Lab.Univalence.html#15079" class="Function">idToEquiv-refl</a> <a id="15164" class="Symbol">{</a><a id="15165" class="Argument">A</a> <a id="15167" class="Symbol">=</a> <a id="15169" href="1Lab.Univalence.html#15169" class="Bound">A</a><a id="15170" class="Symbol">}</a> <a id="15172" class="Symbol">=</a> <a data-type="(P : (y : A) → x ≡ y → Type ℓ₂) (pxr : P x refl) →
J P pxr refl ≡ pxr" id="15174" href="1Lab.Path.html#18637" class="Function">JRefl</a> <a id="15180" class="Symbol">(λ</a> <a id="15183" href="1Lab.Univalence.html#15183" class="Bound">x</a> <a id="15185" href="1Lab.Univalence.html#15185" class="Bound">_</a> <a id="15187" class="Symbol">→</a> <a id="15189" href="1Lab.Univalence.html#15169" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="15191" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="15193" href="1Lab.Univalence.html#15183" class="Bound">x</a><a id="15194" class="Symbol">)</a> <a id="15196" class="Symbol">(_</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="15199" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="15201" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="15208" class="Symbol">)</a>
</pre>
<p>However, because of efficiency concerns (Agda <em>is</em> a programming language, after all), instead of using <span class="Agda"><a href="1Lab.Univalence.html#14975" class="Function">idToEquiv</a></span> defined using J, we use <span class="Agda"><a data-type="A ≡ B → A ≃ B" href="1Lab.Univalence.html#15463" class="Function">pathToEquiv</a></span>, which is <a href="1Lab.Equiv.FromPath.html">defined in an auxilliary module</a>.</p>
<pre class="Agda"><a id="pathToEquiv"></a><a data-type="A ≡ B → A ≃ B" id="15463" href="1Lab.Univalence.html#15463" class="Function">pathToEquiv</a> <a id="15475" class="Symbol">:</a> <a id="15477" class="Symbol">{</a><a id="15478" href="1Lab.Univalence.html#15478" class="Bound">A</a> <a id="15480" href="1Lab.Univalence.html#15480" class="Bound">B</a> <a id="15482" class="Symbol">:</a> <a id="15484" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="15489" href="1Lab.Univalence.html#2837" class="Generalizable">ℓ</a><a id="15490" class="Symbol">}</a> <a id="15492" class="Symbol">→</a> <a id="15494" href="1Lab.Univalence.html#15478" class="Bound">A</a> <a data-type="A → A → Type ℓ" id="15496" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="15498" href="1Lab.Univalence.html#15480" class="Bound">B</a> <a id="15500" class="Symbol">→</a> <a id="15502" href="1Lab.Univalence.html#15478" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="15504" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="15506" href="1Lab.Univalence.html#15480" class="Bound">B</a>
<a data-type="A ≡ B → A ≃ B" id="15508" href="1Lab.Univalence.html#15463" class="Function">pathToEquiv</a> <a id="15520" href="1Lab.Univalence.html#15520" class="Bound">p</a> <a id="15522" class="Symbol">=</a> <a data-type="(P : I → Type ℓ) →
1Lab.Equiv.FromPath.A P ≃ 1Lab.Equiv.FromPath.B P" id="15524" href="1Lab.Equiv.FromPath.html#9222" class="Function">line→equiv</a> <a id="15535" class="Symbol">(λ</a> <a id="15538" href="1Lab.Univalence.html#15538" class="Bound">i</a> <a id="15540" class="Symbol">→</a> <a id="15542" href="1Lab.Univalence.html#15520" class="Bound">p</a> <a id="15544" href="1Lab.Univalence.html#15538" class="Bound">i</a><a id="15545" class="Symbol">)</a>
</pre>
<p>Since equality of equivalences is determined by equality of their underlying functions, to show that <span class="Agda"><a data-type="A ≡ B → A ≃ B" href="1Lab.Univalence.html#15463" class="Function">pathToEquiv</a></span> of <span class="Agda"><a data-type="x ≡ x" href="1Lab.Path.html#2137" class="Function">refl</a></span> is the identity equivalence, we use <span class="Agda"><a data-type="(A : I → Type ℓ) (i : I) → A i1 → A i" href="1Lab.Path.html#49774" class="Function">coe1→i</a></span> to show that <span class="Agda"><a data-type="A ≡ B → A → B" href="1Lab.Path.html#10335" class="Function">transport</a></span> by <span class="Agda"><a data-type="x ≡ x" href="1Lab.Path.html#2137" class="Function">refl</a></span> is the identity.</p>
<pre class="Agda"><a id="pathToEquiv-refl"></a><a data-type="pathToEquiv refl ≡ (id , idEquiv)" id="15818" href="1Lab.Univalence.html#15818" class="Function">pathToEquiv-refl</a> <a id="15835" class="Symbol">:</a> <a id="15837" class="Symbol">{</a><a id="15838" href="1Lab.Univalence.html#15838" class="Bound">A</a> <a id="15840" class="Symbol">:</a> <a id="15842" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="15847" href="1Lab.Univalence.html#2837" class="Generalizable">ℓ</a><a id="15848" class="Symbol">}</a> <a id="15850" class="Symbol">→</a> <a data-type="A ≡ B → A ≃ B" id="15852" href="1Lab.Univalence.html#15463" class="Function">pathToEquiv</a> <a id="15864" class="Symbol">(</a><a data-type="x ≡ x" id="15865" href="1Lab.Path.html#2137" class="Function">refl</a> <a id="15870" class="Symbol">{</a><a id="15871" class="Argument">x</a> <a id="15873" class="Symbol">=</a> <a id="15875" href="1Lab.Univalence.html#15838" class="Bound">A</a><a id="15876" class="Symbol">})</a> <a data-type="A → A → Type ℓ" id="15879" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="15881" class="Symbol">(</a><a data-type="A → A" id="15882" href="1Lab.Type.html#2348" class="Function">id</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="15885" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="15887" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="15894" class="Symbol">)</a>
<a data-type="pathToEquiv refl ≡ (id , idEquiv)" id="15896" href="1Lab.Univalence.html#15818" class="Function">pathToEquiv-refl</a> <a id="15913" class="Symbol">{</a><a id="15914" class="Argument">A</a> <a id="15916" class="Symbol">=</a> <a id="15918" href="1Lab.Univalence.html#15918" class="Bound">A</a><a id="15919" class="Symbol">}</a> <a id="15921" class="Symbol">=</a>
  <a data-type="(p : x .fst ≡ y .fst) → subst B p (x .snd) ≡ y .snd → x ≡ y" id="15925" href="1Lab.Path.html#55595" class="Function">Σ-Path</a> <a id="15932" class="Symbol">(λ</a> <a id="15935" href="1Lab.Univalence.html#15935" class="Bound">i</a> <a id="15937" href="1Lab.Univalence.html#15937" class="Bound">x</a> <a id="15939" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) (i : I) → A i1 → A i" id="15941" href="1Lab.Path.html#49774" class="Function">coe1→i</a> <a id="15948" class="Symbol">(λ</a> <a id="15951" href="1Lab.Univalence.html#15951" class="Bound">i</a> <a id="15953" class="Symbol">→</a> <a id="15955" href="1Lab.Univalence.html#15918" class="Bound">A</a><a id="15956" class="Symbol">)</a> <a id="15958" href="1Lab.Univalence.html#15935" class="Bound">i</a> <a id="15960" href="1Lab.Univalence.html#15937" class="Bound">x</a><a id="15961" class="Symbol">)</a>
         <a id="15972" class="Symbol">(</a><a data-type="((i : I) → isProp (B i)) → (b0 : B i0) (b1 : B i1) → PathP B b0 b1" id="15973" href="1Lab.HLevel.html#13403" class="Function">isProp→PathP</a> <a id="15986" class="Symbol">(λ</a> <a id="15989" href="1Lab.Univalence.html#15989" class="Bound">i</a> <a id="15991" class="Symbol">→</a> <a data-type="(f : A → B) → isProp (isEquiv f)" id="15993" href="1Lab.Equiv.html#4883" class="Function">isProp-isEquiv</a> <a id="16008" class="Symbol">_)</a> <a id="16011" class="Symbol">_</a> <a id="16013" class="Symbol">_)</a>
</pre>
<p>For the other direction, we must show that <span class="Agda"><a data-type="A ≃ B → A ≡ B" href="1Lab.Univalence.html#8796" class="Function">ua</a></span> of <span class="Agda"><a data-type="isEquiv (λ x → x)" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a></span> is <span class="Agda"><a data-type="x ≡ x" href="1Lab.Path.html#2137" class="Function">refl</a></span>. We can do this quite efficiently using <span class="Agda"><a data-type="(A : Type ℓ) → Partial φ (Σ (λ T → T ≃ A)) → Type ℓ&#39;" href="1Lab.Univalence.html#3409" class="Function">Glue</a></span>. Since this is a path between paths, we have two interval variables.</p>
<pre class="Agda"><a id="uaIdEquiv"></a><a data-type="ua ((λ x → x) , idEquiv) ≡ refl" id="16245" href="1Lab.Univalence.html#16245" class="Function">uaIdEquiv</a> <a id="16255" class="Symbol">:</a> <a id="16257" class="Symbol">{</a><a id="16258" href="1Lab.Univalence.html#16258" class="Bound">A</a> <a id="16260" class="Symbol">:</a> <a id="16262" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="16267" href="1Lab.Univalence.html#2837" class="Generalizable">ℓ</a><a id="16268" class="Symbol">}</a> <a id="16270" class="Symbol">→</a> <a data-type="A ≃ B → A ≡ B" id="16272" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="16275" class="Symbol">(_</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="16278" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="16280" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a> <a id="16288" class="Symbol">{</a><a id="16289" class="Argument">A</a> <a id="16291" class="Symbol">=</a> <a id="16293" href="1Lab.Univalence.html#16258" class="Bound">A</a><a id="16294" class="Symbol">})</a> <a data-type="A → A → Type ℓ" id="16297" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="x ≡ x" id="16299" href="1Lab.Path.html#2137" class="Function">refl</a>
<a data-type="ua ((λ x → x) , idEquiv) ≡ refl" id="16304" href="1Lab.Univalence.html#16245" class="Function">uaIdEquiv</a> <a id="16314" class="Symbol">{</a><a id="16315" class="Argument">A</a> <a id="16317" class="Symbol">=</a> <a id="16319" href="1Lab.Univalence.html#16319" class="Bound">A</a><a id="16320" class="Symbol">}</a> <a id="16322" href="1Lab.Univalence.html#16322" class="Bound">i</a> <a id="16324" href="1Lab.Univalence.html#16324" class="Bound">j</a> <a id="16326" class="Symbol">=</a> <a data-type="(A : Type ℓ) → Partial φ (Σ (λ T → T ≃ A)) → Type ℓ&#39;" id="16328" href="1Lab.Univalence.html#3409" class="Function">Glue</a> <a id="16333" href="1Lab.Univalence.html#16319" class="Bound">A</a> <a id="16335" class="Symbol">{</a><a id="16336" class="Argument">φ</a> <a id="16338" class="Symbol">=</a> <a id="16340" href="1Lab.Univalence.html#16322" class="Bound">i</a> <a id="16342" href="1Lab.Path.html#765" class="Primitive Operator">∨</a> <a id="16344" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="16346" href="1Lab.Univalence.html#16324" class="Bound">j</a> <a id="16348" href="1Lab.Path.html#765" class="Primitive Operator">∨</a> <a id="16350" href="1Lab.Univalence.html#16324" class="Bound">j</a><a id="16351" class="Symbol">}</a> <a id="16353" class="Symbol">(λ</a> <a id="16356" href="1Lab.Univalence.html#16356" class="Bound">_</a> <a id="16358" class="Symbol">→</a> <a id="16360" href="1Lab.Univalence.html#16319" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="16362" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="16364" class="Symbol">_</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="16366" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="16368" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="16375" class="Symbol">)</a>
</pre>
<p>We can then prove that the map <span class="Agda"><a data-type="A ≡ B → A ≃ B" href="1Lab.Univalence.html#15463" class="Function">pathToEquiv</a></span> is an isomorphism, hence an equivalence. It’s very useful to have explicit names for the proofs that <span class="Agda"><a data-type="A ≡ B → A ≃ B" href="1Lab.Univalence.html#15463" class="Function">pathToEquiv</a></span> and <span class="Agda"><a data-type="A ≃ B → A ≡ B" href="1Lab.Univalence.html#8796" class="Function">ua</a></span> are equivalences without referring to components of <span class="Agda"><a data-type="Iso (A ≡ B) (A ≃ B)" href="1Lab.Univalence.html#16698" class="Function">univalence-Iso</a></span>, so we introduce names for them as well.</p>
<pre class="Agda"><a id="univalence-Iso"></a><a data-type="Iso (A ≡ B) (A ≃ B)" id="16698" href="1Lab.Univalence.html#16698" class="Function">univalence-Iso</a> <a id="16713" class="Symbol">:</a> <a id="16715" class="Symbol">{</a><a id="16716" href="1Lab.Univalence.html#16716" class="Bound">A</a> <a id="16718" href="1Lab.Univalence.html#16718" class="Bound">B</a> <a id="16720" class="Symbol">:</a> <a id="16722" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="16727" href="1Lab.Univalence.html#2837" class="Generalizable">ℓ</a><a id="16728" class="Symbol">}</a> <a id="16730" class="Symbol">→</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="16732" href="1Lab.Equiv.html#6241" class="Function">Iso</a> <a id="16736" class="Symbol">(</a><a id="16737" href="1Lab.Univalence.html#16716" class="Bound">A</a> <a data-type="A → A → Type ℓ" id="16739" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="16741" href="1Lab.Univalence.html#16718" class="Bound">B</a><a id="16742" class="Symbol">)</a> <a id="16744" class="Symbol">(</a><a id="16745" href="1Lab.Univalence.html#16716" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="16747" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="16749" href="1Lab.Univalence.html#16718" class="Bound">B</a><a id="16750" class="Symbol">)</a>
<a id="univalence"></a><a data-type="isEquiv pathToEquiv" id="16752" href="1Lab.Univalence.html#16752" class="Function">univalence</a>     <a id="16767" class="Symbol">:</a> <a id="16769" class="Symbol">{</a><a id="16770" href="1Lab.Univalence.html#16770" class="Bound">A</a> <a id="16772" href="1Lab.Univalence.html#16772" class="Bound">B</a> <a id="16774" class="Symbol">:</a> <a id="16776" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="16781" href="1Lab.Univalence.html#2837" class="Generalizable">ℓ</a><a id="16782" class="Symbol">}</a> <a id="16784" class="Symbol">→</a> <a data-type="(f : A → B) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="16786" href="1Lab.Equiv.html#2293" class="Record">isEquiv</a> <a id="16794" class="Symbol">(</a><a data-type="A ≡ B → A ≃ B" id="16795" href="1Lab.Univalence.html#15463" class="Function">pathToEquiv</a> <a id="16807" class="Symbol">{</a><a id="16808" class="Argument">A</a> <a id="16810" class="Symbol">=</a> <a id="16812" href="1Lab.Univalence.html#16770" class="Bound">A</a><a id="16813" class="Symbol">}</a> <a id="16815" class="Symbol">{</a><a id="16816" href="1Lab.Univalence.html#16772" class="Bound">B</a><a id="16817" class="Symbol">})</a>
<a id="univalence⁻¹"></a><a data-type="isEquiv ua" id="16820" href="1Lab.Univalence.html#16820" class="Function">univalence⁻¹</a>   <a id="16835" class="Symbol">:</a> <a id="16837" class="Symbol">{</a><a id="16838" href="1Lab.Univalence.html#16838" class="Bound">A</a> <a id="16840" href="1Lab.Univalence.html#16840" class="Bound">B</a> <a id="16842" class="Symbol">:</a> <a id="16844" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="16849" href="1Lab.Univalence.html#2837" class="Generalizable">ℓ</a><a id="16850" class="Symbol">}</a> <a id="16852" class="Symbol">→</a> <a data-type="(f : A → B) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="16854" href="1Lab.Equiv.html#2293" class="Record">isEquiv</a> <a id="16862" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="16863" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="16866" class="Symbol">{</a><a id="16867" class="Argument">A</a> <a id="16869" class="Symbol">=</a> <a id="16871" href="1Lab.Univalence.html#16838" class="Bound">A</a><a id="16872" class="Symbol">}</a> <a id="16874" class="Symbol">{</a><a id="16875" href="1Lab.Univalence.html#16840" class="Bound">B</a><a id="16876" class="Symbol">})</a>

<a data-type="Iso (A ≡ B) (A ≃ B)" id="16880" href="1Lab.Univalence.html#16698" class="Function">univalence-Iso</a> <a id="16895" class="Symbol">{</a><a id="16896" class="Argument">A</a> <a id="16898" class="Symbol">=</a> <a id="16900" href="1Lab.Univalence.html#16900" class="Bound">A</a><a id="16901" class="Symbol">}</a> <a id="16903" class="Symbol">{</a><a id="16904" class="Argument">B</a> <a id="16906" class="Symbol">=</a> <a id="16908" href="1Lab.Univalence.html#16908" class="Bound">B</a><a id="16909" class="Symbol">}</a> <a id="16911" class="Symbol">=</a> <a data-type="A ≡ B → A ≃ B" id="16913" href="1Lab.Univalence.html#15463" class="Function">pathToEquiv</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="16925" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="16927" href="1Lab.Univalence.html#16940" class="Function">iiso</a> <a id="16932" class="Keyword">where</a>
  <a id="16940" href="1Lab.Univalence.html#16940" class="Function">iiso</a> <a id="16945" class="Symbol">:</a> <a data-type="(f : A → B) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="16947" href="1Lab.Equiv.html#5975" class="Record">isIso</a> <a data-type="A ≡ B → A ≃ B" id="16953" href="1Lab.Univalence.html#15463" class="Function">pathToEquiv</a>
  <a id="16967" href="1Lab.Equiv.html#6080" class="Field">isIso.inv</a> <a id="16977" href="1Lab.Univalence.html#16940" class="Function">iiso</a> <a id="16982" class="Symbol">=</a> <a data-type="A ≃ B → A ≡ B" id="16984" href="1Lab.Univalence.html#8796" class="Function">ua</a>
</pre>
<p>We show that <code>pathToEquiv</code> inverts <span class="Agda"><a data-type="A ≃ B → A ≡ B" href="1Lab.Univalence.html#8796" class="Function">ua</a></span>, which means proving that one can recover the original equivalence from the generated path. Because of the computational nature of Cubical Agda, all we have to do is apply <span class="Agda"><a data-type="(f : A ≃ B) (x : A) → transport (ua f) x ≡ f .fst x" href="1Lab.Univalence.html#10955" class="Function">uaβ</a></span>:</p>
<pre class="Agda">  <a id="17236" href="1Lab.Equiv.html#6096" class="Field">isIso.rinv</a> <a id="17247" href="1Lab.Univalence.html#16940" class="Function">iiso</a> <a id="17252" class="Symbol">(</a><a id="17253" href="1Lab.Univalence.html#17253" class="Bound">f</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="17255" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17257" href="1Lab.Univalence.html#17257" class="Bound">isEqv</a><a id="17262" class="Symbol">)</a> <a id="17264" class="Symbol">=</a>
    <a data-type="(p : x .fst ≡ y .fst) → subst B p (x .snd) ≡ y .snd → x ≡ y" id="17270" href="1Lab.Path.html#55595" class="Function">Σ-Path</a> <a id="17277" class="Symbol">(</a><a data-type="((x : A) → f x ≡ g x) → f ≡ g" id="17278" href="1Lab.Path.html#56413" class="Function">funext</a> <a id="17285" class="Symbol">(</a><a data-type="(f : A ≃ B) (x : A) → transport (ua f) x ≡ f .fst x" id="17286" href="1Lab.Univalence.html#10955" class="Function">uaβ</a> <a id="17290" class="Symbol">(</a><a id="17291" href="1Lab.Univalence.html#17253" class="Bound">f</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="17293" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="17295" href="1Lab.Univalence.html#17257" class="Bound">isEqv</a><a id="17300" class="Symbol">)))</a> <a id="17304" class="Symbol">(</a><a data-type="(f : A → B) → isProp (isEquiv f)" id="17305" href="1Lab.Equiv.html#4883" class="Function">isProp-isEquiv</a> <a id="17320" href="1Lab.Univalence.html#17253" class="Bound">f</a> <a id="17322" class="Symbol">_</a> <a id="17324" class="Symbol">_)</a>
</pre>
<p>For the other direction, we use <a href="1Lab.Path.html#J">path induction</a> to reduce the problem from showing that <span class="Agda"><a data-type="A ≃ B → A ≡ B" href="1Lab.Univalence.html#8796" class="Function">ua</a></span> inverts <span class="Agda"><a data-type="A ≡ B → A ≃ B" href="1Lab.Univalence.html#15463" class="Function">pathToEquiv</a></span> for an arbitrary path (which is hard) to showing that <span class="Agda"><a data-type="A ≡ B → A ≃ B" href="1Lab.Univalence.html#15463" class="Function">pathToEquiv</a></span> takes <span class="Agda"><a data-type="x ≡ x" href="1Lab.Path.html#2137" class="Function">refl</a></span> to the identity equivalence (<span class="Agda"><a data-type="pathToEquiv refl ≡ (id , idEquiv)" href="1Lab.Univalence.html#15818" class="Function">pathToEquiv-refl</a></span>), and that <span class="Agda"><a data-type="A ≃ B → A ≡ B" href="1Lab.Univalence.html#8796" class="Function">ua</a></span> takes the identity equivalence to <span class="Agda"><a data-type="x ≡ x" href="1Lab.Path.html#2137" class="Function">refl</a></span> (<span class="Agda"><a data-type="ua ((λ x → x) , idEquiv) ≡ refl" href="1Lab.Univalence.html#16245" class="Function">uaIdEquiv</a></span>).</p>
<pre class="Agda">  <a id="17752" href="1Lab.Equiv.html#6128" class="Field">isIso.linv</a> <a id="17763" href="1Lab.Univalence.html#16940" class="Function">iiso</a> <a id="17768" class="Symbol">=</a> 
    <a data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" id="17775" href="1Lab.Path.html#18079" class="Function">J</a> <a id="17777" class="Symbol">(λ</a> <a id="17780" href="1Lab.Univalence.html#17780" class="Bound">_</a> <a id="17782" href="1Lab.Univalence.html#17782" class="Bound">p</a> <a id="17784" class="Symbol">→</a> <a data-type="A ≃ B → A ≡ B" id="17786" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="17789" class="Symbol">(</a><a data-type="A ≡ B → A ≃ B" id="17790" href="1Lab.Univalence.html#15463" class="Function">pathToEquiv</a> <a id="17802" href="1Lab.Univalence.html#17782" class="Bound">p</a><a id="17803" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="17805" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="17807" href="1Lab.Univalence.html#17782" class="Bound">p</a><a id="17808" class="Symbol">)</a>
      <a id="17816" class="Symbol">(</a><a data-type="(f : (x : A) → B x) (p : x ≡ y) → PathP (λ i → B (p i)) (f x) (f y)" id="17817" href="1Lab.Path.html#19262" class="Function">ap</a> <a data-type="A ≃ B → A ≡ B" id="17820" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a data-type="pathToEquiv refl ≡ (id , idEquiv)" id="17823" href="1Lab.Univalence.html#15818" class="Function">pathToEquiv-refl</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="17840" href="1Lab.Path.html#38031" class="Function Operator">∙</a> <a data-type="ua ((λ x → x) , idEquiv) ≡ refl" id="17842" href="1Lab.Univalence.html#16245" class="Function">uaIdEquiv</a><a id="17851" class="Symbol">)</a>

<a data-type="isEquiv pathToEquiv" id="17854" href="1Lab.Univalence.html#16752" class="Function">univalence</a> <a id="17865" class="Symbol">{</a><a id="17866" class="Argument">A</a> <a id="17868" class="Symbol">=</a> <a id="17870" href="1Lab.Univalence.html#17870" class="Bound">A</a><a id="17871" class="Symbol">}</a> <a id="17873" class="Symbol">{</a><a id="17874" href="1Lab.Univalence.html#17874" class="Bound">B</a><a id="17875" class="Symbol">}</a> <a id="17877" class="Symbol">=</a> <a data-type="(i : isIso f) → isEquiv f" id="17879" href="1Lab.Equiv.html#19765" class="Function">isIso→isEquiv</a> <a id="17893" class="Symbol">(</a><a data-type="Iso (A ≡ B) (A ≃ B)" id="17894" href="1Lab.Univalence.html#16698" class="Function">univalence-Iso</a> <a id="17909" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="17910" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="17913" class="Symbol">)</a>
<a data-type="isEquiv ua" id="17915" href="1Lab.Univalence.html#16820" class="Function">univalence⁻¹</a> <a id="17928" class="Symbol">{</a><a id="17929" class="Argument">A</a> <a id="17931" class="Symbol">=</a> <a id="17933" href="1Lab.Univalence.html#17933" class="Bound">A</a><a id="17934" class="Symbol">}</a> <a id="17936" class="Symbol">{</a><a id="17937" href="1Lab.Univalence.html#17937" class="Bound">B</a><a id="17938" class="Symbol">}</a> <a id="17940" class="Symbol">=</a> <a data-type="(i : isIso f) → isEquiv f" id="17942" href="1Lab.Equiv.html#19765" class="Function">isIso→isEquiv</a> <a id="17956" class="Symbol">(</a><a id="17957" href="1Lab.Equiv.html#6158" class="Function">isIso.inverse</a> <a id="17971" class="Symbol">(</a><a data-type="Iso (A ≡ B) (A ≃ B)" id="17972" href="1Lab.Univalence.html#16698" class="Function">univalence-Iso</a> <a id="17987" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="17988" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="17991" class="Symbol">))</a>
</pre>
<p>In some situations, it is helpful to have a proof that <span class="Agda"><a data-type="A ≡ B → A ≃ B" href="1Lab.Univalence.html#15463" class="Function">pathToEquiv</a></span> followed by <code class="sourceCode agda" data-ident="Lift">an adjustment of levels</code> is still an equivalence:</p>
<pre class="Agda"><a id="univalence-lift"></a><a data-type="isEquiv (λ e → lift (pathToEquiv e))" id="18165" href="1Lab.Univalence.html#18165" class="Function">univalence-lift</a> <a id="18181" class="Symbol">:</a> <a id="18183" class="Symbol">{</a><a id="18184" href="1Lab.Univalence.html#18184" class="Bound">A</a> <a id="18186" href="1Lab.Univalence.html#18186" class="Bound">B</a> <a id="18188" class="Symbol">:</a> <a id="18190" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="18195" href="1Lab.Univalence.html#2837" class="Generalizable">ℓ</a><a id="18196" class="Symbol">}</a> <a id="18198" class="Symbol">→</a> <a data-type="(f : A → B) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="18200" href="1Lab.Equiv.html#2293" class="Record">isEquiv</a> <a id="18208" class="Symbol">(λ</a> <a id="18211" href="1Lab.Univalence.html#18211" class="Bound">e</a> <a id="18213" class="Symbol">→</a> <a data-type="(lower : A) → Lift ℓ A" id="18215" href="1Lab.Type.html#2065" class="InductiveConstructor">lift</a> <a id="18220" class="Symbol">(</a><a data-type="A ≡ B → A ≃ B" id="18221" href="1Lab.Univalence.html#15463" class="Function">pathToEquiv</a> <a id="18233" class="Symbol">{</a><a id="18234" class="Argument">A</a> <a id="18236" class="Symbol">=</a> <a id="18238" href="1Lab.Univalence.html#18184" class="Bound">A</a><a id="18239" class="Symbol">}</a> <a id="18241" class="Symbol">{</a><a id="18242" href="1Lab.Univalence.html#18186" class="Bound">B</a><a id="18243" class="Symbol">}</a> <a id="18245" href="1Lab.Univalence.html#18211" class="Bound">e</a><a id="18246" class="Symbol">))</a>
<a data-type="isEquiv (λ e → lift (pathToEquiv e))" id="18249" href="1Lab.Univalence.html#18165" class="Function">univalence-lift</a> <a id="18265" class="Symbol">{</a><a id="18266" class="Argument">ℓ</a> <a id="18268" class="Symbol">=</a> <a id="18270" href="1Lab.Univalence.html#18270" class="Bound">ℓ</a><a id="18271" class="Symbol">}</a> <a id="18273" class="Symbol">=</a> <a data-type="(i : isIso f) → isEquiv f" id="18275" href="1Lab.Equiv.html#19765" class="Function">isIso→isEquiv</a> <a id="18289" href="1Lab.Univalence.html#18302" class="Function">morp</a> <a id="18294" class="Keyword">where</a>
  <a id="18302" href="1Lab.Univalence.html#18302" class="Function">morp</a> <a id="18307" class="Symbol">:</a> <a data-type="(f : A → B) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="18309" href="1Lab.Equiv.html#5975" class="Record">isIso</a> <a id="18315" class="Symbol">(λ</a> <a id="18318" href="1Lab.Univalence.html#18318" class="Bound">e</a> <a id="18320" class="Symbol">→</a> <a data-type="(lower : A) → Lift ℓ A" id="18322" href="1Lab.Type.html#2065" class="InductiveConstructor">lift</a> <a id="18327" class="Symbol">{</a><a id="18328" class="Argument">ℓ</a> <a id="18330" class="Symbol">=</a> <a data-type="Level → Level" id="18332" href="Agda.Primitive.html#780" class="Primitive">lsuc</a> <a id="18337" href="1Lab.Univalence.html#18270" class="Bound">ℓ</a><a id="18338" class="Symbol">}</a> <a id="18340" class="Symbol">(</a><a data-type="A ≡ B → A ≃ B" id="18341" href="1Lab.Univalence.html#15463" class="Function">pathToEquiv</a> <a id="18353" href="1Lab.Univalence.html#18318" class="Bound">e</a><a id="18354" class="Symbol">))</a>
  <a id="18359" href="1Lab.Univalence.html#18302" class="Function">morp</a> <a id="18364" class="Symbol">.</a><a id="18365" href="1Lab.Equiv.html#6080" class="Field">isIso.inv</a> <a id="18375" href="1Lab.Univalence.html#18375" class="Bound">x</a> <a id="18377" class="Symbol">=</a> <a data-type="A ≃ B → A ≡ B" id="18379" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="18382" class="Symbol">(</a><a id="18383" href="1Lab.Univalence.html#18375" class="Bound">x</a> <a id="18385" class="Symbol">.</a><a id="18386" href="1Lab.Type.html#2082" class="Field">Lift.lower</a><a id="18396" class="Symbol">)</a>
  <a id="18400" href="1Lab.Univalence.html#18302" class="Function">morp</a> <a id="18405" class="Symbol">.</a><a id="18406" href="1Lab.Equiv.html#6096" class="Field">isIso.rinv</a> <a id="18417" href="1Lab.Univalence.html#18417" class="Bound">x</a> <a id="18419" class="Symbol">=</a>
    <a data-type="(lower : A) → Lift ℓ A" id="18425" href="1Lab.Type.html#2065" class="InductiveConstructor">lift</a> <a id="18430" class="Symbol">(</a><a data-type="A ≡ B → A ≃ B" id="18431" href="1Lab.Univalence.html#15463" class="Function">pathToEquiv</a> <a id="18443" class="Symbol">(</a><a data-type="A ≃ B → A ≡ B" id="18444" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="18447" class="Symbol">(</a><a id="18448" href="1Lab.Univalence.html#18417" class="Bound">x</a> <a id="18450" class="Symbol">.</a><a id="18451" href="1Lab.Type.html#2082" class="Field">Lift.lower</a><a id="18461" class="Symbol">)))</a> <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="18465" href="1Lab.Path.html#45199" class="Function Operator">≡⟨</a> <a data-type="(f : (x : A) → B x) (p : x ≡ y) → PathP (λ i → B (p i)) (f x) (f y)" id="18468" href="1Lab.Path.html#19262" class="Function">ap</a> <a data-type="(lower : A) → Lift ℓ A" id="18471" href="1Lab.Type.html#2065" class="InductiveConstructor">lift</a> <a id="18476" class="Symbol">(</a><a data-type="Iso (A ≡ B) (A ≃ B)" id="18477" href="1Lab.Univalence.html#16698" class="Function">univalence-Iso</a> <a id="18492" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="18493" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="18497" class="Symbol">.</a><a id="18498" href="1Lab.Equiv.html#6096" class="Field">isIso.rinv</a> <a id="18509" class="Symbol">_)</a> <a data-type="(x : A) → x ≡ y → y ≡ z → x ≡ z" id="18512" href="1Lab.Path.html#45199" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≡</span></span>
    <a id="18518" href="1Lab.Univalence.html#18417" class="Bound">x</a>                                       <a data-type="(x : A) → x ≡ x" id="18558" href="1Lab.Path.html#45365" class="Function Operator">∎</a>
  <a id="18562" href="1Lab.Univalence.html#18302" class="Function">morp</a> <a id="18567" class="Symbol">.</a><a id="18568" href="1Lab.Equiv.html#6128" class="Field">isIso.linv</a> <a id="18579" href="1Lab.Univalence.html#18579" class="Bound">x</a> <a id="18581" class="Symbol">=</a> <a data-type="Iso (A ≡ B) (A ≃ B)" id="18583" href="1Lab.Univalence.html#16698" class="Function">univalence-Iso</a> <a id="18598" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="18599" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="18603" class="Symbol">.</a><a id="18604" href="1Lab.Equiv.html#6128" class="Field">isIso.linv</a> <a id="18615" class="Symbol">_</a>
</pre>
<h2 id="equivalence-induction"><a href="#equivalence-induction" class="header-link">Equivalence Induction<span class="header-link-emoji">🔗</span></a></h2>
<p>One useful consequence of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>≡</mo><mi>B</mi><mo stretchy="false">)</mo><mo>≃</mo><mo stretchy="false">(</mo><mi>A</mi><mo>≃</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A \equiv B) \simeq (A \simeq B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> is that the type of <em>equivalences</em> satisfies <a href="1Lab.Path.html#J">the same induction principle</a> as the type of <em>equalities</em>. By analogy with how path induction can be characterised as contractibility of singletons and transport, “equivalence induction” can be characterised as transport and contractibility of <em>singletons up to equivalence</em>:</p>
<pre class="Agda"><a id="EquivContr"></a><a data-type="(A : Type ℓ) → isContr (Σ (_≃_ A))" id="19094" href="1Lab.Univalence.html#19094" class="Function">EquivContr</a> <a id="19105" class="Symbol">:</a> <a id="19107" class="Symbol">∀</a> <a id="19109" class="Symbol">{</a><a id="19110" href="1Lab.Univalence.html#19110" class="Bound">ℓ</a><a id="19111" class="Symbol">}</a> <a id="19113" class="Symbol">(</a><a id="19114" href="1Lab.Univalence.html#19114" class="Bound">A</a> <a id="19116" class="Symbol">:</a> <a id="19118" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="19123" href="1Lab.Univalence.html#19110" class="Bound">ℓ</a><a id="19124" class="Symbol">)</a> <a id="19126" class="Symbol">→</a> <a data-type="(A : Type ℓ) → Type ℓ" id="19128" href="1Lab.HLevel.html#1328" class="Record">isContr</a> <a id="19136" class="Symbol">(</a><a data-type="(B : A → Type b) → Type (a ⊔ b)" id="19137" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="19140" href="1Lab.Univalence.html#19140" class="Bound">B</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="19142" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="19144" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="19149" href="1Lab.Univalence.html#19110" class="Bound">ℓ</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="19151" href="1Lab.Type.html#1563" class="Function">]</a> <a id="19153" href="1Lab.Univalence.html#19114" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="19155" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="19157" href="1Lab.Univalence.html#19140" class="Bound">B</a><a id="19158" class="Symbol">)</a>
<a data-type="isContr A → A" id="19160" href="1Lab.HLevel.html#1400" class="Field">isContr.centre</a> <a id="19175" class="Symbol">(</a><a data-type="(A : Type ℓ) → isContr (Σ (_≃_ A))" id="19176" href="1Lab.Univalence.html#19094" class="Function">EquivContr</a> <a id="19187" href="1Lab.Univalence.html#19187" class="Bound">A</a><a id="19188" class="Symbol">)</a>            <a id="19201" class="Symbol">=</a> <a id="19203" href="1Lab.Univalence.html#19187" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="19205" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="19207" class="Symbol">_</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="19209" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="19211" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a>
<a data-type="(r : isContr A) (x : A) → r .centre ≡ x" id="19219" href="1Lab.HLevel.html#1415" class="Field">isContr.paths</a> <a id="19233" class="Symbol">(</a><a data-type="(A : Type ℓ) → isContr (Σ (_≃_ A))" id="19234" href="1Lab.Univalence.html#19094" class="Function">EquivContr</a> <a id="19245" href="1Lab.Univalence.html#19245" class="Bound">A</a><a id="19246" class="Symbol">)</a> <a id="19248" class="Symbol">(</a><a id="19249" href="1Lab.Univalence.html#19249" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="19251" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="19253" href="1Lab.Univalence.html#19253" class="Bound">A≃B</a><a id="19256" class="Symbol">)</a> <a id="19258" href="1Lab.Univalence.html#19258" class="Bound">i</a> <a id="19260" class="Symbol">=</a> <a data-type="A ≃ B → A ≡ B" id="19262" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="19265" href="1Lab.Univalence.html#19253" class="Bound">A≃B</a> <a id="19269" href="1Lab.Univalence.html#19258" class="Bound">i</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="19271" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="19273" href="1Lab.Univalence.html#19291" class="Function">p</a> <a id="19275" href="1Lab.Univalence.html#19258" class="Bound">i</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="19277" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="19279" href="1Lab.Univalence.html#19410" class="Function">q</a> <a id="19281" href="1Lab.Univalence.html#19258" class="Bound">i</a> <a id="19283" class="Keyword">where</a>
  <a id="19291" href="1Lab.Univalence.html#19291" class="Function">p</a> <a id="19293" class="Symbol">:</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="19295" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="19301" class="Symbol">(λ</a> <a id="19304" href="1Lab.Univalence.html#19304" class="Bound">i</a> <a id="19306" class="Symbol">→</a> <a id="19308" href="1Lab.Univalence.html#19245" class="Bound">A</a> <a id="19310" class="Symbol">→</a> <a data-type="A ≃ B → A ≡ B" id="19312" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="19315" href="1Lab.Univalence.html#19253" class="Bound">A≃B</a> <a id="19319" href="1Lab.Univalence.html#19304" class="Bound">i</a><a id="19320" class="Symbol">)</a> <a data-type="A → A" id="19322" href="1Lab.Type.html#2348" class="Function">id</a> <a id="19325" class="Symbol">(</a><a id="19326" href="1Lab.Univalence.html#19253" class="Bound">A≃B</a> <a id="19330" class="Symbol">.</a><a data-type="∑ A B → A" id="19331" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="19334" class="Symbol">)</a>
  <a id="19338" href="1Lab.Univalence.html#19291" class="Function">p</a> <a id="19340" href="1Lab.Univalence.html#19340" class="Bound">i</a> <a id="19342" href="1Lab.Univalence.html#19342" class="Bound">x</a> <a id="19344" class="Symbol">=</a> <a id="19346" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="19351" class="Symbol">(</a><a data-type="(e : A ≃ B) (i : I) (x : Partial (~ i) A)
(y : B [ ~ i ↦ (λ { ((i = i0)) → e .fst (x _) }) ]) →
ua e i [ ~ i ∨ i ↦ (λ { ((i = i0)) → x _ ; ((i = i1)) → outS y }) ]" id="19352" href="1Lab.Univalence.html#13128" class="Function">ua-glue</a> <a id="19360" href="1Lab.Univalence.html#19253" class="Bound">A≃B</a> <a id="19364" href="1Lab.Univalence.html#19340" class="Bound">i</a> <a id="19366" class="Symbol">(λ</a> <a id="19369" class="Symbol">{</a> <a id="19371" class="Symbol">(</a><a id="19372" href="1Lab.Univalence.html#19340" class="Bound">i</a> <a id="19374" class="Symbol">=</a> <a data-type="I" id="19376" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="19378" class="Symbol">)</a> <a id="19380" class="Symbol">→</a> <a id="19382" href="1Lab.Univalence.html#19342" class="Bound">x</a> <a id="19384" class="Symbol">})</a> <a id="19387" class="Symbol">(</a><a id="19388" href="1Lab.Path.html#608" class="Postulate">inS</a> <a id="19392" class="Symbol">(</a><a id="19393" href="1Lab.Univalence.html#19253" class="Bound">A≃B</a> <a id="19397" class="Symbol">.</a><a data-type="∑ A B → A" id="19398" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="19402" href="1Lab.Univalence.html#19342" class="Bound">x</a><a id="19403" class="Symbol">)))</a>

  <a id="19410" href="1Lab.Univalence.html#19410" class="Function">q</a> <a id="19412" class="Symbol">:</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="19414" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="19420" class="Symbol">(λ</a> <a id="19423" href="1Lab.Univalence.html#19423" class="Bound">i</a> <a id="19425" class="Symbol">→</a> <a data-type="(f : A → B) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="19427" href="1Lab.Equiv.html#2293" class="Record">isEquiv</a> <a id="19435" class="Symbol">(</a><a id="19436" href="1Lab.Univalence.html#19291" class="Function">p</a> <a id="19438" href="1Lab.Univalence.html#19423" class="Bound">i</a><a id="19439" class="Symbol">))</a> <a data-type="isEquiv (λ x → x)" id="19442" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a> <a id="19450" class="Symbol">(</a><a id="19451" href="1Lab.Univalence.html#19253" class="Bound">A≃B</a> <a id="19455" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="19456" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="19459" class="Symbol">)</a>
  <a id="19463" href="1Lab.Univalence.html#19410" class="Function">q</a> <a id="19465" class="Symbol">=</a> <a data-type="((i : I) → isProp (B i)) → (b0 : B i0) (b1 : B i1) → PathP B b0 b1" id="19467" href="1Lab.HLevel.html#13403" class="Function">isProp→PathP</a> <a id="19480" class="Symbol">(λ</a> <a id="19483" href="1Lab.Univalence.html#19483" class="Bound">i</a> <a id="19485" class="Symbol">→</a> <a data-type="(f : A → B) → isProp (isEquiv f)" id="19487" href="1Lab.Equiv.html#4883" class="Function">isProp-isEquiv</a> <a id="19502" class="Symbol">(</a><a id="19503" href="1Lab.Univalence.html#19291" class="Function">p</a> <a id="19505" href="1Lab.Univalence.html#19483" class="Bound">i</a><a id="19506" class="Symbol">))</a> <a id="19509" class="Symbol">_</a> <a id="19511" class="Symbol">_</a>
</pre>
<p>Combining <span class="Agda"><a data-type="(A : Type ℓ) → isContr (Σ (_≃_ A))" href="1Lab.Univalence.html#19094" class="Function">EquivContr</a></span> with <span class="Agda"><a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" href="1Lab.Path.html#13853" class="Function">subst</a></span>, we get an induction principle for the type of equivalences based at <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>:</span> To prove <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo separator="true">,</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(B,e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span> for any <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>:</mo><mi>A</mi><mo>≃</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">e : A \simeq B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>,</span> it suffices to consider the case where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">e</span></span></span></span> is the identity equivalence.</p>
<pre class="Agda"><a id="EquivJ"></a><a data-type="(P : (B : Type ℓ) → A ≃ B → Type ℓ&#39;) →
P A ((λ x → x) , idEquiv) → (e : A ≃ B) → P B e" id="19782" href="1Lab.Univalence.html#19782" class="Function">EquivJ</a> <a id="19789" class="Symbol">:</a> <a id="19791" class="Symbol">∀</a> <a id="19793" class="Symbol">{</a><a id="19794" href="1Lab.Univalence.html#19794" class="Bound">ℓ</a> <a id="19796" href="1Lab.Univalence.html#19796" class="Bound">ℓ&#39;</a><a id="19798" class="Symbol">}</a> <a id="19800" class="Symbol">{</a><a id="19801" href="1Lab.Univalence.html#19801" class="Bound">A</a> <a id="19803" class="Symbol">:</a> <a id="19805" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="19810" href="1Lab.Univalence.html#19794" class="Bound">ℓ</a><a id="19811" class="Symbol">}</a>
       <a id="19820" class="Symbol">→</a> <a id="19822" class="Symbol">(</a><a id="19823" href="1Lab.Univalence.html#19823" class="Bound">P</a> <a id="19825" class="Symbol">:</a> <a id="19827" class="Symbol">(</a><a id="19828" href="1Lab.Univalence.html#19828" class="Bound">B</a> <a id="19830" class="Symbol">:</a> <a id="19832" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="19837" href="1Lab.Univalence.html#19794" class="Bound">ℓ</a><a id="19838" class="Symbol">)</a> <a id="19840" class="Symbol">→</a> <a id="19842" href="1Lab.Univalence.html#19801" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="19844" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="19846" href="1Lab.Univalence.html#19828" class="Bound">B</a> <a id="19848" class="Symbol">→</a> <a id="19850" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="19855" href="1Lab.Univalence.html#19796" class="Bound">ℓ&#39;</a><a id="19857" class="Symbol">)</a>
       <a id="19866" class="Symbol">→</a> <a id="19868" href="1Lab.Univalence.html#19823" class="Bound">P</a> <a id="19870" href="1Lab.Univalence.html#19801" class="Bound">A</a> <a id="19872" class="Symbol">(_</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="19875" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv (λ x → x)" id="19877" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a><a id="19884" class="Symbol">)</a>
       <a id="19893" class="Symbol">→</a> <a id="19895" class="Symbol">{</a><a id="19896" href="1Lab.Univalence.html#19896" class="Bound">B</a> <a id="19898" class="Symbol">:</a> <a id="19900" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="19905" href="1Lab.Univalence.html#19794" class="Bound">ℓ</a><a id="19906" class="Symbol">}</a> <a id="19908" class="Symbol">(</a><a id="19909" href="1Lab.Univalence.html#19909" class="Bound">e</a> <a id="19911" class="Symbol">:</a> <a id="19913" href="1Lab.Univalence.html#19801" class="Bound">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="19915" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="19917" href="1Lab.Univalence.html#19896" class="Bound">B</a><a id="19918" class="Symbol">)</a>
       <a id="19927" class="Symbol">→</a> <a id="19929" href="1Lab.Univalence.html#19823" class="Bound">P</a> <a id="19931" href="1Lab.Univalence.html#19896" class="Bound">B</a> <a id="19933" href="1Lab.Univalence.html#19909" class="Bound">e</a>
<a data-type="(P : (B : Type ℓ) → A ≃ B → Type ℓ&#39;) →
P A ((λ x → x) , idEquiv) → (e : A ≃ B) → P B e" id="19935" href="1Lab.Univalence.html#19782" class="Function">EquivJ</a> <a id="19942" href="1Lab.Univalence.html#19942" class="Bound">P</a> <a id="19944" href="1Lab.Univalence.html#19944" class="Bound">pid</a> <a id="19948" href="1Lab.Univalence.html#19948" class="Bound">eqv</a> <a id="19952" class="Symbol">=</a>
  <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="19956" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="19962" class="Symbol">(λ</a> <a id="19965" href="1Lab.Univalence.html#19965" class="Bound">e</a> <a id="19967" class="Symbol">→</a> <a id="19969" href="1Lab.Univalence.html#19942" class="Bound">P</a> <a id="19971" class="Symbol">(</a><a id="19972" href="1Lab.Univalence.html#19965" class="Bound">e</a> <a id="19974" class="Symbol">.</a><a data-type="∑ A B → A" id="19975" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="19978" class="Symbol">)</a> <a id="19980" class="Symbol">(</a><a id="19981" href="1Lab.Univalence.html#19965" class="Bound">e</a> <a id="19983" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="19984" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="19987" class="Symbol">))</a> <a id="19990" class="Symbol">(</a><a data-type="(A : Type ℓ) → isContr (Σ (_≃_ A))" id="19991" href="1Lab.Univalence.html#19094" class="Function">EquivContr</a> <a id="20002" class="Symbol">_</a> <a id="20004" class="Symbol">.</a><a data-type="(r : isContr A) (x : A) → r .centre ≡ x" id="20005" href="1Lab.HLevel.html#1415" class="Field">isContr.paths</a> <a id="20019" class="Symbol">(_</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="20022" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="20024" href="1Lab.Univalence.html#19948" class="Bound">eqv</a><a id="20027" class="Symbol">))</a> <a id="20030" href="1Lab.Univalence.html#19944" class="Bound">pid</a>
</pre>
<p>Equivalence induction simplifies the proofs of many properties about equivalences. For example, if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> is an equivalence, then so is its <span class="Agda"><a data-type="(f : (x : A) → B x) (p : x ≡ y) → PathP (λ i → B (p i)) (f x) (f y)" href="1Lab.Path.html#19262" class="Function">action on paths</a></span> <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{ap}(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">ap</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>.</span></p>
<pre class="Agda"><a id="isEquiv→isEmbedding"></a><a data-type="(f : A → B) → isEquiv f → isEquiv (ap f)" id="20288" href="1Lab.Univalence.html#20288" class="Function">isEquiv→isEmbedding</a> <a id="20308" class="Symbol">:</a> <a id="20310" class="Symbol">∀</a> <a id="20312" class="Symbol">{</a><a id="20313" href="1Lab.Univalence.html#20313" class="Bound">ℓ</a><a id="20314" class="Symbol">}</a> <a id="20316" class="Symbol">{</a><a id="20317" href="1Lab.Univalence.html#20317" class="Bound">A</a> <a id="20319" href="1Lab.Univalence.html#20319" class="Bound">B</a> <a id="20321" class="Symbol">:</a> <a id="20323" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="20328" href="1Lab.Univalence.html#20313" class="Bound">ℓ</a><a id="20329" class="Symbol">}</a>
                    <a id="20351" class="Symbol">→</a> <a id="20353" class="Symbol">(</a><a id="20354" href="1Lab.Univalence.html#20354" class="Bound">f</a> <a id="20356" class="Symbol">:</a> <a id="20358" href="1Lab.Univalence.html#20317" class="Bound">A</a> <a id="20360" class="Symbol">→</a> <a id="20362" href="1Lab.Univalence.html#20319" class="Bound">B</a><a id="20363" class="Symbol">)</a> <a id="20365" class="Symbol">→</a> <a data-type="(f : A → B) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="20367" href="1Lab.Equiv.html#2293" class="Record">isEquiv</a> <a id="20375" href="1Lab.Univalence.html#20354" class="Bound">f</a>
                    <a id="20397" class="Symbol">→</a> <a id="20399" class="Symbol">{</a><a id="20400" href="1Lab.Univalence.html#20400" class="Bound">x</a> <a id="20402" href="1Lab.Univalence.html#20402" class="Bound">y</a> <a id="20404" class="Symbol">:</a> <a id="20406" href="1Lab.Univalence.html#20317" class="Bound">A</a><a id="20407" class="Symbol">}</a>
                    <a id="20429" class="Symbol">→</a> <a data-type="(f : A → B) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="20431" href="1Lab.Equiv.html#2293" class="Record">isEquiv</a> <a id="20439" class="Symbol">(</a><a data-type="(f : (x : A) → B x) (p : x ≡ y) → PathP (λ i → B (p i)) (f x) (f y)" id="20440" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="20443" href="1Lab.Univalence.html#20354" class="Bound">f</a> <a id="20445" class="Symbol">{</a><a id="20446" class="Argument">x</a> <a id="20448" class="Symbol">=</a> <a id="20450" href="1Lab.Univalence.html#20400" class="Bound">x</a><a id="20451" class="Symbol">}</a> <a id="20453" class="Symbol">{</a><a id="20454" class="Argument">y</a> <a id="20456" class="Symbol">=</a> <a id="20458" href="1Lab.Univalence.html#20402" class="Bound">y</a><a id="20459" class="Symbol">})</a>
<a data-type="(f : A → B) → isEquiv f → isEquiv (ap f)" id="20462" href="1Lab.Univalence.html#20288" class="Function">isEquiv→isEmbedding</a> <a id="20482" href="1Lab.Univalence.html#20482" class="Bound">f</a> <a id="20484" href="1Lab.Univalence.html#20484" class="Bound">eqv</a> <a id="20488" class="Symbol">=</a>
  <a data-type="(P : (B : Type ℓ) → A ≃ B → Type ℓ&#39;) →
P A ((λ x → x) , idEquiv) → (e : A ≃ B) → P B e" id="20492" href="1Lab.Univalence.html#19782" class="Function">EquivJ</a> <a id="20499" class="Symbol">(λ</a> <a id="20502" href="1Lab.Univalence.html#20502" class="Bound">B</a> <a id="20504" href="1Lab.Univalence.html#20504" class="Bound">e</a> <a id="20506" class="Symbol">→</a> <a data-type="(f : A → B) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="20508" href="1Lab.Equiv.html#2293" class="Record">isEquiv</a> <a id="20516" class="Symbol">(</a><a data-type="(f : (x : A) → B x) (p : x ≡ y) → PathP (λ i → B (p i)) (f x) (f y)" id="20517" href="1Lab.Path.html#19262" class="Function">ap</a> <a id="20520" class="Symbol">(</a><a id="20521" href="1Lab.Univalence.html#20504" class="Bound">e</a> <a id="20523" class="Symbol">.</a><a data-type="∑ A B → A" id="20524" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="20527" class="Symbol">)))</a> <a data-type="isEquiv (λ x → x)" id="20531" href="1Lab.Equiv.html#2526" class="Function">idEquiv</a> <a id="20539" class="Symbol">(</a><a id="20540" href="1Lab.Univalence.html#20482" class="Bound">f</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="20542" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="20544" href="1Lab.Univalence.html#20484" class="Bound">eqv</a><a id="20547" class="Symbol">)</a>
</pre>
<p>The proof can be rendered in English roughly as follows:</p>
<blockquote>
<p>Suppose <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">f : A \to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> <span class="Agda"><a data-type="(f : A → B) → Type (A.ℓ₁ ⊔ B.ℓ₁)" href="1Lab.Equiv.html#2293" class="Record">is an equivalence</a></span>. We want to show that, for any choice of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">x, y : A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>,</span> the map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi></mrow><mo stretchy="false">(</mo><mi>f</mi><msub><mo stretchy="false">)</mo><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow></msub><mo>:</mo><mi>x</mi><mo>≡</mo><mi>y</mi><mo>→</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>≡</mo><mi>f</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{ap}(f)_{x,y} : x \equiv y \to f(x) \equiv f(y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathrm">ap</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> is an equivalence.</p>
<p>By <span class="Agda"><a data-type="(P : (B : Type ℓ) → A ≃ B → Type ℓ&#39;) →
P A ((λ x → x) , idEquiv) → (e : A ≃ B) → P B e" href="1Lab.Univalence.html#19782" class="Function">induction</a></span>, it suffices to cover the case where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> is <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>,</span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> is the identity function.</p>
<p>But then, we have that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">a</mi><mi mathvariant="normal">p</mi></mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{ap}(\mathrm{id})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathrm">ap</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">id</span></span><span class="mclose">)</span></span></span></span> is <a href="1Lab.Path.html#ap-id">definitionally equal</a> to <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><annotation encoding="application/x-tex">\mathrm{id}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">id</span></span></span></span></span>,</span> which is known to be <span class="Agda"><a data-type="isEquiv (λ x → x)" href="1Lab.Equiv.html#2526" class="Function">an equivalence</a></span>. <span class="qed"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">■</mi></mrow><annotation encoding="application/x-tex">\blacksquare</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.675em;"></span><span class="mord amsrm">■</span></span></span></span></span></p>
</blockquote>
<h2 id="object-classifiers"><a href="#object-classifiers" class="header-link">Object Classifiers<span class="header-link-emoji">🔗</span></a></h2>
<p>In category theory, the idea of <em>classifiers</em> (or <em>classifying objects</em>) often comes up when categories applied to the study of logic. For example, any <a href="https://ncatlab.org/nlab/show/topos#ElementaryTopos">elementary topos</a> has a <em><a href="https://ncatlab.org/nlab/show/subobject+classifier">subobject classifier</a></em>: an object <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Ω</span></span></span></span> such that maps <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>→</mo><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">B \to \Omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Ω</span></span></span></span> corresponds to maps <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> with propositional fibres (equivalently, inclusions <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>↪</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A \hookrightarrow B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6943em;vertical-align:-0.011em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">↪</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>).</span> In higher categorical analyses of logic, classifying objects exist for more maps: an elementary <strong>2</strong>-topos has a <a href="https://ncatlab.org/nlab/show/discrete+object+classifier">discrete object classifier</a>, which classify maps with <em>discrete</em> fibres.</p>
<p>Since a <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>-topos</span> has classifiers for maps with <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>-truncated</span> fibres, and a <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(2,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>-topos</span> has classifiers for maps with <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>-truncated</span> fibres, one might expect that an <a href="https://ncatlab.org/nlab/show/(infinity,1)-topos"><span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">∞</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\io</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">∞</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>-topos</span></a> would have classifiers for maps with fibres that are not truncated at all. This is indeed the case! In HoTT, this fact is internalised using the univalent universes, and we can prove that univalent universes are <a href="https://ncatlab.org/nlab/show/object+classifier"><em>object classifiers</em></a>.</p>
<!--
<pre class="Agda"><a id="22535" class="Keyword">private</a> <a id="22543" class="Keyword">variable</a>
  <a id="22554" href="1Lab.Univalence.html#22554" class="Generalizable">A</a> <a id="22556" href="1Lab.Univalence.html#22556" class="Generalizable">B</a> <a id="22558" href="1Lab.Univalence.html#22558" class="Generalizable">E</a> <a id="22560" class="Symbol">:</a> <a id="22562" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="22567" href="1Lab.Univalence.html#2837" class="Generalizable">ℓ</a>
<a id="22569" class="Keyword">open</a> <a id="22574" href="1Lab.Equiv.html#5975" class="Module">isIso</a>
</pre>-->
<p>As an intermediate step, we prove that the value <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B(a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span> of a type family <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> at a point <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> is equivalent to the fibre of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">f</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi></mrow><mo>:</mo><msub><mi mathvariant="normal">Σ</mi><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></msub><mi>B</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\mathrm{fst} : \Sigma_{(x : A)}B(x) \to A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">fst</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3552em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mrel mtight">:</span><span class="mord mathnormal mtight">A</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> over <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span>.</span> The proof follows from the De Morgan structure on the interval, and the “spread” operation <span class="Agda"><a data-type="(A : I → Type ℓ) (i : I) → A i1 → A i" href="1Lab.Path.html#49774" class="Function">coe1→i</a></span>.</p>
<pre class="Agda"><a id="22882" class="Comment">-- HoTT book lemma 4.8.1</a>
<a id="Fibre-equiv"></a><a data-type="(B : A → Type ℓ&#39;) (a : A) → fibre fst a ≃ B a" id="22907" href="1Lab.Univalence.html#22907" class="Function">Fibre-equiv</a> <a id="22919" class="Symbol">:</a> <a id="22921" class="Symbol">(</a><a id="22922" href="1Lab.Univalence.html#22922" class="Bound">B</a> <a id="22924" class="Symbol">:</a> <a id="22926" href="1Lab.Univalence.html#22554" class="Generalizable">A</a> <a id="22928" class="Symbol">→</a> <a id="22930" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="22935" href="1Lab.Univalence.html#2839" class="Generalizable">ℓ&#39;</a><a id="22937" class="Symbol">)</a> <a id="22939" class="Symbol">(</a><a id="22940" href="1Lab.Univalence.html#22940" class="Bound">a</a> <a id="22942" class="Symbol">:</a> <a id="22944" href="1Lab.Univalence.html#22554" class="Generalizable">A</a><a id="22945" class="Symbol">)</a>
            <a id="22959" class="Symbol">→</a> <a data-type="(A → B) → B → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="22961" href="1Lab.Equiv.html#1881" class="Function">fibre</a> <a id="22967" class="Symbol">(</a><a data-type="∑ A B → A" id="22968" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="22972" class="Symbol">{</a><a id="22973" class="Argument">B</a> <a id="22975" class="Symbol">=</a> <a id="22977" href="1Lab.Univalence.html#22922" class="Bound">B</a><a id="22978" class="Symbol">})</a> <a id="22981" href="1Lab.Univalence.html#22940" class="Bound">a</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="22983" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="22985" href="1Lab.Univalence.html#22922" class="Bound">B</a> <a id="22987" href="1Lab.Univalence.html#22940" class="Bound">a</a>
<a data-type="(B : A → Type ℓ&#39;) (a : A) → fibre fst a ≃ B a" id="22989" href="1Lab.Univalence.html#22907" class="Function">Fibre-equiv</a> <a id="23001" href="1Lab.Univalence.html#23001" class="Bound">B</a> <a id="23003" href="1Lab.Univalence.html#23003" class="Bound">a</a> <a id="23005" class="Symbol">=</a> <a data-type="Iso A B → A ≃ B" id="23007" href="1Lab.Equiv.html#20090" class="Function">Iso→Equiv</a> <a id="23017" href="1Lab.Univalence.html#23030" class="Function">isom</a> <a id="23022" class="Keyword">where</a>
  <a id="23030" href="1Lab.Univalence.html#23030" class="Function">isom</a> <a id="23035" class="Symbol">:</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="23037" href="1Lab.Equiv.html#6241" class="Function">Iso</a> <a id="23041" class="Symbol">_</a> <a id="23043" class="Symbol">_</a>
  <a id="23047" href="1Lab.Univalence.html#23030" class="Function">isom</a> <a id="23052" class="Symbol">.</a><a data-type="∑ A B → A" id="23053" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="23057" class="Symbol">((</a><a id="23059" href="1Lab.Univalence.html#23059" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="23061" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23063" href="1Lab.Univalence.html#23063" class="Bound">y</a><a id="23064" class="Symbol">)</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="23066" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23068" href="1Lab.Univalence.html#23068" class="Bound">p</a><a id="23069" class="Symbol">)</a> <a id="23071" class="Symbol">=</a> <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="23073" href="1Lab.Path.html#13853" class="Function">subst</a> <a id="23079" href="1Lab.Univalence.html#23001" class="Bound">B</a> <a id="23081" href="1Lab.Univalence.html#23068" class="Bound">p</a> <a id="23083" href="1Lab.Univalence.html#23063" class="Bound">y</a>
  <a id="23087" href="1Lab.Univalence.html#23030" class="Function">isom</a> <a id="23092" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="23093" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="23097" class="Symbol">.</a><a id="23098" href="1Lab.Equiv.html#6080" class="Field">inv</a> <a id="23102" href="1Lab.Univalence.html#23102" class="Bound">x</a>        <a id="23111" class="Symbol">=</a> <a id="23113" class="Symbol">(</a><a id="23114" href="1Lab.Univalence.html#23003" class="Bound">a</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="23116" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23118" href="1Lab.Univalence.html#23102" class="Bound">x</a><a id="23119" class="Symbol">)</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="23121" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="x ≡ x" id="23123" href="1Lab.Path.html#2137" class="Function">refl</a>
  <a id="23130" href="1Lab.Univalence.html#23030" class="Function">isom</a> <a id="23135" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="23136" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="23140" class="Symbol">.</a><a id="23141" href="1Lab.Equiv.html#6096" class="Field">rinv</a> <a id="23146" href="1Lab.Univalence.html#23146" class="Bound">x</a> <a id="23148" href="1Lab.Univalence.html#23148" class="Bound">i</a>     <a id="23154" class="Symbol">=</a> <a data-type="(A : I → Type ℓ) (i : I) → A i1 → A i" id="23156" href="1Lab.Path.html#49774" class="Function">coe1→i</a> <a id="23163" class="Symbol">(λ</a> <a id="23166" href="1Lab.Univalence.html#23166" class="Bound">_</a> <a id="23168" class="Symbol">→</a> <a id="23170" href="1Lab.Univalence.html#23001" class="Bound">B</a> <a id="23172" href="1Lab.Univalence.html#23003" class="Bound">a</a><a id="23173" class="Symbol">)</a> <a id="23175" href="1Lab.Univalence.html#23148" class="Bound">i</a> <a id="23177" href="1Lab.Univalence.html#23146" class="Bound">x</a>
  <a id="23181" href="1Lab.Univalence.html#23030" class="Function">isom</a> <a id="23186" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="23187" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="23191" class="Symbol">.</a><a id="23192" href="1Lab.Equiv.html#6128" class="Field">linv</a> <a id="23197" class="Symbol">((</a><a id="23199" href="1Lab.Univalence.html#23199" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="23201" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23203" href="1Lab.Univalence.html#23203" class="Bound">y</a><a id="23204" class="Symbol">)</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="23206" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23208" href="1Lab.Univalence.html#23208" class="Bound">p</a><a id="23209" class="Symbol">)</a> <a id="23211" href="1Lab.Univalence.html#23211" class="Bound">i</a> <a id="23213" class="Symbol">=</a>
    <a id="23219" class="Symbol">(</a><a id="23220" href="1Lab.Univalence.html#23208" class="Bound">p</a> <a id="23222" class="Symbol">(</a><a id="23223" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="23225" href="1Lab.Univalence.html#23211" class="Bound">i</a><a id="23226" class="Symbol">)</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="23228" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="(A : I → Type ℓ) (i : I) → A i1 → A i" id="23230" href="1Lab.Path.html#49774" class="Function">coe1→i</a> <a id="23237" class="Symbol">(λ</a> <a id="23240" href="1Lab.Univalence.html#23240" class="Bound">j</a> <a id="23242" class="Symbol">→</a> <a id="23244" href="1Lab.Univalence.html#23001" class="Bound">B</a> <a id="23246" class="Symbol">(</a><a id="23247" href="1Lab.Univalence.html#23208" class="Bound">p</a> <a id="23249" class="Symbol">(</a><a id="23250" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="23252" href="1Lab.Univalence.html#23211" class="Bound">i</a> <a id="23254" href="1Lab.Path.html#730" class="Primitive Operator">∧</a> <a id="23256" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="23258" href="1Lab.Univalence.html#23240" class="Bound">j</a><a id="23259" class="Symbol">)))</a> <a id="23263" href="1Lab.Univalence.html#23211" class="Bound">i</a> <a id="23265" href="1Lab.Univalence.html#23203" class="Bound">y</a><a id="23266" class="Symbol">)</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="23268" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23270" class="Symbol">λ</a> <a id="23272" href="1Lab.Univalence.html#23272" class="Bound">j</a> <a id="23274" class="Symbol">→</a> <a id="23276" href="1Lab.Univalence.html#23208" class="Bound">p</a> <a id="23278" class="Symbol">(</a><a id="23279" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="23281" href="1Lab.Univalence.html#23211" class="Bound">i</a> <a id="23283" href="1Lab.Path.html#765" class="Primitive Operator">∨</a> <a id="23285" href="1Lab.Univalence.html#23272" class="Bound">j</a><a id="23286" class="Symbol">)</a>
</pre>
<p>Another fact from homotopy theory that we can import into homotopy <em>type</em> theory is that any map is equivalent to a fibration. More specifically, given a map <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>:</mo><mi>E</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">p : E \to B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>,</span> the total space <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> is equivalent to the dependent sum of the fibres. The theorems <span class="Agda"><a data-type="(p : E → B) → E ≃ Σ (fibre p)" href="1Lab.Univalence.html#23681" class="Function">Total-equiv</a></span> and <span class="Agda"><a data-type="(B : A → Type ℓ&#39;) (a : A) → fibre fst a ≃ B a" href="1Lab.Univalence.html#22907" class="Function">Fibre-equiv</a></span> are what justify referring to <span class="Agda"><a data-type="(B : A → Type b) → Type (a ⊔ b)" href="1Lab.Type.html#1563" class="Function">Σ</a></span> the “total space” of a type family.</p>
<pre class="Agda"><a id="Total-equiv"></a><a data-type="(p : E → B) → E ≃ Σ (fibre p)" id="23681" href="1Lab.Univalence.html#23681" class="Function">Total-equiv</a> <a id="23693" class="Symbol">:</a> <a id="23695" class="Symbol">(</a><a id="23696" href="1Lab.Univalence.html#23696" class="Bound">p</a> <a id="23698" class="Symbol">:</a> <a id="23700" href="1Lab.Univalence.html#22558" class="Generalizable">E</a> <a id="23702" class="Symbol">→</a> <a id="23704" href="1Lab.Univalence.html#22556" class="Generalizable">B</a><a id="23705" class="Symbol">)</a> <a id="23707" class="Symbol">→</a> <a id="23709" href="1Lab.Univalence.html#22558" class="Generalizable">E</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="23711" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="23713" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="23715" class="Symbol">(</a><a data-type="(A → B) → B → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="23716" href="1Lab.Equiv.html#1881" class="Function">fibre</a> <a id="23722" href="1Lab.Univalence.html#23696" class="Bound">p</a><a id="23723" class="Symbol">)</a>
<a data-type="(p : E → B) → E ≃ Σ (fibre p)" id="23725" href="1Lab.Univalence.html#23681" class="Function">Total-equiv</a> <a id="23737" href="1Lab.Univalence.html#23737" class="Bound">p</a> <a id="23739" class="Symbol">=</a> <a data-type="Iso A B → A ≃ B" id="23741" href="1Lab.Equiv.html#20090" class="Function">Iso→Equiv</a> <a id="23751" href="1Lab.Univalence.html#23764" class="Function">isom</a> <a id="23756" class="Keyword">where</a>
  <a id="23764" href="1Lab.Univalence.html#23764" class="Function">isom</a> <a id="23769" class="Symbol">:</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="23771" href="1Lab.Equiv.html#6241" class="Function">Iso</a> <a id="23775" class="Symbol">_</a> <a id="23777" class="Symbol">(</a><a data-type="(B : A → Type b) → Type (a ⊔ b)" id="23778" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="23780" class="Symbol">(</a><a data-type="(A → B) → B → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="23781" href="1Lab.Equiv.html#1881" class="Function">fibre</a> <a id="23787" href="1Lab.Univalence.html#23737" class="Bound">p</a><a id="23788" class="Symbol">))</a>
  <a id="23793" href="1Lab.Univalence.html#23764" class="Function">isom</a> <a id="23798" class="Symbol">.</a><a data-type="∑ A B → A" id="23799" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="23803" href="1Lab.Univalence.html#23803" class="Bound">x</a>                   <a id="23823" class="Symbol">=</a> <a id="23825" href="1Lab.Univalence.html#23737" class="Bound">p</a> <a id="23827" href="1Lab.Univalence.html#23803" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="23829" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23831" href="1Lab.Univalence.html#23803" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="23833" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="x ≡ x" id="23835" href="1Lab.Path.html#2137" class="Function">refl</a>
  <a id="23842" href="1Lab.Univalence.html#23764" class="Function">isom</a> <a id="23847" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="23848" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="23852" class="Symbol">.</a><a id="23853" href="1Lab.Equiv.html#6080" class="Field">inv</a> <a id="23857" class="Symbol">(_</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="23860" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23862" href="1Lab.Univalence.html#23862" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="23864" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23866" class="Symbol">_)</a>    <a id="23872" class="Symbol">=</a> <a id="23874" href="1Lab.Univalence.html#23862" class="Bound">x</a>
  <a id="23878" href="1Lab.Univalence.html#23764" class="Function">isom</a> <a id="23883" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="23884" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="23888" class="Symbol">.</a><a id="23889" href="1Lab.Equiv.html#6096" class="Field">rinv</a> <a id="23894" class="Symbol">(</a><a id="23895" href="1Lab.Univalence.html#23895" class="Bound">b</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="23897" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23899" href="1Lab.Univalence.html#23899" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="23901" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23903" href="1Lab.Univalence.html#23903" class="Bound">q</a><a id="23904" class="Symbol">)</a> <a id="23906" href="1Lab.Univalence.html#23906" class="Bound">i</a> <a id="23908" class="Symbol">=</a> <a id="23910" href="1Lab.Univalence.html#23903" class="Bound">q</a> <a id="23912" href="1Lab.Univalence.html#23906" class="Bound">i</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="23914" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23916" href="1Lab.Univalence.html#23899" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="23918" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="23920" class="Symbol">λ</a> <a id="23922" href="1Lab.Univalence.html#23922" class="Bound">j</a> <a id="23924" class="Symbol">→</a> <a id="23926" href="1Lab.Univalence.html#23903" class="Bound">q</a> <a id="23928" class="Symbol">(</a><a id="23929" href="1Lab.Univalence.html#23906" class="Bound">i</a> <a id="23931" href="1Lab.Path.html#730" class="Primitive Operator">∧</a> <a id="23933" href="1Lab.Univalence.html#23922" class="Bound">j</a><a id="23934" class="Symbol">)</a>
  <a id="23938" href="1Lab.Univalence.html#23764" class="Function">isom</a> <a id="23943" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="23944" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="23948" class="Symbol">.</a><a id="23949" href="1Lab.Equiv.html#6128" class="Field">linv</a> <a id="23954" href="1Lab.Univalence.html#23954" class="Bound">x</a>             <a id="23968" class="Symbol">=</a> <a data-type="x ≡ x" id="23970" href="1Lab.Path.html#2137" class="Function">refl</a>
</pre>
<p>Putting these together, we get the promised theorem: The space of maps <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>→</mo><mrow><mi mathvariant="normal">T</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi></mrow></mrow><annotation encoding="application/x-tex">B \to \ty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">Type</span></span></span></span></span> is equivalent to the space of fibrations with base space <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> and variable total space <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>,</span> <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Σ</mi><mrow><mo stretchy="false">(</mo><mi>E</mi><mo>:</mo><mrow><mi mathvariant="normal">T</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi></mrow><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">(</mo><mi>E</mi><mo>→</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Sigma_{(E : \ty)} (E \to B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3552em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span><span class="mrel mtight">:</span><span class="mord mtight"><span class="mord mathrm mtight">Type</span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>.</span> If we allow <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> to live in different universes, then the maps are classified by the biggest universe in which they both fit, namely <code>Type (ℓ ⊔ ℓ&#39;)</code>. Note that the proof of <span class="Agda"><a data-type="Σ (λ E → E → B) ≃ (B → Type (ℓ ⊔ ℓ&#39;))" href="1Lab.Univalence.html#24606" class="Function">Fibration-equiv</a></span> makes fundamental use of <span class="Agda"><a data-type="A ≃ B → A ≡ B" href="1Lab.Univalence.html#8796" class="Function">ua</a></span>, to construct the witnesses that taking fibres and taking total spaces are inverses. Without <span class="Agda"><a data-type="A ≃ B → A ≡ B" href="1Lab.Univalence.html#8796" class="Function">ua</a></span>, we could only get an “isomorphism-up-to-equivalence” of types.</p>
<pre class="Agda"><a id="Fibration-equiv"></a><a data-type="Σ (λ E → E → B) ≃ (B → Type (ℓ ⊔ ℓ&#39;))" id="24606" href="1Lab.Univalence.html#24606" class="Function">Fibration-equiv</a> <a id="24622" class="Symbol">:</a> <a id="24624" class="Symbol">∀</a> <a id="24626" class="Symbol">{</a><a id="24627" href="1Lab.Univalence.html#24627" class="Bound">ℓ</a> <a id="24629" href="1Lab.Univalence.html#24629" class="Bound">ℓ&#39;</a><a id="24631" class="Symbol">}</a> <a id="24633" class="Symbol">{</a><a id="24634" href="1Lab.Univalence.html#24634" class="Bound">B</a> <a id="24636" class="Symbol">:</a> <a id="24638" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="24643" href="1Lab.Univalence.html#24627" class="Bound">ℓ</a><a id="24644" class="Symbol">}</a>
                <a id="24662" class="Symbol">→</a> <a id="24664" class="Symbol">(</a><a data-type="(B : A → Type b) → Type (a ⊔ b)" id="24665" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="24668" href="1Lab.Univalence.html#24668" class="Bound">E</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="24670" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="24672" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="24677" class="Symbol">(</a><a id="24678" href="1Lab.Univalence.html#24627" class="Bound">ℓ</a> <a data-type="Level → Level → Level" id="24680" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="24682" href="1Lab.Univalence.html#24629" class="Bound">ℓ&#39;</a><a id="24684" class="Symbol">)</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="24686" href="1Lab.Type.html#1563" class="Function">]</a> <a id="24688" class="Symbol">(</a><a id="24689" href="1Lab.Univalence.html#24668" class="Bound">E</a> <a id="24691" class="Symbol">→</a> <a id="24693" href="1Lab.Univalence.html#24634" class="Bound">B</a><a id="24694" class="Symbol">))</a>
                <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="24713" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="24715" class="Symbol">(</a><a id="24716" href="1Lab.Univalence.html#24634" class="Bound">B</a> <a id="24718" class="Symbol">→</a> <a id="24720" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="24725" class="Symbol">(</a><a id="24726" href="1Lab.Univalence.html#24627" class="Bound">ℓ</a> <a data-type="Level → Level → Level" id="24728" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="24730" href="1Lab.Univalence.html#24629" class="Bound">ℓ&#39;</a><a id="24732" class="Symbol">))</a>
<a data-type="Σ (λ E → E → B) ≃ (B → Type (ℓ ⊔ ℓ&#39;))" id="24735" href="1Lab.Univalence.html#24606" class="Function">Fibration-equiv</a> <a id="24751" class="Symbol">{</a><a id="24752" class="Argument">B</a> <a id="24754" class="Symbol">=</a> <a id="24756" href="1Lab.Univalence.html#24756" class="Bound">B</a><a id="24757" class="Symbol">}</a> <a id="24759" class="Symbol">=</a> <a data-type="Iso A B → A ≃ B" id="24761" href="1Lab.Equiv.html#20090" class="Function">Iso→Equiv</a> <a id="24771" href="1Lab.Univalence.html#24784" class="Function">isom</a> <a id="24776" class="Keyword">where</a>
  <a id="24784" href="1Lab.Univalence.html#24784" class="Function">isom</a> <a id="24789" class="Symbol">:</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="24791" href="1Lab.Equiv.html#6241" class="Function">Iso</a> <a id="24795" class="Symbol">(</a><a data-type="(B : A → Type b) → Type (a ⊔ b)" id="24796" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="24799" href="1Lab.Univalence.html#24799" class="Bound">E</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="24801" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="24803" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="24808" class="Symbol">_</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="24810" href="1Lab.Type.html#1563" class="Function">]</a> <a id="24812" class="Symbol">(</a><a id="24813" href="1Lab.Univalence.html#24799" class="Bound">E</a> <a id="24815" class="Symbol">→</a> <a id="24817" href="1Lab.Univalence.html#24756" class="Bound">B</a><a id="24818" class="Symbol">))</a> <a id="24821" class="Symbol">(</a><a id="24822" href="1Lab.Univalence.html#24756" class="Bound">B</a> <a id="24824" class="Symbol">→</a> <a id="24826" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="24831" class="Symbol">_)</a>
  <a id="24836" href="1Lab.Univalence.html#24784" class="Function">isom</a> <a id="24841" class="Symbol">.</a><a data-type="∑ A B → A" id="24842" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="24846" class="Symbol">(</a><a id="24847" href="1Lab.Univalence.html#24847" class="Bound">E</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="24849" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="24851" href="1Lab.Univalence.html#24851" class="Bound">p</a><a id="24852" class="Symbol">)</a>       <a id="24860" class="Symbol">=</a> <a data-type="(A → B) → B → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="24862" href="1Lab.Equiv.html#1881" class="Function">fibre</a> <a id="24868" href="1Lab.Univalence.html#24851" class="Bound">p</a>
  <a id="24872" href="1Lab.Univalence.html#24784" class="Function">isom</a> <a id="24877" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="24878" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="24882" class="Symbol">.</a><a id="24883" href="1Lab.Equiv.html#6080" class="Field">inv</a> <a id="24887" href="1Lab.Univalence.html#24887" class="Bound">p⁻¹</a>      <a id="24896" class="Symbol">=</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="24898" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="24900" href="1Lab.Univalence.html#24887" class="Bound">p⁻¹</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="24904" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="∑ A B → A" id="24906" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a>
  <a id="24912" href="1Lab.Univalence.html#24784" class="Function">isom</a> <a id="24917" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="24918" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="24922" class="Symbol">.</a><a id="24923" href="1Lab.Equiv.html#6096" class="Field">rinv</a> <a id="24928" href="1Lab.Univalence.html#24928" class="Bound">prep</a> <a id="24933" href="1Lab.Univalence.html#24933" class="Bound">i</a> <a id="24935" href="1Lab.Univalence.html#24935" class="Bound">x</a> <a id="24937" class="Symbol">=</a> <a data-type="A ≃ B → A ≡ B" id="24939" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="24942" class="Symbol">(</a><a data-type="(B : A → Type ℓ&#39;) (a : A) → fibre fst a ≃ B a" id="24943" href="1Lab.Univalence.html#22907" class="Function">Fibre-equiv</a> <a id="24955" href="1Lab.Univalence.html#24928" class="Bound">prep</a> <a id="24960" href="1Lab.Univalence.html#24935" class="Bound">x</a><a id="24961" class="Symbol">)</a> <a id="24963" href="1Lab.Univalence.html#24933" class="Bound">i</a>
  <a id="24967" href="1Lab.Univalence.html#24784" class="Function">isom</a> <a id="24972" class="Symbol">.</a><a data-type="(r : ∑ A B) → B (r .fst)" id="24973" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="24977" class="Symbol">.</a><a id="24978" href="1Lab.Equiv.html#6128" class="Field">linv</a> <a id="24983" class="Symbol">(</a><a id="24984" href="1Lab.Univalence.html#24984" class="Bound">E</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="24986" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="24988" href="1Lab.Univalence.html#24988" class="Bound">p</a><a id="24989" class="Symbol">)</a> <a id="24991" href="1Lab.Univalence.html#24991" class="Bound">i</a>
    <a id="24997" class="Symbol">=</a> <a data-type="A ≃ B → A ≡ B" id="24999" href="1Lab.Univalence.html#8796" class="Function">ua</a> <a id="25002" href="1Lab.Univalence.html#25061" class="Function">e</a> <a id="25004" class="Symbol">(</a><a id="25005" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="25007" href="1Lab.Univalence.html#24991" class="Bound">i</a><a id="25008" class="Symbol">)</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="25010" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="25012" class="Symbol">λ</a> <a id="25014" href="1Lab.Univalence.html#25014" class="Bound">x</a> <a id="25016" class="Symbol">→</a> <a data-type="∑ A B → A" id="25018" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="25022" class="Symbol">(</a><a id="25023" href="1Lab.Path.html#639" class="Primitive">outS</a> <a id="25028" class="Symbol">(</a><a data-type="(e : A ≃ B) (i : I) (x : ua e i) →
B [ ~ i ∨ i ↦ (λ { ((i = i0)) → e .fst x ; ((i = i1)) → x }) ]" id="25029" href="1Lab.Univalence.html#12054" class="Function">ua-unglue</a> <a id="25039" href="1Lab.Univalence.html#25061" class="Function">e</a> <a id="25041" class="Symbol">(</a><a id="25042" href="1Lab.Path.html#800" class="Primitive Operator">~</a> <a id="25044" href="1Lab.Univalence.html#24991" class="Bound">i</a><a id="25045" class="Symbol">)</a> <a id="25047" href="1Lab.Univalence.html#25014" class="Bound">x</a><a id="25048" class="Symbol">))</a>
    <a id="25055" class="Keyword">where</a> <a id="25061" href="1Lab.Univalence.html#25061" class="Function">e</a> <a id="25063" class="Symbol">=</a> <a data-type="(p : E → B) → E ≃ Σ (fibre p)" id="25065" href="1Lab.Univalence.html#23681" class="Function">Total-equiv</a> <a id="25077" href="1Lab.Univalence.html#24988" class="Bound">p</a>
</pre>
<p>To solidify the explanation that object classifiers generalise the <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n-2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>-truncated</span> object classifiers you would find in a <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>-topos,</span> we prove that any class of maps described by a property <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> which holds of all of its fibres (or even <em>structure</em> on all of its fibres!) has a classifying object — the total space <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">\Sigma P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>.</span></p>
<p>For instance, if we take <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> to be the property of <span class="Agda"><a data-type="Type ℓ → Type ℓ" href="1Lab.HLevel.html#2594" class="Function">being a proposition</a></span>, this theorem tells us that <code>Σ isProp</code> classifies <em>subobjects</em>. With the slight caveat that <code>Σ isProp</code> is not closed under impredicative quantification, this corresponds exactly to the notion of subobject classifier in a <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>-topos,</span> since the maps with propositional fibres are precisely the injective maps.</p>
<!--
<pre class="Agda"><a id="25832" href="1Lab.Univalence.html#25832" class="Function">_</a> <a id="25834" class="Symbol">=</a> <a id="25836" href="1Lab.HLevel.html#2594" class="Function">isProp</a>
</pre>-->
<p>Since the type of “maps into B with variable domain and P fibres” has a very unwieldy description — both in words or in Agda syntax — we abbreviate it by <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">ℓ</mi><msub><mi mathvariant="normal">/</mi><mrow><mo stretchy="false">[</mo><mi>P</mi><mo stretchy="false">]</mo></mrow></msub><mi>B</mi></mrow><annotation encoding="application/x-tex">\ell /_{[P]} B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3552em;"></span><span class="mord">ℓ</span><span class="mord"><span class="mord">/</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">[</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mclose mtight">]</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>.</span> The notation is meant to evoke the idea of a slice category: The objects of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi mathvariant="normal">/</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">C/c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord">/</span><span class="mord mathnormal">c</span></span></span></span> are objects of the category <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span> equipped with choices of maps into <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>.</span> Similarly, the objects of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">ℓ</mi><msub><mi mathvariant="normal">/</mi><mrow><mo stretchy="false">[</mo><mi>P</mi><mo stretchy="false">]</mo></mrow></msub><mi>B</mi></mrow><annotation encoding="application/x-tex">\ell/_{[P]}B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3552em;"></span><span class="mord">ℓ</span><span class="mord"><span class="mord">/</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">[</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mclose mtight">]</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> are objects of the universe <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">T</mi><mi mathvariant="normal">y</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">e</mi></mrow><mtext> </mtext><mi mathvariant="normal">ℓ</mi></mrow><annotation encoding="application/x-tex">\ty\
\ell</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">Type</span></span><span class="mspace"> </span><span class="mord">ℓ</span></span></span></span>,</span> with a choice of map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> into <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>,</span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> holds for all the fibres of <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>.</span></p>
<pre class="Agda"><a id="_/[_]_"></a><a data-type="(ℓ : Level) →
(Type (ℓ&#39; ⊔ ℓ) → Type ℓ&#39;&#39;) →
Type ℓ&#39; → Type (lsuc ℓ&#39; ⊔ ℓ&#39;&#39; ⊔ lsuc ℓ)" id="26355" href="1Lab.Univalence.html#26355" class="Function Operator">_/[_]_</a> <a id="26362" class="Symbol">:</a> <a id="26364" class="Symbol">∀</a> <a id="26366" class="Symbol">{</a><a id="26367" href="1Lab.Univalence.html#26367" class="Bound">ℓ&#39;</a> <a id="26370" href="1Lab.Univalence.html#26370" class="Bound">ℓ&#39;&#39;</a><a id="26373" class="Symbol">}</a> <a id="26375" class="Symbol">(</a><a id="26376" href="1Lab.Univalence.html#26376" class="Bound">ℓ</a> <a id="26378" class="Symbol">:</a> <a data-type="Type" id="26380" href="Agda.Primitive.html#597" class="Postulate">Level</a><a id="26385" class="Symbol">)</a> <a id="26387" class="Symbol">→</a> <a id="26389" class="Symbol">(</a><a id="26390" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="26395" class="Symbol">(</a><a id="26396" href="1Lab.Univalence.html#26376" class="Bound">ℓ</a> <a data-type="Level → Level → Level" id="26398" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="26400" href="1Lab.Univalence.html#26367" class="Bound">ℓ&#39;</a><a id="26402" class="Symbol">)</a> <a id="26404" class="Symbol">→</a> <a id="26406" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="26411" href="1Lab.Univalence.html#26370" class="Bound">ℓ&#39;&#39;</a><a id="26414" class="Symbol">)</a> <a id="26416" class="Symbol">→</a> <a id="26418" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="26423" href="1Lab.Univalence.html#26367" class="Bound">ℓ&#39;</a> <a id="26426" class="Symbol">→</a> <a id="26428" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="26433" class="Symbol">_</a>
<a data-type="(ℓ : Level) →
(Type (ℓ&#39; ⊔ ℓ) → Type ℓ&#39;&#39;) →
Type ℓ&#39; → Type (lsuc ℓ&#39; ⊔ ℓ&#39;&#39; ⊔ lsuc ℓ)" id="26435" href="1Lab.Univalence.html#26355" class="Function Operator">_/[_]_</a> <a id="26442" class="Symbol">{</a><a id="26443" href="1Lab.Univalence.html#26443" class="Bound">ℓ</a><a id="26444" class="Symbol">}</a> <a id="26446" href="1Lab.Univalence.html#26446" class="Bound">ℓ&#39;</a> <a id="26449" href="1Lab.Univalence.html#26449" class="Bound">P</a> <a id="26451" href="1Lab.Univalence.html#26451" class="Bound">B</a> <a id="26453" class="Symbol">=</a>
  <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="26457" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="26459" class="Symbol">λ</a> <a id="26461" class="Symbol">(</a><a id="26462" href="1Lab.Univalence.html#26462" class="Bound">A</a> <a id="26464" class="Symbol">:</a> <a id="26466" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="26471" class="Symbol">(</a><a id="26472" href="1Lab.Univalence.html#26443" class="Bound">ℓ</a> <a data-type="Level → Level → Level" id="26474" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="26476" href="1Lab.Univalence.html#26446" class="Bound">ℓ&#39;</a><a id="26478" class="Symbol">))</a> <a id="26481" class="Symbol">→</a>
  <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="26485" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="26487" class="Symbol">λ</a> <a id="26489" class="Symbol">(</a><a id="26490" href="1Lab.Univalence.html#26490" class="Bound">f</a> <a id="26492" class="Symbol">:</a> <a id="26494" href="1Lab.Univalence.html#26462" class="Bound">A</a> <a id="26496" class="Symbol">→</a> <a id="26498" href="1Lab.Univalence.html#26451" class="Bound">B</a><a id="26499" class="Symbol">)</a> <a id="26501" class="Symbol">→</a>
  <a id="26505" class="Symbol">(</a><a id="26506" href="1Lab.Univalence.html#26506" class="Bound">x</a> <a id="26508" class="Symbol">:</a> <a id="26510" href="1Lab.Univalence.html#26451" class="Bound">B</a><a id="26511" class="Symbol">)</a> <a id="26513" class="Symbol">→</a> <a id="26515" href="1Lab.Univalence.html#26449" class="Bound">P</a> <a id="26517" class="Symbol">(</a><a data-type="(A → B) → B → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="26518" href="1Lab.Equiv.html#1881" class="Function">fibre</a> <a id="26524" href="1Lab.Univalence.html#26490" class="Bound">f</a> <a id="26526" href="1Lab.Univalence.html#26506" class="Bound">x</a><a id="26527" class="Symbol">)</a>
</pre>
<p>The proof that the slice <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">ℓ</mi><msub><mi mathvariant="normal">/</mi><mrow><mo stretchy="false">[</mo><mi>P</mi><mo stretchy="false">]</mo></mrow></msub><mi>B</mi></mrow><annotation encoding="application/x-tex">\ell /_{[P]} B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3552em;"></span><span class="mord">ℓ</span><span class="mord"><span class="mord">/</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">[</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">P</span><span class="mclose mtight">]</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> is classified by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">\Sigma P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span> follows from elementary properties of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span> types (namely: <span class="Agda"><a data-type="Σ (λ x → Σ (C x)) ≃ Σ (λ x → C (x .fst) (x .snd))" href="1Lab.Type.Sigma.html#4048" class="Function">reassociation</a></span>, <span class="Agda"><a data-type="((x : A) → Σ (C x)) ≃ Σ (λ f → (x : A) → C x (f x))" href="1Lab.Type.Sigma.html#4425" class="Function">distributivity</a></span> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span> over <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Π</span></span></span></span>),</span> and the classification theorem <span class="Agda"><a data-type="Σ (λ E → E → B) ≃ (B → Type (ℓ ⊔ ℓ&#39;))" href="1Lab.Univalence.html#24606" class="Function">Fibration-equiv</a></span>. Really, the most complicated part of this proof is rearranging the nested sum and product types to a form to which we can apply <span class="Agda"><a data-type="Σ (λ E → E → B) ≃ (B → Type (ℓ ⊔ ℓ&#39;))" href="1Lab.Univalence.html#24606" class="Function">Fibration-equiv</a></span>.</p>
<pre class="Agda"><a id="Map-classifier"></a><a data-type="(P : Type (ℓ ⊔ ℓ&#39;) → Type ℓ&#39;&#39;) → (ℓ /[ P ] B) ≃ (B → Σ P)" id="26991" href="1Lab.Univalence.html#26991" class="Function">Map-classifier</a>
  <a id="27008" class="Symbol">:</a> <a id="27010" class="Symbol">∀</a> <a id="27012" class="Symbol">{</a><a id="27013" href="1Lab.Univalence.html#27013" class="Bound">ℓ</a> <a id="27015" href="1Lab.Univalence.html#27015" class="Bound">ℓ&#39;</a> <a id="27018" href="1Lab.Univalence.html#27018" class="Bound">ℓ&#39;&#39;</a><a id="27021" class="Symbol">}</a> <a id="27023" class="Symbol">{</a><a id="27024" href="1Lab.Univalence.html#27024" class="Bound">B</a> <a id="27026" class="Symbol">:</a> <a id="27028" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="27033" href="1Lab.Univalence.html#27015" class="Bound">ℓ&#39;</a><a id="27035" class="Symbol">}</a> <a id="27037" class="Symbol">(</a><a id="27038" href="1Lab.Univalence.html#27038" class="Bound">P</a> <a id="27040" class="Symbol">:</a> <a id="27042" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="27047" class="Symbol">(</a><a id="27048" href="1Lab.Univalence.html#27013" class="Bound">ℓ</a> <a data-type="Level → Level → Level" id="27050" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="27052" href="1Lab.Univalence.html#27015" class="Bound">ℓ&#39;</a><a id="27054" class="Symbol">)</a> <a id="27056" class="Symbol">→</a> <a id="27058" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="27063" href="1Lab.Univalence.html#27018" class="Bound">ℓ&#39;&#39;</a><a id="27066" class="Symbol">)</a>
  <a id="27070" class="Symbol">→</a> <a id="27072" class="Symbol">(</a><a id="27073" href="1Lab.Univalence.html#27013" class="Bound">ℓ</a> <a data-type="(ℓ : Level) →
(Type (ℓ&#39; ⊔ ℓ) → Type ℓ&#39;&#39;) →
Type ℓ&#39; → Type (lsuc ℓ&#39; ⊔ ℓ&#39;&#39; ⊔ lsuc ℓ)" id="27075" href="1Lab.Univalence.html#26355" class="Function Operator">/[</a> <a id="27078" href="1Lab.Univalence.html#27038" class="Bound">P</a> <a data-type="(ℓ : Level) →
(Type (ℓ&#39; ⊔ ℓ) → Type ℓ&#39;&#39;) →
Type ℓ&#39; → Type (lsuc ℓ&#39; ⊔ ℓ&#39;&#39; ⊔ lsuc ℓ)" id="27080" href="1Lab.Univalence.html#26355" class="Function Operator">]</a> <a id="27082" href="1Lab.Univalence.html#27024" class="Bound">B</a><a id="27083" class="Symbol">)</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="27085" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="27087" class="Symbol">(</a><a id="27088" href="1Lab.Univalence.html#27024" class="Bound">B</a> <a id="27090" class="Symbol">→</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="27092" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="27094" href="1Lab.Univalence.html#27038" class="Bound">P</a><a id="27095" class="Symbol">)</a>
<a data-type="(P : Type (ℓ ⊔ ℓ&#39;) → Type ℓ&#39;&#39;) → (ℓ /[ P ] B) ≃ (B → Σ P)" id="27097" href="1Lab.Univalence.html#26991" class="Function">Map-classifier</a> <a id="27112" class="Symbol">{</a><a id="27113" class="Argument">ℓ</a> <a id="27115" class="Symbol">=</a> <a id="27117" href="1Lab.Univalence.html#27117" class="Bound">ℓ</a><a id="27118" class="Symbol">}</a> <a id="27120" class="Symbol">{</a><a id="27121" class="Argument">B</a> <a id="27123" class="Symbol">=</a> <a id="27125" href="1Lab.Univalence.html#27125" class="Bound">B</a><a id="27126" class="Symbol">}</a> <a id="27128" href="1Lab.Univalence.html#27128" class="Bound">P</a> <a id="27130" class="Symbol">=</a>
  <a id="27134" class="Symbol">(</a><a data-type="(B : A → Type b) → Type (a ⊔ b)" id="27135" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="27137" class="Symbol">λ</a> <a id="27139" href="1Lab.Univalence.html#27139" class="Bound">A</a> <a id="27141" class="Symbol">→</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="27143" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="27145" class="Symbol">λ</a> <a id="27147" href="1Lab.Univalence.html#27147" class="Bound">f</a> <a id="27149" class="Symbol">→</a> <a id="27151" class="Symbol">(</a><a id="27152" href="1Lab.Univalence.html#27152" class="Bound">x</a> <a id="27154" class="Symbol">:</a> <a id="27156" href="1Lab.Univalence.html#27125" class="Bound">B</a><a id="27157" class="Symbol">)</a> <a id="27159" class="Symbol">→</a> <a id="27161" href="1Lab.Univalence.html#27128" class="Bound">P</a> <a id="27163" class="Symbol">(</a><a data-type="(A → B) → B → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="27164" href="1Lab.Equiv.html#1881" class="Function">fibre</a> <a id="27170" href="1Lab.Univalence.html#27147" class="Bound">f</a> <a id="27172" href="1Lab.Univalence.html#27152" class="Bound">x</a><a id="27173" class="Symbol">))</a>     <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="27180" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a data-type="Σ (λ x → Σ (C x)) ≃ Σ (λ x → C (x .fst) (x .snd))" id="27183" href="1Lab.Type.Sigma.html#4048" class="Function">Σ-assoc</a> <a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="27191" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a id="27195" class="Symbol">(</a><a data-type="(B : A → Type b) → Type (a ⊔ b)" id="27196" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="27198" class="Symbol">λ</a> <a id="27200" class="Symbol">{</a> <a id="27202" class="Symbol">(</a><a id="27203" href="1Lab.Univalence.html#27203" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B fst₁) → ∑ A B" id="27205" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="27207" href="1Lab.Univalence.html#27207" class="Bound">f</a><a id="27208" class="Symbol">)</a> <a id="27210" class="Symbol">→</a> <a id="27212" class="Symbol">(</a><a id="27213" href="1Lab.Univalence.html#27213" class="Bound">x</a> <a id="27215" class="Symbol">:</a> <a id="27217" href="1Lab.Univalence.html#27125" class="Bound">B</a><a id="27218" class="Symbol">)</a> <a id="27220" class="Symbol">→</a> <a id="27222" href="1Lab.Univalence.html#27128" class="Bound">P</a> <a id="27224" class="Symbol">(</a><a data-type="(A → B) → B → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="27225" href="1Lab.Equiv.html#1881" class="Function">fibre</a> <a id="27231" href="1Lab.Univalence.html#27207" class="Bound">f</a> <a id="27233" href="1Lab.Univalence.html#27213" class="Bound">x</a><a id="27234" class="Symbol">)</a> <a id="27236" class="Symbol">})</a>   <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="27241" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a data-type="(e : A ≃ A&#39;) → Σ (B ∘ e .fst) ≃ Σ B" id="27244" href="1Lab.Type.Sigma.html#2062" class="Function">Σ-ap-fst</a> <a id="27253" class="Symbol">(</a><a data-type="Σ (λ E → E → B) ≃ (B → Type (ℓ ⊔ ℓ&#39;))" id="27254" href="1Lab.Univalence.html#24606" class="Function">Fibration-equiv</a> <a id="27270" class="Symbol">{</a><a id="27271" class="Argument">ℓ&#39;</a> <a id="27274" class="Symbol">=</a> <a id="27276" href="1Lab.Univalence.html#27117" class="Bound">ℓ</a><a id="27277" class="Symbol">})</a> <a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="27280" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a id="27284" class="Symbol">(</a><a data-type="(B : A → Type b) → Type (a ⊔ b)" id="27285" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="27287" class="Symbol">λ</a> <a id="27289" href="1Lab.Univalence.html#27289" class="Bound">A</a> <a id="27291" class="Symbol">→</a> <a id="27293" class="Symbol">(</a><a id="27294" href="1Lab.Univalence.html#27294" class="Bound">x</a> <a id="27296" class="Symbol">:</a> <a id="27298" href="1Lab.Univalence.html#27125" class="Bound">B</a><a id="27299" class="Symbol">)</a> <a id="27301" class="Symbol">→</a> <a id="27303" href="1Lab.Univalence.html#27128" class="Bound">P</a> <a id="27305" class="Symbol">(</a><a id="27306" href="1Lab.Univalence.html#27289" class="Bound">A</a> <a id="27308" href="1Lab.Univalence.html#27294" class="Bound">x</a><a id="27309" class="Symbol">))</a>                   <span class="reasoning-step"><span class="as-written Function Operator"><a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="27330" href="1Lab.Equiv.html#22832" class="Function Operator">≃⟨</a> <a data-type="((x : A) → Σ (C x)) ≃ Σ (λ f → (x : A) → C x (f x))" id="27333" href="1Lab.Type.Sigma.html#4425" class="Function">Σ-Π-distrib</a> <a data-type="A ≃ B → B ≃ A" id="27345" href="1Lab.Equiv.html#21246" class="Function Operator">e⁻¹</a> <a data-type="(A : Type ℓ) → A ≃ B → B ≃ C → A ≃ C" id="27349" href="1Lab.Equiv.html#22832" class="Function Operator">⟩</a></span><span class="alternate Function Operator">≃</span></span>
  <a id="27353" class="Symbol">(</a><a id="27354" href="1Lab.Univalence.html#27125" class="Bound">B</a> <a id="27356" class="Symbol">→</a> <a data-type="(B : A → Type b) → Type (a ⊔ b)" id="27358" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="27360" href="1Lab.Univalence.html#27128" class="Bound">P</a><a id="27361" class="Symbol">)</a>                                     <a data-type="(A : Type ℓ) → A ≃ A" id="27399" href="1Lab.Equiv.html#23023" class="Function Operator">≃∎</a>
</pre>
<section class="footnotes" role="doc-endnotes">
<hr></hr>
<ol>
<li id="fn1" role="doc-endnote"><p>Not the fundamental theorem of engineering!<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
  </article>
</div>

</main>
</body>
</html>