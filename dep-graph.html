<html>

<head>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="/graphdata.js"></script>

  <style type="text/css">
    body {
      width: 100%;
      height: 100%;
    }

    svg {
      width: 100%;
      height: 100%;
    }
  </style>
</head>

<body>
  <script type="text/javascript">
    async function digestMessage(message) {
      const encoder = new TextEncoder();
      const data = encoder.encode(message);
      const hash = await crypto.subtle.digest('SHA-256', data);
      return hash;
    }

    function clamp(x, lo, hi) {
      return x < lo ? lo : x > hi ? hi : x;
    }
    function hsv2rgb(h,s,v) {
      let f = (n,k=(n+h/60)%6) => v - v*s*Math.max( Math.min(k,4-k,1), 0);
      let col = [f(5),f(3),f(1)].map(x=>x*255|0).join(', ')
      return "rgb(" + col + ")";
    }

    const
      width = document.documentElement.clientWidth,
      height = document.documentElement.clientHeight,
      idm = {};
    const colors = {};

    graphnodes.map((x, i) => {
      idm[x.id] = i
      digestMessage(x.id).then(c => colors[x.id] = Math.abs(new Int32Array(c)[0]) % 359);
    });

    const links = graphedges.map(x => ({
      source: idm[x.from],
      target: idm[x.to],
    }));

    const simulation = d3.forceSimulation(graphnodes)
      .force('charge', d3.forceManyBody().strength(-400))
      .force('center', d3.forceCenter(width / 2, height / 2))
      .force('link', d3.forceLink(links))
      .force('collision', d3.forceCollide().radius(d => d.vis === true ? d.radius + d.label.length * 10 : d.radius));

    const zoom = d3.zoom();

    const svg = d3.select('body').append('svg')
      .attr('width', width)
      .attr('height', height)
      .call(zoom)
      .append('g');

    const lines = svg.selectAll('line')
      .data(links)
      .join('line')
      .attr('stroke', '#ccc');

    const nodes = svg.selectAll('circle')
      .data(graphnodes)
      .join('circle')
      .attr('r', 10)

    const labels =
      svg.selectAll('text')
        .data(graphnodes)
        .join('text')
        .text(d => d.label)
        .attr('visibility', 'hidden');

    let visible = null;
    const render = () => {
      nodes
        .attr('cx', d => d.x)
        .attr('cy', d => d.y)
        .attr('fill', d => d.fill || (colors[d.id] ? hsv2rgb(colors[d.id], 1, 1) : '#9ebef0'))
        .attr('visibility', d => visible !== null ? (visible[d.id] ? "" : "hidden") : "");
      lines
        .attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y)
        .attr('stroke', d => d.fill || '#eee')
        .attr('visibility', d => visible !== null ? (visible[d.index] ? "" : "hidden") : "");
      labels
        .attr('x', d => d.x + 10)
        .attr('y', d => d.y + 10)
        .attr('visibility', d => visible !== null ? (visible[d.id] ? "" : "hidden") : d.vis ? '' : 'hidden');
    };

    simulation.on('tick', render);

    zoom.on('zoom', ({transform: transform}) => {
      svg.attr("transform", "translate(" + transform.x + "," + transform.y + ") scale(" + transform.k + ")");
    });

    const drag = d3.drag().on("drag", (event, d) => {
      d.fx = clamp(event.x, 0, width);
      d.fy = clamp(event.y, 0, height);
      simulation.alpha(1).restart();
    });

    nodes.call(drag);

    const reachable = {};
    const explore = (d, h, s, v, out, vis={}, ho = 0) => {
      if (vis[d.id] !== undefined) return out;
      const col = hsv2rgb(h,s,v);

      out.push({
        elem: d,
        col: col,
        defCol: colors[d.id] ? hsv2rgb(colors[d.id], 1, 1) : '#ff0000',
        hops: ho
      });

      vis[d.id] = true;
      for (const l of links) {
        if (l.target.id === d.id) {
          out.push({
            elem: l,
            col: col,
            defCol: '#eee',
            hops: ho
          });

          explore(l.source, h, s, v * 0.95, out, vis, ho + 1);
        }
      }
      return out;
    };

    nodes.on('mouseenter', (ev, d) => {
      if (reachable[d.id] === undefined) {
        reachable[d.id] = explore(d, colors[d.id], 1, 1, [], {});
      }
      d.vis = true;

      for (e of reachable[d.id]) {
        e.elem.fill = e.col
      }

      render();
    }).on('mouseleave', (ev, d) => {
      d.vis = false;

      for (e of reachable[d.id]) {
        e.elem.fill = e.defCol;
      }
      render();
    }).on('click', (ev, d) => {
      if (!ev.ctrlKey) return;
      if (visible !== null && visible.started.id === d.id) {
        visible = null;
        render();
        return;
      }

      visible = { started: d };
      for (e of reachable[d.id]) {
        visible[e.elem.id || e.elem.index] = true;
      }
      console.log(d.index);
      visible[d.id] = true;
      render();
    });
  </script>
</body>

</html>
