<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8"></meta>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"></meta>
  <meta name="keywords" content="Agda,categories,topos"></meta>

  <title>1Lab.Type.Sigma - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css"></link>
  <link rel="stylesheet" href="/css/katex.min.css"></link>
  <link rel="stylesheet" href="/css/agda-cats.css"></link>

  <meta name="twitter:card" content="summary"></meta>
  <meta name="twitter:title" content="1Lab.Type.Sigma - 1Lab"></meta>
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png"></meta>

  <meta name="og:title" content="1Lab.Type.Sigma - 1Lab"></meta>
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png"></meta>
  <meta name="og:site-name" content="1Lab"></meta>
  <meta name="og:type" content="website"></meta>

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory."></meta>
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory."></meta>
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory."></meta>
  
  <script src="/equations.js" type="text/javascript"></script> 
  <script src="/highlight-hover.js" type="text/javascript"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>
</head>

<body>
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0;">
                <a class="Module">1Lab.Type.Sigma</a>
              </h3>

      <!-- Cube logo -->
      <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px"></img>
      
      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr></hr>
      <ul>
      <li><a href="#properties-of-σ-types"><a href="#properties-of-σ-types" class="header-link">Properties of Σ types<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#groupoid-structure"><a href="#groupoid-structure" class="header-link">Groupoid structure<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#closure-under-equivalences"><a href="#closure-under-equivalences" class="header-link">Closure under equivalences<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#paths-in-subtypes"><a href="#paths-in-subtypes" class="header-link">Paths in subtypes<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#dependent-sums-of-contractibles"><a href="#dependent-sums-of-contractibles" class="header-link">Dependent sums of contractibles<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      </ul>
      <hr></hr>

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>
      </div>

      <hr></hr>

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
              <a href="index.html">️back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/61d814ac1bbdd2bb2eb5f61a3c66bb3ce13904b9/src/1Lab/Type/Sigma.lagda.md">link to source</a> <br />
      </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="index.html">️back to index</a>
      </div>
      
      <!-- Font toggle checkbox -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>
    </div>

<pre class="Agda"><a id="5" class="Keyword">open</a> <a id="10" class="Keyword">import</a> <a id="17" href="1Lab.HLevel.html" class="Module">1Lab.HLevel</a>
<a id="29" class="Keyword">open</a> <a id="34" class="Keyword">import</a> <a id="41" href="1Lab.Equiv.html" class="Module">1Lab.Equiv</a>
<a id="52" class="Keyword">open</a> <a id="57" class="Keyword">import</a> <a id="64" href="1Lab.Path.html" class="Module">1Lab.Path</a>
<a id="74" class="Keyword">open</a> <a id="79" class="Keyword">import</a> <a id="86" href="1Lab.Type.html" class="Module">1Lab.Type</a>

<a id="97" class="Keyword">module</a> <a id="104" href="1Lab.Type.Sigma.html" class="Module">1Lab.Type.Sigma</a> <a id="120" class="Keyword">where</a>
</pre>
<!--
<pre class="Agda"><a id="140" class="Keyword">private</a> <a id="148" class="Keyword">variable</a>
  <a id="159" href="1Lab.Type.Sigma.html#159" class="Generalizable">ℓ</a> <a id="161" href="1Lab.Type.Sigma.html#161" class="Generalizable">ℓ₁</a> <a id="164" class="Symbol">:</a> <a id="166" href="Agda.Primitive.html#597" class="Postulate">Level</a>
  <a id="174" href="1Lab.Type.Sigma.html#174" class="Generalizable">A</a> <a id="176" href="1Lab.Type.Sigma.html#176" class="Generalizable">A&#39;</a> <a id="179" class="Symbol">:</a> <a id="181" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="186" href="1Lab.Type.Sigma.html#159" class="Generalizable">ℓ</a>
  <a id="190" href="1Lab.Type.Sigma.html#190" class="Generalizable">B</a> <a id="192" href="1Lab.Type.Sigma.html#192" class="Generalizable">P</a> <a id="194" href="1Lab.Type.Sigma.html#194" class="Generalizable">Q</a> <a id="196" class="Symbol">:</a> <a id="198" href="1Lab.Type.Sigma.html#174" class="Generalizable">A</a> <a id="200" class="Symbol">→</a> <a id="202" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="207" href="1Lab.Type.Sigma.html#159" class="Generalizable">ℓ</a>

<a id="210" class="Keyword">open</a> <a id="215" class="Keyword">import</a> <a id="222" href="Agda.Builtin.Sigma.html" class="Module">Agda.Builtin.Sigma</a> <a id="241" class="Keyword">renaming</a> <a id="250" class="Symbol">(</a><a id="251" href="Agda.Builtin.Sigma.html#166" class="Record">Σ</a> <a id="253" class="Symbol">to</a> <a id="256" class="Record">∑</a><a id="257" class="Symbol">)</a> <a id="259" class="Keyword">public</a>
<a id="266" class="Comment">-- ^ for Agda display</a>
</pre>-->
<h1 id="properties-of-σ-types"><a href="#properties-of-σ-types" class="header-link">Properties of Σ types<span class="header-link-emoji">🔗</span></a></h1>
<p>This module contains properties of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Σ</span></span></span></span> types, not necessarily organised in any way.</p>
<h2 id="groupoid-structure"><a href="#groupoid-structure" class="header-link">Groupoid structure<span class="header-link-emoji">🔗</span></a></h2>
<p>The first thing we prove is that <em>paths in sigmas are sigmas of paths</em>. The type signatures make it clearer:</p>
<pre class="Agda"><a id="Σ-PathP-iso"></a><a data-type="Iso (Σ (λ p → PathP (λ i → B₁ i (p i)) (x .snd) (y .snd)))
(PathP (λ i → Σ (B₁ i)) x y)" id="553" href="1Lab.Type.Sigma.html#553" class="Function">Σ-PathP-iso</a> <a id="565" class="Symbol">:</a> <a id="567" class="Symbol">{</a><a id="568" href="1Lab.Type.Sigma.html#568" class="Bound">A</a> <a id="570" class="Symbol">:</a> <a id="572" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="574" class="Symbol">→</a> <a id="576" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="581" href="1Lab.Type.Sigma.html#159" class="Generalizable">ℓ</a><a id="582" class="Symbol">}</a> <a id="584" class="Symbol">{</a><a id="585" href="1Lab.Type.Sigma.html#585" class="Bound">B</a> <a id="587" class="Symbol">:</a> <a id="589" class="Symbol">(</a><a id="590" href="1Lab.Type.Sigma.html#590" class="Bound">i</a> <a id="592" class="Symbol">:</a> <a id="594" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="595" class="Symbol">)</a> <a id="597" class="Symbol">→</a> <a id="599" href="1Lab.Type.Sigma.html#568" class="Bound">A</a> <a id="601" href="1Lab.Type.Sigma.html#590" class="Bound">i</a> <a id="603" class="Symbol">→</a> <a id="605" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="610" href="1Lab.Type.Sigma.html#161" class="Generalizable">ℓ₁</a><a id="612" class="Symbol">}</a>
              <a id="628" class="Symbol">{</a><a id="629" href="1Lab.Type.Sigma.html#629" class="Bound">x</a> <a id="631" class="Symbol">:</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="633" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="635" class="Symbol">(</a><a id="636" href="1Lab.Type.Sigma.html#585" class="Bound">B</a> <a id="638" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="640" class="Symbol">)}</a> <a id="643" class="Symbol">{</a><a id="644" href="1Lab.Type.Sigma.html#644" class="Bound">y</a> <a id="646" class="Symbol">:</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="648" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="650" class="Symbol">(</a><a id="651" href="1Lab.Type.Sigma.html#585" class="Bound">B</a> <a id="653" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="655" class="Symbol">)}</a>
            <a id="670" class="Symbol">→</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="672" href="1Lab.Equiv.html#6241" class="Function">Iso</a> <a id="676" class="Symbol">(</a><a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="677" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="680" href="1Lab.Type.Sigma.html#680" class="Bound">p</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="682" href="1Lab.Type.html#1563" class="Function">∈</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="684" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="690" href="1Lab.Type.Sigma.html#568" class="Bound">A</a> <a id="692" class="Symbol">(</a><a id="693" href="1Lab.Type.Sigma.html#629" class="Bound">x</a> <a id="695" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="696" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="699" class="Symbol">)</a> <a id="701" class="Symbol">(</a><a id="702" href="1Lab.Type.Sigma.html#644" class="Bound">y</a> <a id="704" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="705" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="708" class="Symbol">)</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="710" href="1Lab.Type.html#1563" class="Function">]</a>
                    <a id="732" class="Symbol">(</a><a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="733" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="739" class="Symbol">(λ</a> <a id="742" href="1Lab.Type.Sigma.html#742" class="Bound">i</a> <a id="744" class="Symbol">→</a> <a id="746" href="1Lab.Type.Sigma.html#585" class="Bound">B</a> <a id="748" href="1Lab.Type.Sigma.html#742" class="Bound">i</a> <a id="750" class="Symbol">(</a><a id="751" href="1Lab.Type.Sigma.html#680" class="Bound">p</a> <a id="753" href="1Lab.Type.Sigma.html#742" class="Bound">i</a><a id="754" class="Symbol">))</a> <a id="757" class="Symbol">(</a><a id="758" href="1Lab.Type.Sigma.html#629" class="Bound">x</a> <a id="760" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="761" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="764" class="Symbol">)</a> <a id="766" class="Symbol">(</a><a id="767" href="1Lab.Type.Sigma.html#644" class="Bound">y</a> <a id="769" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="770" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="773" class="Symbol">)))</a>
                  <a id="795" class="Symbol">(</a><a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="796" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="802" class="Symbol">(λ</a> <a id="805" href="1Lab.Type.Sigma.html#805" class="Bound">i</a> <a id="807" class="Symbol">→</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="809" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="811" class="Symbol">(</a><a id="812" href="1Lab.Type.Sigma.html#585" class="Bound">B</a> <a id="814" href="1Lab.Type.Sigma.html#805" class="Bound">i</a><a id="815" class="Symbol">))</a> <a id="818" href="1Lab.Type.Sigma.html#629" class="Bound">x</a> <a id="820" href="1Lab.Type.Sigma.html#644" class="Bound">y</a><a id="821" class="Symbol">)</a>

<a id="Σ-Path-iso"></a><a data-type="Iso (Σ (λ p → subst B₁ p (x .snd) ≡ y .snd)) (x ≡ y)" id="824" href="1Lab.Type.Sigma.html#824" class="Function">Σ-Path-iso</a> <a id="835" class="Symbol">:</a> <a id="837" class="Symbol">{</a><a id="838" href="1Lab.Type.Sigma.html#838" class="Bound">x</a> <a id="840" href="1Lab.Type.Sigma.html#840" class="Bound">y</a> <a id="842" class="Symbol">:</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="844" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="846" href="1Lab.Type.Sigma.html#190" class="Generalizable">B</a><a id="847" class="Symbol">}</a>
           <a id="860" class="Symbol">→</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="862" href="1Lab.Equiv.html#6241" class="Function">Iso</a> <a id="866" class="Symbol">(</a><a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="867" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="870" href="1Lab.Type.Sigma.html#870" class="Bound">p</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="872" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="874" href="1Lab.Type.Sigma.html#838" class="Bound">x</a> <a id="876" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="877" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="A → A → Type ℓ" id="881" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="883" href="1Lab.Type.Sigma.html#840" class="Bound">y</a> <a id="885" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="886" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="890" href="1Lab.Type.html#1563" class="Function">]</a> <a id="892" class="Symbol">(</a><a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="893" href="1Lab.Path.html#15372" class="Function">subst</a> <a id="899" href="1Lab.Type.Sigma.html#190" class="Generalizable">B</a> <a id="901" href="1Lab.Type.Sigma.html#870" class="Bound">p</a> <a id="903" class="Symbol">(</a><a id="904" href="1Lab.Type.Sigma.html#838" class="Bound">x</a> <a id="906" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="907" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="910" class="Symbol">)</a> <a data-type="A → A → Type ℓ" id="912" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="914" href="1Lab.Type.Sigma.html#840" class="Bound">y</a> <a id="916" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="917" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="920" class="Symbol">))</a>
                 <a id="940" class="Symbol">(</a><a id="941" href="1Lab.Type.Sigma.html#838" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="943" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="945" href="1Lab.Type.Sigma.html#840" class="Bound">y</a><a id="946" class="Symbol">)</a>
</pre>
<p>The first of these, using a dependent path, is easy to prove directly, because paths in cubical type theory <em>automatically</em> inherit the structure of their domain types. The second is a consequence of the first, using the fact that <span class="Agda"><a data-type="(P : I → Type ℓ) (p : P i0) (q : P i1) →
PathP P p q ≡ Path (P i1) (transport P p) q" href="1Lab.Path.html#49166" class="Function">PathPs and paths over a transport are the same</a></span>.</p>
<pre class="Agda"><a data-type="∑ A B₁ → A" id="1268" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="Iso (Σ (λ p → PathP (λ i → B₁ i (p i)) (x .snd) (y .snd)))
(PathP (λ i → Σ (B₁ i)) x y)" id="1272" href="1Lab.Type.Sigma.html#553" class="Function">Σ-PathP-iso</a> <a id="1284" class="Symbol">(</a><a id="1285" href="1Lab.Type.Sigma.html#1285" class="Bound">p</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="1287" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1289" href="1Lab.Type.Sigma.html#1289" class="Bound">q</a><a id="1290" class="Symbol">)</a> <a id="1292" href="1Lab.Type.Sigma.html#1292" class="Bound">i</a> <a id="1294" class="Symbol">=</a> <a id="1296" href="1Lab.Type.Sigma.html#1285" class="Bound">p</a> <a id="1298" href="1Lab.Type.Sigma.html#1292" class="Bound">i</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="1300" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1302" href="1Lab.Type.Sigma.html#1289" class="Bound">q</a> <a id="1304" href="1Lab.Type.Sigma.html#1292" class="Bound">i</a>
<a data-type="isIso f → B₁ → A" id="1306" href="1Lab.Equiv.html#6080" class="Field">isIso.inv</a> <a id="1316" class="Symbol">(</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="1317" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Iso (Σ (λ p → PathP (λ i → B₁ i (p i)) (x .snd) (y .snd)))
(PathP (λ i → Σ (B₁ i)) x y)" id="1321" href="1Lab.Type.Sigma.html#553" class="Function">Σ-PathP-iso</a><a id="1332" class="Symbol">)</a> <a id="1334" href="1Lab.Type.Sigma.html#1334" class="Bound">p</a> <a id="1336" class="Symbol">=</a> <a id="1338" class="Symbol">(λ</a> <a id="1341" href="1Lab.Type.Sigma.html#1341" class="Bound">i</a> <a id="1343" class="Symbol">→</a> <a id="1345" href="1Lab.Type.Sigma.html#1334" class="Bound">p</a> <a id="1347" href="1Lab.Type.Sigma.html#1341" class="Bound">i</a> <a id="1349" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="1350" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="1353" class="Symbol">)</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="1355" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1357" class="Symbol">(λ</a> <a id="1360" href="1Lab.Type.Sigma.html#1360" class="Bound">i</a> <a id="1362" class="Symbol">→</a> <a id="1364" href="1Lab.Type.Sigma.html#1334" class="Bound">p</a> <a id="1366" href="1Lab.Type.Sigma.html#1360" class="Bound">i</a> <a id="1368" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="1369" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="1372" class="Symbol">)</a>
<a data-type="(r : isIso f) → isRightInverse (r .inv) f" id="1374" href="1Lab.Equiv.html#6096" class="Field">isIso.rinv</a> <a id="1385" class="Symbol">(</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="1386" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Iso (Σ (λ p → PathP (λ i → B₁ i (p i)) (x .snd) (y .snd)))
(PathP (λ i → Σ (B₁ i)) x y)" id="1390" href="1Lab.Type.Sigma.html#553" class="Function">Σ-PathP-iso</a><a id="1401" class="Symbol">)</a> <a id="1403" href="1Lab.Type.Sigma.html#1403" class="Bound">x</a> <a id="1405" class="Symbol">=</a> <a data-type="x ≡ x" id="1407" href="1Lab.Path.html#3591" class="Function">refl</a>
<a data-type="(r : isIso f) → isLeftInverse (r .inv) f" id="1412" href="1Lab.Equiv.html#6128" class="Field">isIso.linv</a> <a id="1423" class="Symbol">(</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="1424" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a data-type="Iso (Σ (λ p → PathP (λ i → B₁ i (p i)) (x .snd) (y .snd)))
(PathP (λ i → Σ (B₁ i)) x y)" id="1428" href="1Lab.Type.Sigma.html#553" class="Function">Σ-PathP-iso</a><a id="1439" class="Symbol">)</a> <a id="1441" href="1Lab.Type.Sigma.html#1441" class="Bound">x</a> <a id="1443" class="Symbol">=</a> <a data-type="x ≡ x" id="1445" href="1Lab.Path.html#3591" class="Function">refl</a>

<a data-type="Iso (Σ (λ p → subst B₁ p (x .snd) ≡ y .snd)) (x ≡ y)" id="1451" href="1Lab.Type.Sigma.html#824" class="Function">Σ-Path-iso</a> <a id="1462" class="Symbol">{</a><a id="1463" class="Argument">B</a> <a id="1465" class="Symbol">=</a> <a id="1467" href="1Lab.Type.Sigma.html#1467" class="Bound">B</a><a id="1468" class="Symbol">}</a> <a id="1470" class="Symbol">{</a><a id="1471" href="1Lab.Type.Sigma.html#1471" class="Bound">x</a><a id="1472" class="Symbol">}</a> <a id="1474" class="Symbol">{</a><a id="1475" href="1Lab.Type.Sigma.html#1475" class="Bound">y</a><a id="1476" class="Symbol">}</a> <a id="1478" class="Symbol">=</a>
  <a data-type="A ≡ B₁ → A → B₁" id="1482" href="1Lab.Path.html#11846" class="Function">transport</a> <a id="1492" class="Symbol">(λ</a> <a id="1495" href="1Lab.Type.Sigma.html#1495" class="Bound">i</a> <a id="1497" class="Symbol">→</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="1499" href="1Lab.Equiv.html#6241" class="Function">Iso</a> <a id="1503" class="Symbol">(</a><a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="1504" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="1507" href="1Lab.Type.Sigma.html#1507" class="Bound">p</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="1509" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="1511" href="1Lab.Type.Sigma.html#1471" class="Bound">x</a> <a id="1513" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="1514" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="A → A → Type ℓ" id="1518" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="1520" href="1Lab.Type.Sigma.html#1475" class="Bound">y</a> <a id="1522" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="1523" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="1527" href="1Lab.Type.html#1563" class="Function">]</a>
                         <a id="1554" class="Symbol">(</a><a data-type="(P : I → Type ℓ) (p : P i0) (q : P i1) →
PathP P p q ≡ Path (P i1) (transport P p) q" id="1555" href="1Lab.Path.html#49166" class="Function">PathP≡Path</a> <a id="1566" class="Symbol">(λ</a> <a id="1569" href="1Lab.Type.Sigma.html#1569" class="Bound">j</a> <a id="1571" class="Symbol">→</a> <a id="1573" href="1Lab.Type.Sigma.html#1467" class="Bound">B</a> <a id="1575" class="Symbol">(</a><a id="1576" href="1Lab.Type.Sigma.html#1507" class="Bound">p</a> <a id="1578" href="1Lab.Type.Sigma.html#1569" class="Bound">j</a><a id="1579" class="Symbol">))</a> <a id="1582" class="Symbol">(</a><a id="1583" href="1Lab.Type.Sigma.html#1471" class="Bound">x</a> <a id="1585" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="1586" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="1589" class="Symbol">)</a> <a id="1591" class="Symbol">(</a><a id="1592" href="1Lab.Type.Sigma.html#1475" class="Bound">y</a> <a id="1594" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="1595" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="1598" class="Symbol">)</a> <a id="1600" href="1Lab.Type.Sigma.html#1495" class="Bound">i</a><a id="1601" class="Symbol">))</a>
                       <a id="1627" class="Symbol">(</a><a id="1628" href="1Lab.Type.Sigma.html#1471" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="1630" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="1632" href="1Lab.Type.Sigma.html#1475" class="Bound">y</a><a id="1633" class="Symbol">))</a>
            <a data-type="Iso (Σ (λ p → PathP (λ i → B₁ i (p i)) (x .snd) (y .snd)))
(PathP (λ i → Σ (B₁ i)) x y)" id="1648" href="1Lab.Type.Sigma.html#553" class="Function">Σ-PathP-iso</a>
</pre>
<h2 id="closure-under-equivalences"><a href="#closure-under-equivalences" class="header-link">Closure under equivalences<span class="header-link-emoji">🔗</span></a></h2>
<p>Univalence automatically implies that every type former respects equivalences. However, this theorem is limited to equivalences between types <em>in the same universe</em>. Thus, we provide <span class="Agda"><a data-type="(e : A ≃ A&#39;) → Σ (B₁ ∘ e .fst) ≃ Σ B₁" href="1Lab.Type.Sigma.html#2062" class="Function">Σ-ap-fst</a></span>, <span class="Agda"><a data-type="((x : A) → P x ≃ Q x) → Σ P ≃ Σ Q" href="1Lab.Type.Sigma.html#2017" class="Function">Σ-ap-snd</a></span>, and <span class="Agda"><a data-type="(e : A ≃ A&#39;) → ((x : A) → P x ≃ Q (e .fst x)) → Σ P ≃ Σ Q" href="1Lab.Type.Sigma.html#2110" class="Function">Σ-ap</a></span>, which allows one to perturb a <span class="Agda"><a data-type="(A : Type a) (B₁ : A → Type b) → Type (a ⊔ b)" href="Agda.Builtin.Sigma.html#166" class="Record">Σ</a></span> by equivalences across levels:</p>
<pre class="Agda"><a id="Σ-ap-snd"></a><a data-type="((x : A) → P x ≃ Q x) → Σ P ≃ Σ Q" id="2017" href="1Lab.Type.Sigma.html#2017" class="Function">Σ-ap-snd</a> <a id="2026" class="Symbol">:</a> <a id="2028" class="Symbol">((</a><a id="2030" href="1Lab.Type.Sigma.html#2030" class="Bound">x</a> <a id="2032" class="Symbol">:</a> <a id="2034" href="1Lab.Type.Sigma.html#174" class="Generalizable">A</a><a id="2035" class="Symbol">)</a> <a id="2037" class="Symbol">→</a> <a id="2039" href="1Lab.Type.Sigma.html#192" class="Generalizable">P</a> <a id="2041" href="1Lab.Type.Sigma.html#2030" class="Bound">x</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="2043" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="2045" href="1Lab.Type.Sigma.html#194" class="Generalizable">Q</a> <a id="2047" href="1Lab.Type.Sigma.html#2030" class="Bound">x</a><a id="2048" class="Symbol">)</a> <a id="2050" class="Symbol">→</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="2052" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="2054" href="1Lab.Type.Sigma.html#192" class="Generalizable">P</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="2056" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="2058" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="2060" href="1Lab.Type.Sigma.html#194" class="Generalizable">Q</a>
<a id="Σ-ap-fst"></a><a data-type="(e : A ≃ A&#39;) → Σ (B₁ ∘ e .fst) ≃ Σ B₁" id="2062" href="1Lab.Type.Sigma.html#2062" class="Function">Σ-ap-fst</a> <a id="2071" class="Symbol">:</a> <a id="2073" class="Symbol">(</a><a id="2074" href="1Lab.Type.Sigma.html#2074" class="Bound">e</a> <a id="2076" class="Symbol">:</a> <a id="2078" href="1Lab.Type.Sigma.html#174" class="Generalizable">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="2080" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="2082" href="1Lab.Type.Sigma.html#176" class="Generalizable">A&#39;</a><a id="2084" class="Symbol">)</a> <a id="2086" class="Symbol">→</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="2088" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="2090" class="Symbol">(</a><a id="2091" href="1Lab.Type.Sigma.html#190" class="Generalizable">B</a> <a data-type="(B₁ → C) → (A → B₁) → A → C" id="2093" href="1Lab.Type.html#2217" class="Function Operator">∘</a> <a id="2095" href="1Lab.Type.Sigma.html#2074" class="Bound">e</a> <a id="2097" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="2098" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="2101" class="Symbol">)</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="2103" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="2105" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="2107" href="1Lab.Type.Sigma.html#190" class="Generalizable">B</a>

<a id="Σ-ap"></a><a data-type="(e : A ≃ A&#39;) → ((x : A) → P x ≃ Q (e .fst x)) → Σ P ≃ Σ Q" id="2110" href="1Lab.Type.Sigma.html#2110" class="Function">Σ-ap</a> <a id="2115" class="Symbol">:</a> <a id="2117" class="Symbol">(</a><a id="2118" href="1Lab.Type.Sigma.html#2118" class="Bound">e</a> <a id="2120" class="Symbol">:</a> <a id="2122" href="1Lab.Type.Sigma.html#174" class="Generalizable">A</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="2124" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="2126" href="1Lab.Type.Sigma.html#176" class="Generalizable">A&#39;</a><a id="2128" class="Symbol">)</a> <a id="2130" class="Symbol">→</a> <a id="2132" class="Symbol">((</a><a id="2134" href="1Lab.Type.Sigma.html#2134" class="Bound">x</a> <a id="2136" class="Symbol">:</a> <a id="2138" href="1Lab.Type.Sigma.html#174" class="Generalizable">A</a><a id="2139" class="Symbol">)</a> <a id="2141" class="Symbol">→</a> <a id="2143" href="1Lab.Type.Sigma.html#192" class="Generalizable">P</a> <a id="2145" href="1Lab.Type.Sigma.html#2134" class="Bound">x</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="2147" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="2149" href="1Lab.Type.Sigma.html#194" class="Generalizable">Q</a> <a id="2151" class="Symbol">(</a><a id="2152" href="1Lab.Type.Sigma.html#2118" class="Bound">e</a> <a id="2154" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="2155" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="2159" href="1Lab.Type.Sigma.html#2134" class="Bound">x</a><a id="2160" class="Symbol">))</a> <a id="2163" class="Symbol">→</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="2165" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="2167" href="1Lab.Type.Sigma.html#192" class="Generalizable">P</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="2169" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="2171" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="2173" href="1Lab.Type.Sigma.html#194" class="Generalizable">Q</a>
<a data-type="(e : A ≃ A&#39;) → ((x : A) → P x ≃ Q (e .fst x)) → Σ P ≃ Σ Q" id="2175" href="1Lab.Type.Sigma.html#2110" class="Function">Σ-ap</a> <a id="2180" href="1Lab.Type.Sigma.html#2180" class="Bound">e</a> <a id="2182" href="1Lab.Type.Sigma.html#2182" class="Bound">e&#39;</a> <a id="2185" class="Symbol">=</a> <a data-type="((x : A) → P x ≃ Q x) → Σ P ≃ Σ Q" id="2187" href="1Lab.Type.Sigma.html#2017" class="Function">Σ-ap-snd</a> <a id="2196" href="1Lab.Type.Sigma.html#2182" class="Bound">e&#39;</a> <a data-type="A ≃ B₁ → B₁ ≃ C → A ≃ C" id="2199" href="1Lab.Equiv.html#21166" class="Function Operator">∙e</a> <a data-type="(e : A ≃ A&#39;) → Σ (B₁ ∘ e .fst) ≃ Σ B₁" id="2202" href="1Lab.Type.Sigma.html#2062" class="Function">Σ-ap-fst</a> <a id="2211" href="1Lab.Type.Sigma.html#2180" class="Bound">e</a>
</pre>
<details>
<summary>
The proofs of these theorems are not very enlightening, but they are included for completeness.
</summary>
<pre class="Agda"><a data-type="((x : A) → P x ≃ Q x) → Σ P ≃ Σ Q" id="2349" href="1Lab.Type.Sigma.html#2017" class="Function">Σ-ap-snd</a> <a id="2358" class="Symbol">{</a><a id="2359" class="Argument">A</a> <a id="2361" class="Symbol">=</a> <a id="2363" href="1Lab.Type.Sigma.html#2363" class="Bound">A</a><a id="2364" class="Symbol">}</a> <a id="2366" class="Symbol">{</a><a id="2367" class="Argument">P</a> <a id="2369" class="Symbol">=</a> <a id="2371" href="1Lab.Type.Sigma.html#2371" class="Bound">P</a><a id="2372" class="Symbol">}</a> <a id="2374" class="Symbol">{</a><a id="2375" class="Argument">Q</a> <a id="2377" class="Symbol">=</a> <a id="2379" href="1Lab.Type.Sigma.html#2379" class="Bound">Q</a><a id="2380" class="Symbol">}</a> <a id="2382" href="1Lab.Type.Sigma.html#2382" class="Bound">pointwise</a> <a id="2392" class="Symbol">=</a> <a data-type="Iso A B₁ → A ≃ B₁" id="2394" href="1Lab.Equiv.html#20100" class="Function">Iso→Equiv</a> <a id="2404" href="1Lab.Type.Sigma.html#2503" class="Function">morp</a> <a id="2409" class="Keyword">where</a>
  <a id="2417" href="1Lab.Type.Sigma.html#2417" class="Function">pwise</a> <a id="2423" class="Symbol">:</a> <a id="2425" class="Symbol">(</a><a id="2426" href="1Lab.Type.Sigma.html#2426" class="Bound">x</a> <a id="2428" class="Symbol">:</a> <a id="2430" href="1Lab.Type.Sigma.html#2363" class="Bound">A</a><a id="2431" class="Symbol">)</a> <a id="2433" class="Symbol">→</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="2435" href="1Lab.Equiv.html#6241" class="Function">Iso</a> <a id="2439" class="Symbol">(</a><a id="2440" href="1Lab.Type.Sigma.html#2371" class="Bound">P</a> <a id="2442" href="1Lab.Type.Sigma.html#2426" class="Bound">x</a><a id="2443" class="Symbol">)</a> <a id="2445" class="Symbol">(</a><a id="2446" href="1Lab.Type.Sigma.html#2379" class="Bound">Q</a> <a id="2448" href="1Lab.Type.Sigma.html#2426" class="Bound">x</a><a id="2449" class="Symbol">)</a>
  <a id="2453" href="1Lab.Type.Sigma.html#2417" class="Function">pwise</a> <a id="2459" href="1Lab.Type.Sigma.html#2459" class="Bound">x</a> <a id="2461" class="Symbol">=</a> <a id="2463" class="Symbol">_</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="2465" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="isEquiv f → isIso f" id="2467" href="1Lab.Equiv.html#6787" class="Function">isEquiv→isIso</a> <a id="2481" class="Symbol">(</a><a id="2482" href="1Lab.Type.Sigma.html#2382" class="Bound">pointwise</a> <a id="2492" href="1Lab.Type.Sigma.html#2459" class="Bound">x</a> <a id="2494" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="2495" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="2498" class="Symbol">)</a>

  <a id="2503" href="1Lab.Type.Sigma.html#2503" class="Function">morp</a> <a id="2508" class="Symbol">:</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="2510" href="1Lab.Equiv.html#6241" class="Function">Iso</a> <a id="2514" class="Symbol">(</a><a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="2515" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="2517" href="1Lab.Type.Sigma.html#2371" class="Bound">P</a><a id="2518" class="Symbol">)</a> <a id="2520" class="Symbol">(</a><a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="2521" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="2523" href="1Lab.Type.Sigma.html#2379" class="Bound">Q</a><a id="2524" class="Symbol">)</a>
  <a data-type="∑ A B₁ → A" id="2528" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="2532" href="1Lab.Type.Sigma.html#2503" class="Function">morp</a> <a id="2537" class="Symbol">(</a><a id="2538" href="1Lab.Type.Sigma.html#2538" class="Bound">i</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="2540" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2542" href="1Lab.Type.Sigma.html#2542" class="Bound">x</a><a id="2543" class="Symbol">)</a> <a id="2545" class="Symbol">=</a> <a id="2547" href="1Lab.Type.Sigma.html#2538" class="Bound">i</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="2549" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2551" href="1Lab.Type.Sigma.html#2382" class="Bound">pointwise</a> <a id="2561" href="1Lab.Type.Sigma.html#2538" class="Bound">i</a> <a id="2563" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="2564" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="2568" href="1Lab.Type.Sigma.html#2542" class="Bound">x</a>
  <a data-type="isIso f → B₁ → A" id="2572" href="1Lab.Equiv.html#6080" class="Field">isIso.inv</a> <a id="2582" class="Symbol">(</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="2583" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="2587" href="1Lab.Type.Sigma.html#2503" class="Function">morp</a><a id="2591" class="Symbol">)</a> <a id="2593" class="Symbol">(</a><a id="2594" href="1Lab.Type.Sigma.html#2594" class="Bound">i</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="2596" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2598" href="1Lab.Type.Sigma.html#2598" class="Bound">x</a><a id="2599" class="Symbol">)</a> <a id="2601" class="Symbol">=</a> <a id="2603" href="1Lab.Type.Sigma.html#2594" class="Bound">i</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="2605" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2607" href="1Lab.Type.Sigma.html#2417" class="Function">pwise</a> <a id="2613" href="1Lab.Type.Sigma.html#2594" class="Bound">i</a> <a id="2615" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="2616" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="2620" class="Symbol">.</a><a data-type="isIso f → B₁ → A" id="2621" href="1Lab.Equiv.html#6080" class="Field">isIso.inv</a> <a id="2631" href="1Lab.Type.Sigma.html#2598" class="Bound">x</a>
  <a data-type="(r : isIso f) → isRightInverse (r .inv) f" id="2635" href="1Lab.Equiv.html#6096" class="Field">isIso.rinv</a> <a id="2646" class="Symbol">(</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="2647" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="2651" href="1Lab.Type.Sigma.html#2503" class="Function">morp</a><a id="2655" class="Symbol">)</a> <a id="2657" class="Symbol">(</a><a id="2658" href="1Lab.Type.Sigma.html#2658" class="Bound">i</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="2660" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2662" href="1Lab.Type.Sigma.html#2662" class="Bound">x</a><a id="2663" class="Symbol">)</a> <a id="2665" class="Symbol">=</a> <a data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" id="2667" href="1Lab.Path.html#21240" class="Function">ap₂</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="2671" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a> <a data-type="x ≡ x" id="2675" href="1Lab.Path.html#3591" class="Function">refl</a> <a id="2680" class="Symbol">(</a><a id="2681" href="1Lab.Type.Sigma.html#2417" class="Function">pwise</a> <a id="2687" href="1Lab.Type.Sigma.html#2658" class="Bound">i</a> <a id="2689" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="2690" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="2694" class="Symbol">.</a><a data-type="(r : isIso f) → isRightInverse (r .inv) f" id="2695" href="1Lab.Equiv.html#6096" class="Field">isIso.rinv</a> <a id="2706" class="Symbol">_)</a>
  <a data-type="(r : isIso f) → isLeftInverse (r .inv) f" id="2711" href="1Lab.Equiv.html#6128" class="Field">isIso.linv</a> <a id="2722" class="Symbol">(</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="2723" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="2727" href="1Lab.Type.Sigma.html#2503" class="Function">morp</a><a id="2731" class="Symbol">)</a> <a id="2733" class="Symbol">(</a><a id="2734" href="1Lab.Type.Sigma.html#2734" class="Bound">i</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="2736" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2738" href="1Lab.Type.Sigma.html#2738" class="Bound">x</a><a id="2739" class="Symbol">)</a> <a id="2741" class="Symbol">=</a> <a data-type="(f : (x : A) (y : B₁ x) → C x y) (p : x ≡ y)
(q : PathP (λ i → B₁ (p i)) α β) →
PathP (λ i → C (p i) (q i)) (f x α) (f y β)" id="2743" href="1Lab.Path.html#21240" class="Function">ap₂</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="2747" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a> <a data-type="x ≡ x" id="2751" href="1Lab.Path.html#3591" class="Function">refl</a> <a id="2756" class="Symbol">(</a><a id="2757" href="1Lab.Type.Sigma.html#2417" class="Function">pwise</a> <a id="2763" href="1Lab.Type.Sigma.html#2734" class="Bound">i</a> <a id="2765" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="2766" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="2770" class="Symbol">.</a><a data-type="(r : isIso f) → isLeftInverse (r .inv) f" id="2771" href="1Lab.Equiv.html#6128" class="Field">isIso.linv</a> <a id="2782" class="Symbol">_)</a>

<a data-type="(e : A ≃ A&#39;) → Σ (B₁ ∘ e .fst) ≃ Σ B₁" id="2786" href="1Lab.Type.Sigma.html#2062" class="Function">Σ-ap-fst</a> <a id="2795" class="Symbol">{</a><a id="2796" class="Argument">A</a> <a id="2798" class="Symbol">=</a> <a id="2800" href="1Lab.Type.Sigma.html#2800" class="Bound">A</a><a id="2801" class="Symbol">}</a> <a id="2803" class="Symbol">{</a><a id="2804" class="Argument">A&#39;</a> <a id="2807" class="Symbol">=</a> <a id="2809" href="1Lab.Type.Sigma.html#2809" class="Bound">A&#39;</a><a id="2811" class="Symbol">}</a> <a id="2813" class="Symbol">{</a><a id="2814" class="Argument">B</a> <a id="2816" class="Symbol">=</a> <a id="2818" href="1Lab.Type.Sigma.html#2818" class="Bound">B</a><a id="2819" class="Symbol">}</a> <a id="2821" href="1Lab.Type.Sigma.html#2821" class="Bound">e</a> <a id="2823" class="Symbol">=</a> <a id="2825" href="1Lab.Type.Sigma.html#2852" class="Function">intro</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="2831" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2833" href="1Lab.Type.Sigma.html#2915" class="Function">isEqIntro</a>
 <a id="2844" class="Keyword">where</a>
  <a id="2852" href="1Lab.Type.Sigma.html#2852" class="Function">intro</a> <a id="2858" class="Symbol">:</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="2860" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="2862" class="Symbol">(</a><a id="2863" href="1Lab.Type.Sigma.html#2818" class="Bound">B</a> <a data-type="(B₁ → C) → (A → B₁) → A → C" id="2865" href="1Lab.Type.html#2217" class="Function Operator">∘</a> <a id="2867" href="1Lab.Type.Sigma.html#2821" class="Bound">e</a> <a id="2869" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="2870" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="2873" class="Symbol">)</a> <a id="2875" class="Symbol">→</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="2877" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="2879" href="1Lab.Type.Sigma.html#2818" class="Bound">B</a>
  <a id="2883" href="1Lab.Type.Sigma.html#2852" class="Function">intro</a> <a id="2889" class="Symbol">(</a><a id="2890" href="1Lab.Type.Sigma.html#2890" class="Bound">a</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="2892" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2894" href="1Lab.Type.Sigma.html#2894" class="Bound">b</a><a id="2895" class="Symbol">)</a> <a id="2897" class="Symbol">=</a> <a id="2899" href="1Lab.Type.Sigma.html#2821" class="Bound">e</a> <a id="2901" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="2902" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="2906" href="1Lab.Type.Sigma.html#2890" class="Bound">a</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="2908" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2910" href="1Lab.Type.Sigma.html#2894" class="Bound">b</a>

  <a id="2915" href="1Lab.Type.Sigma.html#2915" class="Function">isEqIntro</a> <a id="2925" class="Symbol">:</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="2927" href="1Lab.Equiv.html#2293" class="Record">isEquiv</a> <a id="2935" href="1Lab.Type.Sigma.html#2852" class="Function">intro</a>
  <a id="2943" href="1Lab.Type.Sigma.html#2915" class="Function">isEqIntro</a> <a id="2953" class="Symbol">.</a><a data-type="isEquiv f → (y : B₁) → isContr (fibre f y)" id="2954" href="1Lab.Equiv.html#2382" class="Field">isEqv</a> <a id="2960" href="1Lab.Type.Sigma.html#2960" class="Bound">x</a> <a id="2962" class="Symbol">=</a> <a data-type="(centre₁ : A) (paths₁ : (x : A) → centre₁ ≡ x) → isContr A" id="2964" href="1Lab.HLevel.html#1382" class="InductiveConstructor">contr</a> <a id="2970" href="1Lab.Type.Sigma.html#3315" class="Function">ctr</a> <a id="2974" href="1Lab.Type.Sigma.html#3381" class="Function">isCtr</a> <a id="2980" class="Keyword">where</a>
    <a id="2990" href="1Lab.Type.Sigma.html#2990" class="Function">PB</a> <a id="2993" class="Symbol">:</a> <a id="2995" class="Symbol">∀</a> <a id="2997" class="Symbol">{</a><a id="2998" href="1Lab.Type.Sigma.html#2998" class="Bound">x</a> <a id="3000" href="1Lab.Type.Sigma.html#3000" class="Bound">y</a><a id="3001" class="Symbol">}</a> <a id="3003" class="Symbol">→</a> <a id="3005" href="1Lab.Type.Sigma.html#2998" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="3007" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="3009" href="1Lab.Type.Sigma.html#3000" class="Bound">y</a> <a id="3011" class="Symbol">→</a> <a id="3013" href="1Lab.Type.Sigma.html#2818" class="Bound">B</a> <a id="3015" href="1Lab.Type.Sigma.html#2998" class="Bound">x</a> <a id="3017" class="Symbol">→</a> <a id="3019" href="1Lab.Type.Sigma.html#2818" class="Bound">B</a> <a id="3021" href="1Lab.Type.Sigma.html#3000" class="Bound">y</a> <a id="3023" class="Symbol">→</a> <a id="3025" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3030" class="Symbol">_</a>
    <a id="3036" href="1Lab.Type.Sigma.html#2990" class="Function">PB</a> <a id="3039" href="1Lab.Type.Sigma.html#3039" class="Bound">p</a> <a id="3041" class="Symbol">=</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="3043" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="3049" class="Symbol">(λ</a> <a id="3052" href="1Lab.Type.Sigma.html#3052" class="Bound">i</a> <a id="3054" class="Symbol">→</a> <a id="3056" href="1Lab.Type.Sigma.html#2818" class="Bound">B</a> <a id="3058" class="Symbol">(</a><a id="3059" href="1Lab.Type.Sigma.html#3039" class="Bound">p</a> <a id="3061" href="1Lab.Type.Sigma.html#3052" class="Bound">i</a><a id="3062" class="Symbol">))</a>

    <a id="3070" class="Keyword">open</a> <a id="3075" href="1Lab.Type.html#1649" class="Module">Σ</a> <a id="3077" href="1Lab.Type.Sigma.html#2960" class="Bound">x</a> <a id="3079" class="Keyword">renaming</a> <a id="3088" class="Symbol">(</a><a data-type="∑ A B₁ → A" id="3089" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="3093" class="Symbol">to</a> <a id="3096" class="Field">a&#39;</a><a id="3098" class="Symbol">;</a> <a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="3100" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="3104" class="Symbol">to</a> <a id="3107" class="Field">b</a><a id="3108" class="Symbol">)</a>
    <a id="3114" class="Keyword">open</a> <a id="3119" href="1Lab.Type.html#1649" class="Module">Σ</a> <a id="3121" class="Symbol">(</a><a id="3122" href="1Lab.Type.Sigma.html#2821" class="Bound">e</a> <a id="3124" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="3125" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="3129" class="Symbol">.</a><a data-type="isEquiv f → (y : B₁) → isContr (fibre f y)" id="3130" href="1Lab.Equiv.html#2382" class="Field">isEqv</a> <a id="3136" href="1Lab.Type.Sigma.html#3096" class="Field">a&#39;</a> <a id="3139" class="Symbol">.</a><a data-type="isContr A → A" id="3140" href="1Lab.HLevel.html#1400" class="Field">isContr.centre</a><a id="3154" class="Symbol">)</a> <a id="3156" class="Keyword">renaming</a> <a id="3165" class="Symbol">(</a><a data-type="∑ A B₁ → A" id="3166" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="3170" class="Symbol">to</a> <a id="3173" class="Field">ctrA</a><a id="3177" class="Symbol">;</a> <a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="3179" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="3183" class="Symbol">to</a> <a id="3186" class="Field">α</a><a id="3187" class="Symbol">)</a>

    <a id="3194" href="1Lab.Type.Sigma.html#3194" class="Function">ctrB</a> <a id="3199" class="Symbol">:</a> <a id="3201" href="1Lab.Type.Sigma.html#2818" class="Bound">B</a> <a id="3203" class="Symbol">(</a><a id="3204" href="1Lab.Type.Sigma.html#2821" class="Bound">e</a> <a id="3206" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="3207" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="3211" href="1Lab.Type.Sigma.html#3173" class="Function">ctrA</a><a id="3215" class="Symbol">)</a>
    <a id="3221" href="1Lab.Type.Sigma.html#3194" class="Function">ctrB</a> <a id="3226" class="Symbol">=</a> <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="3228" href="1Lab.Path.html#15372" class="Function">subst</a> <a id="3234" href="1Lab.Type.Sigma.html#2818" class="Bound">B</a> <a id="3236" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="3237" href="1Lab.Path.html#10628" class="Function">sym</a> <a id="3241" href="1Lab.Type.Sigma.html#3186" class="Function">α</a><a id="3242" class="Symbol">)</a> <a id="3244" href="1Lab.Type.Sigma.html#3107" class="Field">b</a>

    <a id="3251" href="1Lab.Type.Sigma.html#3251" class="Function">ctrP</a> <a id="3256" class="Symbol">:</a> <a id="3258" href="1Lab.Type.Sigma.html#2990" class="Function">PB</a> <a id="3261" href="1Lab.Type.Sigma.html#3186" class="Function">α</a> <a id="3263" href="1Lab.Type.Sigma.html#3194" class="Function">ctrB</a> <a id="3268" href="1Lab.Type.Sigma.html#3107" class="Field">b</a>
    <a id="3274" href="1Lab.Type.Sigma.html#3251" class="Function">ctrP</a> <a id="3279" href="1Lab.Type.Sigma.html#3279" class="Bound">i</a> <a id="3281" class="Symbol">=</a> <a data-type="(A : I → Type ℓ) (i : I) → A i1 → A i" id="3283" href="1Lab.Path.html#51777" class="Function">coe1→i</a> <a id="3290" class="Symbol">(λ</a> <a id="3293" href="1Lab.Type.Sigma.html#3293" class="Bound">i</a> <a id="3295" class="Symbol">→</a> <a id="3297" href="1Lab.Type.Sigma.html#2818" class="Bound">B</a> <a id="3299" class="Symbol">(</a><a id="3300" href="1Lab.Type.Sigma.html#3186" class="Function">α</a> <a id="3302" href="1Lab.Type.Sigma.html#3293" class="Bound">i</a><a id="3303" class="Symbol">))</a> <a id="3306" href="1Lab.Type.Sigma.html#3279" class="Bound">i</a> <a id="3308" href="1Lab.Type.Sigma.html#3107" class="Field">b</a>

    <a id="3315" href="1Lab.Type.Sigma.html#3315" class="Function">ctr</a> <a id="3319" class="Symbol">:</a> <a data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="3321" href="1Lab.Equiv.html#1881" class="Function">fibre</a> <a id="3327" href="1Lab.Type.Sigma.html#2852" class="Function">intro</a> <a id="3333" href="1Lab.Type.Sigma.html#2960" class="Bound">x</a>
    <a id="3339" href="1Lab.Type.Sigma.html#3315" class="Function">ctr</a> <a id="3343" class="Symbol">=</a> <a id="3345" class="Symbol">(</a><a id="3346" href="1Lab.Type.Sigma.html#3173" class="Function">ctrA</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="3351" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3353" href="1Lab.Type.Sigma.html#3194" class="Function">ctrB</a><a id="3357" class="Symbol">)</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="3359" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="(p : x .fst ≡ y .fst) →
PathP (λ i → B₁ (p i)) (x .snd) (y .snd) → x ≡ y" id="3361" href="1Lab.Path.html#57201" class="Function">Σ-PathP</a> <a id="3369" href="1Lab.Type.Sigma.html#3186" class="Function">α</a> <a id="3371" href="1Lab.Type.Sigma.html#3251" class="Function">ctrP</a>

    <a id="3381" href="1Lab.Type.Sigma.html#3381" class="Function">isCtr</a> <a id="3387" class="Symbol">:</a> <a id="3389" class="Symbol">∀</a> <a id="3391" href="1Lab.Type.Sigma.html#3391" class="Bound">y</a> <a id="3393" class="Symbol">→</a> <a id="3395" href="1Lab.Type.Sigma.html#3315" class="Function">ctr</a> <a data-type="A → A → Type ℓ" id="3399" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="3401" href="1Lab.Type.Sigma.html#3391" class="Bound">y</a>
    <a id="3407" href="1Lab.Type.Sigma.html#3381" class="Function">isCtr</a> <a id="3413" class="Symbol">((</a><a id="3415" href="1Lab.Type.Sigma.html#3415" class="Bound">r</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="3417" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3419" href="1Lab.Type.Sigma.html#3419" class="Bound">s</a><a id="3420" class="Symbol">)</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="3422" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3424" href="1Lab.Type.Sigma.html#3424" class="Bound">p</a><a id="3425" class="Symbol">)</a> <a id="3427" class="Symbol">=</a> <a id="3429" class="Symbol">λ</a> <a id="3431" href="1Lab.Type.Sigma.html#3431" class="Bound">i</a> <a id="3433" class="Symbol">→</a> <a id="3435" class="Symbol">(</a><a id="3436" href="1Lab.Type.Sigma.html#3661" class="Function">a≡r</a> <a id="3440" href="1Lab.Type.Sigma.html#3431" class="Bound">i</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="3442" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3444" href="1Lab.Type.Sigma.html#3685" class="Function">b!≡s</a> <a id="3449" href="1Lab.Type.Sigma.html#3431" class="Bound">i</a><a id="3450" class="Symbol">)</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="3452" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="(p : x .fst ≡ y .fst) →
PathP (λ i → B₁ (p i)) (x .snd) (y .snd) → x ≡ y" id="3454" href="1Lab.Path.html#57201" class="Function">Σ-PathP</a> <a id="3462" class="Symbol">(</a><a id="3463" href="1Lab.Type.Sigma.html#3673" class="Function">α≡ρ</a> <a id="3467" href="1Lab.Type.Sigma.html#3431" class="Bound">i</a><a id="3468" class="Symbol">)</a> <a id="3470" class="Symbol">(</a><a id="3471" href="1Lab.Type.Sigma.html#3856" class="Function">coh</a> <a id="3475" href="1Lab.Type.Sigma.html#3431" class="Bound">i</a><a id="3476" class="Symbol">)</a> <a id="3478" class="Keyword">where</a>
      <a id="3490" class="Keyword">open</a> <a id="3495" href="1Lab.Type.html#1649" class="Module">Σ</a> <a id="3497" class="Symbol">(</a><a data-type="Iso (Σ (λ p → PathP (λ i → B₁ i (p i)) (x .snd) (y .snd)))
(PathP (λ i → Σ (B₁ i)) x y)" id="3498" href="1Lab.Type.Sigma.html#553" class="Function">Σ-PathP-iso</a> <a id="3510" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="3511" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="3515" class="Symbol">.</a><a data-type="isIso f → B₁ → A" id="3516" href="1Lab.Equiv.html#6080" class="Field">isIso.inv</a> <a id="3526" href="1Lab.Type.Sigma.html#3424" class="Bound">p</a><a id="3527" class="Symbol">)</a> <a id="3529" class="Keyword">renaming</a> <a id="3538" class="Symbol">(</a><a data-type="∑ A B₁ → A" id="3539" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="3543" class="Symbol">to</a> <a id="3546" class="Field">ρ</a><a id="3547" class="Symbol">;</a> <a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="3549" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="3553" class="Symbol">to</a> <a id="3556" class="Field">σ</a><a id="3557" class="Symbol">)</a>
      <a id="3565" class="Keyword">open</a> <a id="3570" href="1Lab.Type.html#1649" class="Module">Σ</a> <a id="3572" class="Symbol">(</a><a data-type="Iso (Σ (λ p → PathP (λ i → B₁ i (p i)) (x .snd) (y .snd)))
(PathP (λ i → Σ (B₁ i)) x y)" id="3573" href="1Lab.Type.Sigma.html#553" class="Function">Σ-PathP-iso</a> <a id="3585" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="3586" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="3590" class="Symbol">.</a><a data-type="isIso f → B₁ → A" id="3591" href="1Lab.Equiv.html#6080" class="Field">isIso.inv</a> <a id="3601" class="Symbol">(</a><a id="3602" href="1Lab.Type.Sigma.html#2821" class="Bound">e</a> <a id="3604" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="3605" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="3609" class="Symbol">.</a><a data-type="isEquiv f → (y : B₁) → isContr (fibre f y)" id="3610" href="1Lab.Equiv.html#2382" class="Field">isEqv</a> <a id="3616" href="1Lab.Type.Sigma.html#3096" class="Field">a&#39;</a> <a id="3619" class="Symbol">.</a><a data-type="(r : isContr A) (x : A) → r .centre ≡ x" id="3620" href="1Lab.HLevel.html#1415" class="Field">isContr.paths</a> <a id="3634" class="Symbol">(</a><a id="3635" href="1Lab.Type.Sigma.html#3415" class="Bound">r</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="3637" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3639" href="1Lab.Type.Sigma.html#3546" class="Function">ρ</a><a id="3640" class="Symbol">)))</a> <a id="3644" class="Keyword">renaming</a> <a id="3653" class="Symbol">(</a><a data-type="∑ A B₁ → A" id="3654" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="3658" class="Symbol">to</a> <a id="3661" class="Field">a≡r</a><a id="3664" class="Symbol">;</a> <a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="3666" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="3670" class="Symbol">to</a> <a id="3673" class="Field">α≡ρ</a><a id="3676" class="Symbol">)</a>

      <a id="3685" href="1Lab.Type.Sigma.html#3685" class="Function">b!≡s</a> <a id="3690" class="Symbol">:</a> <a id="3692" href="1Lab.Type.Sigma.html#2990" class="Function">PB</a> <a id="3695" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="3696" href="1Lab.Path.html#20807" class="Function">ap</a> <a id="3699" class="Symbol">(</a><a id="3700" href="1Lab.Type.Sigma.html#2821" class="Bound">e</a> <a id="3702" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="3703" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="3706" class="Symbol">)</a> <a id="3708" href="1Lab.Type.Sigma.html#3661" class="Function">a≡r</a><a id="3711" class="Symbol">)</a> <a id="3713" href="1Lab.Type.Sigma.html#3194" class="Function">ctrB</a> <a id="3718" href="1Lab.Type.Sigma.html#3419" class="Bound">s</a>
      <a id="3726" href="1Lab.Type.Sigma.html#3685" class="Function">b!≡s</a> <a id="3731" href="1Lab.Type.Sigma.html#3731" class="Bound">i</a> <a id="3733" class="Symbol">=</a> <a id="3735" href="1Lab.Path.html#2332" class="Primitive">comp</a> <a id="3740" class="Symbol">(λ</a> <a id="3743" href="1Lab.Type.Sigma.html#3743" class="Bound">k</a> <a id="3745" class="Symbol">→</a> <a id="3747" href="1Lab.Type.Sigma.html#2818" class="Bound">B</a> <a id="3749" class="Symbol">(</a><a id="3750" href="1Lab.Type.Sigma.html#3673" class="Function">α≡ρ</a> <a id="3754" href="1Lab.Type.Sigma.html#3731" class="Bound">i</a> <a id="3756" class="Symbol">(</a><a id="3757" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="3759" href="1Lab.Type.Sigma.html#3743" class="Bound">k</a><a id="3760" class="Symbol">)))</a> <a id="3764" class="Symbol">(λ</a> <a id="3767" href="1Lab.Type.Sigma.html#3767" class="Bound">k</a> <a id="3769" class="Symbol">→</a> <a id="3771" class="Symbol">(λ</a>
        <a id="3782" class="Symbol">{</a> <a id="3784" class="Symbol">(</a><a id="3785" href="1Lab.Type.Sigma.html#3731" class="Bound">i</a> <a id="3787" class="Symbol">=</a> <a id="3789" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="3791" class="Symbol">)</a> <a id="3793" class="Symbol">→</a> <a id="3795" href="1Lab.Type.Sigma.html#3251" class="Function">ctrP</a> <a id="3800" class="Symbol">(</a><a id="3801" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="3803" href="1Lab.Type.Sigma.html#3767" class="Bound">k</a><a id="3804" class="Symbol">)</a>
        <a id="3814" class="Symbol">;</a> <a id="3816" class="Symbol">(</a><a id="3817" href="1Lab.Type.Sigma.html#3731" class="Bound">i</a> <a id="3819" class="Symbol">=</a> <a id="3821" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="3823" class="Symbol">)</a> <a id="3825" class="Symbol">→</a> <a id="3827" href="1Lab.Type.Sigma.html#3556" class="Function">σ</a> <a id="3829" class="Symbol">(</a><a id="3830" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="3832" href="1Lab.Type.Sigma.html#3767" class="Bound">k</a><a id="3833" class="Symbol">)</a>
        <a id="3843" class="Symbol">}))</a> <a id="3847" href="1Lab.Type.Sigma.html#3107" class="Field">b</a>

      <a id="3856" href="1Lab.Type.Sigma.html#3856" class="Function">coh</a> <a id="3860" class="Symbol">:</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="3862" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="3868" class="Symbol">(λ</a> <a id="3871" href="1Lab.Type.Sigma.html#3871" class="Bound">i</a> <a id="3873" class="Symbol">→</a> <a id="3875" href="1Lab.Type.Sigma.html#2990" class="Function">PB</a> <a id="3878" class="Symbol">(</a><a id="3879" href="1Lab.Type.Sigma.html#3673" class="Function">α≡ρ</a> <a id="3883" href="1Lab.Type.Sigma.html#3871" class="Bound">i</a><a id="3884" class="Symbol">)</a> <a id="3886" class="Symbol">(</a><a id="3887" href="1Lab.Type.Sigma.html#3685" class="Function">b!≡s</a> <a id="3892" href="1Lab.Type.Sigma.html#3871" class="Bound">i</a><a id="3893" class="Symbol">)</a> <a id="3895" href="1Lab.Type.Sigma.html#3107" class="Field">b</a><a id="3896" class="Symbol">)</a> <a id="3898" href="1Lab.Type.Sigma.html#3251" class="Function">ctrP</a> <a id="3903" href="1Lab.Type.Sigma.html#3556" class="Function">σ</a>
      <a id="3911" href="1Lab.Type.Sigma.html#3856" class="Function">coh</a> <a id="3915" href="1Lab.Type.Sigma.html#3915" class="Bound">i</a> <a id="3917" href="1Lab.Type.Sigma.html#3917" class="Bound">j</a> <a id="3919" class="Symbol">=</a> <a data-type="(A : I → Type ℓ) (u : (i : I) → Partial φ (A i))
(u0 : A i0 [ φ ↦ u i0 ]) →
PathP A (outS u0) (comp A u (outS u0))" id="3921" href="1Lab.Path.html#37643" class="Function">fill</a> <a id="3926" class="Symbol">(λ</a> <a id="3929" href="1Lab.Type.Sigma.html#3929" class="Bound">k</a> <a id="3931" class="Symbol">→</a> <a id="3933" href="1Lab.Type.Sigma.html#2818" class="Bound">B</a> <a id="3935" class="Symbol">(</a><a id="3936" href="1Lab.Type.Sigma.html#3673" class="Function">α≡ρ</a> <a id="3940" href="1Lab.Type.Sigma.html#3915" class="Bound">i</a> <a id="3942" class="Symbol">(</a><a id="3943" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="3945" href="1Lab.Type.Sigma.html#3929" class="Bound">k</a><a id="3946" class="Symbol">)))</a> <a id="3950" class="Symbol">(λ</a> <a id="3953" href="1Lab.Type.Sigma.html#3953" class="Bound">k</a> <a id="3955" class="Symbol">→</a> <a id="3957" class="Symbol">(λ</a>
        <a id="3968" class="Symbol">{</a> <a id="3970" class="Symbol">(</a><a id="3971" href="1Lab.Type.Sigma.html#3915" class="Bound">i</a> <a id="3973" class="Symbol">=</a> <a id="3975" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="3977" class="Symbol">)</a> <a id="3979" class="Symbol">→</a> <a id="3981" href="1Lab.Type.Sigma.html#3251" class="Function">ctrP</a> <a id="3986" class="Symbol">(</a><a id="3987" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="3989" href="1Lab.Type.Sigma.html#3953" class="Bound">k</a><a id="3990" class="Symbol">)</a>
        <a id="4000" class="Symbol">;</a> <a id="4002" class="Symbol">(</a><a id="4003" href="1Lab.Type.Sigma.html#3915" class="Bound">i</a> <a id="4005" class="Symbol">=</a> <a id="4007" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="4009" class="Symbol">)</a> <a id="4011" class="Symbol">→</a> <a id="4013" href="1Lab.Type.Sigma.html#3556" class="Function">σ</a> <a id="4015" class="Symbol">(</a><a id="4016" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="4018" href="1Lab.Type.Sigma.html#3953" class="Bound">k</a><a id="4019" class="Symbol">)</a>
        <a id="4029" class="Symbol">}))</a> <a id="4033" class="Symbol">(</a><a id="4034" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="4038" href="1Lab.Type.Sigma.html#3107" class="Field">b</a><a id="4039" class="Symbol">)</a> <a id="4041" class="Symbol">(</a><a id="4042" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="4044" href="1Lab.Type.Sigma.html#3917" class="Bound">j</a><a id="4045" class="Symbol">)</a>

<a id="Σ-assoc"></a><a data-type="Σ (λ x → Σ (C x)) ≃ Σ (λ x → C (x .fst) (x .snd))" id="4048" href="1Lab.Type.Sigma.html#4048" class="Function">Σ-assoc</a> <a id="4056" class="Symbol">:</a> <a id="4058" class="Symbol">∀</a> <a id="4060" class="Symbol">{</a><a id="4061" href="1Lab.Type.Sigma.html#4061" class="Bound">ℓ</a> <a id="4063" href="1Lab.Type.Sigma.html#4063" class="Bound">ℓ&#39;</a> <a id="4066" href="1Lab.Type.Sigma.html#4066" class="Bound">ℓ&#39;&#39;</a><a id="4069" class="Symbol">}</a> <a id="4071" class="Symbol">{</a><a id="4072" href="1Lab.Type.Sigma.html#4072" class="Bound">A</a> <a id="4074" class="Symbol">:</a> <a id="4076" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="4081" href="1Lab.Type.Sigma.html#4061" class="Bound">ℓ</a><a id="4082" class="Symbol">}</a> <a id="4084" class="Symbol">{</a><a id="4085" href="1Lab.Type.Sigma.html#4085" class="Bound">B</a> <a id="4087" class="Symbol">:</a> <a id="4089" href="1Lab.Type.Sigma.html#4072" class="Bound">A</a> <a id="4091" class="Symbol">→</a> <a id="4093" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="4098" href="1Lab.Type.Sigma.html#4063" class="Bound">ℓ&#39;</a><a id="4100" class="Symbol">}</a> <a id="4102" class="Symbol">{</a><a id="4103" href="1Lab.Type.Sigma.html#4103" class="Bound">C</a> <a id="4105" class="Symbol">:</a> <a id="4107" class="Symbol">(</a><a id="4108" href="1Lab.Type.Sigma.html#4108" class="Bound">x</a> <a id="4110" class="Symbol">:</a> <a id="4112" href="1Lab.Type.Sigma.html#4072" class="Bound">A</a><a id="4113" class="Symbol">)</a> <a id="4115" class="Symbol">→</a> <a id="4117" href="1Lab.Type.Sigma.html#4085" class="Bound">B</a> <a id="4119" href="1Lab.Type.Sigma.html#4108" class="Bound">x</a> <a id="4121" class="Symbol">→</a> <a id="4123" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="4128" href="1Lab.Type.Sigma.html#4066" class="Bound">ℓ&#39;&#39;</a><a id="4131" class="Symbol">}</a>
        <a id="4141" class="Symbol">→</a> <a id="4143" class="Symbol">(</a><a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="4144" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="4147" href="1Lab.Type.Sigma.html#4147" class="Bound">x</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="4149" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="4151" href="1Lab.Type.Sigma.html#4072" class="Bound">A</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="4153" href="1Lab.Type.html#1563" class="Function">]</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="4155" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="4158" href="1Lab.Type.Sigma.html#4158" class="Bound">y</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="4160" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="4162" href="1Lab.Type.Sigma.html#4085" class="Bound">B</a> <a id="4164" href="1Lab.Type.Sigma.html#4147" class="Bound">x</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="4166" href="1Lab.Type.html#1563" class="Function">]</a> <a id="4168" href="1Lab.Type.Sigma.html#4103" class="Bound">C</a> <a id="4170" href="1Lab.Type.Sigma.html#4147" class="Bound">x</a> <a id="4172" href="1Lab.Type.Sigma.html#4158" class="Bound">y</a><a id="4173" class="Symbol">)</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="4175" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="4177" class="Symbol">(</a><a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="4178" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="4181" href="1Lab.Type.Sigma.html#4181" class="Bound">x</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="4183" href="1Lab.Type.html#1563" class="Function">∈</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="4185" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="4187" href="1Lab.Type.Sigma.html#4085" class="Bound">B</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="4189" href="1Lab.Type.html#1563" class="Function">]</a> <a id="4191" class="Symbol">(</a><a id="4192" href="1Lab.Type.Sigma.html#4103" class="Bound">C</a> <a id="4194" class="Symbol">(</a><a id="4195" href="1Lab.Type.Sigma.html#4181" class="Bound">x</a> <a id="4197" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="4198" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="4201" class="Symbol">)</a> <a id="4203" class="Symbol">(</a><a id="4204" href="1Lab.Type.Sigma.html#4181" class="Bound">x</a> <a id="4206" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="4207" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="4210" class="Symbol">)))</a>
<a data-type="Σ (λ x → Σ (C x)) ≃ Σ (λ x → C (x .fst) (x .snd))" id="4214" href="1Lab.Type.Sigma.html#4048" class="Function">Σ-assoc</a> <a id="4222" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="4223" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="4227" class="Symbol">(</a><a id="4228" href="1Lab.Type.Sigma.html#4228" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="4230" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4232" href="1Lab.Type.Sigma.html#4232" class="Bound">y</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="4234" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4236" href="1Lab.Type.Sigma.html#4236" class="Bound">z</a><a id="4237" class="Symbol">)</a> <a id="4239" class="Symbol">=</a> <a id="4241" class="Symbol">(</a><a id="4242" href="1Lab.Type.Sigma.html#4228" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="4244" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4246" href="1Lab.Type.Sigma.html#4232" class="Bound">y</a><a id="4247" class="Symbol">)</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="4249" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4251" href="1Lab.Type.Sigma.html#4236" class="Bound">z</a>
<a data-type="Σ (λ x → Σ (C x)) ≃ Σ (λ x → C (x .fst) (x .snd))" id="4253" href="1Lab.Type.Sigma.html#4048" class="Function">Σ-assoc</a> <a id="4261" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="4262" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="4266" class="Symbol">.</a><a data-type="isEquiv f → (y : B₁) → isContr (fibre f y)" id="4267" href="1Lab.Equiv.html#2382" class="Field">isEqv</a> <a id="4273" href="1Lab.Type.Sigma.html#4273" class="Bound">y</a> <a id="4275" class="Symbol">.</a><a data-type="isContr A → A" id="4276" href="1Lab.HLevel.html#1400" class="Field">centre</a> <a id="4283" class="Symbol">=</a> <a data-type="(g : B₁ → A) (b : B₁) →
Σ
(λ t →
   (t&#39; : fibre f b) →
   Path (fibre f (f (g b))) t
   (g (f (t&#39; .fst)) , ap (f ∘ g) (t&#39; .snd)))" id="4285" href="1Lab.Equiv.html#2799" class="Function">strict-fibres</a> <a id="4299" class="Symbol">(λ</a> <a id="4302" class="Symbol">{</a> <a id="4304" class="Symbol">((</a><a id="4306" href="1Lab.Type.Sigma.html#4306" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="4308" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4310" href="1Lab.Type.Sigma.html#4310" class="Bound">y</a><a id="4311" class="Symbol">)</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="4313" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4315" href="1Lab.Type.Sigma.html#4315" class="Bound">z</a><a id="4316" class="Symbol">)</a> <a id="4318" class="Symbol">→</a> <a id="4320" href="1Lab.Type.Sigma.html#4306" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="4322" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4324" href="1Lab.Type.Sigma.html#4310" class="Bound">y</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="4326" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4328" href="1Lab.Type.Sigma.html#4315" class="Bound">z</a><a id="4329" class="Symbol">})</a> <a id="4332" href="1Lab.Type.Sigma.html#4273" class="Bound">y</a> <a id="4334" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="4335" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a>
<a data-type="Σ (λ x → Σ (C x)) ≃ Σ (λ x → C (x .fst) (x .snd))" id="4339" href="1Lab.Type.Sigma.html#4048" class="Function">Σ-assoc</a> <a id="4347" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="4348" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="4352" class="Symbol">.</a><a data-type="isEquiv f → (y : B₁) → isContr (fibre f y)" id="4353" href="1Lab.Equiv.html#2382" class="Field">isEqv</a> <a id="4359" href="1Lab.Type.Sigma.html#4359" class="Bound">y</a> <a id="4361" class="Symbol">.</a><a data-type="(r : isContr A) (x : A) → r .centre ≡ x" id="4362" href="1Lab.HLevel.html#1415" class="Field">paths</a> <a id="4368" class="Symbol">=</a> <a data-type="(g : B₁ → A) (b : B₁) →
Σ
(λ t →
   (t&#39; : fibre f b) →
   Path (fibre f (f (g b))) t
   (g (f (t&#39; .fst)) , ap (f ∘ g) (t&#39; .snd)))" id="4370" href="1Lab.Equiv.html#2799" class="Function">strict-fibres</a> <a id="4384" class="Symbol">(λ</a> <a id="4387" class="Symbol">{</a> <a id="4389" class="Symbol">((</a><a id="4391" href="1Lab.Type.Sigma.html#4391" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="4393" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4395" href="1Lab.Type.Sigma.html#4395" class="Bound">y</a><a id="4396" class="Symbol">)</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="4398" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4400" href="1Lab.Type.Sigma.html#4400" class="Bound">z</a><a id="4401" class="Symbol">)</a> <a id="4403" class="Symbol">→</a> <a id="4405" href="1Lab.Type.Sigma.html#4391" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="4407" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4409" href="1Lab.Type.Sigma.html#4395" class="Bound">y</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="4411" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4413" href="1Lab.Type.Sigma.html#4400" class="Bound">z</a><a id="4414" class="Symbol">})</a> <a id="4417" href="1Lab.Type.Sigma.html#4359" class="Bound">y</a> <a id="4419" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="4420" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a>

<a id="Σ-Π-distrib"></a><a data-type="((x : A) → Σ (C x)) ≃ Σ (λ f → (x : A) → C x (f x))" id="4425" href="1Lab.Type.Sigma.html#4425" class="Function">Σ-Π-distrib</a> <a id="4437" class="Symbol">:</a> <a id="4439" class="Symbol">∀</a> <a id="4441" class="Symbol">{</a><a id="4442" href="1Lab.Type.Sigma.html#4442" class="Bound">ℓ</a> <a id="4444" href="1Lab.Type.Sigma.html#4444" class="Bound">ℓ&#39;</a> <a id="4447" href="1Lab.Type.Sigma.html#4447" class="Bound">ℓ&#39;&#39;</a><a id="4450" class="Symbol">}</a> <a id="4452" class="Symbol">{</a><a id="4453" href="1Lab.Type.Sigma.html#4453" class="Bound">A</a> <a id="4455" class="Symbol">:</a> <a id="4457" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="4462" href="1Lab.Type.Sigma.html#4442" class="Bound">ℓ</a><a id="4463" class="Symbol">}</a> <a id="4465" class="Symbol">{</a><a id="4466" href="1Lab.Type.Sigma.html#4466" class="Bound">B</a> <a id="4468" class="Symbol">:</a> <a id="4470" href="1Lab.Type.Sigma.html#4453" class="Bound">A</a> <a id="4472" class="Symbol">→</a> <a id="4474" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="4479" href="1Lab.Type.Sigma.html#4444" class="Bound">ℓ&#39;</a><a id="4481" class="Symbol">}</a> <a id="4483" class="Symbol">{</a><a id="4484" href="1Lab.Type.Sigma.html#4484" class="Bound">C</a> <a id="4486" class="Symbol">:</a> <a id="4488" class="Symbol">(</a><a id="4489" href="1Lab.Type.Sigma.html#4489" class="Bound">x</a> <a id="4491" class="Symbol">:</a> <a id="4493" href="1Lab.Type.Sigma.html#4453" class="Bound">A</a><a id="4494" class="Symbol">)</a> <a id="4496" class="Symbol">→</a> <a id="4498" href="1Lab.Type.Sigma.html#4466" class="Bound">B</a> <a id="4500" href="1Lab.Type.Sigma.html#4489" class="Bound">x</a> <a id="4502" class="Symbol">→</a> <a id="4504" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="4509" href="1Lab.Type.Sigma.html#4447" class="Bound">ℓ&#39;&#39;</a><a id="4512" class="Symbol">}</a>
            <a id="4526" class="Symbol">→</a> <a id="4528" class="Symbol">((</a><a id="4530" href="1Lab.Type.Sigma.html#4530" class="Bound">x</a> <a id="4532" class="Symbol">:</a> <a id="4534" href="1Lab.Type.Sigma.html#4453" class="Bound">A</a><a id="4535" class="Symbol">)</a> <a id="4537" class="Symbol">→</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="4539" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="4542" href="1Lab.Type.Sigma.html#4542" class="Bound">y</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="4544" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="4546" href="1Lab.Type.Sigma.html#4466" class="Bound">B</a> <a id="4548" href="1Lab.Type.Sigma.html#4530" class="Bound">x</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="4550" href="1Lab.Type.html#1563" class="Function">]</a> <a id="4552" href="1Lab.Type.Sigma.html#4484" class="Bound">C</a> <a id="4554" href="1Lab.Type.Sigma.html#4530" class="Bound">x</a> <a id="4556" href="1Lab.Type.Sigma.html#4542" class="Bound">y</a><a id="4557" class="Symbol">)</a>
            <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="4571" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="4573" class="Symbol">(</a><a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="4574" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="4577" href="1Lab.Type.Sigma.html#4577" class="Bound">f</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="4579" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="4581" class="Symbol">((</a><a id="4583" href="1Lab.Type.Sigma.html#4583" class="Bound">x</a> <a id="4585" class="Symbol">:</a> <a id="4587" href="1Lab.Type.Sigma.html#4453" class="Bound">A</a><a id="4588" class="Symbol">)</a> <a id="4590" class="Symbol">→</a> <a id="4592" href="1Lab.Type.Sigma.html#4466" class="Bound">B</a> <a id="4594" href="1Lab.Type.Sigma.html#4583" class="Bound">x</a><a id="4595" class="Symbol">)</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="4597" href="1Lab.Type.html#1563" class="Function">]</a> <a id="4599" class="Symbol">((</a><a id="4601" href="1Lab.Type.Sigma.html#4601" class="Bound">x</a> <a id="4603" class="Symbol">:</a> <a id="4605" href="1Lab.Type.Sigma.html#4453" class="Bound">A</a><a id="4606" class="Symbol">)</a> <a id="4608" class="Symbol">→</a> <a id="4610" href="1Lab.Type.Sigma.html#4484" class="Bound">C</a> <a id="4612" href="1Lab.Type.Sigma.html#4601" class="Bound">x</a> <a id="4614" class="Symbol">(</a><a id="4615" href="1Lab.Type.Sigma.html#4577" class="Bound">f</a> <a id="4617" href="1Lab.Type.Sigma.html#4601" class="Bound">x</a><a id="4618" class="Symbol">)))</a>
<a data-type="((x : A) → Σ (C x)) ≃ Σ (λ f → (x : A) → C x (f x))" id="4622" href="1Lab.Type.Sigma.html#4425" class="Function">Σ-Π-distrib</a> <a id="4634" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="4635" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="4639" href="1Lab.Type.Sigma.html#4639" class="Bound">f</a> <a id="4641" class="Symbol">=</a> <a id="4643" class="Symbol">(λ</a> <a id="4646" href="1Lab.Type.Sigma.html#4646" class="Bound">x</a> <a id="4648" class="Symbol">→</a> <a id="4650" href="1Lab.Type.Sigma.html#4639" class="Bound">f</a> <a id="4652" href="1Lab.Type.Sigma.html#4646" class="Bound">x</a> <a id="4654" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="4655" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="4658" class="Symbol">)</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="4660" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4662" class="Symbol">λ</a> <a id="4664" href="1Lab.Type.Sigma.html#4664" class="Bound">x</a> <a id="4666" class="Symbol">→</a> <a id="4668" href="1Lab.Type.Sigma.html#4639" class="Bound">f</a> <a id="4670" href="1Lab.Type.Sigma.html#4664" class="Bound">x</a> <a id="4672" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="4673" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a>
<a data-type="((x : A) → Σ (C x)) ≃ Σ (λ f → (x : A) → C x (f x))" id="4677" href="1Lab.Type.Sigma.html#4425" class="Function">Σ-Π-distrib</a> <a id="4689" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="4690" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="4694" class="Symbol">.</a><a data-type="isEquiv f → (y : B₁) → isContr (fibre f y)" id="4695" href="1Lab.Equiv.html#2382" class="Field">isEqv</a> <a id="4701" href="1Lab.Type.Sigma.html#4701" class="Bound">y</a> <a id="4703" class="Symbol">.</a><a data-type="isContr A → A" id="4704" href="1Lab.HLevel.html#1400" class="Field">centre</a> <a id="4711" class="Symbol">=</a> <a data-type="(g : B₁ → A) (b : B₁) →
Σ
(λ t →
   (t&#39; : fibre f b) →
   Path (fibre f (f (g b))) t
   (g (f (t&#39; .fst)) , ap (f ∘ g) (t&#39; .snd)))" id="4713" href="1Lab.Equiv.html#2799" class="Function">strict-fibres</a> <a id="4727" class="Symbol">(λ</a> <a id="4730" href="1Lab.Type.Sigma.html#4730" class="Bound">f</a> <a id="4732" href="1Lab.Type.Sigma.html#4732" class="Bound">x</a> <a id="4734" class="Symbol">→</a> <a id="4736" href="1Lab.Type.Sigma.html#4730" class="Bound">f</a> <a id="4738" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="4739" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="4743" href="1Lab.Type.Sigma.html#4732" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="4745" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4747" href="1Lab.Type.Sigma.html#4730" class="Bound">f</a> <a id="4749" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="4750" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="4754" href="1Lab.Type.Sigma.html#4732" class="Bound">x</a><a id="4755" class="Symbol">)</a> <a id="4757" href="1Lab.Type.Sigma.html#4701" class="Bound">y</a> <a id="4759" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="4760" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a>
<a data-type="((x : A) → Σ (C x)) ≃ Σ (λ f → (x : A) → C x (f x))" id="4764" href="1Lab.Type.Sigma.html#4425" class="Function">Σ-Π-distrib</a> <a id="4776" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="4777" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="4781" class="Symbol">.</a><a data-type="isEquiv f → (y : B₁) → isContr (fibre f y)" id="4782" href="1Lab.Equiv.html#2382" class="Field">isEqv</a> <a id="4788" href="1Lab.Type.Sigma.html#4788" class="Bound">y</a> <a id="4790" class="Symbol">.</a><a data-type="(r : isContr A) (x : A) → r .centre ≡ x" id="4791" href="1Lab.HLevel.html#1415" class="Field">paths</a> <a id="4797" class="Symbol">=</a> <a data-type="(g : B₁ → A) (b : B₁) →
Σ
(λ t →
   (t&#39; : fibre f b) →
   Path (fibre f (f (g b))) t
   (g (f (t&#39; .fst)) , ap (f ∘ g) (t&#39; .snd)))" id="4799" href="1Lab.Equiv.html#2799" class="Function">strict-fibres</a> <a id="4813" class="Symbol">(λ</a> <a id="4816" href="1Lab.Type.Sigma.html#4816" class="Bound">f</a> <a id="4818" href="1Lab.Type.Sigma.html#4818" class="Bound">x</a> <a id="4820" class="Symbol">→</a> <a id="4822" href="1Lab.Type.Sigma.html#4816" class="Bound">f</a> <a id="4824" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="4825" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="4829" href="1Lab.Type.Sigma.html#4818" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="4831" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4833" href="1Lab.Type.Sigma.html#4816" class="Bound">f</a> <a id="4835" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="4836" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="4840" href="1Lab.Type.Sigma.html#4818" class="Bound">x</a><a id="4841" class="Symbol">)</a> <a id="4843" href="1Lab.Type.Sigma.html#4788" class="Bound">y</a> <a id="4845" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="4846" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a>
</pre>
</details>
<h2 id="paths-in-subtypes"><a href="#paths-in-subtypes" class="header-link">Paths in subtypes<span class="header-link-emoji">🔗</span></a></h2>
<p>When <code>P</code> is a family of propositions, it is sound to regard <code>Σ[ x ∈ A ] (P x)</code> as a <em>subtype</em> of <code>A</code>. This is because identification in the subtype is characterised uniquely by identification of the first projections:</p>
<pre class="Agda"><a id="Σ≡Prop"></a><a data-type="((x : A) → isProp (B₁ x)) → x .fst ≡ y .fst → x ≡ y" id="5116" href="1Lab.Type.Sigma.html#5116" class="Function">Σ≡Prop</a> <a id="5123" class="Symbol">:</a> <a id="5125" class="Symbol">{</a><a id="5126" href="1Lab.Type.Sigma.html#5126" class="Bound">B</a> <a id="5128" class="Symbol">:</a> <a id="5130" href="1Lab.Type.Sigma.html#174" class="Generalizable">A</a> <a id="5132" class="Symbol">→</a> <a id="5134" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="5139" href="1Lab.Type.Sigma.html#159" class="Generalizable">ℓ</a><a id="5140" class="Symbol">}</a>
       <a id="5149" class="Symbol">→</a> <a id="5151" class="Symbol">(∀</a> <a id="5154" href="1Lab.Type.Sigma.html#5154" class="Bound">x</a> <a id="5156" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="5158" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="5165" class="Symbol">(</a><a id="5166" href="1Lab.Type.Sigma.html#5126" class="Bound">B</a> <a id="5168" href="1Lab.Type.Sigma.html#5154" class="Bound">x</a><a id="5169" class="Symbol">))</a>
       <a id="5179" class="Symbol">→</a> <a id="5181" class="Symbol">{</a><a id="5182" href="1Lab.Type.Sigma.html#5182" class="Bound">x</a> <a id="5184" href="1Lab.Type.Sigma.html#5184" class="Bound">y</a> <a id="5186" class="Symbol">:</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="5188" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="5190" href="1Lab.Type.Sigma.html#5126" class="Bound">B</a><a id="5191" class="Symbol">}</a>
       <a id="5200" class="Symbol">→</a> <a id="5202" class="Symbol">(</a><a id="5203" href="1Lab.Type.Sigma.html#5182" class="Bound">x</a> <a id="5205" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="5206" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="A → A → Type ℓ" id="5210" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="5212" href="1Lab.Type.Sigma.html#5184" class="Bound">y</a> <a id="5214" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="5215" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="5218" class="Symbol">)</a> <a id="5220" class="Symbol">→</a> <a id="5222" href="1Lab.Type.Sigma.html#5182" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="5224" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="5226" href="1Lab.Type.Sigma.html#5184" class="Bound">y</a>
<a data-type="((x : A) → isProp (B₁ x)) → x .fst ≡ y .fst → x ≡ y" id="5228" href="1Lab.Type.Sigma.html#5116" class="Function">Σ≡Prop</a> <a id="5235" href="1Lab.Type.Sigma.html#5235" class="Bound">bp</a> <a id="5238" class="Symbol">{</a><a id="5239" href="1Lab.Type.Sigma.html#5239" class="Bound">x</a><a id="5240" class="Symbol">}</a> <a id="5242" class="Symbol">{</a><a id="5243" href="1Lab.Type.Sigma.html#5243" class="Bound">y</a><a id="5244" class="Symbol">}</a> <a id="5246" href="1Lab.Type.Sigma.html#5246" class="Bound">p</a> <a id="5248" href="1Lab.Type.Sigma.html#5248" class="Bound">i</a> <a id="5250" class="Symbol">=</a> <a id="5252" href="1Lab.Type.Sigma.html#5246" class="Bound">p</a> <a id="5254" href="1Lab.Type.Sigma.html#5248" class="Bound">i</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="5256" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="((i : I) → isProp (B₁ i)) →
(b0 : B₁ i0) (b1 : B₁ i1) → PathP B₁ b0 b1" id="5258" href="1Lab.HLevel.html#13502" class="Function">isProp→PathP</a> <a id="5271" class="Symbol">(λ</a> <a id="5274" href="1Lab.Type.Sigma.html#5274" class="Bound">i</a> <a id="5276" class="Symbol">→</a> <a id="5278" href="1Lab.Type.Sigma.html#5235" class="Bound">bp</a> <a id="5281" class="Symbol">(</a><a id="5282" href="1Lab.Type.Sigma.html#5246" class="Bound">p</a> <a id="5284" href="1Lab.Type.Sigma.html#5274" class="Bound">i</a><a id="5285" class="Symbol">))</a> <a id="5288" class="Symbol">(</a><a id="5289" href="1Lab.Type.Sigma.html#5239" class="Bound">x</a> <a id="5291" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="5292" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="5295" class="Symbol">)</a> <a id="5297" class="Symbol">(</a><a id="5298" href="1Lab.Type.Sigma.html#5243" class="Bound">y</a> <a id="5300" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="5301" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="5304" class="Symbol">)</a> <a id="5306" href="1Lab.Type.Sigma.html#5248" class="Bound">i</a>
</pre>
<p>The proof that this is an equivalence uses a cubical argument, but the gist of it is that since <code>B</code> is a family of propositions, it really doesn’t matter where we get our equality of <code>B</code>-s from - whether it was from the input, or from <code class="sourceCode agda">Σ≡Path</code>.</p>
<pre class="Agda"><a id="isEquiv-Σ≡Prop"></a><a data-type="(bp : (x : A) → isProp (B₁ x)) → isEquiv (Σ≡Prop bp)" id="5574" href="1Lab.Type.Sigma.html#5574" class="Function">isEquiv-Σ≡Prop</a>
  <a id="5591" class="Symbol">:</a> <a id="5593" class="Symbol">{</a><a id="5594" href="1Lab.Type.Sigma.html#5594" class="Bound">B</a> <a id="5596" class="Symbol">:</a> <a id="5598" href="1Lab.Type.Sigma.html#174" class="Generalizable">A</a> <a id="5600" class="Symbol">→</a> <a id="5602" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="5607" href="1Lab.Type.Sigma.html#159" class="Generalizable">ℓ</a><a id="5608" class="Symbol">}</a>
  <a id="5612" class="Symbol">→</a> <a id="5614" class="Symbol">(</a><a id="5615" href="1Lab.Type.Sigma.html#5615" class="Bound">bp</a> <a id="5618" class="Symbol">:</a> <a id="5620" class="Symbol">∀</a> <a id="5622" href="1Lab.Type.Sigma.html#5622" class="Bound">x</a> <a id="5624" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="5626" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="5633" class="Symbol">(</a><a id="5634" href="1Lab.Type.Sigma.html#5594" class="Bound">B</a> <a id="5636" href="1Lab.Type.Sigma.html#5622" class="Bound">x</a><a id="5637" class="Symbol">))</a>
  <a id="5642" class="Symbol">→</a> <a id="5644" class="Symbol">{</a><a id="5645" href="1Lab.Type.Sigma.html#5645" class="Bound">x</a> <a id="5647" href="1Lab.Type.Sigma.html#5647" class="Bound">y</a> <a id="5649" class="Symbol">:</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="5651" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="5653" href="1Lab.Type.Sigma.html#5594" class="Bound">B</a><a id="5654" class="Symbol">}</a>
  <a id="5658" class="Symbol">→</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="5660" href="1Lab.Equiv.html#2293" class="Record">isEquiv</a> <a id="5668" class="Symbol">(</a><a data-type="((x : A) → isProp (B₁ x)) → x .fst ≡ y .fst → x ≡ y" id="5669" href="1Lab.Type.Sigma.html#5116" class="Function">Σ≡Prop</a> <a id="5676" href="1Lab.Type.Sigma.html#5615" class="Bound">bp</a> <a id="5679" class="Symbol">{</a><a id="5680" href="1Lab.Type.Sigma.html#5645" class="Bound">x</a><a id="5681" class="Symbol">}</a> <a id="5683" class="Symbol">{</a><a id="5684" href="1Lab.Type.Sigma.html#5647" class="Bound">y</a><a id="5685" class="Symbol">})</a>
<a data-type="(bp : (x : A) → isProp (B₁ x)) → isEquiv (Σ≡Prop bp)" id="5688" href="1Lab.Type.Sigma.html#5574" class="Function">isEquiv-Σ≡Prop</a> <a id="5703" href="1Lab.Type.Sigma.html#5703" class="Bound">bp</a> <a id="5706" class="Symbol">{</a><a id="5707" href="1Lab.Type.Sigma.html#5707" class="Bound">x</a><a id="5708" class="Symbol">}</a> <a id="5710" class="Symbol">{</a><a id="5711" href="1Lab.Type.Sigma.html#5711" class="Bound">y</a><a id="5712" class="Symbol">}</a> <a id="5714" class="Symbol">=</a> <a data-type="(i : isIso f) → isEquiv f" id="5716" href="1Lab.Equiv.html#19775" class="Function">isIso→isEquiv</a> <a id="5730" href="1Lab.Type.Sigma.html#5745" class="Function">is-iso</a> <a id="5737" class="Keyword">where</a>
  <a id="5745" href="1Lab.Type.Sigma.html#5745" class="Function">is-iso</a> <a id="5752" class="Symbol">:</a> <a data-type="(f : A → B₁) → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="5754" href="1Lab.Equiv.html#5975" class="Record">isIso</a> <a id="5760" class="Symbol">_</a>
  <a id="5764" href="1Lab.Type.Sigma.html#5745" class="Function">is-iso</a> <a id="5771" class="Symbol">.</a><a data-type="isIso f → B₁ → A" id="5772" href="1Lab.Equiv.html#6080" class="Field">isIso.inv</a> <a id="5782" class="Symbol">=</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="5784" href="1Lab.Path.html#20807" class="Function">ap</a> <a data-type="∑ A B₁ → A" id="5787" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a>
  <a id="5793" href="1Lab.Type.Sigma.html#5745" class="Function">is-iso</a> <a id="5800" class="Symbol">.</a><a data-type="(r : isIso f) → isLeftInverse (r .inv) f" id="5801" href="1Lab.Equiv.html#6128" class="Field">isIso.linv</a> <a id="5812" href="1Lab.Type.Sigma.html#5812" class="Bound">p</a> <a id="5814" class="Symbol">=</a> <a data-type="x ≡ x" id="5816" href="1Lab.Path.html#3591" class="Function">refl</a>
</pre>
<p>The <span class="Agda"><a data-type="isIso f → B₁ → A" href="1Lab.Equiv.html#6080" class="Field">inverse</a></span> is the <span class="Agda"><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" href="1Lab.Path.html#20807" class="Function">action on paths</a></span> of the <span class="Agda"><a data-type="∑ A B₁ → A" href="Agda.Builtin.Sigma.html#252" class="Field">first projection</a></span>, which lets us conclude <code>x .fst ≡ y .fst</code> from <code>x ≡ y</code>. This is a left inverse to <span class="Agda"><a data-type="((x : A) → isProp (B₁ x)) → x .fst ≡ y .fst → x ≡ y" href="1Lab.Type.Sigma.html#5116" class="Function">Σ≡Prop</a></span> on the nose. For the other direction, we have the aforementioned cubical argument:</p>
<pre class="Agda">  <a id="6139" href="1Lab.Type.Sigma.html#5745" class="Function">is-iso</a> <a id="6146" class="Symbol">.</a><a data-type="(r : isIso f) → isRightInverse (r .inv) f" id="6147" href="1Lab.Equiv.html#6096" class="Field">isIso.rinv</a> <a id="6158" href="1Lab.Type.Sigma.html#6158" class="Bound">p</a> <a id="6160" href="1Lab.Type.Sigma.html#6160" class="Bound">i</a> <a id="6162" href="1Lab.Type.Sigma.html#6162" class="Bound">j</a> <a id="6164" class="Symbol">=</a>
    <a id="6170" href="1Lab.Type.Sigma.html#6158" class="Bound">p</a> <a id="6172" href="1Lab.Type.Sigma.html#6162" class="Bound">j</a> <a id="6174" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="6175" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="6179" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="((i : I) → isProp (B₁ i)) →
(b0 : B₁ i0) (b1 : B₁ i1) → PathP B₁ b0 b1" id="6181" href="1Lab.HLevel.html#13502" class="Function">isProp→PathP</a> <a id="6194" class="Symbol">(λ</a> <a id="6197" href="1Lab.Type.Sigma.html#6197" class="Bound">k</a> <a id="6199" class="Symbol">→</a> <a data-type="(n : Nat) → isHLevel A n → isHLevel (x ≡ y) n" id="6201" href="1Lab.HLevel.html#9738" class="Function">isHLevelPath</a> <a id="6214" class="Number">1</a> <a id="6216" class="Symbol">(</a><a id="6217" href="1Lab.Type.Sigma.html#5703" class="Bound">bp</a> <a id="6220" class="Symbol">(</a><a id="6221" href="1Lab.Type.Sigma.html#6158" class="Bound">p</a> <a id="6223" href="1Lab.Type.Sigma.html#6197" class="Bound">k</a> <a id="6225" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="6226" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="6229" class="Symbol">))</a>
                                      <a id="6270" class="Symbol">{</a><a id="6271" class="Argument">x</a> <a id="6273" class="Symbol">=</a> <a data-type="((x : A) → isProp (B₁ x)) → x .fst ≡ y .fst → x ≡ y" id="6275" href="1Lab.Type.Sigma.html#5116" class="Function">Σ≡Prop</a> <a id="6282" href="1Lab.Type.Sigma.html#5703" class="Bound">bp</a> <a id="6285" class="Symbol">{</a><a id="6286" href="1Lab.Type.Sigma.html#5707" class="Bound">x</a><a id="6287" class="Symbol">}</a> <a id="6289" class="Symbol">{</a><a id="6290" href="1Lab.Type.Sigma.html#5711" class="Bound">y</a><a id="6291" class="Symbol">}</a> <a id="6293" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="6294" href="1Lab.Path.html#20807" class="Function">ap</a> <a data-type="∑ A B₁ → A" id="6297" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="6301" href="1Lab.Type.Sigma.html#6158" class="Bound">p</a><a id="6302" class="Symbol">)</a> <a id="6304" href="1Lab.Type.Sigma.html#6197" class="Bound">k</a> <a id="6306" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="6307" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="6310" class="Symbol">}</a>
                                      <a id="6350" class="Symbol">{</a><a id="6351" class="Argument">y</a> <a id="6353" class="Symbol">=</a> <a id="6355" href="1Lab.Type.Sigma.html#6158" class="Bound">p</a> <a id="6357" href="1Lab.Type.Sigma.html#6197" class="Bound">k</a> <a id="6359" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="6360" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="6363" class="Symbol">})</a>
                            <a data-type="x ≡ x" id="6394" href="1Lab.Path.html#3591" class="Function">refl</a> <a data-type="x ≡ x" id="6399" href="1Lab.Path.html#3591" class="Function">refl</a> <a id="6404" href="1Lab.Type.Sigma.html#6162" class="Bound">j</a> <a id="6406" href="1Lab.Type.Sigma.html#6160" class="Bound">i</a>
</pre>
<p>Since <span class="Agda"><a data-type="((x : A) → isProp (B₁ x)) → x .fst ≡ y .fst → x ≡ y" href="1Lab.Type.Sigma.html#5116" class="Function">Σ≡Prop</a></span> is an equivalence, this implies that its inverse, <code class="sourceCode agda">ap fst</code>, is also an equivalence; This is precisely what it means for <span class="Agda"><a data-type="∑ A B₁ → A" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a></span> to be an <a href="1Lab.Equiv.Embedding.html">embedding</a>.</p>
<p>There is also a convenient packaging of the previous two definitions into an equivalence:</p>
<pre class="Agda"><a id="Σ≡Prop≃"></a><a data-type="((x : A) → isProp (B₁ x)) → (x .fst ≡ y .fst) ≃ (x ≡ y)" id="6739" href="1Lab.Type.Sigma.html#6739" class="Function">Σ≡Prop≃</a> <a id="6747" class="Symbol">:</a> <a id="6749" class="Symbol">{</a><a id="6750" href="1Lab.Type.Sigma.html#6750" class="Bound">B</a> <a id="6752" class="Symbol">:</a> <a id="6754" href="1Lab.Type.Sigma.html#174" class="Generalizable">A</a> <a id="6756" class="Symbol">→</a> <a id="6758" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="6763" href="1Lab.Type.Sigma.html#159" class="Generalizable">ℓ</a><a id="6764" class="Symbol">}</a>
        <a id="6774" class="Symbol">→</a> <a id="6776" class="Symbol">(∀</a> <a id="6779" href="1Lab.Type.Sigma.html#6779" class="Bound">x</a> <a id="6781" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="6783" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="6790" class="Symbol">(</a><a id="6791" href="1Lab.Type.Sigma.html#6750" class="Bound">B</a> <a id="6793" href="1Lab.Type.Sigma.html#6779" class="Bound">x</a><a id="6794" class="Symbol">))</a>
        <a id="6805" class="Symbol">→</a> <a id="6807" class="Symbol">{</a><a id="6808" href="1Lab.Type.Sigma.html#6808" class="Bound">x</a> <a id="6810" href="1Lab.Type.Sigma.html#6810" class="Bound">y</a> <a id="6812" class="Symbol">:</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="6814" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="6816" href="1Lab.Type.Sigma.html#6750" class="Bound">B</a><a id="6817" class="Symbol">}</a>
        <a id="6827" class="Symbol">→</a> <a id="6829" class="Symbol">(</a><a id="6830" href="1Lab.Type.Sigma.html#6808" class="Bound">x</a> <a id="6832" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="6833" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a data-type="A → A → Type ℓ" id="6837" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="6839" href="1Lab.Type.Sigma.html#6810" class="Bound">y</a> <a id="6841" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="6842" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a><a id="6845" class="Symbol">)</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="6847" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="6849" class="Symbol">(</a><a id="6850" href="1Lab.Type.Sigma.html#6808" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="6852" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="6854" href="1Lab.Type.Sigma.html#6810" class="Bound">y</a><a id="6855" class="Symbol">)</a>
<a data-type="((x : A) → isProp (B₁ x)) → (x .fst ≡ y .fst) ≃ (x ≡ y)" id="6857" href="1Lab.Type.Sigma.html#6739" class="Function">Σ≡Prop≃</a> <a id="6865" href="1Lab.Type.Sigma.html#6865" class="Bound">bp</a> <a id="6868" class="Symbol">=</a> <a data-type="((x : A) → isProp (B₁ x)) → x .fst ≡ y .fst → x ≡ y" id="6870" href="1Lab.Type.Sigma.html#5116" class="Function">Σ≡Prop</a> <a id="6877" href="1Lab.Type.Sigma.html#6865" class="Bound">bp</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="6880" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="(bp : (x : A) → isProp (B₁ x)) → isEquiv (Σ≡Prop bp)" id="6882" href="1Lab.Type.Sigma.html#5574" class="Function">isEquiv-Σ≡Prop</a> <a id="6897" href="1Lab.Type.Sigma.html#6865" class="Bound">bp</a>

<a id="Σ≡Prop-Sq"></a><a data-type="((x : A) → isProp (B₁ x)) →
Square (ap fst p) (ap fst q) (ap fst s) (ap fst r) → Square p q s r" id="6901" href="1Lab.Type.Sigma.html#6901" class="Function">Σ≡Prop-Sq</a> <a id="6911" class="Symbol">:</a> <a id="6913" class="Symbol">∀</a> <a id="6915" class="Symbol">{</a><a id="6916" href="1Lab.Type.Sigma.html#6916" class="Bound">ℓ</a> <a id="6918" href="1Lab.Type.Sigma.html#6918" class="Bound">ℓ&#39;</a><a id="6920" class="Symbol">}</a> <a id="6922" class="Symbol">{</a><a id="6923" href="1Lab.Type.Sigma.html#6923" class="Bound">A</a> <a id="6925" class="Symbol">:</a> <a id="6927" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="6932" href="1Lab.Type.Sigma.html#6916" class="Bound">ℓ</a><a id="6933" class="Symbol">}</a> <a id="6935" class="Symbol">{</a><a id="6936" href="1Lab.Type.Sigma.html#6936" class="Bound">B</a> <a id="6938" class="Symbol">:</a> <a id="6940" href="1Lab.Type.Sigma.html#6923" class="Bound">A</a> <a id="6942" class="Symbol">→</a> <a id="6944" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="6949" href="1Lab.Type.Sigma.html#6918" class="Bound">ℓ&#39;</a><a id="6951" class="Symbol">}</a> 
          <a id="6964" class="Symbol">→</a> <a id="6966" class="Symbol">{</a><a id="6967" href="1Lab.Type.Sigma.html#6967" class="Bound">w</a> <a id="6969" href="1Lab.Type.Sigma.html#6969" class="Bound">x</a> <a id="6971" href="1Lab.Type.Sigma.html#6971" class="Bound">y</a> <a id="6973" href="1Lab.Type.Sigma.html#6973" class="Bound">z</a> <a id="6975" class="Symbol">:</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="6977" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="6979" href="1Lab.Type.Sigma.html#6936" class="Bound">B</a><a id="6980" class="Symbol">}</a> 
          <a id="6993" class="Symbol">→</a> <a id="6995" class="Symbol">(∀</a> <a id="6998" href="1Lab.Type.Sigma.html#6998" class="Bound">x</a> <a id="7000" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="7002" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="7009" class="Symbol">(</a><a id="7010" href="1Lab.Type.Sigma.html#6936" class="Bound">B</a> <a id="7012" href="1Lab.Type.Sigma.html#6998" class="Bound">x</a><a id="7013" class="Symbol">))</a>
          <a id="7026" class="Symbol">→</a> <a id="7028" class="Symbol">{</a><a id="7029" href="1Lab.Type.Sigma.html#7029" class="Bound">p</a> <a id="7031" class="Symbol">:</a> <a id="7033" href="1Lab.Type.Sigma.html#6969" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="7035" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="7037" href="1Lab.Type.Sigma.html#6967" class="Bound">w</a><a id="7038" class="Symbol">}</a> <a id="7040" class="Symbol">{</a><a id="7041" href="1Lab.Type.Sigma.html#7041" class="Bound">q</a> <a id="7043" class="Symbol">:</a> <a id="7045" href="1Lab.Type.Sigma.html#6969" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="7047" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="7049" href="1Lab.Type.Sigma.html#6971" class="Bound">y</a><a id="7050" class="Symbol">}</a> <a id="7052" class="Symbol">{</a><a id="7053" href="1Lab.Type.Sigma.html#7053" class="Bound">s</a> <a id="7055" class="Symbol">:</a> <a id="7057" href="1Lab.Type.Sigma.html#6967" class="Bound">w</a> <a data-type="A → A → Type ℓ" id="7059" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="7061" href="1Lab.Type.Sigma.html#6973" class="Bound">z</a><a id="7062" class="Symbol">}</a> <a id="7064" class="Symbol">{</a><a id="7065" href="1Lab.Type.Sigma.html#7065" class="Bound">r</a> <a id="7067" class="Symbol">:</a> <a id="7069" href="1Lab.Type.Sigma.html#6971" class="Bound">y</a> <a data-type="A → A → Type ℓ" id="7071" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="7073" href="1Lab.Type.Sigma.html#6973" class="Bound">z</a><a id="7074" class="Symbol">}</a>
          <a id="7086" class="Symbol">→</a> <a data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" id="7088" href="1Lab.Path.html#9479" class="Function">Square</a> <a id="7095" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="7096" href="1Lab.Path.html#20807" class="Function">ap</a> <a data-type="∑ A B₁ → A" id="7099" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="7103" href="1Lab.Type.Sigma.html#7029" class="Bound">p</a><a id="7104" class="Symbol">)</a> <a id="7106" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="7107" href="1Lab.Path.html#20807" class="Function">ap</a> <a data-type="∑ A B₁ → A" id="7110" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="7114" href="1Lab.Type.Sigma.html#7041" class="Bound">q</a><a id="7115" class="Symbol">)</a> <a id="7117" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="7118" href="1Lab.Path.html#20807" class="Function">ap</a> <a data-type="∑ A B₁ → A" id="7121" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="7125" href="1Lab.Type.Sigma.html#7053" class="Bound">s</a><a id="7126" class="Symbol">)</a> <a id="7128" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="7129" href="1Lab.Path.html#20807" class="Function">ap</a> <a data-type="∑ A B₁ → A" id="7132" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="7136" href="1Lab.Type.Sigma.html#7065" class="Bound">r</a><a id="7137" class="Symbol">)</a>
          <a id="7149" class="Symbol">→</a> <a data-type="a00 ≡ a01 → a00 ≡ a10 → a01 ≡ a11 → a10 ≡ a11 → Type ℓ" id="7151" href="1Lab.Path.html#9479" class="Function">Square</a> <a id="7158" href="1Lab.Type.Sigma.html#7029" class="Bound">p</a> <a id="7160" href="1Lab.Type.Sigma.html#7041" class="Bound">q</a> <a id="7162" href="1Lab.Type.Sigma.html#7053" class="Bound">s</a> <a id="7164" href="1Lab.Type.Sigma.html#7065" class="Bound">r</a>
<a data-type="((x : A) → isProp (B₁ x)) →
Square (ap fst p) (ap fst q) (ap fst s) (ap fst r) → Square p q s r" id="7166" href="1Lab.Type.Sigma.html#6901" class="Function">Σ≡Prop-Sq</a> <a id="7176" href="1Lab.Type.Sigma.html#7176" class="Bound">Bprop</a> <a id="7182" href="1Lab.Type.Sigma.html#7182" class="Bound">sq</a> <a id="7185" href="1Lab.Type.Sigma.html#7185" class="Bound">i</a> <a id="7187" href="1Lab.Type.Sigma.html#7187" class="Bound">j</a> <a id="7189" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="7190" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="7194" class="Symbol">=</a> <a id="7196" href="1Lab.Type.Sigma.html#7182" class="Bound">sq</a> <a id="7199" href="1Lab.Type.Sigma.html#7185" class="Bound">i</a> <a id="7201" href="1Lab.Type.Sigma.html#7187" class="Bound">j</a>
<a data-type="((x : A) → isProp (B₁ x)) →
Square (ap fst p) (ap fst q) (ap fst s) (ap fst r) → Square p q s r" id="7203" href="1Lab.Type.Sigma.html#6901" class="Function">Σ≡Prop-Sq</a> <a id="7213" href="1Lab.Type.Sigma.html#7213" class="Bound">Bprop</a> <a id="7219" class="Symbol">{</a><a id="7220" href="1Lab.Type.Sigma.html#7220" class="Bound">p</a><a id="7221" class="Symbol">}</a> <a id="7223" class="Symbol">{</a><a id="7224" href="1Lab.Type.Sigma.html#7224" class="Bound">q</a><a id="7225" class="Symbol">}</a> <a id="7227" class="Symbol">{</a><a id="7228" href="1Lab.Type.Sigma.html#7228" class="Bound">s</a><a id="7229" class="Symbol">}</a> <a id="7231" class="Symbol">{</a><a id="7232" href="1Lab.Type.Sigma.html#7232" class="Bound">r</a><a id="7233" class="Symbol">}</a> <a id="7235" href="1Lab.Type.Sigma.html#7235" class="Bound">sq</a> <a id="7238" href="1Lab.Type.Sigma.html#7238" class="Bound">i</a> <a id="7240" href="1Lab.Type.Sigma.html#7240" class="Bound">j</a> <a id="7242" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="7243" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="7247" class="Symbol">=</a> 
  <a data-type="((i j : I) → isProp (B₁ i j)) →
(p : PathP (λ j → B₁ j i0) a c) (q : PathP (B₁ i0) a b)
(s : PathP (B₁ i1) c d) (r : PathP (λ j → B₁ j i1) b d) →
SquareP B₁ p q s r" id="7252" href="1Lab.HLevel.html#14452" class="Function">isProp→SquareP</a> <a id="7267" class="Symbol">(λ</a> <a id="7270" href="1Lab.Type.Sigma.html#7270" class="Bound">i</a> <a id="7272" href="1Lab.Type.Sigma.html#7272" class="Bound">j</a> <a id="7274" class="Symbol">→</a> <a id="7276" href="1Lab.Type.Sigma.html#7213" class="Bound">Bprop</a> <a id="7282" class="Symbol">(</a><a id="7283" href="1Lab.Type.Sigma.html#7235" class="Bound">sq</a> <a id="7286" href="1Lab.Type.Sigma.html#7270" class="Bound">i</a> <a id="7288" href="1Lab.Type.Sigma.html#7272" class="Bound">j</a><a id="7289" class="Symbol">))</a> 
    <a id="7297" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="7298" href="1Lab.Path.html#20807" class="Function">ap</a> <a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="7301" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="7305" href="1Lab.Type.Sigma.html#7220" class="Bound">p</a><a id="7306" class="Symbol">)</a> <a id="7308" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="7309" href="1Lab.Path.html#20807" class="Function">ap</a> <a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="7312" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="7316" href="1Lab.Type.Sigma.html#7224" class="Bound">q</a><a id="7317" class="Symbol">)</a> <a id="7319" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="7320" href="1Lab.Path.html#20807" class="Function">ap</a> <a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="7323" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="7327" href="1Lab.Type.Sigma.html#7228" class="Bound">s</a><a id="7328" class="Symbol">)</a> <a id="7330" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="7331" href="1Lab.Path.html#20807" class="Function">ap</a> <a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="7334" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="7338" href="1Lab.Type.Sigma.html#7232" class="Bound">r</a><a id="7339" class="Symbol">)</a> <a id="7341" href="1Lab.Type.Sigma.html#7238" class="Bound">i</a> <a id="7343" href="1Lab.Type.Sigma.html#7240" class="Bound">j</a>
</pre>
<h2 id="dependent-sums-of-contractibles"><a href="#dependent-sums-of-contractibles" class="header-link">Dependent sums of contractibles<span class="header-link-emoji">🔗</span></a></h2>
<p>If <code>B</code> is a family of contractible types, then <code>Σ B ≃ A</code>:</p>
<pre class="Agda"><a id="Σ-contract"></a><a data-type="((x : A) → isContr (B₁ x)) → Σ B₁ ≃ A" id="7453" href="1Lab.Type.Sigma.html#7453" class="Function">Σ-contract</a> <a id="7464" class="Symbol">:</a> <a id="7466" class="Symbol">{</a><a id="7467" href="1Lab.Type.Sigma.html#7467" class="Bound">B</a> <a id="7469" class="Symbol">:</a> <a id="7471" href="1Lab.Type.Sigma.html#174" class="Generalizable">A</a> <a id="7473" class="Symbol">→</a> <a id="7475" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="7480" href="1Lab.Type.Sigma.html#159" class="Generalizable">ℓ</a><a id="7481" class="Symbol">}</a> <a id="7483" class="Symbol">→</a> <a id="7485" class="Symbol">(∀</a> <a id="7488" href="1Lab.Type.Sigma.html#7488" class="Bound">x</a> <a id="7490" class="Symbol">→</a> <a data-type="(A : Type ℓ) → Type ℓ" id="7492" href="1Lab.HLevel.html#1328" class="Record">isContr</a> <a id="7500" class="Symbol">(</a><a id="7501" href="1Lab.Type.Sigma.html#7467" class="Bound">B</a> <a id="7503" href="1Lab.Type.Sigma.html#7488" class="Bound">x</a><a id="7504" class="Symbol">))</a> <a id="7507" class="Symbol">→</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="7509" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="7511" href="1Lab.Type.Sigma.html#7467" class="Bound">B</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="7513" href="1Lab.Equiv.html#2442" class="Function Operator">≃</a> <a id="7515" href="1Lab.Type.Sigma.html#174" class="Generalizable">A</a>
<a data-type="((x : A) → isContr (B₁ x)) → Σ B₁ ≃ A" id="7517" href="1Lab.Type.Sigma.html#7453" class="Function">Σ-contract</a> <a id="7528" href="1Lab.Type.Sigma.html#7528" class="Bound">bcontr</a> <a id="7535" class="Symbol">=</a> <a data-type="Iso A B₁ → A ≃ B₁" id="7537" href="1Lab.Equiv.html#20100" class="Function">Iso→Equiv</a> <a id="7547" href="1Lab.Type.Sigma.html#7563" class="Function">the-iso</a> <a id="7555" class="Keyword">where</a>
  <a id="7563" href="1Lab.Type.Sigma.html#7563" class="Function">the-iso</a> <a id="7571" class="Symbol">:</a> <a data-type="Type ℓ₁ → Type ℓ₂ → Type (ℓ₁ ⊔ ℓ₂)" id="7573" href="1Lab.Equiv.html#6241" class="Function">Iso</a> <a id="7577" class="Symbol">_</a> <a id="7579" class="Symbol">_</a>
  <a id="7583" href="1Lab.Type.Sigma.html#7563" class="Function">the-iso</a> <a id="7591" class="Symbol">.</a><a data-type="∑ A B₁ → A" id="7592" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="7596" class="Symbol">(</a><a id="7597" href="1Lab.Type.Sigma.html#7597" class="Bound">a</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="7599" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7601" href="1Lab.Type.Sigma.html#7601" class="Bound">b</a><a id="7602" class="Symbol">)</a> <a id="7604" class="Symbol">=</a> <a id="7606" href="1Lab.Type.Sigma.html#7597" class="Bound">a</a>
  <a id="7610" href="1Lab.Type.Sigma.html#7563" class="Function">the-iso</a> <a id="7618" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="7619" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="7623" class="Symbol">.</a><a data-type="isIso f → B₁ → A" id="7624" href="1Lab.Equiv.html#6080" class="Field">isIso.inv</a> <a id="7634" href="1Lab.Type.Sigma.html#7634" class="Bound">x</a> <a id="7636" class="Symbol">=</a> <a id="7638" href="1Lab.Type.Sigma.html#7634" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="7640" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7642" href="1Lab.Type.Sigma.html#7528" class="Bound">bcontr</a> <a id="7649" class="Symbol">_</a> <a id="7651" class="Symbol">.</a><a data-type="isContr A → A" id="7652" href="1Lab.HLevel.html#1400" class="Field">centre</a>
  <a id="7661" href="1Lab.Type.Sigma.html#7563" class="Function">the-iso</a> <a id="7669" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="7670" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="7674" class="Symbol">.</a><a data-type="(r : isIso f) → isRightInverse (r .inv) f" id="7675" href="1Lab.Equiv.html#6096" class="Field">isIso.rinv</a> <a id="7686" href="1Lab.Type.Sigma.html#7686" class="Bound">x</a> <a id="7688" class="Symbol">=</a> <a data-type="x ≡ x" id="7690" href="1Lab.Path.html#3591" class="Function">refl</a>
  <a id="7697" href="1Lab.Type.Sigma.html#7563" class="Function">the-iso</a> <a id="7705" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="7706" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="7710" class="Symbol">.</a><a data-type="(r : isIso f) → isLeftInverse (r .inv) f" id="7711" href="1Lab.Equiv.html#6128" class="Field">isIso.linv</a> <a id="7722" class="Symbol">(</a><a id="7723" href="1Lab.Type.Sigma.html#7723" class="Bound">a</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="7725" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7727" href="1Lab.Type.Sigma.html#7727" class="Bound">b</a><a id="7728" class="Symbol">)</a> <a id="7730" href="1Lab.Type.Sigma.html#7730" class="Bound">i</a> <a id="7732" class="Symbol">=</a> <a id="7734" href="1Lab.Type.Sigma.html#7723" class="Bound">a</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="7736" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7738" href="1Lab.Type.Sigma.html#7528" class="Bound">bcontr</a> <a id="7745" href="1Lab.Type.Sigma.html#7723" class="Bound">a</a> <a id="7747" class="Symbol">.</a><a data-type="(r : isContr A) (x : A) → r .centre ≡ x" id="7748" href="1Lab.HLevel.html#1415" class="Field">paths</a> <a id="7754" href="1Lab.Type.Sigma.html#7727" class="Bound">b</a> <a id="7756" href="1Lab.Type.Sigma.html#7730" class="Bound">i</a>
</pre>
<pre class="Agda"><a id="Σ-map₂"></a><a data-type="(P x → Q x) → Σ P → Σ Q" id="7771" href="1Lab.Type.Sigma.html#7771" class="Function">Σ-map₂</a> <a id="7778" class="Symbol">:</a> <a id="7780" class="Symbol">({</a><a id="7782" href="1Lab.Type.Sigma.html#7782" class="Bound">x</a> <a id="7784" class="Symbol">:</a> <a id="7786" href="1Lab.Type.Sigma.html#174" class="Generalizable">A</a><a id="7787" class="Symbol">}</a> <a id="7789" class="Symbol">→</a> <a id="7791" href="1Lab.Type.Sigma.html#192" class="Generalizable">P</a> <a id="7793" href="1Lab.Type.Sigma.html#7782" class="Bound">x</a> <a id="7795" class="Symbol">→</a> <a id="7797" href="1Lab.Type.Sigma.html#194" class="Generalizable">Q</a> <a id="7799" href="1Lab.Type.Sigma.html#7782" class="Bound">x</a><a id="7800" class="Symbol">)</a> <a id="7802" class="Symbol">→</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="7804" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="7806" href="1Lab.Type.Sigma.html#192" class="Generalizable">P</a> <a id="7808" class="Symbol">→</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="7810" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="7812" href="1Lab.Type.Sigma.html#194" class="Generalizable">Q</a>
<a data-type="(P x → Q x) → Σ P → Σ Q" id="7814" href="1Lab.Type.Sigma.html#7771" class="Function">Σ-map₂</a> <a id="7821" href="1Lab.Type.Sigma.html#7821" class="Bound">f</a> <a id="7823" class="Symbol">(</a><a id="7824" href="1Lab.Type.Sigma.html#7824" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="7826" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7828" href="1Lab.Type.Sigma.html#7828" class="Bound">y</a><a id="7829" class="Symbol">)</a> <a id="7831" class="Symbol">=</a> <a id="7833" class="Symbol">(</a><a id="7834" href="1Lab.Type.Sigma.html#7824" class="Bound">x</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="7836" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7838" href="1Lab.Type.Sigma.html#7821" class="Bound">f</a> <a id="7840" href="1Lab.Type.Sigma.html#7828" class="Bound">y</a><a id="7841" class="Symbol">)</a>
</pre>
  </article>
</div>

</main>
</body>
<style>.equations { display: none !important; }</style></html>