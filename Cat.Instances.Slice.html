<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>Cat.Instances.Slice - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />
  <link rel="stylesheet" href="/css/agda-cats.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Cat.Instances.Slice - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="Cat.Instances.Slice - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory." />
  
  <script src="/equations.js"></script>
  <script src="/highlight-hover.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>
</head>

<body>
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">Cat.Instances.Slice</a>
              </h3>

      <!-- Cube logo -->
      <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#slice-categories"><a href="#slice-categories" class="header-link">Slice categories<span class="header-link-emoji">🔗</span></a></a>
      <ul>
      <li><a href="#limits"><a href="#limits" class="header-link">Limits<span class="header-link-emoji">🔗</span></a></a></li>
      </ul></li>
      <li><a href="#slices-of-sets"><a href="#slices-of-sets" class="header-link">Slices of Sets<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#slices-preserve-univalence"><a href="#slices-preserve-univalence" class="header-link">Slices preserve univalence<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#arbitrary-limits-in-slices"><a href="#arbitrary-limits-in-slices" class="header-link">Arbitrary limits in slices<span class="header-link-emoji">🔗</span></a></a></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
              <a href="index.html">️back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/416be7e292c55263244fee2224c8493d13fe9858/src/Cat/Instances/Slice.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by Amélia Liao</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="index.html">️back to index</a>
      </div>
      
      <!-- Font toggle checkbox -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="Cat.Instances.Shape.Terminal.html" class="Module">Cat.Instances.Shape.Terminal</a>
<a id="50" class="Keyword">open</a> <a id="55" class="Keyword">import</a> <a id="62" href="Cat.Instances.Shape.Join.html" class="Module">Cat.Instances.Shape.Join</a>
<a id="87" class="Keyword">open</a> <a id="92" class="Keyword">import</a> <a id="99" href="Cat.Instances.Discrete.html" class="Module">Cat.Instances.Discrete</a>
<a id="122" class="Keyword">open</a> <a id="127" class="Keyword">import</a> <a id="134" href="Cat.Instances.Functor.html" class="Module">Cat.Instances.Functor</a>
<a id="156" class="Keyword">open</a> <a id="161" class="Keyword">import</a> <a id="168" href="Cat.Diagram.Limit.Base.html" class="Module">Cat.Diagram.Limit.Base</a>
<a id="191" class="Keyword">open</a> <a id="196" class="Keyword">import</a> <a id="203" href="Cat.Diagram.Pullback.html" class="Module">Cat.Diagram.Pullback</a>
<a id="224" class="Keyword">open</a> <a id="229" class="Keyword">import</a> <a id="236" href="Cat.Diagram.Terminal.html" class="Module">Cat.Diagram.Terminal</a>
<a id="257" class="Keyword">open</a> <a id="262" class="Keyword">import</a> <a id="269" href="Cat.Diagram.Product.html" class="Module">Cat.Diagram.Product</a>
<a id="289" class="Keyword">open</a> <a id="294" class="Keyword">import</a> <a id="301" href="Cat.Functor.Base.html" class="Module">Cat.Functor.Base</a>
<a id="318" class="Keyword">open</a> <a id="323" class="Keyword">import</a> <a id="330" href="Cat.Univalent.html" class="Module">Cat.Univalent</a>
<a id="344" class="Keyword">open</a> <a id="349" class="Keyword">import</a> <a id="356" href="Cat.Prelude.html" class="Module">Cat.Prelude</a>

<a id="369" class="Keyword">open</a> <a id="374" class="Keyword">import</a> <a id="381" href="Data.Sum.html" class="Module">Data.Sum</a>

<a id="391" class="Keyword">import</a> <a id="398" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a>

<a id="413" class="Keyword">module</a> <a id="420" href="Cat.Instances.Slice.html" class="Module">Cat.Instances.Slice</a> <a id="440" class="Keyword">where</a>
</pre>
<!--
<pre class="Agda"><a id="464" class="Keyword">private</a> <a id="472" class="Keyword">variable</a>
  <a id="483" href="Cat.Instances.Slice.html#483" class="Generalizable">o</a> <a id="485" href="Cat.Instances.Slice.html#485" class="Generalizable">ℓ</a> <a id="487" href="Cat.Instances.Slice.html#487" class="Generalizable">o′</a> <a id="490" href="Cat.Instances.Slice.html#490" class="Generalizable">ℓ′</a> <a id="493" class="Symbol">:</a> <a id="495" href="Agda.Primitive.html#597" class="Postulate">Level</a>
<a id="501" class="Keyword">open</a> <a id="506" href="Cat.Base.html#6614" class="Module">Functor</a>
<a id="514" class="Keyword">open</a> <a id="519" href="Cat.Base.html#10813" class="Module Operator">_=&gt;_</a>

<a id="525" class="Keyword">module</a> <a id="532" href="Cat.Instances.Slice.html#532" class="Module">_</a> <a id="534" class="Symbol">{</a><a id="535" href="Cat.Instances.Slice.html#535" class="Bound">o</a> <a id="537" href="Cat.Instances.Slice.html#537" class="Bound">ℓ</a><a id="538" class="Symbol">}</a> <a id="540" class="Symbol">{</a><a id="541" href="Cat.Instances.Slice.html#541" class="Bound">C</a> <a id="543" class="Symbol">:</a> <a id="545" href="Cat.Base.html#644" class="Record">Precategory</a> <a id="557" href="Cat.Instances.Slice.html#535" class="Bound">o</a> <a id="559" href="Cat.Instances.Slice.html#537" class="Bound">ℓ</a><a id="560" class="Symbol">}</a> <a id="562" class="Keyword">where</a>
  <a id="570" class="Keyword">private</a>
    <a id="582" class="Keyword">module</a> <a id="589" href="Cat.Instances.Slice.html#589" class="Module">C</a> <a id="591" class="Symbol">=</a> <a id="593" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="607" href="Cat.Instances.Slice.html#541" class="Bound">C</a>
    <a id="613" class="Keyword">variable</a> <a id="622" href="Cat.Instances.Slice.html#622" class="Generalizable">a</a> <a id="624" href="Cat.Instances.Slice.html#624" class="Generalizable">b</a> <a id="626" href="Cat.Instances.Slice.html#626" class="Generalizable">c</a> <a id="628" class="Symbol">:</a> <a id="630" href="Cat.Base.html#1341" class="Field">C.Ob</a>
</pre>-->
<h1 id="slice-categories"><a href="#slice-categories" class="header-link">Slice categories<span class="header-link-emoji">🔗</span></a></h1>
<p>When working in <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">S</mi><mi mathvariant="bold">e</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">s</mi></mrow><annotation encoding="application/x-tex">\sets</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord"><span class="mord mathbf">Sets</span></span></span></span></span>,</span> there is an evident notion of <em>family indexed by a set</em>: a family of sets <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>F</mi><mi>i</mi></msub><msub><mo stretchy="false">)</mo><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow></msub></mrow><annotation encoding="application/x-tex">(F_i)_{i \in I}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1774em;"><span></span></span></span></span></span></span></span></span></span> is equivalently a functor <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mrow><mi mathvariant="normal">D</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">c</mi></mrow><mo stretchy="false">(</mo><mi>I</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mrow><mi mathvariant="bold">S</mi><mi mathvariant="bold">e</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">s</mi></mrow><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[\id{Disc}(I), \sets]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathrm">Disc</span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathbf">Sets</span></span><span class="mclose">]</span></span></span></span>,</span> where we have equipped the set <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span> with the <a href="Cat.Instances.Discrete.html">discrete category</a> structure. This works essentially because of the <a href="Cat.Instances.StrictCat.Cohesive.html#disc-γ">discrete category-global sections</a> adjunction, but in general this can not be applied to other categories, like <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">G</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">u</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">s</mi></mrow><annotation encoding="application/x-tex">\id{Groups}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathrm">Groups</span></span></span></span></span>.</span> How, then, should we work with “indexed families” in general categories?</p>
<p>The answer is to consider, rather than families themselves, the <em>projections from their total spaces</em> as the primitive objects. A family indexed by <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span>,</span> then, would consist of an object <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> and a morphism <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>:</mo><mi>A</mi><mo>→</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">t : A \to I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span>,</span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> is considered as the “total space” object and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> assigns gives the “tag” of each object. By analysing how <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> <a href="Cat.Diagram.Pullback.html">pulls back</a> along maps <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>→</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">B \to I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span>,</span> we recover a notion of “fibres”: the collection with index <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> can be recovered as the pullback <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>t</mi><mo>∗</mo></msup><mi>i</mi></mrow><annotation encoding="application/x-tex">t^*i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6887em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord mathnormal">i</span></span></span></span>.</span></p>
<p>Note that, since the discussion in the preceding paragraph made no mention of the category of sets, it applies in any category! More generally, for any category <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span> and object <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>:</mo><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">c : \ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>,</span> we have a <em>category of objects indexed by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span></em>, the <strong>slice category</strong> <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi><mi mathvariant="normal">/</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">\ca{C}/c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mord">/</span><span class="mord mathnormal">c</span></span></span></span>.</span> An object of “the slice over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>” is given by an object <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>:</mo><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">d : \ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span> to serve as the domain, and a map <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>d</mi><mo>→</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">f : d \to c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>.</span></p>
<pre class="Agda">  <a id="2183" class="Keyword">record</a> <a data-type="(c : Ob C) → Type (o ⊔ ℓ)" id="2190" href="Cat.Instances.Slice.html#2190" class="Record">/-Obj</a> <a id="2196" class="Symbol">(</a><a id="2197" href="Cat.Instances.Slice.html#2197" class="Bound">c</a> <a id="2199" class="Symbol">:</a> <a data-type="Precategory o h → Type o" id="2201" href="Cat.Base.html#1341" class="Field">C.Ob</a><a id="2205" class="Symbol">)</a> <a id="2207" class="Symbol">:</a> <a id="2209" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2214" class="Symbol">(</a><a id="2215" href="Cat.Instances.Slice.html#535" class="Bound">o</a> <a data-type="Level → Level → Level" id="2217" href="Agda.Primitive.html#810" class="Primitive Operator">⊔</a> <a id="2219" href="Cat.Instances.Slice.html#537" class="Bound">ℓ</a><a id="2220" class="Symbol">)</a> <a id="2222" class="Keyword">where</a>
    <a id="2232" class="Keyword">no-eta-equality</a>
    <a id="2252" class="Keyword">constructor</a> <a data-type="(map₁ : Hom C domain c) → /-Obj c" id="2264" href="Cat.Instances.Slice.html#2264" class="InductiveConstructor">cut</a>
    <a id="2272" class="Keyword">field</a>
      <a id="2284" class="Symbol">{</a><a data-type="/-Obj c → Ob C" id="2285" href="Cat.Instances.Slice.html#2285" class="Field">domain</a><a id="2291" class="Symbol">}</a> <a id="2293" class="Symbol">:</a> <a data-type="Precategory o h → Type o" id="2295" href="Cat.Base.html#1341" class="Field">C.Ob</a>
      <a data-type="(r : /-Obj c) → Hom C (r .domain) c" id="2306" href="Cat.Instances.Slice.html#2306" class="Field">map</a>      <a id="2315" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="2317" href="Cat.Base.html#1358" class="Field">C.Hom</a> <a data-type="/-Obj c → Ob C" id="2323" href="Cat.Instances.Slice.html#2285" class="Field">domain</a> <a id="2330" href="Cat.Instances.Slice.html#2197" class="Bound">c</a>
</pre>
<p>A map between <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>a</mi><mo>→</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">f : a \to c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>:</mo><mi>b</mi><mo>→</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">g : b \to c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span> is given by a map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>:</mo><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">h : a \to b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> such that the triangle below commutes. Since we’re thinking of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> as <em>families indexed by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span></em>, commutativity of the triangle says that the map <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span> “respects reindexing”, or less obliquely “preserves fibres”.</p>
<div class="diagram-container">
<img src="0ffcfaf4257a8f37b987393aa562f9e0d820fdc3.svg" title="commutative diagram" class="diagram quiver" />
</div>
<pre class="Agda">  <a id="2809" class="Keyword">record</a> <a data-type="(a b : /-Obj c) → Type ℓ" id="2816" href="Cat.Instances.Slice.html#2816" class="Record">/-Hom</a> <a id="2822" class="Symbol">(</a><a id="2823" href="Cat.Instances.Slice.html#2823" class="Bound">a</a> <a id="2825" href="Cat.Instances.Slice.html#2825" class="Bound">b</a> <a id="2827" class="Symbol">:</a> <a data-type="(c : Ob C) → Type (o ⊔ ℓ)" id="2829" href="Cat.Instances.Slice.html#2190" class="Record">/-Obj</a> <a id="2835" href="Cat.Instances.Slice.html#626" class="Generalizable">c</a><a id="2836" class="Symbol">)</a> <a id="2838" class="Symbol">:</a> <a id="2840" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="2845" href="Cat.Instances.Slice.html#537" class="Bound">ℓ</a> <a id="2847" class="Keyword">where</a>
    <a id="2857" class="Keyword">no-eta-equality</a>
    <a id="2877" class="Keyword">private</a>
      <a id="2891" class="Keyword">module</a> <a id="2898" href="Cat.Instances.Slice.html#2898" class="Module">a</a> <a id="2900" class="Symbol">=</a> <a data-type="(c : Ob C) → Type (o ⊔ ℓ)" id="2902" href="Cat.Instances.Slice.html#2190" class="Module">/-Obj</a> <a id="2908" href="Cat.Instances.Slice.html#2823" class="Bound">a</a>
      <a id="2916" class="Keyword">module</a> <a id="2923" href="Cat.Instances.Slice.html#2923" class="Module">b</a> <a id="2925" class="Symbol">=</a> <a data-type="(c : Ob C) → Type (o ⊔ ℓ)" id="2927" href="Cat.Instances.Slice.html#2190" class="Module">/-Obj</a> <a id="2933" href="Cat.Instances.Slice.html#2825" class="Bound">b</a>
    <a id="2939" class="Keyword">field</a>
      <a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="2951" href="Cat.Instances.Slice.html#2951" class="Field">map</a>      <a id="2960" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="2962" href="Cat.Base.html#1358" class="Field">C.Hom</a> <a data-type="/-Obj c → Ob C" id="2968" href="Cat.Instances.Slice.html#2285" class="Function">a.domain</a> <a data-type="/-Obj c → Ob C" id="2977" href="Cat.Instances.Slice.html#2285" class="Function">b.domain</a>
      <a data-type="(r : /-Hom a b) → (C ∘ map b) (r .map) ≡ a .map" id="2992" href="Cat.Instances.Slice.html#2992" class="Field">commutes</a> <a id="3001" class="Symbol">:</a> <a data-type="(r : /-Obj c) → Hom C (r .domain) c" id="3003" href="Cat.Instances.Slice.html#2306" class="Function">b.map</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="3009" href="Cat.Base.html#2928" class="Field Operator">C.∘</a> <a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="3013" href="Cat.Instances.Slice.html#2951" class="Field">map</a> <a data-type="A → A → Type ℓ" id="3017" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : /-Obj c) → Hom C (r .domain) c" id="3019" href="Cat.Instances.Slice.html#2306" class="Function">a.map</a>
</pre>
<!--
<pre class="Agda">  <a id="3045" href="Cat.Instances.Slice.html#3045" class="Function">/-Obj-path</a> <a id="3056" class="Symbol">:</a> <a id="3058" class="Symbol">∀</a> <a id="3060" class="Symbol">{</a><a id="3061" href="Cat.Instances.Slice.html#3061" class="Bound">c</a><a id="3062" class="Symbol">}</a> <a id="3064" class="Symbol">{</a><a id="3065" href="Cat.Instances.Slice.html#3065" class="Bound">x</a> <a id="3067" href="Cat.Instances.Slice.html#3067" class="Bound">y</a> <a id="3069" class="Symbol">:</a> <a id="3071" href="Cat.Instances.Slice.html#2190" class="Record">/-Obj</a> <a id="3077" href="Cat.Instances.Slice.html#3061" class="Bound">c</a><a id="3078" class="Symbol">}</a>
             <a id="3093" class="Symbol">→</a> <a id="3095" class="Symbol">(</a><a id="3096" href="Cat.Instances.Slice.html#3096" class="Bound">p</a> <a id="3098" class="Symbol">:</a> <a id="3100" href="Cat.Instances.Slice.html#3065" class="Bound">x</a> <a id="3102" class="Symbol">.</a><a id="3103" href="Cat.Instances.Slice.html#2285" class="Field">/-Obj.domain</a> <a id="3116" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="3118" href="Cat.Instances.Slice.html#3067" class="Bound">y</a> <a id="3120" class="Symbol">.</a><a id="3121" href="Cat.Instances.Slice.html#2285" class="Field">/-Obj.domain</a><a id="3133" class="Symbol">)</a>
             <a id="3148" class="Symbol">→</a> <a id="3150" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="3156" class="Symbol">(λ</a> <a id="3159" href="Cat.Instances.Slice.html#3159" class="Bound">i</a> <a id="3161" class="Symbol">→</a> <a id="3163" href="Cat.Base.html#1358" class="Field">C.Hom</a> <a id="3169" class="Symbol">(</a><a id="3170" href="Cat.Instances.Slice.html#3096" class="Bound">p</a> <a id="3172" href="Cat.Instances.Slice.html#3159" class="Bound">i</a><a id="3173" class="Symbol">)</a> <a id="3175" href="Cat.Instances.Slice.html#3061" class="Bound">c</a><a id="3176" class="Symbol">)</a> <a id="3178" class="Symbol">(</a><a id="3179" href="Cat.Instances.Slice.html#3065" class="Bound">x</a> <a id="3181" class="Symbol">.</a><a id="3182" href="Cat.Instances.Slice.html#2306" class="Field">/-Obj.map</a><a id="3191" class="Symbol">)</a> <a id="3193" class="Symbol">(</a><a id="3194" href="Cat.Instances.Slice.html#3067" class="Bound">y</a> <a id="3196" class="Symbol">.</a><a id="3197" href="Cat.Instances.Slice.html#2306" class="Field">/-Obj.map</a><a id="3206" class="Symbol">)</a>
             <a id="3221" class="Symbol">→</a> <a id="3223" href="Cat.Instances.Slice.html#3065" class="Bound">x</a> <a id="3225" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="3227" href="Cat.Instances.Slice.html#3067" class="Bound">y</a>
  <a id="3231" href="Cat.Instances.Slice.html#3045" class="Function">/-Obj-path</a> <a id="3242" href="Cat.Instances.Slice.html#3242" class="Bound">p</a> <a id="3244" href="Cat.Instances.Slice.html#3244" class="Bound">q</a> <a id="3246" href="Cat.Instances.Slice.html#3246" class="Bound">i</a> <a id="3248" class="Symbol">.</a><a id="3249" href="Cat.Instances.Slice.html#2285" class="Field">/-Obj.domain</a> <a id="3262" class="Symbol">=</a> <a id="3264" href="Cat.Instances.Slice.html#3242" class="Bound">p</a> <a id="3266" href="Cat.Instances.Slice.html#3246" class="Bound">i</a>
  <a id="3270" href="Cat.Instances.Slice.html#3045" class="Function">/-Obj-path</a> <a id="3281" href="Cat.Instances.Slice.html#3281" class="Bound">p</a> <a id="3283" href="Cat.Instances.Slice.html#3283" class="Bound">q</a> <a id="3285" href="Cat.Instances.Slice.html#3285" class="Bound">i</a> <a id="3287" class="Symbol">.</a><a id="3288" href="Cat.Instances.Slice.html#2306" class="Field">/-Obj.map</a> <a id="3298" class="Symbol">=</a> <a id="3300" href="Cat.Instances.Slice.html#3283" class="Bound">q</a> <a id="3302" href="Cat.Instances.Slice.html#3285" class="Bound">i</a>

  <a id="3307" href="Cat.Instances.Slice.html#3307" class="Function">/-Hom-pathp</a> <a id="3319" class="Symbol">:</a> <a id="3321" class="Symbol">∀</a> <a id="3323" class="Symbol">{</a><a id="3324" href="Cat.Instances.Slice.html#3324" class="Bound">c</a> <a id="3326" href="Cat.Instances.Slice.html#3326" class="Bound">a</a> <a id="3328" href="Cat.Instances.Slice.html#3328" class="Bound">a′</a> <a id="3331" href="Cat.Instances.Slice.html#3331" class="Bound">b</a> <a id="3333" href="Cat.Instances.Slice.html#3333" class="Bound">b′</a><a id="3335" class="Symbol">}</a> <a id="3337" class="Symbol">(</a><a id="3338" href="Cat.Instances.Slice.html#3338" class="Bound">p</a> <a id="3340" class="Symbol">:</a> <a id="3342" href="Cat.Instances.Slice.html#3326" class="Bound">a</a> <a id="3344" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="3346" href="Cat.Instances.Slice.html#3328" class="Bound">a′</a><a id="3348" class="Symbol">)</a> <a id="3350" class="Symbol">(</a><a id="3351" href="Cat.Instances.Slice.html#3351" class="Bound">q</a> <a id="3353" class="Symbol">:</a> <a id="3355" href="Cat.Instances.Slice.html#3331" class="Bound">b</a> <a id="3357" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="3359" href="Cat.Instances.Slice.html#3333" class="Bound">b′</a><a id="3361" class="Symbol">)</a>
                <a id="3379" class="Symbol">{</a><a id="3380" href="Cat.Instances.Slice.html#3380" class="Bound">x</a> <a id="3382" class="Symbol">:</a> <a id="3384" href="Cat.Instances.Slice.html#2816" class="Record">/-Hom</a> <a id="3390" class="Symbol">{</a><a id="3391" class="Argument">c</a> <a id="3393" class="Symbol">=</a> <a id="3395" href="Cat.Instances.Slice.html#3324" class="Bound">c</a><a id="3396" class="Symbol">}</a> <a id="3398" href="Cat.Instances.Slice.html#3326" class="Bound">a</a> <a id="3400" href="Cat.Instances.Slice.html#3331" class="Bound">b</a><a id="3401" class="Symbol">}</a> <a id="3403" class="Symbol">{</a><a id="3404" href="Cat.Instances.Slice.html#3404" class="Bound">y</a> <a id="3406" class="Symbol">:</a> <a id="3408" href="Cat.Instances.Slice.html#2816" class="Record">/-Hom</a> <a id="3414" href="Cat.Instances.Slice.html#3328" class="Bound">a′</a> <a id="3417" href="Cat.Instances.Slice.html#3333" class="Bound">b′</a><a id="3419" class="Symbol">}</a>
              <a id="3435" class="Symbol">→</a> <a id="3437" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="3443" class="Symbol">(λ</a> <a id="3446" href="Cat.Instances.Slice.html#3446" class="Bound">i</a> <a id="3448" class="Symbol">→</a> <a id="3450" href="Cat.Base.html#1358" class="Field">C.Hom</a> <a id="3456" class="Symbol">(</a><a id="3457" href="Cat.Instances.Slice.html#3338" class="Bound">p</a> <a id="3459" href="Cat.Instances.Slice.html#3446" class="Bound">i</a> <a id="3461" class="Symbol">.</a><a id="3462" href="Cat.Instances.Slice.html#2285" class="Field">/-Obj.domain</a><a id="3474" class="Symbol">)</a> <a id="3476" class="Symbol">(</a><a id="3477" href="Cat.Instances.Slice.html#3351" class="Bound">q</a> <a id="3479" href="Cat.Instances.Slice.html#3446" class="Bound">i</a> <a id="3481" class="Symbol">.</a><a id="3482" href="Cat.Instances.Slice.html#2285" class="Field">/-Obj.domain</a><a id="3494" class="Symbol">))</a>
                        <a id="3521" class="Symbol">(</a><a id="3522" href="Cat.Instances.Slice.html#3380" class="Bound">x</a> <a id="3524" class="Symbol">.</a><a id="3525" href="Cat.Instances.Slice.html#2951" class="Field">/-Hom.map</a><a id="3534" class="Symbol">)</a> <a id="3536" class="Symbol">(</a><a id="3537" href="Cat.Instances.Slice.html#3404" class="Bound">y</a> <a id="3539" class="Symbol">.</a><a id="3540" href="Cat.Instances.Slice.html#2951" class="Field">/-Hom.map</a><a id="3549" class="Symbol">)</a>
              <a id="3565" class="Symbol">→</a> <a id="3567" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="3573" class="Symbol">(λ</a> <a id="3576" href="Cat.Instances.Slice.html#3576" class="Bound">i</a> <a id="3578" class="Symbol">→</a> <a id="3580" href="Cat.Instances.Slice.html#2816" class="Record">/-Hom</a> <a id="3586" class="Symbol">(</a><a id="3587" href="Cat.Instances.Slice.html#3338" class="Bound">p</a> <a id="3589" href="Cat.Instances.Slice.html#3576" class="Bound">i</a><a id="3590" class="Symbol">)</a> <a id="3592" class="Symbol">(</a><a id="3593" href="Cat.Instances.Slice.html#3351" class="Bound">q</a> <a id="3595" href="Cat.Instances.Slice.html#3576" class="Bound">i</a><a id="3596" class="Symbol">))</a> <a id="3599" href="Cat.Instances.Slice.html#3380" class="Bound">x</a> <a id="3601" href="Cat.Instances.Slice.html#3404" class="Bound">y</a>
  <a id="3605" href="Cat.Instances.Slice.html#3307" class="Function">/-Hom-pathp</a> <a id="3617" href="Cat.Instances.Slice.html#3617" class="Bound">p</a> <a id="3619" href="Cat.Instances.Slice.html#3619" class="Bound">q</a> <a id="3621" class="Symbol">{</a><a id="3622" href="Cat.Instances.Slice.html#3622" class="Bound">x</a><a id="3623" class="Symbol">}</a> <a id="3625" class="Symbol">{</a><a id="3626" href="Cat.Instances.Slice.html#3626" class="Bound">y</a><a id="3627" class="Symbol">}</a> <a id="3629" href="Cat.Instances.Slice.html#3629" class="Bound">r</a> <a id="3631" class="Symbol">=</a> <a id="3633" href="Cat.Instances.Slice.html#3664" class="Function">path</a> <a id="3638" class="Keyword">where</a>
    <a id="3648" class="Keyword">open</a> <a id="3653" href="Cat.Instances.Slice.html#2816" class="Module">/-Hom</a>

    <a id="3664" href="Cat.Instances.Slice.html#3664" class="Function">path</a> <a id="3669" class="Symbol">:</a> <a id="3671" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="3677" class="Symbol">(λ</a> <a id="3680" href="Cat.Instances.Slice.html#3680" class="Bound">i</a> <a id="3682" class="Symbol">→</a> <a id="3684" href="Cat.Instances.Slice.html#2816" class="Record">/-Hom</a> <a id="3690" class="Symbol">(</a><a id="3691" href="Cat.Instances.Slice.html#3617" class="Bound">p</a> <a id="3693" href="Cat.Instances.Slice.html#3680" class="Bound">i</a><a id="3694" class="Symbol">)</a> <a id="3696" class="Symbol">(</a><a id="3697" href="Cat.Instances.Slice.html#3619" class="Bound">q</a> <a id="3699" href="Cat.Instances.Slice.html#3680" class="Bound">i</a><a id="3700" class="Symbol">))</a>  <a id="3704" href="Cat.Instances.Slice.html#3622" class="Bound">x</a> <a id="3706" href="Cat.Instances.Slice.html#3626" class="Bound">y</a>
    <a id="3712" href="Cat.Instances.Slice.html#3664" class="Function">path</a> <a id="3717" href="Cat.Instances.Slice.html#3717" class="Bound">i</a> <a id="3719" class="Symbol">.</a><a id="3720" href="Cat.Instances.Slice.html#2951" class="Field">map</a> <a id="3724" class="Symbol">=</a> <a id="3726" href="Cat.Instances.Slice.html#3629" class="Bound">r</a> <a id="3728" href="Cat.Instances.Slice.html#3717" class="Bound">i</a>
    <a id="3734" href="Cat.Instances.Slice.html#3664" class="Function">path</a> <a id="3739" href="Cat.Instances.Slice.html#3739" class="Bound">i</a> <a id="3741" class="Symbol">.</a><a id="3742" href="Cat.Instances.Slice.html#2992" class="Field">commutes</a> <a id="3751" class="Symbol">=</a>
      <a id="3759" href="1Lab.HLevel.html#13498" class="Function">is-prop→pathp</a>
        <a id="3781" class="Symbol">(λ</a> <a id="3784" href="Cat.Instances.Slice.html#3784" class="Bound">i</a> <a id="3786" class="Symbol">→</a> <a id="3788" href="Cat.Base.html#1706" class="Field">C.Hom-set</a> <a id="3798" class="Symbol">(</a><a id="3799" href="Cat.Instances.Slice.html#3617" class="Bound">p</a> <a id="3801" href="Cat.Instances.Slice.html#3784" class="Bound">i</a> <a id="3803" class="Symbol">.</a><a id="3804" href="Cat.Instances.Slice.html#2285" class="Field">/-Obj.domain</a><a id="3816" class="Symbol">)</a> <a id="3818" class="Symbol">_</a>
                         <a id="3845" class="Symbol">(</a><a id="3846" href="Cat.Instances.Slice.html#3619" class="Bound">q</a> <a id="3848" href="Cat.Instances.Slice.html#3784" class="Bound">i</a> <a id="3850" class="Symbol">.</a><a id="3851" href="Cat.Instances.Slice.html#2306" class="Field">/-Obj.map</a> <a id="3861" href="Cat.Base.html#2928" class="Field Operator">C.∘</a> <a id="3865" href="Cat.Instances.Slice.html#3629" class="Bound">r</a> <a id="3867" href="Cat.Instances.Slice.html#3784" class="Bound">i</a><a id="3868" class="Symbol">)</a> <a id="3870" class="Symbol">(</a><a id="3871" href="Cat.Instances.Slice.html#3617" class="Bound">p</a> <a id="3873" href="Cat.Instances.Slice.html#3784" class="Bound">i</a> <a id="3875" class="Symbol">.</a><a id="3876" href="Cat.Instances.Slice.html#2306" class="Field">/-Obj.map</a><a id="3885" class="Symbol">))</a>
        <a id="3896" class="Symbol">(</a><a id="3897" href="Cat.Instances.Slice.html#3622" class="Bound">x</a> <a id="3899" class="Symbol">.</a><a id="3900" href="Cat.Instances.Slice.html#2992" class="Field">commutes</a><a id="3908" class="Symbol">)</a> <a id="3910" class="Symbol">(</a><a id="3911" href="Cat.Instances.Slice.html#3626" class="Bound">y</a> <a id="3913" class="Symbol">.</a><a id="3914" href="Cat.Instances.Slice.html#2992" class="Field">commutes</a><a id="3922" class="Symbol">)</a> <a id="3924" href="Cat.Instances.Slice.html#3739" class="Bound">i</a>

  <a id="3929" href="Cat.Instances.Slice.html#3929" class="Function">/-Hom-path</a> <a id="3940" class="Symbol">:</a> <a id="3942" class="Symbol">∀</a> <a id="3944" class="Symbol">{</a><a id="3945" href="Cat.Instances.Slice.html#3945" class="Bound">c</a> <a id="3947" href="Cat.Instances.Slice.html#3947" class="Bound">a</a> <a id="3949" href="Cat.Instances.Slice.html#3949" class="Bound">b</a><a id="3950" class="Symbol">}</a> <a id="3952" class="Symbol">{</a><a id="3953" href="Cat.Instances.Slice.html#3953" class="Bound">x</a> <a id="3955" href="Cat.Instances.Slice.html#3955" class="Bound">y</a> <a id="3957" class="Symbol">:</a> <a id="3959" href="Cat.Instances.Slice.html#2816" class="Record">/-Hom</a> <a id="3965" class="Symbol">{</a><a id="3966" class="Argument">c</a> <a id="3968" class="Symbol">=</a> <a id="3970" href="Cat.Instances.Slice.html#3945" class="Bound">c</a><a id="3971" class="Symbol">}</a> <a id="3973" href="Cat.Instances.Slice.html#3947" class="Bound">a</a> <a id="3975" href="Cat.Instances.Slice.html#3949" class="Bound">b</a><a id="3976" class="Symbol">}</a>
             <a id="3991" class="Symbol">→</a> <a id="3993" href="Cat.Instances.Slice.html#3953" class="Bound">x</a> <a id="3995" class="Symbol">.</a><a id="3996" href="Cat.Instances.Slice.html#2951" class="Field">/-Hom.map</a> <a id="4006" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="4008" href="Cat.Instances.Slice.html#3955" class="Bound">y</a> <a id="4010" class="Symbol">.</a><a id="4011" href="Cat.Instances.Slice.html#2951" class="Field">/-Hom.map</a>
             <a id="4034" class="Symbol">→</a> <a id="4036" href="Cat.Instances.Slice.html#3953" class="Bound">x</a> <a id="4038" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="4040" href="Cat.Instances.Slice.html#3955" class="Bound">y</a>
  <a id="4044" href="Cat.Instances.Slice.html#3929" class="Function">/-Hom-path</a> <a id="4055" class="Symbol">=</a> <a id="4057" href="Cat.Instances.Slice.html#3307" class="Function">/-Hom-pathp</a> <a id="4069" href="1Lab.Path.html#3593" class="Function">refl</a> <a id="4074" href="1Lab.Path.html#3593" class="Function">refl</a>

  <a id="4082" class="Keyword">abstract</a>
    <a id="4095" href="Cat.Instances.Slice.html#4095" class="Function">/-Hom-is-set</a> <a id="4108" class="Symbol">:</a> <a id="4110" class="Symbol">∀</a> <a id="4112" class="Symbol">{</a><a id="4113" href="Cat.Instances.Slice.html#4113" class="Bound">c</a> <a id="4115" href="Cat.Instances.Slice.html#4115" class="Bound">a</a> <a id="4117" href="Cat.Instances.Slice.html#4117" class="Bound">b</a><a id="4118" class="Symbol">}</a> <a id="4120" class="Symbol">→</a> <a id="4122" href="1Lab.HLevel.html#3356" class="Function">is-set</a> <a id="4129" class="Symbol">(</a><a id="4130" href="Cat.Instances.Slice.html#2816" class="Record">/-Hom</a> <a id="4136" class="Symbol">{</a><a id="4137" class="Argument">c</a> <a id="4139" class="Symbol">=</a> <a id="4141" href="Cat.Instances.Slice.html#4113" class="Bound">c</a><a id="4142" class="Symbol">}</a> <a id="4144" href="Cat.Instances.Slice.html#4115" class="Bound">a</a> <a id="4146" href="Cat.Instances.Slice.html#4117" class="Bound">b</a><a id="4147" class="Symbol">)</a>
    <a id="4153" href="Cat.Instances.Slice.html#4095" class="Function">/-Hom-is-set</a> <a id="4166" class="Symbol">{</a><a id="4167" class="Argument">a</a> <a id="4169" class="Symbol">=</a> <a id="4171" href="Cat.Instances.Slice.html#4171" class="Bound">a</a><a id="4172" class="Symbol">}</a> <a id="4174" class="Symbol">{</a><a id="4175" href="Cat.Instances.Slice.html#4175" class="Bound">b</a><a id="4176" class="Symbol">}</a> <a id="4178" class="Symbol">=</a>
      <a id="4186" href="1Lab.HLevel.Retracts.html#1652" class="Function">retract→is-hlevel</a> <a id="4204" class="Number">2</a> <a id="4206" href="Cat.Instances.Slice.html#4550" class="Function">pack</a> <a id="4211" href="Cat.Instances.Slice.html#4657" class="Function">unpack</a> <a id="4218" href="Cat.Instances.Slice.html#4741" class="Function">inv</a> <a id="4222" href="Cat.Instances.Slice.html#4397" class="Function">T-is-set</a>
      <a id="4237" class="Keyword">where</a>
        <a id="4251" class="Keyword">module</a> <a id="4258" href="Cat.Instances.Slice.html#4258" class="Module">a</a> <a id="4260" class="Symbol">=</a> <a id="4262" href="Cat.Instances.Slice.html#2190" class="Module">/-Obj</a> <a id="4268" href="Cat.Instances.Slice.html#4171" class="Bound">a</a>
        <a id="4278" class="Keyword">module</a> <a id="4285" href="Cat.Instances.Slice.html#4285" class="Module">b</a> <a id="4287" class="Symbol">=</a> <a id="4289" href="Cat.Instances.Slice.html#2190" class="Module">/-Obj</a> <a id="4295" href="Cat.Instances.Slice.html#4175" class="Bound">b</a>

        <a id="4306" href="Cat.Instances.Slice.html#4306" class="Function">T</a> <a id="4308" class="Symbol">:</a> <a id="4310" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="4315" href="Cat.Instances.Slice.html#537" class="Bound">ℓ</a>
        <a id="4325" href="Cat.Instances.Slice.html#4306" class="Function">T</a> <a id="4327" class="Symbol">=</a> <a id="4329" href="1Lab.Type.html#1573" class="Function">Σ[</a> <a id="4332" href="Cat.Instances.Slice.html#4332" class="Bound">map</a> <a id="4336" href="1Lab.Type.html#1573" class="Function">∈</a> <a id="4338" href="Cat.Base.html#1358" class="Field">C.Hom</a> <a id="4344" href="Cat.Instances.Slice.html#2285" class="Function">a.domain</a> <a id="4353" href="Cat.Instances.Slice.html#2285" class="Field">b.domain</a> <a id="4362" href="1Lab.Type.html#1573" class="Function">]</a> <a id="4364" class="Symbol">(</a><a id="4365" href="Cat.Instances.Slice.html#2306" class="Field">b.map</a> <a id="4371" href="Cat.Base.html#2928" class="Field Operator">C.∘</a> <a id="4375" href="Cat.Instances.Slice.html#4332" class="Bound">map</a> <a id="4379" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="4381" href="Cat.Instances.Slice.html#2306" class="Function">a.map</a><a id="4386" class="Symbol">)</a>

        <a id="4397" href="Cat.Instances.Slice.html#4397" class="Function">T-is-set</a> <a id="4406" class="Symbol">:</a> <a id="4408" href="1Lab.HLevel.html#3356" class="Function">is-set</a> <a id="4415" href="Cat.Instances.Slice.html#4306" class="Function">T</a>
        <a id="4425" href="Cat.Instances.Slice.html#4397" class="Function">T-is-set</a> <a id="4434" class="Symbol">=</a> <a id="4436" href="1Lab.HLevel.Retracts.html#5166" class="Function">Σ-is-hlevel</a> <a id="4448" class="Number">2</a> <a id="4450" class="Symbol">(</a><a id="4451" href="Cat.Base.html#1706" class="Field">C.Hom-set</a> <a id="4461" class="Symbol">_</a> <a id="4463" class="Symbol">_)</a>
                                <a id="4498" class="Symbol">(λ</a> <a id="4501" href="Cat.Instances.Slice.html#4501" class="Bound">_</a> <a id="4503" class="Symbol">→</a> <a id="4505" href="1Lab.HLevel.html#5554" class="Function">is-prop→is-set</a> <a id="4520" class="Symbol">(</a><a id="4521" href="Cat.Base.html#1706" class="Field">C.Hom-set</a> <a id="4531" class="Symbol">_</a> <a id="4533" class="Symbol">_</a> <a id="4535" class="Symbol">_</a> <a id="4537" class="Symbol">_))</a>

        <a id="4550" href="Cat.Instances.Slice.html#4550" class="Function">pack</a> <a id="4555" class="Symbol">:</a> <a id="4557" href="Cat.Instances.Slice.html#4306" class="Function">T</a> <a id="4559" class="Symbol">→</a> <a id="4561" href="Cat.Instances.Slice.html#2816" class="Record">/-Hom</a> <a id="4567" href="Cat.Instances.Slice.html#4171" class="Bound">a</a> <a id="4569" href="Cat.Instances.Slice.html#4175" class="Bound">b</a>
        <a id="4579" href="Cat.Instances.Slice.html#4550" class="Function">pack</a> <a id="4584" class="Symbol">(</a><a id="4585" href="Cat.Instances.Slice.html#4585" class="Bound">f</a> <a id="4587" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4589" href="Cat.Instances.Slice.html#4589" class="Bound">g</a><a id="4590" class="Symbol">)</a> <a id="4592" class="Symbol">.</a><a id="4593" href="Cat.Instances.Slice.html#2951" class="Field">/-Hom.map</a> <a id="4603" class="Symbol">=</a> <a id="4605" href="Cat.Instances.Slice.html#4585" class="Bound">f</a>
        <a id="4615" href="Cat.Instances.Slice.html#4550" class="Function">pack</a> <a id="4620" class="Symbol">(</a><a id="4621" href="Cat.Instances.Slice.html#4621" class="Bound">f</a> <a id="4623" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4625" href="Cat.Instances.Slice.html#4625" class="Bound">g</a><a id="4626" class="Symbol">)</a> <a id="4628" class="Symbol">.</a><a id="4629" href="Cat.Instances.Slice.html#2992" class="Field">/-Hom.commutes</a> <a id="4644" class="Symbol">=</a> <a id="4646" href="Cat.Instances.Slice.html#4625" class="Bound">g</a>

        <a id="4657" href="Cat.Instances.Slice.html#4657" class="Function">unpack</a> <a id="4664" class="Symbol">:</a> <a id="4666" href="Cat.Instances.Slice.html#2816" class="Record">/-Hom</a> <a id="4672" href="Cat.Instances.Slice.html#4171" class="Bound">a</a> <a id="4674" href="Cat.Instances.Slice.html#4175" class="Bound">b</a> <a id="4676" class="Symbol">→</a> <a id="4678" href="Cat.Instances.Slice.html#4306" class="Function">T</a>
        <a id="4688" href="Cat.Instances.Slice.html#4657" class="Function">unpack</a> <a id="4695" href="Cat.Instances.Slice.html#4695" class="Bound">x</a> <a id="4697" class="Symbol">=</a> <a id="4699" href="Cat.Instances.Slice.html#4695" class="Bound">x</a> <a id="4701" class="Symbol">.</a><a id="4702" href="Cat.Instances.Slice.html#2951" class="Field">/-Hom.map</a> <a id="4712" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4714" href="Cat.Instances.Slice.html#4695" class="Bound">x</a> <a id="4716" class="Symbol">.</a><a id="4717" href="Cat.Instances.Slice.html#2992" class="Field">/-Hom.commutes</a>

        <a id="4741" href="Cat.Instances.Slice.html#4741" class="Function">inv</a> <a id="4745" class="Symbol">:</a> <a id="4747" href="1Lab.Equiv.html#5649" class="Function">is-left-inverse</a> <a id="4763" href="Cat.Instances.Slice.html#4550" class="Function">pack</a> <a id="4768" href="Cat.Instances.Slice.html#4657" class="Function">unpack</a>
        <a id="4783" href="Cat.Instances.Slice.html#4741" class="Function">inv</a> <a id="4787" href="Cat.Instances.Slice.html#4787" class="Bound">x</a> <a id="4789" class="Symbol">=</a> <a id="4791" href="Cat.Instances.Slice.html#3929" class="Function">/-Hom-path</a> <a id="4802" href="1Lab.Path.html#3593" class="Function">refl</a>
</pre>-->
<p>The slice category <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi><mi mathvariant="normal">/</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">\ca{C}/c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mord">/</span><span class="mord mathnormal">c</span></span></span></span> is given by the <span class="Agda"><a data-type="(c : Ob C) → Type (o ⊔ ℓ)" href="Cat.Instances.Slice.html#2190" class="Record">/-Obj</a></span> and <span class="Agda"><a data-type="(a b : /-Obj c) → Type ℓ" href="Cat.Instances.Slice.html#2816" class="Record">/-Hom</a></span>s.</p>
<pre class="Agda"><a id="Slice"></a><a data-type="(C : Precategory o ℓ) → Ob C → Precategory (o ⊔ ℓ) ℓ" id="4907" href="Cat.Instances.Slice.html#4907" class="Function">Slice</a> <a id="4913" class="Symbol">:</a> <a id="4915" class="Symbol">(</a><a id="4916" href="Cat.Instances.Slice.html#4916" class="Bound">C</a> <a id="4918" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="4920" href="Cat.Base.html#644" class="Record">Precategory</a> <a id="4932" href="Cat.Instances.Slice.html#483" class="Generalizable">o</a> <a id="4934" href="Cat.Instances.Slice.html#485" class="Generalizable">ℓ</a><a id="4935" class="Symbol">)</a> <a id="4937" class="Symbol">→</a> <a data-type="Precategory o h → Type o" id="4939" href="Cat.Base.html#1341" class="Field">Precategory.Ob</a> <a id="4954" href="Cat.Instances.Slice.html#4916" class="Bound">C</a> <a id="4956" class="Symbol">→</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="4958" href="Cat.Base.html#644" class="Record">Precategory</a> <a id="4970" class="Symbol">_</a> <a id="4972" class="Symbol">_</a>
<a data-type="(C : Precategory o ℓ) → Ob C → Precategory (o ⊔ ℓ) ℓ" id="4974" href="Cat.Instances.Slice.html#4907" class="Function">Slice</a> <a id="4980" href="Cat.Instances.Slice.html#4980" class="Bound">C</a> <a id="4982" href="Cat.Instances.Slice.html#4982" class="Bound">c</a> <a id="4984" class="Symbol">=</a> <a id="4986" href="Cat.Instances.Slice.html#5077" class="Function">precat</a> <a id="4993" class="Keyword">where</a>
  <a id="5001" class="Keyword">import</a> <a id="5008" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="5022" href="Cat.Instances.Slice.html#4980" class="Bound">C</a> <a id="5024" class="Symbol">as</a> <a id="5027" href="Cat.Instances.Slice.html#5027" class="Module">C</a>
  <a id="5031" class="Keyword">open</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="5036" href="Cat.Base.html#644" class="Module">Precategory</a>
  <a id="5050" class="Keyword">open</a> <a data-type="(a b : /-Obj c) → Type ℓ" id="5055" href="Cat.Instances.Slice.html#2816" class="Module">/-Hom</a>
  <a id="5063" class="Keyword">open</a> <a data-type="(c : Ob C) → Type (o ⊔ ℓ)" id="5068" href="Cat.Instances.Slice.html#2190" class="Module">/-Obj</a>

  <a id="5077" href="Cat.Instances.Slice.html#5077" class="Function">precat</a> <a id="5084" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="5086" href="Cat.Base.html#644" class="Record">Precategory</a> <a id="5098" class="Symbol">_</a> <a id="5100" class="Symbol">_</a>
  <a id="5104" href="Cat.Instances.Slice.html#5077" class="Function">precat</a> <a id="5111" class="Symbol">.</a><a data-type="Precategory o h → Type o" id="5112" href="Cat.Base.html#1341" class="Field">Ob</a> <a id="5115" class="Symbol">=</a> <a data-type="(c : Ob C) → Type (o ⊔ ℓ)" id="5117" href="Cat.Instances.Slice.html#2190" class="Record">/-Obj</a> <a id="5123" class="Symbol">{</a><a id="5124" class="Argument">C</a> <a id="5126" class="Symbol">=</a> <a id="5128" href="Cat.Instances.Slice.html#4980" class="Bound">C</a><a id="5129" class="Symbol">}</a> <a id="5131" href="Cat.Instances.Slice.html#4982" class="Bound">c</a>
  <a id="5135" href="Cat.Instances.Slice.html#5077" class="Function">precat</a> <a id="5142" class="Symbol">.</a><a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="5143" href="Cat.Base.html#1358" class="Field">Hom</a> <a id="5147" class="Symbol">=</a> <a data-type="(a b : /-Obj c) → Type ℓ" id="5149" href="Cat.Instances.Slice.html#2816" class="Record">/-Hom</a>
  <a id="5157" href="Cat.Instances.Slice.html#5077" class="Function">precat</a> <a id="5164" class="Symbol">.</a><a data-type="(r : Precategory o h) (x y : r .Ob) → is-set (r .Hom x y)" id="5165" href="Cat.Base.html#1706" class="Field">Hom-set</a> <a id="5173" href="Cat.Instances.Slice.html#5173" class="Bound">x</a> <a id="5175" href="Cat.Instances.Slice.html#5175" class="Bound">y</a> <a id="5177" class="Symbol">=</a> <a data-type="is-set (/-Hom a b)" id="5179" href="Cat.Instances.Slice.html#4095" class="Function">/-Hom-is-set</a>
  <a id="5194" href="Cat.Instances.Slice.html#5077" class="Function">precat</a> <a id="5201" class="Symbol">.</a><a data-type="(r : Precategory o h) → r .Hom x x" id="5202" href="Cat.Base.html#2898" class="Field">id</a> <a id="5205" class="Symbol">.</a><a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="5206" href="Cat.Instances.Slice.html#2951" class="Field">map</a>      <a id="5215" class="Symbol">=</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="5217" href="Cat.Base.html#2898" class="Function">C.id</a>
  <a id="5224" href="Cat.Instances.Slice.html#5077" class="Function">precat</a> <a id="5231" class="Symbol">.</a><a data-type="(r : Precategory o h) → r .Hom x x" id="5232" href="Cat.Base.html#2898" class="Field">id</a> <a id="5235" class="Symbol">.</a><a data-type="(r : /-Hom a b) → (C ∘ map b) (r .map) ≡ a .map" id="5236" href="Cat.Instances.Slice.html#2992" class="Field">commutes</a> <a id="5245" class="Symbol">=</a> <a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" id="5247" href="Cat.Base.html#3359" class="Function">C.idr</a> <a id="5253" class="Symbol">_</a>
</pre>
<p>For composition in the slice over <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>,</span> note that if the triangle (the commutativity condition for <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>)</span> and the rhombus (the commutativity condition for <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>)</span> both commute, then so does the larger triangle (the commutativity for <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">g \circ f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6389em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>).</span></p>
<div class="diagram-container">
<img src="ea2c1a022ad5800c9620a112804bb1863e2284fe.svg" title="commutative diagram" class="diagram quiver tall-1" />
</div>
<pre class="Agda">  <a id="5824" href="Cat.Instances.Slice.html#5077" class="Function">precat</a> <a id="5831" class="Symbol">.</a><a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="5832" href="Cat.Base.html#2928" class="Field Operator">_∘_</a> <a id="5836" class="Symbol">{</a><a id="5837" href="Cat.Instances.Slice.html#5837" class="Bound">x</a><a id="5838" class="Symbol">}</a> <a id="5840" class="Symbol">{</a><a id="5841" href="Cat.Instances.Slice.html#5841" class="Bound">y</a><a id="5842" class="Symbol">}</a> <a id="5844" class="Symbol">{</a><a id="5845" href="Cat.Instances.Slice.html#5845" class="Bound">z</a><a id="5846" class="Symbol">}</a> <a id="5848" href="Cat.Instances.Slice.html#5848" class="Bound">f</a> <a id="5850" href="Cat.Instances.Slice.html#5850" class="Bound">g</a> <a id="5852" class="Symbol">=</a> <a id="5854" href="Cat.Instances.Slice.html#5914" class="Function">fog</a> <a id="5858" class="Keyword">where</a>
    <a id="5868" class="Keyword">module</a> <a id="5875" href="Cat.Instances.Slice.html#5875" class="Module">f</a> <a id="5877" class="Symbol">=</a> <a data-type="(a b : /-Obj c) → Type ℓ" id="5879" href="Cat.Instances.Slice.html#2816" class="Module">/-Hom</a> <a id="5885" href="Cat.Instances.Slice.html#5848" class="Bound">f</a>
    <a id="5891" class="Keyword">module</a> <a id="5898" href="Cat.Instances.Slice.html#5898" class="Module">g</a> <a id="5900" class="Symbol">=</a> <a data-type="(a b : /-Obj c) → Type ℓ" id="5902" href="Cat.Instances.Slice.html#2816" class="Module">/-Hom</a> <a id="5908" href="Cat.Instances.Slice.html#5850" class="Bound">g</a>
    <a id="5914" href="Cat.Instances.Slice.html#5914" class="Function">fog</a> <a id="5918" class="Symbol">:</a> <a data-type="(a b : /-Obj c) → Type ℓ" id="5920" href="Cat.Instances.Slice.html#2816" class="Record">/-Hom</a> <a id="5926" class="Symbol">_</a> <a id="5928" class="Symbol">_</a>
    <a id="5934" href="Cat.Instances.Slice.html#5914" class="Function">fog</a> <a id="5938" class="Symbol">.</a><a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="5939" href="Cat.Instances.Slice.html#2951" class="Field">map</a> <a id="5943" class="Symbol">=</a> <a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="5945" href="Cat.Instances.Slice.html#2951" class="Function">f.map</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="5951" href="Cat.Base.html#2928" class="Function Operator">C.∘</a> <a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="5955" href="Cat.Instances.Slice.html#2951" class="Field">g.map</a>
    <a id="5965" href="Cat.Instances.Slice.html#5914" class="Function">fog</a> <a id="5969" class="Symbol">.</a><a data-type="(r : /-Hom a b) → (C ∘ map b) (r .map) ≡ a .map" id="5970" href="Cat.Instances.Slice.html#2992" class="Field">commutes</a> <a id="5979" class="Symbol">=</a>
      <a id="5987" href="Cat.Instances.Slice.html#5845" class="Bound">z</a> <a id="5989" class="Symbol">.</a><a data-type="(r : /-Obj c) → Hom C (r .domain) c" id="5990" href="Cat.Instances.Slice.html#2306" class="Field">map</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="5994" href="Cat.Base.html#2928" class="Function Operator">C.∘</a> <a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="5998" href="Cat.Instances.Slice.html#2951" class="Function">f.map</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="6004" href="Cat.Base.html#2928" class="Function Operator">C.∘</a> <a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="6008" href="Cat.Instances.Slice.html#2951" class="Field">g.map</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="6014" href="1Lab.Path.html#46642" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ a) ((C ∘ b) f) ≡ (C ∘ c) f" id="6017" href="Cat.Reasoning.html#1554" class="Function">C.pulll</a> <a data-type="(r : /-Hom a b) → (C ∘ map b) (r .map) ≡ a .map" id="6025" href="Cat.Instances.Slice.html#2992" class="Function">f.commutes</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="6036" href="1Lab.Path.html#46642" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="6044" href="Cat.Instances.Slice.html#5841" class="Bound">y</a> <a id="6046" class="Symbol">.</a><a data-type="(r : /-Obj c) → Hom C (r .domain) c" id="6047" href="Cat.Instances.Slice.html#2306" class="Field">map</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="6051" href="Cat.Base.html#2928" class="Function Operator">C.∘</a> <a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="6055" href="Cat.Instances.Slice.html#2951" class="Field">g.map</a>           <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="6071" href="1Lab.Path.html#46642" class="Function">≡⟨</a> <a data-type="(r : /-Hom a b) → (C ∘ map b) (r .map) ≡ a .map" id="6074" href="Cat.Instances.Slice.html#2992" class="Field">g.commutes</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="6085" href="1Lab.Path.html#46642" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
      <a id="6093" href="Cat.Instances.Slice.html#5837" class="Bound">x</a> <a id="6095" class="Symbol">.</a><a data-type="(r : /-Obj c) → Hom C (r .domain) c" id="6096" href="Cat.Instances.Slice.html#2306" class="Field">map</a>                     <a data-type="(x : A) → x ≡ x" id="6120" href="1Lab.Path.html#46970" class="Function Operator">∎</a>
  <a id="6124" href="Cat.Instances.Slice.html#5077" class="Function">precat</a> <a id="6131" class="Symbol">.</a><a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" id="6132" href="Cat.Base.html#3359" class="Field">idr</a> <a id="6136" href="Cat.Instances.Slice.html#6136" class="Bound">f</a> <a id="6138" class="Symbol">=</a> <a data-type="x .map ≡ y .map → x ≡ y" id="6140" href="Cat.Instances.Slice.html#3929" class="Function">/-Hom-path</a> <a id="6151" class="Symbol">(</a><a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" id="6152" href="Cat.Base.html#3359" class="Function">C.idr</a> <a id="6158" class="Symbol">_)</a>
  <a id="6163" href="Cat.Instances.Slice.html#5077" class="Function">precat</a> <a id="6170" class="Symbol">.</a><a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" id="6171" href="Cat.Base.html#3404" class="Field">idl</a> <a id="6175" href="Cat.Instances.Slice.html#6175" class="Bound">f</a> <a id="6177" class="Symbol">=</a> <a data-type="x .map ≡ y .map → x ≡ y" id="6179" href="Cat.Instances.Slice.html#3929" class="Function">/-Hom-path</a> <a id="6190" class="Symbol">(</a><a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" id="6191" href="Cat.Base.html#3404" class="Function">C.idl</a> <a id="6197" class="Symbol">_)</a>
  <a id="6202" href="Cat.Instances.Slice.html#5077" class="Function">precat</a> <a id="6209" class="Symbol">.</a><a data-type="(r : Precategory o h) (f : r .Hom y z) (g : r .Hom x y)
(h : r .Hom w x) →
r ._∘_ f (r ._∘_ g h) ≡ r ._∘_ (r ._∘_ f g) h" id="6210" href="Cat.Base.html#3779" class="Field">assoc</a> <a id="6216" href="Cat.Instances.Slice.html#6216" class="Bound">f</a> <a id="6218" href="Cat.Instances.Slice.html#6218" class="Bound">g</a> <a id="6220" href="Cat.Instances.Slice.html#6220" class="Bound">h</a> <a id="6222" class="Symbol">=</a> <a data-type="x .map ≡ y .map → x ≡ y" id="6224" href="Cat.Instances.Slice.html#3929" class="Function">/-Hom-path</a> <a id="6235" class="Symbol">(</a><a data-type="(r : Precategory o h) (f : r .Hom y z) (g : r .Hom x y)
(h : r .Hom w x) →
r ._∘_ f (r ._∘_ g h) ≡ r ._∘_ (r ._∘_ f g) h" id="6236" href="Cat.Base.html#3779" class="Function">C.assoc</a> <a id="6244" class="Symbol">_</a> <a id="6246" class="Symbol">_</a> <a id="6248" class="Symbol">_)</a>
</pre>
<h2 id="limits"><a href="#limits" class="header-link">Limits<span class="header-link-emoji">🔗</span></a></h2>
<p>We discuss some limits in the slice of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span> over <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>.</span> First, every slice category has a terminal object, given by the identity map <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">i</mi><mi mathvariant="normal">d</mi></mrow><mo>:</mo><mi>c</mi><mo>→</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">\id{id} : c \to c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">id</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>.</span></p>
<pre class="Agda"><a id="6432" class="Keyword">module</a> <a id="6439" href="Cat.Instances.Slice.html#6439" class="Module">_</a> <a id="6441" class="Symbol">{</a><a id="6442" href="Cat.Instances.Slice.html#6442" class="Bound">o</a> <a id="6444" href="Cat.Instances.Slice.html#6444" class="Bound">ℓ</a><a id="6445" class="Symbol">}</a> <a id="6447" class="Symbol">{</a><a id="6448" href="Cat.Instances.Slice.html#6448" class="Bound">C</a> <a id="6450" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="6452" href="Cat.Base.html#644" class="Record">Precategory</a> <a id="6464" href="Cat.Instances.Slice.html#6442" class="Bound">o</a> <a id="6466" href="Cat.Instances.Slice.html#6444" class="Bound">ℓ</a><a id="6467" class="Symbol">}</a> <a id="6469" class="Symbol">{</a><a id="6470" href="Cat.Instances.Slice.html#6470" class="Bound">c</a> <a id="6472" class="Symbol">:</a> <a data-type="Precategory o h → Type o" id="6474" href="Cat.Base.html#1341" class="Field">Precategory.Ob</a> <a id="6489" href="Cat.Instances.Slice.html#6448" class="Bound">C</a><a id="6490" class="Symbol">}</a> <a id="6492" class="Keyword">where</a>
  <a id="6500" class="Keyword">import</a> <a id="6507" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="6521" href="Cat.Instances.Slice.html#6448" class="Bound">C</a> as <a id="6526" href="Cat.Instances.Slice.html#6526" class="Module">C</a>
  <a id="6530" class="Keyword">import</a> <a id="6537" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="6551" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) → Ob C → Precategory (o ⊔ ℓ) ℓ" id="6552" href="Cat.Instances.Slice.html#4907" class="Function">Slice</a> <a id="6558" href="Cat.Instances.Slice.html#6448" class="Bound">C</a> <a id="6560" href="Cat.Instances.Slice.html#6470" class="Bound">c</a><a id="6561" class="Symbol">)</a> as <a id="6566" href="Cat.Instances.Slice.html#6566" class="Module">C/c</a>
  <a id="6572" class="Keyword">open</a> <a data-type="(a b : /-Obj c) → Type ℓ" id="6577" href="Cat.Instances.Slice.html#2816" class="Module">/-Hom</a>
  <a id="6585" class="Keyword">open</a> <a data-type="(c : Ob C) → Type (o ⊔ ℓ)" id="6590" href="Cat.Instances.Slice.html#2190" class="Module">/-Obj</a>

  <a data-type="is-terminal (Slice C c) (cut (C .id))" id="6599" href="Cat.Instances.Slice.html#6599" class="Function">Slice-terminal-object</a> <a id="6621" class="Symbol">:</a> <a data-type="(C : Precategory o h) → Ob C → Type (o ⊔ h)" id="6623" href="Cat.Diagram.Terminal.html#328" class="Function">is-terminal</a> <a id="6635" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) → Ob C → Precategory (o ⊔ ℓ) ℓ" id="6636" href="Cat.Instances.Slice.html#4907" class="Function">Slice</a> <a id="6642" href="Cat.Instances.Slice.html#6448" class="Bound">C</a> <a id="6644" href="Cat.Instances.Slice.html#6470" class="Bound">c</a><a id="6645" class="Symbol">)</a> <a id="6647" class="Symbol">(</a><a data-type="(map₁ : Hom C domain c) → /-Obj c" id="6648" href="Cat.Instances.Slice.html#2264" class="InductiveConstructor">cut</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="6652" href="Cat.Base.html#2898" class="Function">C.id</a><a id="6656" class="Symbol">)</a>
  <a data-type="is-terminal (Slice C c) (cut (C .id))" id="6660" href="Cat.Instances.Slice.html#6599" class="Function">Slice-terminal-object</a> <a id="6682" href="Cat.Instances.Slice.html#6682" class="Bound">obj</a> <a id="6686" class="Symbol">.</a><a data-type="is-contr A → A" id="6687" href="1Lab.HLevel.html#1401" class="Field">centre</a> <a id="6694" class="Symbol">.</a><a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="6695" href="Cat.Instances.Slice.html#2951" class="Field">map</a> <a id="6699" class="Symbol">=</a> <a id="6701" href="Cat.Instances.Slice.html#6682" class="Bound">obj</a> <a id="6705" class="Symbol">.</a><a data-type="(r : /-Obj c) → Hom C (r .domain) c" id="6706" href="Cat.Instances.Slice.html#2306" class="Field">map</a>
  <a data-type="is-terminal (Slice C c) (cut (C .id))" id="6712" href="Cat.Instances.Slice.html#6599" class="Function">Slice-terminal-object</a> <a id="6734" href="Cat.Instances.Slice.html#6734" class="Bound">obj</a> <a id="6738" class="Symbol">.</a><a data-type="is-contr A → A" id="6739" href="1Lab.HLevel.html#1401" class="Field">centre</a> <a id="6746" class="Symbol">.</a><a data-type="(r : /-Hom a b) → (C ∘ map b) (r .map) ≡ a .map" id="6747" href="Cat.Instances.Slice.html#2992" class="Field">commutes</a> <a id="6756" class="Symbol">=</a> <a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" id="6758" href="Cat.Base.html#3404" class="Function">C.idl</a> <a id="6764" class="Symbol">_</a>
  <a data-type="is-terminal (Slice C c) (cut (C .id))" id="6768" href="Cat.Instances.Slice.html#6599" class="Function">Slice-terminal-object</a> <a id="6790" href="Cat.Instances.Slice.html#6790" class="Bound">obj</a> <a id="6794" class="Symbol">.</a><a data-type="(r : is-contr A) (x : A) → r .centre ≡ x" id="6795" href="1Lab.HLevel.html#1416" class="Field">paths</a> <a id="6801" href="Cat.Instances.Slice.html#6801" class="Bound">other</a> <a id="6807" class="Symbol">=</a>
    <a data-type="x .map ≡ y .map → x ≡ y" id="6813" href="Cat.Instances.Slice.html#3929" class="Function">/-Hom-path</a> <a id="6824" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="6825" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="6829" class="Symbol">(</a><a id="6830" href="Cat.Instances.Slice.html#6801" class="Bound">other</a> <a id="6836" class="Symbol">.</a><a data-type="(r : /-Hom a b) → (C ∘ map b) (r .map) ≡ a .map" id="6837" href="Cat.Instances.Slice.html#2992" class="Field">commutes</a><a id="6845" class="Symbol">)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="6847" href="1Lab.Path.html#39485" class="Function Operator">∙</a> <a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" id="6849" href="Cat.Base.html#3404" class="Function">C.idl</a> <a id="6855" class="Symbol">_)</a>
</pre>
<p>Products in a slice category are slightly more complicated, but recall that another word for pullback is “fibred product”. Indeed, in the pullback page we noted that the pullback of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">X \to Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>→</mo><mi>Z</mi></mrow><annotation encoding="application/x-tex">Y \to Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span> is exactly the product of those maps in the slice over <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span></span></span></span>.</span></p>
<!--
<pre class="Agda"><a id="7143" class="Keyword">module</a> <a id="7150" href="Cat.Instances.Slice.html#7150" class="Module">_</a> <a id="7152" class="Symbol">{</a><a id="7153" href="Cat.Instances.Slice.html#7153" class="Bound">o</a> <a id="7155" href="Cat.Instances.Slice.html#7155" class="Bound">ℓ</a><a id="7156" class="Symbol">}</a> <a id="7158" class="Symbol">{</a><a id="7159" href="Cat.Instances.Slice.html#7159" class="Bound">C</a> <a id="7161" class="Symbol">:</a> <a id="7163" href="Cat.Base.html#644" class="Record">Precategory</a> <a id="7175" href="Cat.Instances.Slice.html#7153" class="Bound">o</a> <a id="7177" href="Cat.Instances.Slice.html#7155" class="Bound">ℓ</a><a id="7178" class="Symbol">}</a> <a id="7180" class="Symbol">{</a><a id="7181" href="Cat.Instances.Slice.html#7181" class="Bound">c</a> <a id="7183" class="Symbol">:</a> <a id="7185" href="Cat.Base.html#1341" class="Field">Precategory.Ob</a> <a id="7200" href="Cat.Instances.Slice.html#7159" class="Bound">C</a><a id="7201" class="Symbol">}</a> <a id="7203" class="Keyword">where</a>
  <a id="7211" class="Keyword">import</a> <a id="7218" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="7232" href="Cat.Instances.Slice.html#7159" class="Bound">C</a> as <a id="7237" href="Cat.Instances.Slice.html#7237" class="Module">C</a>
  <a id="7241" class="Keyword">import</a> <a id="7248" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="7262" class="Symbol">(</a><a id="7263" href="Cat.Instances.Slice.html#4907" class="Function">Slice</a> <a id="7269" href="Cat.Instances.Slice.html#7159" class="Bound">C</a> <a id="7271" href="Cat.Instances.Slice.html#7181" class="Bound">c</a><a id="7272" class="Symbol">)</a> as <a id="7277" href="Cat.Instances.Slice.html#7277" class="Module">C/c</a>
  <a id="7283" class="Keyword">private</a> <a id="7291" class="Keyword">variable</a>
    <a id="7304" href="Cat.Instances.Slice.html#7304" class="Generalizable">a</a> <a id="7306" href="Cat.Instances.Slice.html#7306" class="Generalizable">b</a> <a id="7308" class="Symbol">:</a> <a id="7310" href="Cat.Base.html#1341" class="Function">C.Ob</a>
    <a id="7319" href="Cat.Instances.Slice.html#7319" class="Generalizable">f</a> <a id="7321" href="Cat.Instances.Slice.html#7321" class="Generalizable">g</a> <a id="7323" href="Cat.Instances.Slice.html#7323" class="Generalizable">π₁</a> <a id="7326" href="Cat.Instances.Slice.html#7326" class="Generalizable">π₂</a> <a id="7329" class="Symbol">:</a> <a id="7331" href="Cat.Base.html#1358" class="Function">C.Hom</a> <a id="7337" href="Cat.Instances.Slice.html#7304" class="Generalizable">a</a> <a id="7339" href="Cat.Instances.Slice.html#7306" class="Generalizable">b</a>
  <a id="7343" class="Keyword">open</a> <a id="7348" href="Cat.Instances.Slice.html#2816" class="Module">/-Hom</a>
  <a id="7356" class="Keyword">open</a> <a id="7361" href="Cat.Instances.Slice.html#2190" class="Module">/-Obj</a>
</pre>-->
<p>Suppose we have a pullback diagram like the one below, i.e., a limit of the diagram <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mi>f</mi></mpadded></mover><mi>c</mi><mover><mo stretchy="true" minsize="3.0em">←</mo><mpadded width="+0.6em" lspace="0.3em"><mi>g</mi></mpadded></mover><mi>b</mi></mrow><annotation encoding="application/x-tex">a \xrightarrow{f} c \xleftarrow{g} b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1191em;vertical-align:-0.011em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1081em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9344em;vertical-align:-0.011em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9234em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMinYMin slice"><path d="M400000 241H110l3-3c68.7-52.7 113.7-120
 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8
-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247
c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208
 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3
 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202
 l-3-3h399890zM100 241v40h399900v-40z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>,</span> in the category <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>.</span> We’ll show that it’s also a limit of the (discrete) diagram consisting of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> and <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>,</span> but now in the slice category <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi><mi mathvariant="normal">/</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">\ca{C}/c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mord">/</span><span class="mord mathnormal">c</span></span></span></span>.</span></p>
<div class="diagram-container">
<img src="f575bf101931cf48ac014bfde2065dd79f35c226.svg" title="commutative diagram" class="diagram quiver" />
</div>
<p>For starters, note that we have seemingly “two” distinct choices for maps <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><msub><mo>×</mo><mi>c</mi></msub><mi>b</mi><mo>→</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a \times_c b \to c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mbin">×</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>,</span> but since the square above commutes, either one will do. For definiteness, we go with the composite <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∘</mo><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">f \circ \pi_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</span></p>
<pre class="Agda">  <a id="8188" class="Keyword">module</a>
    <a id="8199" href="Cat.Instances.Slice.html#8199" class="Module">_</a> <a id="8201" class="Symbol">{</a><a id="8202" href="Cat.Instances.Slice.html#8202" class="Bound">f</a> <a id="8204" href="Cat.Instances.Slice.html#8204" class="Bound">g</a> <a id="8206" class="Symbol">:</a> <a data-type="(c : Ob C) → Type (o ⊔ ℓ)" id="8208" href="Cat.Instances.Slice.html#2190" class="Record">/-Obj</a> <a id="8214" href="Cat.Instances.Slice.html#7181" class="Bound">c</a><a id="8215" class="Symbol">}</a> <a id="8217" class="Symbol">{</a><a id="8218" href="Cat.Instances.Slice.html#8218" class="Bound">Pb</a> <a id="8221" class="Symbol">:</a> <a data-type="Precategory o h → Type o" id="8223" href="Cat.Base.html#1341" class="Function">C.Ob</a><a id="8227" class="Symbol">}</a> <a id="8229" class="Symbol">{</a><a id="8230" href="Cat.Instances.Slice.html#8230" class="Bound">π₁</a> <a id="8233" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="8235" href="Cat.Base.html#1358" class="Function">C.Hom</a> <a id="8241" href="Cat.Instances.Slice.html#8218" class="Bound">Pb</a> <a id="8244" class="Symbol">(</a><a id="8245" href="Cat.Instances.Slice.html#8202" class="Bound">f</a> <a id="8247" class="Symbol">.</a><a data-type="/-Obj c → Ob C" id="8248" href="Cat.Instances.Slice.html#2285" class="Field">domain</a><a id="8254" class="Symbol">)}</a>
                                  <a id="8291" class="Symbol">{</a><a id="8292" href="Cat.Instances.Slice.html#8292" class="Bound">π₂</a> <a id="8295" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="8297" href="Cat.Base.html#1358" class="Function">C.Hom</a> <a id="8303" href="Cat.Instances.Slice.html#8218" class="Bound">Pb</a> <a id="8306" class="Symbol">(</a><a id="8307" href="Cat.Instances.Slice.html#8204" class="Bound">g</a> <a id="8309" class="Symbol">.</a><a data-type="/-Obj c → Ob C" id="8310" href="Cat.Instances.Slice.html#2285" class="Field">domain</a><a id="8316" class="Symbol">)}</a>
      <a id="8325" class="Symbol">(</a><a id="8326" href="Cat.Instances.Slice.html#8326" class="Bound">pb</a> <a id="8329" class="Symbol">:</a> <a data-type="(C : Precategory ℓ ℓ′) (p₁ : Hom C P X) (f : Hom C X Z)
(p₂ : Hom C P Y) (g : Hom C Y Z) →
Type (ℓ ⊔ ℓ′)" id="8331" href="Cat.Diagram.Pullback.html#622" class="Record">is-pullback</a> <a id="8343" href="Cat.Instances.Slice.html#7159" class="Bound">C</a> <a id="8345" class="Symbol">{</a><a id="8346" class="Argument">X</a> <a id="8348" class="Symbol">=</a> <a id="8350" href="Cat.Instances.Slice.html#8202" class="Bound">f</a> <a id="8352" class="Symbol">.</a><a data-type="/-Obj c → Ob C" id="8353" href="Cat.Instances.Slice.html#2285" class="Field">domain</a><a id="8359" class="Symbol">}</a> <a id="8361" class="Symbol">{</a><a id="8362" class="Argument">Z</a> <a id="8364" class="Symbol">=</a> <a id="8366" href="Cat.Instances.Slice.html#7181" class="Bound">c</a><a id="8367" class="Symbol">}</a> <a id="8369" class="Symbol">{</a><a id="8370" class="Argument">Y</a> <a id="8372" class="Symbol">=</a> <a id="8374" href="Cat.Instances.Slice.html#8204" class="Bound">g</a> <a id="8376" class="Symbol">.</a><a data-type="/-Obj c → Ob C" id="8377" href="Cat.Instances.Slice.html#2285" class="Field">domain</a><a id="8383" class="Symbol">}</a> <a id="8385" class="Symbol">{</a><a id="8386" class="Argument">P</a> <a id="8388" class="Symbol">=</a> <a id="8390" href="Cat.Instances.Slice.html#8218" class="Bound">Pb</a><a id="8392" class="Symbol">}</a>
        <a id="8402" href="Cat.Instances.Slice.html#8230" class="Bound">π₁</a> <a id="8405" class="Symbol">(</a><a data-type="(r : /-Obj c) → Hom C (r .domain) c" id="8406" href="Cat.Instances.Slice.html#2306" class="Field">map</a> <a id="8410" class="Symbol">{_}</a> <a id="8414" class="Symbol">{_}</a> <a id="8418" class="Symbol">{</a><a id="8419" href="Cat.Instances.Slice.html#7159" class="Bound">C</a><a id="8420" class="Symbol">}</a> <a id="8422" class="Symbol">{</a><a id="8423" href="Cat.Instances.Slice.html#7181" class="Bound">c</a><a id="8424" class="Symbol">}</a> <a id="8426" href="Cat.Instances.Slice.html#8202" class="Bound">f</a><a id="8427" class="Symbol">)</a> <a id="8429" href="Cat.Instances.Slice.html#8292" class="Bound">π₂</a> <a id="8432" class="Symbol">(</a><a data-type="(r : /-Obj c) → Hom C (r .domain) c" id="8433" href="Cat.Instances.Slice.html#2306" class="Field">map</a> <a id="8437" class="Symbol">{_}</a> <a id="8441" class="Symbol">{_}</a> <a id="8445" class="Symbol">{</a><a id="8446" href="Cat.Instances.Slice.html#7159" class="Bound">C</a><a id="8447" class="Symbol">}</a> <a id="8449" class="Symbol">{</a><a id="8450" href="Cat.Instances.Slice.html#7181" class="Bound">c</a><a id="8451" class="Symbol">}</a> <a id="8453" href="Cat.Instances.Slice.html#8204" class="Bound">g</a><a id="8454" class="Symbol">))</a>
    <a id="8461" class="Keyword">where</a>
    <a id="8471" class="Keyword">private</a> <a id="8479" class="Keyword">module</a> <a id="8486" href="Cat.Instances.Slice.html#8486" class="Module">pb</a> <a id="8489" class="Symbol">=</a> <a data-type="(C : Precategory ℓ ℓ′) (p₁ : Hom C P X) (f : Hom C X Z)
(p₂ : Hom C P Y) (g : Hom C Y Z) →
Type (ℓ ⊔ ℓ′)" id="8491" href="Cat.Diagram.Pullback.html#622" class="Module">is-pullback</a> <a id="8503" href="Cat.Instances.Slice.html#8326" class="Bound">pb</a>

    <a data-type="(pb : is-pullback C π₁ (map f) π₂ (map g)) → Slice C c .Ob" id="8511" href="Cat.Instances.Slice.html#8511" class="Function">is-pullback→product-over</a> <a id="8536" class="Symbol">:</a> <a data-type="Precategory o h → Type o" id="8538" href="Cat.Base.html#1341" class="Function">C/c.Ob</a>
    <a data-type="(pb : is-pullback C π₁ (map f) π₂ (map g)) → Slice C c .Ob" id="8549" href="Cat.Instances.Slice.html#8511" class="Function">is-pullback→product-over</a> <a id="8574" class="Symbol">=</a> <a data-type="(map₁ : Hom C domain c) → /-Obj c" id="8576" href="Cat.Instances.Slice.html#2264" class="InductiveConstructor">cut</a> <a id="8580" class="Symbol">(</a><a id="8581" href="Cat.Instances.Slice.html#8202" class="Bound">f</a> <a id="8583" class="Symbol">.</a><a data-type="(r : /-Obj c) → Hom C (r .domain) c" id="8584" href="Cat.Instances.Slice.html#2306" class="Field">map</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="8588" href="Cat.Base.html#2928" class="Function Operator">C.∘</a> <a id="8592" href="Cat.Instances.Slice.html#8230" class="Bound">π₁</a><a id="8594" class="Symbol">)</a>
</pre>
<p>Now, by commutativity of the square, the maps <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\pi_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> in the diagram above extend to maps <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>f</mi><mo>∘</mo><msub><mi>π</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>→</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">(f \circ \pi_1) \to f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>f</mi><mo>∘</mo><msub><mi>π</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>→</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">(f \circ \pi_1) \to g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> in <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi><mi mathvariant="normal">/</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">\ca{C}/c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mord">/</span><span class="mord mathnormal">c</span></span></span></span>.</span> Indeed, note that by scribbling a red line across the diagonal of the diagram, we get the two needed triangles as the induced subdivisions.</p>
<div class="diagram-container">
<img src="71070ffb6e5ced3e9f64bea6689b547e41953dee.svg" title="commutative diagram" class="diagram quiver" />
</div>
<pre class="Agda">    <a data-type="(pb : is-pullback C π₁ (map f) π₂ (map g)) →
Slice C c .Hom (is-pullback→product-over pb) f" id="9255" href="Cat.Instances.Slice.html#9255" class="Function">is-pullback→π₁</a> <a id="9270" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="9272" href="Cat.Base.html#1358" class="Function">C/c.Hom</a> <a data-type="(pb : is-pullback C π₁ (map f) π₂ (map g)) → Slice C c .Ob" id="9280" href="Cat.Instances.Slice.html#8511" class="Function">is-pullback→product-over</a> <a id="9305" href="Cat.Instances.Slice.html#8202" class="Bound">f</a>
    <a data-type="(pb : is-pullback C π₁ (map f) π₂ (map g)) →
Slice C c .Hom (is-pullback→product-over pb) f" id="9311" href="Cat.Instances.Slice.html#9255" class="Function">is-pullback→π₁</a> <a id="9326" class="Symbol">.</a><a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="9327" href="Cat.Instances.Slice.html#2951" class="Field">map</a>      <a id="9336" class="Symbol">=</a> <a id="9338" href="Cat.Instances.Slice.html#8230" class="Bound">π₁</a>
    <a data-type="(pb : is-pullback C π₁ (map f) π₂ (map g)) →
Slice C c .Hom (is-pullback→product-over pb) f" id="9345" href="Cat.Instances.Slice.html#9255" class="Function">is-pullback→π₁</a> <a id="9360" class="Symbol">.</a><a data-type="(r : /-Hom a b) → (C ∘ map b) (r .map) ≡ a .map" id="9361" href="Cat.Instances.Slice.html#2992" class="Field">commutes</a> <a id="9370" href="Cat.Instances.Slice.html#9370" class="Bound">i</a> <a id="9372" class="Symbol">=</a> <a id="9374" href="Cat.Instances.Slice.html#8202" class="Bound">f</a> <a id="9376" class="Symbol">.</a><a data-type="(r : /-Obj c) → Hom C (r .domain) c" id="9377" href="Cat.Instances.Slice.html#2306" class="Field">map</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="9381" href="Cat.Base.html#2928" class="Function Operator">C.∘</a> <a id="9385" href="Cat.Instances.Slice.html#8230" class="Bound">π₁</a>

    <a data-type="(pb : is-pullback C π₁ (map f) π₂ (map g)) →
Slice C c .Hom (is-pullback→product-over pb) g" id="9393" href="Cat.Instances.Slice.html#9393" class="Function">is-pullback→π₂</a> <a id="9408" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="9410" href="Cat.Base.html#1358" class="Function">C/c.Hom</a> <a data-type="(pb : is-pullback C π₁ (map f) π₂ (map g)) → Slice C c .Ob" id="9418" href="Cat.Instances.Slice.html#8511" class="Function">is-pullback→product-over</a> <a id="9443" href="Cat.Instances.Slice.html#8204" class="Bound">g</a>
    <a data-type="(pb : is-pullback C π₁ (map f) π₂ (map g)) →
Slice C c .Hom (is-pullback→product-over pb) g" id="9449" href="Cat.Instances.Slice.html#9393" class="Function">is-pullback→π₂</a> <a id="9464" class="Symbol">.</a><a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="9465" href="Cat.Instances.Slice.html#2951" class="Field">map</a>        <a id="9476" class="Symbol">=</a> <a id="9478" href="Cat.Instances.Slice.html#8292" class="Bound">π₂</a>
    <a data-type="(pb : is-pullback C π₁ (map f) π₂ (map g)) →
Slice C c .Hom (is-pullback→product-over pb) g" id="9485" href="Cat.Instances.Slice.html#9393" class="Function">is-pullback→π₂</a> <a id="9500" class="Symbol">.</a><a data-type="(r : /-Hom a b) → (C ∘ map b) (r .map) ≡ a .map" id="9501" href="Cat.Instances.Slice.html#2992" class="Field">commutes</a> <a id="9510" href="Cat.Instances.Slice.html#9510" class="Bound">i</a> <a id="9512" class="Symbol">=</a> <a data-type="(r : Pullback C f g) → (C ∘ f) (r .p₁) ≡ (C ∘ g) (r .p₂)" id="9514" href="Cat.Diagram.Pullback.html#733" class="Field">pb.square</a> <a id="9524" class="Symbol">(</a><a id="9525" href="1Lab.Path.html#2261" class="Primitive Operator">~</a> <a id="9527" href="Cat.Instances.Slice.html#9510" class="Bound">i</a><a id="9528" class="Symbol">)</a>

    <a id="9535" class="Keyword">open</a> <a data-type="(C : Precategory o h) (π₁ : Hom C P A) (π₂ : Hom C P B₁) →
Type (o ⊔ h)" id="9540" href="Cat.Diagram.Product.html#1774" class="Module">is-product</a>
</pre>
<p>Unfolding what it means for a diagram to be a universal cone over the discrete diagram consisting of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> in the category <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi><mi mathvariant="normal">/</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">\ca{C}/c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mord">/</span><span class="mord mathnormal">c</span></span></span></span>,</span> we see that it is exactly the data of the pullback of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> in <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>,</span> as below:</p>
<pre class="Agda">    <a data-type="(pb : is-pullback C π₁ (map f) π₂ (map g)) →
is-product (Slice C c) (is-pullback→π₁ pb) (is-pullback→π₂ pb)" id="9799" href="Cat.Instances.Slice.html#9799" class="Function">is-pullback→is-fibre-product</a>
      <a id="9834" class="Symbol">:</a> <a data-type="(C : Precategory o h) (π₁ : Hom C P A) (π₂ : Hom C P B₁) →
Type (o ⊔ h)" id="9836" href="Cat.Diagram.Product.html#1774" class="Record">is-product</a> <a id="9847" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) → Ob C → Precategory (o ⊔ ℓ) ℓ" id="9848" href="Cat.Instances.Slice.html#4907" class="Function">Slice</a> <a id="9854" href="Cat.Instances.Slice.html#7159" class="Bound">C</a> <a id="9856" href="Cat.Instances.Slice.html#7181" class="Bound">c</a><a id="9857" class="Symbol">)</a> <a data-type="(pb : is-pullback C π₁ (map f) π₂ (map g)) →
Slice C c .Hom (is-pullback→product-over pb) f" id="9859" href="Cat.Instances.Slice.html#9255" class="Function">is-pullback→π₁</a> <a data-type="(pb : is-pullback C π₁ (map f) π₂ (map g)) →
Slice C c .Hom (is-pullback→product-over pb) g" id="9874" href="Cat.Instances.Slice.html#9393" class="Function">is-pullback→π₂</a>
    <a data-type="(pb : is-pullback C π₁ (map f) π₂ (map g)) →
is-product (Slice C c) (is-pullback→π₁ pb) (is-pullback→π₂ pb)" id="9893" href="Cat.Instances.Slice.html#9799" class="Function">is-pullback→is-fibre-product</a> <a id="9922" class="Symbol">.</a><a data-type="(r : Product C A B₁) → Hom C Q A → Hom C Q B₁ → Hom C Q (r .apex)" id="9923" href="Cat.Diagram.Product.html#1856" class="Field Operator">⟨_,_⟩</a> <a id="9929" class="Symbol">{</a><a id="9930" href="Cat.Instances.Slice.html#9930" class="Bound">Q</a><a id="9931" class="Symbol">}</a> <a id="9933" href="Cat.Instances.Slice.html#9933" class="Bound">/f</a> <a id="9936" href="Cat.Instances.Slice.html#9936" class="Bound">/g</a> <a id="9939" class="Symbol">=</a> <a id="9941" href="Cat.Instances.Slice.html#10025" class="Function">factor</a>
      <a id="9954" class="Keyword">where</a>
        <a id="9968" class="Keyword">module</a> <a id="9975" href="Cat.Instances.Slice.html#9975" class="Module">f</a> <a id="9977" class="Symbol">=</a> <a data-type="(a b : /-Obj c) → Type ℓ" id="9979" href="Cat.Instances.Slice.html#2816" class="Module">/-Hom</a> <a id="9985" href="Cat.Instances.Slice.html#9933" class="Bound">/f</a>
        <a id="9996" class="Keyword">module</a> <a id="10003" href="Cat.Instances.Slice.html#10003" class="Module">g</a> <a id="10005" class="Symbol">=</a> <a data-type="(a b : /-Obj c) → Type ℓ" id="10007" href="Cat.Instances.Slice.html#2816" class="Module">/-Hom</a> <a id="10013" href="Cat.Instances.Slice.html#9936" class="Bound">/g</a>

        <a id="10025" href="Cat.Instances.Slice.html#10025" class="Function">factor</a> <a id="10032" class="Symbol">:</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="10034" href="Cat.Base.html#1358" class="Function">C/c.Hom</a> <a id="10042" href="Cat.Instances.Slice.html#9930" class="Bound">Q</a> <a id="10044" class="Symbol">_</a>
        <a id="10054" href="Cat.Instances.Slice.html#10025" class="Function">factor</a> <a id="10061" class="Symbol">.</a><a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="10062" href="Cat.Instances.Slice.html#2951" class="Field">map</a> <a id="10066" class="Symbol">=</a> <a data-type="(r : Pullback C f g) →
(C ∘ f) p₁&#39; ≡ (C ∘ g) p₂&#39; → Hom C P′ (r .apex)" id="10068" href="Cat.Diagram.Pullback.html#1452" class="Field">pb.limiting</a> <a id="10080" class="Symbol">(</a><a data-type="(r : /-Hom a b) → (C ∘ map b) (r .map) ≡ a .map" id="10081" href="Cat.Instances.Slice.html#2992" class="Function">f.commutes</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="10092" href="1Lab.Path.html#39485" class="Function Operator">∙</a> <a data-type="x ≡ y → y ≡ x" id="10094" href="1Lab.Path.html#10558" class="Function">sym</a> <a data-type="(r : /-Hom a b) → (C ∘ map b) (r .map) ≡ a .map" id="10098" href="Cat.Instances.Slice.html#2992" class="Field">g.commutes</a><a id="10108" class="Symbol">)</a>
        <a id="10118" href="Cat.Instances.Slice.html#10025" class="Function">factor</a> <a id="10125" class="Symbol">.</a><a data-type="(r : /-Hom a b) → (C ∘ map b) (r .map) ≡ a .map" id="10126" href="Cat.Instances.Slice.html#2992" class="Field">commutes</a> <a id="10135" class="Symbol">=</a>
          <a id="10147" class="Symbol">(</a><a id="10148" href="Cat.Instances.Slice.html#8202" class="Bound">f</a> <a id="10150" class="Symbol">.</a><a data-type="(r : /-Obj c) → Hom C (r .domain) c" id="10151" href="Cat.Instances.Slice.html#2306" class="Field">map</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="10155" href="Cat.Base.html#2928" class="Function Operator">C.∘</a> <a id="10159" href="Cat.Instances.Slice.html#8230" class="Bound">π₁</a><a id="10161" class="Symbol">)</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="10163" href="Cat.Base.html#2928" class="Function Operator">C.∘</a> <a data-type="(r : Pullback C f g) →
(C ∘ f) p₁&#39; ≡ (C ∘ g) p₂&#39; → Hom C P′ (r .apex)" id="10167" href="Cat.Diagram.Pullback.html#1452" class="Field">pb.limiting</a> <a id="10179" class="Symbol">_</a> <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="10181" href="1Lab.Path.html#46642" class="Function">≡⟨</a> <a data-type="(C : Precategory o ℓ) (ab≡c : (C ∘ a) b ≡ c) →
(C ∘ (C ∘ f) a) b ≡ (C ∘ f) c" id="10184" href="Cat.Reasoning.html#1684" class="Function">C.pullr</a> <a data-type="(r : Pullback C f g) → (C ∘ r .p₁) (has-is-pb r .limiting p) ≡ p₁&#39;" id="10192" href="Cat.Diagram.Pullback.html#1552" class="Field">pb.p₁∘limiting</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="10207" href="1Lab.Path.html#46642" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a id="10219" href="Cat.Instances.Slice.html#8202" class="Bound">f</a> <a id="10221" class="Symbol">.</a><a data-type="(r : /-Obj c) → Hom C (r .domain) c" id="10222" href="Cat.Instances.Slice.html#2306" class="Field">map</a> <a data-type="(r : Precategory o h) → r .Hom y z → r .Hom x y → r .Hom x z" id="10226" href="Cat.Base.html#2928" class="Function Operator">C.∘</a> <a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="10230" href="Cat.Instances.Slice.html#2951" class="Function">f.map</a>                  <span class="reasoning-step"><span class="as-written Function"><a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="10253" href="1Lab.Path.html#46642" class="Function">≡⟨</a> <a data-type="(r : /-Hom a b) → (C ∘ map b) (r .map) ≡ a .map" id="10256" href="Cat.Instances.Slice.html#2992" class="Function">f.commutes</a> <a data-type="(x : A) → y ≡ z → x ≡ y → x ≡ z" id="10267" href="1Lab.Path.html#46642" class="Function">⟩</a></span><span class="alternate Function">≡</span></span>
          <a id="10279" href="Cat.Instances.Slice.html#9930" class="Bound">Q</a> <a id="10281" class="Symbol">.</a><a data-type="(r : /-Obj c) → Hom C (r .domain) c" id="10282" href="Cat.Instances.Slice.html#2306" class="Field">map</a>                            <a data-type="(x : A) → x ≡ x" id="10313" href="1Lab.Path.html#46970" class="Function Operator">∎</a>

    <a data-type="(pb : is-pullback C π₁ (map f) π₂ (map g)) →
is-product (Slice C c) (is-pullback→π₁ pb) (is-pullback→π₂ pb)" id="10320" href="Cat.Instances.Slice.html#9799" class="Function">is-pullback→is-fibre-product</a> <a id="10349" class="Symbol">.</a><a data-type="(r : Product C A B₁) →
(C ∘ r .π₁) (has-is-product r .⟨_,_⟩ p1 p2) ≡ p1" id="10350" href="Cat.Diagram.Product.html#1918" class="Field">π₁∘factor</a> <a id="10360" class="Symbol">=</a> <a data-type="x .map ≡ y .map → x ≡ y" id="10362" href="Cat.Instances.Slice.html#3929" class="Function">/-Hom-path</a> <a data-type="(r : Pullback C f g) → (C ∘ r .p₁) (has-is-pb r .limiting p) ≡ p₁&#39;" id="10373" href="Cat.Diagram.Pullback.html#1552" class="Field">pb.p₁∘limiting</a>
    <a data-type="(pb : is-pullback C π₁ (map f) π₂ (map g)) →
is-product (Slice C c) (is-pullback→π₁ pb) (is-pullback→π₂ pb)" id="10392" href="Cat.Instances.Slice.html#9799" class="Function">is-pullback→is-fibre-product</a> <a id="10421" class="Symbol">.</a><a data-type="(r : Product C A B₁) →
(C ∘ r .π₂) (has-is-product r .⟨_,_⟩ p1 p2) ≡ p2" id="10422" href="Cat.Diagram.Product.html#1984" class="Field">π₂∘factor</a> <a id="10432" class="Symbol">=</a> <a data-type="x .map ≡ y .map → x ≡ y" id="10434" href="Cat.Instances.Slice.html#3929" class="Function">/-Hom-path</a> <a data-type="(r : Pullback C f g) → (C ∘ r .p₂) (has-is-pb r .limiting p) ≡ p₂&#39;" id="10445" href="Cat.Diagram.Pullback.html#1618" class="Field">pb.p₂∘limiting</a>
    <a data-type="(pb : is-pullback C π₁ (map f) π₂ (map g)) →
is-product (Slice C c) (is-pullback→π₁ pb) (is-pullback→π₂ pb)" id="10464" href="Cat.Instances.Slice.html#9799" class="Function">is-pullback→is-fibre-product</a> <a id="10493" class="Symbol">.</a><a data-type="(r : Product C A B₁) (other : Hom C Q (r .apex)) →
(C ∘ r .π₁) other ≡ p1 →
(C ∘ r .π₂) other ≡ p2 → other ≡ has-is-product r .⟨_,_⟩ p1 p2" id="10494" href="Cat.Diagram.Product.html#2051" class="Field">unique</a> <a id="10501" href="Cat.Instances.Slice.html#10501" class="Bound">other</a> <a id="10507" href="Cat.Instances.Slice.html#10507" class="Bound">p</a> <a id="10509" href="Cat.Instances.Slice.html#10509" class="Bound">q</a> <a id="10511" class="Symbol">=</a>
      <a data-type="x .map ≡ y .map → x ≡ y" id="10519" href="Cat.Instances.Slice.html#3929" class="Function">/-Hom-path</a> <a id="10530" class="Symbol">(</a><a data-type="(r : Pullback C f g) →
(C ∘ r .p₁) lim&#39; ≡ p₁&#39; →
(C ∘ r .p₂) lim&#39; ≡ p₂&#39; → lim&#39; ≡ has-is-pb r .limiting p" id="10531" href="Cat.Diagram.Pullback.html#1685" class="Field">pb.unique</a> <a id="10541" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="10542" href="1Lab.Path.html#20756" class="Function">ap</a> <a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="10545" href="Cat.Instances.Slice.html#2951" class="Field">map</a> <a id="10549" href="Cat.Instances.Slice.html#10507" class="Bound">p</a><a id="10550" class="Symbol">)</a> <a id="10552" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="10553" href="1Lab.Path.html#20756" class="Function">ap</a> <a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="10556" href="Cat.Instances.Slice.html#2951" class="Field">map</a> <a id="10560" href="Cat.Instances.Slice.html#10509" class="Bound">q</a><a id="10561" class="Symbol">))</a>

  <a data-type="Pullback C (f .map) (g .map) → Product (Slice C c) f g" id="10567" href="Cat.Instances.Slice.html#10567" class="Function">Pullback→Fibre-product</a>
    <a id="10594" class="Symbol">:</a> <a id="10596" class="Symbol">∀</a> <a id="10598" class="Symbol">{</a><a id="10599" href="Cat.Instances.Slice.html#10599" class="Bound">f</a> <a id="10601" href="Cat.Instances.Slice.html#10601" class="Bound">g</a> <a id="10603" class="Symbol">:</a> <a data-type="(c : Ob C) → Type (o ⊔ ℓ)" id="10605" href="Cat.Instances.Slice.html#2190" class="Record">/-Obj</a> <a id="10611" href="Cat.Instances.Slice.html#7181" class="Bound">c</a><a id="10612" class="Symbol">}</a>
    <a id="10618" class="Symbol">→</a> <a data-type="(C : Precategory ℓ ℓ′) (f : Hom C X Z) (g : Hom C Y Z) →
Type (ℓ ⊔ ℓ′)" id="10620" href="Cat.Diagram.Pullback.html#2946" class="Record">Pullback</a> <a id="10629" href="Cat.Instances.Slice.html#7159" class="Bound">C</a> <a id="10631" class="Symbol">(</a><a id="10632" href="Cat.Instances.Slice.html#10599" class="Bound">f</a> <a id="10634" class="Symbol">.</a><a data-type="(r : /-Obj c) → Hom C (r .domain) c" id="10635" href="Cat.Instances.Slice.html#2306" class="Field">map</a><a id="10638" class="Symbol">)</a> <a id="10640" class="Symbol">(</a><a id="10641" href="Cat.Instances.Slice.html#10601" class="Bound">g</a> <a id="10643" class="Symbol">.</a><a data-type="(r : /-Obj c) → Hom C (r .domain) c" id="10644" href="Cat.Instances.Slice.html#2306" class="Field">map</a><a id="10647" class="Symbol">)</a> <a id="10649" class="Symbol">→</a> <a data-type="(C : Precategory o h) (A B₁ : Ob C) → Type (o ⊔ h)" id="10651" href="Cat.Diagram.Product.html#2703" class="Record">Product</a> <a id="10659" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) → Ob C → Precategory (o ⊔ ℓ) ℓ" id="10660" href="Cat.Instances.Slice.html#4907" class="Function">Slice</a> <a id="10666" href="Cat.Instances.Slice.html#7159" class="Bound">C</a> <a id="10668" href="Cat.Instances.Slice.html#7181" class="Bound">c</a><a id="10669" class="Symbol">)</a> <a id="10671" href="Cat.Instances.Slice.html#10599" class="Bound">f</a> <a id="10673" href="Cat.Instances.Slice.html#10601" class="Bound">g</a>
  <a data-type="Pullback C (f .map) (g .map) → Product (Slice C c) f g" id="10677" href="Cat.Instances.Slice.html#10567" class="Function">Pullback→Fibre-product</a> <a id="10700" href="Cat.Instances.Slice.html#10700" class="Bound">pb</a> <a id="10703" class="Symbol">.</a><a data-type="Product C A B₁ → Ob C" id="10704" href="Cat.Diagram.Product.html#2773" class="Field">Product.apex</a> <a id="10717" class="Symbol">=</a> <a id="10719" class="Symbol">_</a>
  <a data-type="Pullback C (f .map) (g .map) → Product (Slice C c) f g" id="10723" href="Cat.Instances.Slice.html#10567" class="Function">Pullback→Fibre-product</a> <a id="10746" href="Cat.Instances.Slice.html#10746" class="Bound">pb</a> <a id="10749" class="Symbol">.</a><a data-type="(r : Product C A B₁) → Hom C (r .apex) A" id="10750" href="Cat.Diagram.Product.html#2787" class="Field">Product.π₁</a> <a id="10761" class="Symbol">=</a> <a id="10763" class="Symbol">_</a>
  <a data-type="Pullback C (f .map) (g .map) → Product (Slice C c) f g" id="10767" href="Cat.Instances.Slice.html#10567" class="Function">Pullback→Fibre-product</a> <a id="10790" href="Cat.Instances.Slice.html#10790" class="Bound">pb</a> <a id="10793" class="Symbol">.</a><a data-type="(r : Product C A B₁) → Hom C (r .apex) B₁" id="10794" href="Cat.Diagram.Product.html#2807" class="Field">Product.π₂</a> <a id="10805" class="Symbol">=</a> <a id="10807" class="Symbol">_</a>
  <a data-type="Pullback C (f .map) (g .map) → Product (Slice C c) f g" id="10811" href="Cat.Instances.Slice.html#10567" class="Function">Pullback→Fibre-product</a> <a id="10834" href="Cat.Instances.Slice.html#10834" class="Bound">pb</a> <a id="10837" class="Symbol">.</a><a data-type="(r : Product C A B₁) → is-product C (r .π₁) (r .π₂)" id="10838" href="Cat.Diagram.Product.html#2827" class="Field">Product.has-is-product</a> <a id="10861" class="Symbol">=</a>
    <a data-type="(pb : is-pullback C π₁ (map f) π₂ (map g)) →
is-product (Slice C c) (is-pullback→π₁ pb) (is-pullback→π₂ pb)" id="10867" href="Cat.Instances.Slice.html#9799" class="Function">is-pullback→is-fibre-product</a> <a id="10896" class="Symbol">(</a><a id="10897" href="Cat.Instances.Slice.html#10834" class="Bound">pb</a> <a id="10900" class="Symbol">.</a><a data-type="(r : Pullback C f g) → is-pullback C (r .p₁) f (r .p₂) g" id="10901" href="Cat.Diagram.Pullback.html#3081" class="Field">Pullback.has-is-pb</a><a id="10919" class="Symbol">)</a>
</pre>
<h1 id="slices-of-sets"><a href="#slices-of-sets" class="header-link">Slices of Sets<span class="header-link-emoji">🔗</span></a></h1>
<p>We now prove the correspondence between slices of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">S</mi><mi mathvariant="bold">e</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">s</mi></mrow><annotation encoding="application/x-tex">\sets</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord"><span class="mord mathbf">Sets</span></span></span></span></span> and functor categories into <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">S</mi><mi mathvariant="bold">e</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">s</mi></mrow><annotation encoding="application/x-tex">\sets</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord"><span class="mord mathbf">Sets</span></span></span></span></span>,</span> i.e. the corresponding between indexing and slicing mentioned in the first paragraph.</p>
<pre class="Agda">
<a id="11135" class="Keyword">module</a> <a id="11142" href="Cat.Instances.Slice.html#11142" class="Module">_</a> <a id="11144" class="Symbol">{</a><a id="11145" href="Cat.Instances.Slice.html#11145" class="Bound">I</a> <a id="11147" class="Symbol">:</a> <a data-type="(ℓ : Level) → Type (lsuc ℓ)" id="11149" href="1Lab.HLevel.Universe.html#5250" class="Function">Set</a> <a id="11153" href="Cat.Instances.Slice.html#485" class="Generalizable">ℓ</a><a id="11154" class="Symbol">}</a> <a id="11156" class="Keyword">where</a>
  <a id="11164" class="Keyword">open</a> <a data-type="(c : Ob C) → Type (o ⊔ ℓ)" id="11169" href="Cat.Instances.Slice.html#2190" class="Module">/-Obj</a>
  <a id="11177" class="Keyword">open</a> <a data-type="(a b : /-Obj c) → Type ℓ" id="11182" href="Cat.Instances.Slice.html#2816" class="Module">/-Hom</a>
</pre>
<p>We shall prove that the functor <span class="Agda"><a data-type="Functor Cat[ Disc′ I₁ , Sets ℓ ] (Slice (Sets ℓ) I₁)" href="Cat.Instances.Slice.html#11518" class="Function">Total-space</a></span>, defined below, is an equivalence of categories, i.e. that it is fully faithful and essentially surjective. But first, we must define the functor! Like its name implies, it maps the functor <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi>I</mi><mo>→</mo><mrow><mi mathvariant="bold">S</mi><mi mathvariant="bold">e</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">s</mi></mrow></mrow><annotation encoding="application/x-tex">F : I → \sets</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6861em;"></span><span class="mord"><span class="mord mathbf">Sets</span></span></span></span></span> to the first projection map <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">f</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi></mrow><mo>:</mo><mo>∑</mo><mi>F</mi><mo>→</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">\id{fst} : \sum F \to I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">fst</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span>.</span></p>
<pre class="Agda">  <a data-type="Functor Cat[ Disc′ I₁ , Sets ℓ ] (Slice (Sets ℓ) I₁)" id="11518" href="Cat.Instances.Slice.html#11518" class="Function">Total-space</a> <a id="11530" class="Symbol">:</a> <a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="11532" href="Cat.Base.html#6614" class="Record">Functor</a> <a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Precategory (o₁ ⊔ o₂ ⊔ h₁ ⊔ h₂) (o₁ ⊔ h₁ ⊔ h₂)" id="11540" href="Cat.Instances.Functor.html#2078" class="Function Operator">Cat[</a> <a data-type="Set ℓ → Precategory ℓ ℓ" id="11545" href="Cat.Instances.Discrete.html#701" class="Function">Disc′</a> <a id="11551" href="Cat.Instances.Slice.html#11145" class="Bound">I</a> <a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Precategory (o₁ ⊔ o₂ ⊔ h₁ ⊔ h₂) (o₁ ⊔ h₁ ⊔ h₂)" id="11553" href="Cat.Instances.Functor.html#2078" class="Function Operator">,</a> <a data-type="(o : Level) → Precategory (lsuc o) o" id="11555" href="Cat.Base.html#6268" class="Function">Sets</a> <a id="11560" href="Cat.Instances.Slice.html#11153" class="Bound">ℓ</a> <a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Precategory (o₁ ⊔ o₂ ⊔ h₁ ⊔ h₂) (o₁ ⊔ h₁ ⊔ h₂)" id="11562" href="Cat.Instances.Functor.html#2078" class="Function Operator">]</a> <a id="11564" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) → Ob C → Precategory (o ⊔ ℓ) ℓ" id="11565" href="Cat.Instances.Slice.html#4907" class="Function">Slice</a> <a id="11571" class="Symbol">(</a><a data-type="(o : Level) → Precategory (lsuc o) o" id="11572" href="Cat.Base.html#6268" class="Function">Sets</a> <a id="11577" href="Cat.Instances.Slice.html#11153" class="Bound">ℓ</a><a id="11578" class="Symbol">)</a> <a id="11580" href="Cat.Instances.Slice.html#11145" class="Bound">I</a><a id="11581" class="Symbol">)</a>
  <a data-type="Functor Cat[ Disc′ I₁ , Sets ℓ ] (Slice (Sets ℓ) I₁)" id="11585" href="Cat.Instances.Slice.html#11518" class="Function">Total-space</a> <a id="11597" class="Symbol">.</a><a data-type="Functor C D → C .Ob → Ob D" id="11598" href="Cat.Base.html#7400" class="Field">F₀</a> <a id="11601" href="Cat.Instances.Slice.html#11601" class="Bound">F</a> <a id="11603" class="Symbol">.</a><a data-type="/-Obj c → Ob C" id="11604" href="Cat.Instances.Slice.html#2285" class="Field">domain</a> <a id="11611" class="Symbol">=</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="11613" href="1Lab.Type.html#1573" class="Function">Σ</a> <a id="11615" class="Symbol">(</a><a data-type="n-Type ℓ n → Type ℓ" id="11616" href="1Lab.HLevel.Universe.html#3120" class="Field Operator">∣_∣</a> <a id="11620" href="Cat.Prelude.html#232" class="Function Operator">⊙</a> <a data-type="Functor C D → C .Ob → Ob D" id="11622" href="Cat.Base.html#7400" class="Field">F₀</a> <a id="11625" href="Cat.Instances.Slice.html#11601" class="Bound">F</a><a id="11626" class="Symbol">)</a>
                            <a data-type="(∣_∣₁ : Type ℓ) (is-tr₁ : is-hlevel ∣_∣₁ n) → n-Type ℓ n" id="11656" href="1Lab.HLevel.Universe.html#3104" class="InductiveConstructor Operator">,</a> <a data-type="(n : Nat) →
is-hlevel A n → ((x : A) → is-hlevel (B₁ x) n) → is-hlevel (Σ B₁) n" id="11658" href="1Lab.HLevel.Retracts.html#5166" class="Function">Σ-is-hlevel</a> <a id="11670" class="Number">2</a> <a id="11672" class="Symbol">(</a><a id="11673" href="Cat.Instances.Slice.html#11145" class="Bound">I</a> <a id="11675" class="Symbol">.</a><a data-type="(r : n-Type ℓ n) → is-hlevel (r .∣_∣) n" id="11676" href="1Lab.HLevel.Universe.html#3139" class="Field">is-tr</a><a id="11681" class="Symbol">)</a> <a id="11683" class="Symbol">(</a><a data-type="(r : n-Type ℓ n) → is-hlevel (r .∣_∣) n" id="11684" href="1Lab.HLevel.Universe.html#3139" class="Field">is-tr</a> <a id="11690" href="Cat.Prelude.html#232" class="Function Operator">⊙</a> <a data-type="Functor C D → C .Ob → Ob D" id="11692" href="Cat.Base.html#7400" class="Field">F₀</a> <a id="11695" href="Cat.Instances.Slice.html#11601" class="Bound">F</a><a id="11696" class="Symbol">)</a>
  <a data-type="Functor Cat[ Disc′ I₁ , Sets ℓ ] (Slice (Sets ℓ) I₁)" id="11700" href="Cat.Instances.Slice.html#11518" class="Function">Total-space</a> <a id="11712" class="Symbol">.</a><a data-type="Functor C D → C .Ob → Ob D" id="11713" href="Cat.Base.html#7400" class="Field">F₀</a> <a id="11716" href="Cat.Instances.Slice.html#11716" class="Bound">F</a> <a id="11718" class="Symbol">.</a><a data-type="(r : /-Obj c) → Hom C (r .domain) c" id="11719" href="Cat.Instances.Slice.html#2306" class="Field">map</a> <a id="11723" class="Symbol">=</a> <a data-type="∑ A B₁ → A" id="11725" href="Agda.Builtin.Sigma.html#252" class="Field">fst</a>

  <a data-type="Functor Cat[ Disc′ I₁ , Sets ℓ ] (Slice (Sets ℓ) I₁)" id="11732" href="Cat.Instances.Slice.html#11518" class="Function">Total-space</a> <a id="11744" class="Symbol">.</a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="11745" href="Cat.Base.html#7421" class="Field">F₁</a> <a id="11748" href="Cat.Instances.Slice.html#11748" class="Bound">nt</a> <a id="11751" class="Symbol">.</a><a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="11752" href="Cat.Instances.Slice.html#2951" class="Field">map</a> <a id="11756" class="Symbol">(</a><a id="11757" href="Cat.Instances.Slice.html#11757" class="Bound">i</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="11759" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="11761" href="Cat.Instances.Slice.html#11761" class="Bound">x</a><a id="11762" class="Symbol">)</a> <a id="11764" class="Symbol">=</a> <a id="11766" href="Cat.Instances.Slice.html#11757" class="Bound">i</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="11768" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="11770" href="Cat.Instances.Slice.html#11748" class="Bound">nt</a> <a id="11773" class="Symbol">.</a><a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" id="11774" href="Cat.Base.html#11363" class="Field">η</a> <a id="11776" class="Symbol">_</a> <a id="11778" href="Cat.Instances.Slice.html#11761" class="Bound">x</a>
  <a data-type="Functor Cat[ Disc′ I₁ , Sets ℓ ] (Slice (Sets ℓ) I₁)" id="11782" href="Cat.Instances.Slice.html#11518" class="Function">Total-space</a> <a id="11794" class="Symbol">.</a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="11795" href="Cat.Base.html#7421" class="Field">F₁</a> <a id="11798" href="Cat.Instances.Slice.html#11798" class="Bound">nt</a> <a id="11801" class="Symbol">.</a><a data-type="(r : /-Hom a b) → (C ∘ map b) (r .map) ≡ a .map" id="11802" href="Cat.Instances.Slice.html#2992" class="Field">commutes</a>    <a id="11814" class="Symbol">=</a> <a data-type="x ≡ x" id="11816" href="1Lab.Path.html#3593" class="Function">refl</a>

  <a data-type="Functor Cat[ Disc′ I₁ , Sets ℓ ] (Slice (Sets ℓ) I₁)" id="11824" href="Cat.Instances.Slice.html#11518" class="Function">Total-space</a> <a id="11836" class="Symbol">.</a><a data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" id="11837" href="Cat.Base.html#7747" class="Field">F-id</a>    <a id="11845" class="Symbol">=</a> <a data-type="x .map ≡ y .map → x ≡ y" id="11847" href="Cat.Instances.Slice.html#3929" class="Function">/-Hom-path</a> <a data-type="x ≡ x" id="11858" href="1Lab.Path.html#3593" class="Function">refl</a>
  <a data-type="Functor Cat[ Disc′ I₁ , Sets ℓ ] (Slice (Sets ℓ) I₁)" id="11865" href="Cat.Instances.Slice.html#11518" class="Function">Total-space</a> <a id="11877" class="Symbol">.</a><a data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" id="11878" href="Cat.Base.html#7787" class="Field">F-∘</a> <a id="11882" class="Symbol">_</a> <a id="11884" class="Symbol">_</a> <a id="11886" class="Symbol">=</a> <a data-type="x .map ≡ y .map → x ≡ y" id="11888" href="Cat.Instances.Slice.html#3929" class="Function">/-Hom-path</a> <a data-type="x ≡ x" id="11899" href="1Lab.Path.html#3593" class="Function">refl</a>
</pre>
<p>To prove that the <span class="Agda"><a data-type="Functor Cat[ Disc′ I₁ , Sets ℓ ] (Slice (Sets ℓ) I₁)" href="Cat.Instances.Slice.html#11518" class="Function">Total-space</a></span> functor is <span class="Agda"><a data-type="Functor C D → Type (C.o ⊔ C.h ⊔ D.h)" href="Cat.Functor.Base.html#1110" class="Function">fully faithful</a></span>, we will exhibit a quasi-inverse to its action on morphisms. Given a fibre-preserving map between <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">f</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi></mrow><mo>:</mo><mo>∑</mo><mi>F</mi><mo>→</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">\id{fst} : \sum F \to I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">fst</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span> and <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">f</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi></mrow><mo>:</mo><mo>∑</mo><mi>G</mi><mo>→</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">\id{fst} : \sum G \to I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">fst</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span>,</span> we recover a natural transformation between <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> and <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>.</span> The hardest part is showing naturality, where we use path induction.</p>
<pre class="Agda">  <a data-type="is-fully-faithful Total-space" id="12299" href="Cat.Instances.Slice.html#12299" class="Function">Total-space-is-ff</a> <a id="12317" class="Symbol">:</a> <a data-type="Functor C D → Type (C.o ⊔ C.h ⊔ D.h)" id="12319" href="Cat.Functor.Base.html#1110" class="Function">is-fully-faithful</a> <a data-type="Functor Cat[ Disc′ I₁ , Sets ℓ ] (Slice (Sets ℓ) I₁)" id="12337" href="Cat.Instances.Slice.html#11518" class="Function">Total-space</a>
  <a data-type="is-fully-faithful Total-space" id="12351" href="Cat.Instances.Slice.html#12299" class="Function">Total-space-is-ff</a> <a id="12369" class="Symbol">{</a><a id="12370" href="Cat.Instances.Slice.html#12370" class="Bound">f1</a><a id="12372" class="Symbol">}</a> <a id="12374" class="Symbol">{</a><a id="12375" href="Cat.Instances.Slice.html#12375" class="Bound">f2</a><a id="12377" class="Symbol">}</a> <a id="12379" class="Symbol">=</a> <a data-type="(i : is-iso f) → is-equiv f" id="12381" href="1Lab.Equiv.html#19815" class="Function">is-iso→is-equiv</a>
    <a id="12401" class="Symbol">(</a><a data-type="(inv₁ : B₁ → A) (rinv₁ : is-right-inverse inv₁ f)
(linv₁ : is-left-inverse inv₁ f) →
is-iso f" id="12402" href="1Lab.Equiv.html#6116" class="InductiveConstructor">iso</a> <a id="12406" href="Cat.Instances.Slice.html#12490" class="Function">from</a> <a id="12411" href="Cat.Instances.Slice.html#12962" class="Function">linv</a> <a id="12416" class="Symbol">(λ</a> <a id="12419" href="Cat.Instances.Slice.html#12419" class="Bound">x</a> <a id="12421" class="Symbol">→</a> <a data-type="((x : C .Ob) → a .η x ≡ b .η x) → a ≡ b" id="12423" href="Cat.Base.html#15695" class="Function">Nat-path</a> <a id="12432" class="Symbol">(λ</a> <a id="12435" href="Cat.Instances.Slice.html#12435" class="Bound">x</a> <a id="12437" class="Symbol">→</a> <a data-type="((x : A) → f x ≡ g x) → f ≡ g" id="12439" href="1Lab.Path.html#58409" class="Function">funext</a> <a id="12446" class="Symbol">(λ</a> <a id="12449" href="Cat.Instances.Slice.html#12449" class="Bound">_</a> <a id="12451" class="Symbol">→</a> <a data-type="(x : A) → transport (λ i → A) x ≡ x" id="12453" href="1Lab.Path.html#13454" class="Function">transport-refl</a> <a id="12468" class="Symbol">_))))</a>
    <a id="12478" class="Keyword">where</a>
      <a id="12490" href="Cat.Instances.Slice.html#12490" class="Function">from</a> <a id="12495" class="Symbol">:</a> <a data-type="(a b : /-Obj c) → Type ℓ" id="12497" href="Cat.Instances.Slice.html#2816" class="Record">/-Hom</a> <a id="12503" class="Symbol">(</a><a data-type="Functor Cat[ Disc′ I₁ , Sets ℓ ] (Slice (Sets ℓ) I₁)" id="12504" href="Cat.Instances.Slice.html#11518" class="Function">Total-space</a> <a id="12516" class="Symbol">.</a><a data-type="Functor C D → C .Ob → Ob D" id="12517" href="Cat.Base.html#7400" class="Field">F₀</a> <a id="12520" href="Cat.Instances.Slice.html#12370" class="Bound">f1</a><a id="12522" class="Symbol">)</a> <a id="12524" class="Symbol">(</a><a data-type="Functor Cat[ Disc′ I₁ , Sets ℓ ] (Slice (Sets ℓ) I₁)" id="12525" href="Cat.Instances.Slice.html#11518" class="Function">Total-space</a> <a id="12537" class="Symbol">.</a><a data-type="Functor C D → C .Ob → Ob D" id="12538" href="Cat.Base.html#7400" class="Field">F₀</a> <a id="12541" href="Cat.Instances.Slice.html#12375" class="Bound">f2</a><a id="12543" class="Symbol">)</a> <a id="12545" class="Symbol">→</a> <a id="12547" href="Cat.Instances.Slice.html#12370" class="Bound">f1</a> <a data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" id="12550" href="Cat.Base.html#10813" class="Record Operator">=&gt;</a> <a id="12553" href="Cat.Instances.Slice.html#12375" class="Bound">f2</a>
      <a id="12562" href="Cat.Instances.Slice.html#12490" class="Function">from</a> <a id="12567" href="Cat.Instances.Slice.html#12567" class="Bound">mp</a> <a id="12570" class="Symbol">=</a> <a id="12572" href="Cat.Instances.Slice.html#12733" class="Function">nt</a> <a id="12575" class="Keyword">where</a>
        <a id="12589" href="Cat.Instances.Slice.html#12589" class="Function">eta</a> <a id="12593" class="Symbol">:</a> <a id="12595" class="Symbol">∀</a> <a id="12597" href="Cat.Instances.Slice.html#12597" class="Bound">i</a> <a id="12599" class="Symbol">→</a> <a data-type="n-Type ℓ n → Type ℓ" id="12601" href="1Lab.HLevel.Universe.html#3120" class="Field Operator">∣</a> <a data-type="Functor C D → C .Ob → Ob D" id="12603" href="Cat.Base.html#7400" class="Field">F₀</a> <a id="12606" href="Cat.Instances.Slice.html#12370" class="Bound">f1</a> <a id="12609" href="Cat.Instances.Slice.html#12597" class="Bound">i</a> <a data-type="n-Type ℓ n → Type ℓ" id="12611" href="1Lab.HLevel.Universe.html#3120" class="Field Operator">∣</a> <a id="12613" class="Symbol">→</a> <a data-type="n-Type ℓ n → Type ℓ" id="12615" href="1Lab.HLevel.Universe.html#3120" class="Field Operator">∣</a> <a data-type="Functor C D → C .Ob → Ob D" id="12617" href="Cat.Base.html#7400" class="Field">F₀</a> <a id="12620" href="Cat.Instances.Slice.html#12375" class="Bound">f2</a> <a id="12623" href="Cat.Instances.Slice.html#12597" class="Bound">i</a> <a data-type="n-Type ℓ n → Type ℓ" id="12625" href="1Lab.HLevel.Universe.html#3120" class="Field Operator">∣</a>
        <a id="12635" href="Cat.Instances.Slice.html#12589" class="Function">eta</a> <a id="12639" href="Cat.Instances.Slice.html#12639" class="Bound">i</a> <a id="12641" href="Cat.Instances.Slice.html#12641" class="Bound">j</a> <a id="12643" class="Symbol">=</a>
          <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="12655" href="1Lab.Path.html#15309" class="Function">subst</a> <a id="12661" class="Symbol">(</a><a data-type="n-Type ℓ n → Type ℓ" id="12662" href="1Lab.HLevel.Universe.html#3120" class="Field Operator">∣_∣</a> <a id="12666" href="Cat.Prelude.html#232" class="Function Operator">⊙</a> <a data-type="Functor C D → C .Ob → Ob D" id="12668" href="Cat.Base.html#7400" class="Field">F₀</a> <a id="12671" href="Cat.Instances.Slice.html#12375" class="Bound">f2</a><a id="12673" class="Symbol">)</a> <a id="12675" class="Symbol">(</a><a data-type="f ≡ g → (x : A) → f x ≡ g x" id="12676" href="1Lab.Path.html#58050" class="Function">happly</a> <a id="12683" class="Symbol">(</a><a id="12684" href="Cat.Instances.Slice.html#12567" class="Bound">mp</a> <a id="12687" class="Symbol">.</a><a data-type="(r : /-Hom a b) → (C ∘ map b) (r .map) ≡ a .map" id="12688" href="Cat.Instances.Slice.html#2992" class="Field">commutes</a><a id="12696" class="Symbol">)</a> <a id="12698" class="Symbol">_)</a> <a id="12701" class="Symbol">(</a><a id="12702" href="Cat.Instances.Slice.html#12567" class="Bound">mp</a> <a id="12705" class="Symbol">.</a><a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="12706" href="Cat.Instances.Slice.html#2951" class="Field">map</a> <a id="12710" class="Symbol">(</a><a id="12711" href="Cat.Instances.Slice.html#12639" class="Bound">i</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="12713" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="12715" href="Cat.Instances.Slice.html#12641" class="Bound">j</a><a id="12716" class="Symbol">)</a> <a id="12718" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="12719" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="12722" class="Symbol">)</a>

        <a id="12733" href="Cat.Instances.Slice.html#12733" class="Function">nt</a> <a id="12736" class="Symbol">:</a> <a id="12738" href="Cat.Instances.Slice.html#12370" class="Bound">f1</a> <a data-type="(F G : Functor C D) → Type (o₁ ⊔ h₁ ⊔ h₂)" id="12741" href="Cat.Base.html#10813" class="Record Operator">=&gt;</a> <a id="12744" href="Cat.Instances.Slice.html#12375" class="Bound">f2</a>
        <a id="12755" href="Cat.Instances.Slice.html#12733" class="Function">nt</a> <a id="12758" class="Symbol">.</a><a data-type="F =&gt; G → (x : C .Ob) → D .Hom (₀ F x) (₀ G x)" id="12759" href="Cat.Base.html#11363" class="Field">η</a> <a id="12761" class="Symbol">=</a> <a id="12763" href="Cat.Instances.Slice.html#12589" class="Function">eta</a>
        <a id="12775" href="Cat.Instances.Slice.html#12733" class="Function">nt</a> <a id="12778" class="Symbol">.</a><a data-type="(r : F =&gt; G) (x y : C .Ob) (f : C .Hom x y) →
D ._∘_ (r .η y) (₁ F f) ≡ D ._∘_ (₁ G f) (r .η x)" id="12779" href="Cat.Base.html#11941" class="Field">is-natural</a> <a id="12790" class="Symbol">_</a> <a id="12792" class="Symbol">_</a> <a id="12794" href="Cat.Instances.Slice.html#12794" class="Bound">f</a> <a id="12796" class="Symbol">=</a>
          <a data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" id="12808" href="1Lab.Path.html#19544" class="Function">J</a> <a id="12810" class="Symbol">(λ</a> <a id="12813" href="Cat.Instances.Slice.html#12813" class="Bound">_</a> <a id="12815" href="Cat.Instances.Slice.html#12815" class="Bound">p</a> <a id="12817" class="Symbol">→</a> <a id="12819" href="Cat.Instances.Slice.html#12589" class="Function">eta</a> <a id="12823" class="Symbol">_</a> <a id="12825" href="Cat.Prelude.html#232" class="Function Operator">⊙</a> <a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="12827" href="Cat.Base.html#7421" class="Field">F₁</a> <a id="12830" href="Cat.Instances.Slice.html#12370" class="Bound">f1</a> <a id="12833" href="Cat.Instances.Slice.html#12815" class="Bound">p</a> <a data-type="A → A → Type ℓ" id="12835" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="12837" href="Cat.Base.html#7421" class="Field">F₁</a> <a id="12840" href="Cat.Instances.Slice.html#12375" class="Bound">f2</a> <a id="12843" href="Cat.Instances.Slice.html#12815" class="Bound">p</a> <a id="12845" href="Cat.Prelude.html#232" class="Function Operator">⊙</a> <a id="12847" href="Cat.Instances.Slice.html#12589" class="Function">eta</a> <a id="12851" class="Symbol">_)</a>
            <a id="12866" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="12867" href="1Lab.Path.html#20756" class="Function">ap</a> <a id="12870" class="Symbol">(</a><a id="12871" href="Cat.Instances.Slice.html#12589" class="Function">eta</a> <a id="12875" class="Symbol">_</a> <a id="12877" href="Cat.Prelude.html#232" class="Function Operator">⊙_</a><a id="12879" class="Symbol">)</a> <a id="12881" class="Symbol">(</a><a data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" id="12882" href="Cat.Base.html#7747" class="Field">F-id</a> <a id="12887" href="Cat.Instances.Slice.html#12370" class="Bound">f1</a><a id="12889" class="Symbol">)</a> <a data-type="x ≡ y → y ≡ z → x ≡ z" id="12891" href="1Lab.Path.html#39485" class="Function Operator">∙</a> <a data-type="x ≡ y → y ≡ x" id="12893" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="12897" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="12898" href="1Lab.Path.html#20756" class="Function">ap</a> <a id="12901" class="Symbol">(</a><a id="12902" href="Cat.Prelude.html#232" class="Function Operator">_⊙</a> <a id="12905" href="Cat.Instances.Slice.html#12589" class="Function">eta</a> <a id="12909" class="Symbol">_)</a> <a id="12912" class="Symbol">(</a><a data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" id="12913" href="Cat.Base.html#7747" class="Field">F-id</a> <a id="12918" href="Cat.Instances.Slice.html#12375" class="Bound">f2</a><a id="12920" class="Symbol">)))</a>
            <a id="12936" href="Cat.Instances.Slice.html#12794" class="Bound">f</a>
</pre>
<!--
<pre class="Agda">      <a id="12962" href="Cat.Instances.Slice.html#12962" class="Function">linv</a> <a id="12967" class="Symbol">:</a> <a id="12969" href="1Lab.Equiv.html#5649" class="Function">is-left-inverse</a> <a id="12985" class="Symbol">(</a><a id="12986" href="Cat.Base.html#7421" class="Field">F₁</a> <a id="12989" href="Cat.Instances.Slice.html#11518" class="Function">Total-space</a><a id="13000" class="Symbol">)</a> <a id="13002" href="Cat.Instances.Slice.html#12490" class="Function">from</a>
      <a id="13013" href="Cat.Instances.Slice.html#12962" class="Function">linv</a> <a id="13018" href="Cat.Instances.Slice.html#13018" class="Bound">x</a> <a id="13020" class="Symbol">=</a>
        <a id="13030" href="Cat.Instances.Slice.html#3929" class="Function">/-Hom-path</a> <a id="13041" class="Symbol">(</a><a id="13042" href="1Lab.Path.html#58409" class="Function">funext</a> <a id="13049" class="Symbol">(λ</a> <a id="13052" href="Cat.Instances.Slice.html#13052" class="Bound">y</a> <a id="13054" class="Symbol">→</a>
          <a id="13066" href="1Lab.Path.html#57594" class="Function">Σ-path</a> <a id="13073" class="Symbol">(</a><a id="13074" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="13078" class="Symbol">(</a><a id="13079" href="1Lab.Path.html#58050" class="Function">happly</a> <a id="13086" class="Symbol">(</a><a id="13087" href="Cat.Instances.Slice.html#13018" class="Bound">x</a> <a id="13089" class="Symbol">.</a><a id="13090" href="Cat.Instances.Slice.html#2992" class="Field">commutes</a><a id="13098" class="Symbol">)</a> <a id="13100" class="Symbol">_))</a>
            <a id="13116" class="Symbol">(</a> <a id="13118" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="13122" class="Symbol">(</a><a id="13123" href="1Lab.Univalence.html#28559" class="Function">transport-∙</a> <a id="13135" class="Symbol">(</a><a id="13136" href="1Lab.Path.html#20756" class="Function">ap</a> <a id="13139" class="Symbol">(</a><a id="13140" href="1Lab.HLevel.Universe.html#3120" class="Field Operator">∣_∣</a> <a id="13144" href="Cat.Prelude.html#232" class="Function Operator">⊙</a> <a id="13146" href="Cat.Base.html#7400" class="Field">F₀</a> <a id="13149" href="Cat.Instances.Slice.html#12375" class="Bound">f2</a><a id="13151" class="Symbol">)</a> <a id="13153" class="Symbol">(</a><a id="13154" href="1Lab.Path.html#58050" class="Function">happly</a> <a id="13161" class="Symbol">(</a><a id="13162" href="Cat.Instances.Slice.html#13018" class="Bound">x</a> <a id="13164" class="Symbol">.</a><a id="13165" href="Cat.Instances.Slice.html#2992" class="Field">commutes</a><a id="13173" class="Symbol">)</a> <a id="13175" href="Cat.Instances.Slice.html#13052" class="Bound">y</a><a id="13176" class="Symbol">))</a>
                          <a id="13205" class="Symbol">(</a><a id="13206" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="13210" class="Symbol">(</a><a id="13211" href="1Lab.Path.html#20756" class="Function">ap</a> <a id="13214" class="Symbol">(</a><a id="13215" href="1Lab.HLevel.Universe.html#3120" class="Field Operator">∣_∣</a> <a id="13219" href="Cat.Prelude.html#232" class="Function Operator">⊙</a> <a id="13221" href="Cat.Base.html#7400" class="Field">F₀</a> <a id="13224" href="Cat.Instances.Slice.html#12375" class="Bound">f2</a><a id="13226" class="Symbol">)</a> <a id="13228" class="Symbol">(</a><a id="13229" href="1Lab.Path.html#58050" class="Function">happly</a> <a id="13236" class="Symbol">(</a><a id="13237" href="Cat.Instances.Slice.html#13018" class="Bound">x</a> <a id="13239" class="Symbol">.</a><a id="13240" href="Cat.Instances.Slice.html#2992" class="Field">commutes</a><a id="13248" class="Symbol">)</a> <a id="13250" href="Cat.Instances.Slice.html#13052" class="Bound">y</a><a id="13251" class="Symbol">)))</a>
                          <a id="13281" class="Symbol">_)</a>
            <a id="13296" href="1Lab.Path.html#38318" class="Function Operator">··</a> <a id="13299" href="1Lab.Path.html#21189" class="Function">ap₂</a> <a id="13303" href="1Lab.Path.html#11776" class="Function">transport</a> <a id="13313" class="Symbol">(</a><a id="13314" href="1Lab.Path.Groupoid.html#4923" class="Function">∙-inv-r</a> <a id="13322" class="Symbol">(</a><a id="13323" href="1Lab.Path.html#20756" class="Function">ap</a> <a id="13326" class="Symbol">(</a><a id="13327" href="1Lab.HLevel.Universe.html#3120" class="Field Operator">∣_∣</a> <a id="13331" href="Cat.Prelude.html#232" class="Function Operator">⊙</a> <a id="13333" href="Cat.Base.html#7400" class="Field">F₀</a> <a id="13336" href="Cat.Instances.Slice.html#12375" class="Bound">f2</a><a id="13338" class="Symbol">)</a> <a id="13340" class="Symbol">(</a><a id="13341" href="1Lab.Path.html#58050" class="Function">happly</a> <a id="13348" class="Symbol">(</a><a id="13349" href="Cat.Instances.Slice.html#13018" class="Bound">x</a> <a id="13351" class="Symbol">.</a><a id="13352" href="Cat.Instances.Slice.html#2992" class="Field">commutes</a><a id="13360" class="Symbol">)</a> <a id="13362" href="Cat.Instances.Slice.html#13052" class="Bound">y</a><a id="13363" class="Symbol">)))</a>
                             <a id="13396" href="1Lab.Path.html#3593" class="Function">refl</a>
            <a id="13413" href="1Lab.Path.html#38318" class="Function Operator">··</a> <a id="13416" href="1Lab.Path.html#13454" class="Function">transport-refl</a> <a id="13431" class="Symbol">_)))</a>
</pre>-->
<p>For essential surjectivity, given a map <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>X</mi><mo>→</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">f : X \to I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span></span>,</span> we recover a family of sets <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msup><mi>f</mi><mo>∗</mo></msup><mi>i</mi><msub><mo stretchy="false">)</mo><mrow><mi>i</mi><mo>∈</mo><mi>I</mi></mrow></msub></mrow><annotation encoding="application/x-tex">(f^*i)_{i \in I}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord mathnormal">i</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.07847em;">I</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1774em;"><span></span></span></span></span></span></span></span></span></span> by taking the <span class="Agda"><a data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" href="1Lab.Equiv.html#1873" class="Function">fibre</a></span> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> over each point, which cleanly extends to a functor. To show that the <span class="Agda"><a data-type="Functor Cat[ Disc′ I₁ , Sets ℓ ] (Slice (Sets ℓ) I₁)" href="Cat.Instances.Slice.html#11518" class="Function">Total-space</a></span> of this functor is isomorphic to the map we started with, we use one of the auxilliary lemmas used in the construction of an object classifier: <span class="Agda"><a data-type="(p : E → B₁) → E ≃ Σ (fibre p)" href="1Lab.Univalence.html#23719" class="Function">Total-equiv</a></span>. This is cleaner than exhibiting an isomorphism directly, though it does involve an appeal to univalence.</p>
<pre class="Agda">  <a data-type="is-split-eso Total-space" id="13956" href="Cat.Instances.Slice.html#13956" class="Function">Total-space-is-eso</a> <a id="13975" class="Symbol">:</a> <a data-type="Functor C D → Type (C.o ⊔ D.o ⊔ D.h)" id="13977" href="Cat.Functor.Base.html#5029" class="Function">is-split-eso</a> <a data-type="Functor Cat[ Disc′ I₁ , Sets ℓ ] (Slice (Sets ℓ) I₁)" id="13990" href="Cat.Instances.Slice.html#11518" class="Function">Total-space</a>
  <a data-type="is-split-eso Total-space" id="14004" href="Cat.Instances.Slice.html#13956" class="Function">Total-space-is-eso</a> <a id="14023" href="Cat.Instances.Slice.html#14023" class="Bound">fam</a> <a id="14027" class="Symbol">=</a> <a id="14029" href="Cat.Instances.Slice.html#14071" class="Function">functor</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="14037" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="(C : Precategory o h) → A ≡ B₁ → (C ≅ A) B₁" id="14039" href="Cat.Univalent.html#1379" class="Function">path→iso</a> <a id="14048" class="Symbol">_</a> <a id="14050" href="Cat.Instances.Slice.html#14428" class="Function">path</a>
    <a id="14059" class="Keyword">where</a>
      <a id="14071" href="Cat.Instances.Slice.html#14071" class="Function">functor</a> <a id="14079" class="Symbol">:</a> <a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="14081" href="Cat.Base.html#6614" class="Record">Functor</a> <a id="14089" class="Symbol">_</a> <a id="14091" class="Symbol">_</a>
      <a id="14099" href="Cat.Instances.Slice.html#14071" class="Function">functor</a> <a id="14107" class="Symbol">.</a><a data-type="Functor C D → C .Ob → Ob D" id="14108" href="Cat.Base.html#7400" class="Field">F₀</a> <a id="14111" href="Cat.Instances.Slice.html#14111" class="Bound">i</a> <a id="14113" class="Symbol">=</a> <a data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="14115" href="1Lab.Equiv.html#1873" class="Function">fibre</a> <a id="14121" class="Symbol">(</a><a id="14122" href="Cat.Instances.Slice.html#14023" class="Bound">fam</a> <a id="14126" class="Symbol">.</a><a data-type="(r : /-Obj c) → Hom C (r .domain) c" id="14127" href="Cat.Instances.Slice.html#2306" class="Field">map</a><a id="14130" class="Symbol">)</a> <a id="14132" href="Cat.Instances.Slice.html#14111" class="Bound">i</a>
                    <a data-type="(∣_∣₁ : Type ℓ) (is-tr₁ : is-hlevel ∣_∣₁ n) → n-Type ℓ n" id="14154" href="1Lab.HLevel.Universe.html#3104" class="InductiveConstructor Operator">,</a> <a data-type="(n : Nat) →
is-hlevel A n → ((x : A) → is-hlevel (B₁ x) n) → is-hlevel (Σ B₁) n" id="14156" href="1Lab.HLevel.Retracts.html#5166" class="Function">Σ-is-hlevel</a> <a id="14168" class="Number">2</a> <a id="14170" class="Symbol">(</a><a id="14171" href="Cat.Instances.Slice.html#14023" class="Bound">fam</a> <a id="14175" class="Symbol">.</a><a data-type="/-Obj c → Ob C" id="14176" href="Cat.Instances.Slice.html#2285" class="Field">domain</a> <a id="14183" class="Symbol">.</a><a data-type="(r : n-Type ℓ n) → is-hlevel (r .∣_∣) n" id="14184" href="1Lab.HLevel.Universe.html#3139" class="Field">is-tr</a><a id="14189" class="Symbol">)</a>
                                    <a id="14227" class="Symbol">λ</a> <a id="14229" href="Cat.Instances.Slice.html#14229" class="Bound">_</a> <a id="14231" class="Symbol">→</a> <a data-type="is-prop A → is-set A" id="14233" href="1Lab.HLevel.html#5554" class="Function">is-prop→is-set</a> <a id="14248" class="Symbol">(</a><a id="14249" href="Cat.Instances.Slice.html#11145" class="Bound">I</a> <a id="14251" class="Symbol">.</a><a data-type="(r : n-Type ℓ n) → is-hlevel (r .∣_∣) n" id="14252" href="1Lab.HLevel.Universe.html#3139" class="Field">is-tr</a> <a id="14258" class="Symbol">_</a> <a id="14260" class="Symbol">_)</a>
      <a id="14269" href="Cat.Instances.Slice.html#14071" class="Function">functor</a> <a id="14277" class="Symbol">.</a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="14278" href="Cat.Base.html#7421" class="Field">F₁</a> <a id="14281" href="Cat.Instances.Slice.html#14281" class="Bound">p</a> <a id="14283" class="Symbol">=</a> <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="14285" href="1Lab.Path.html#15309" class="Function">subst</a> <a id="14291" class="Symbol">(</a><a data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="14292" href="1Lab.Equiv.html#1873" class="Function">fibre</a> <a id="14298" class="Symbol">(</a><a id="14299" href="Cat.Instances.Slice.html#14023" class="Bound">fam</a> <a id="14303" class="Symbol">.</a><a data-type="(r : /-Obj c) → Hom C (r .domain) c" id="14304" href="Cat.Instances.Slice.html#2306" class="Field">map</a><a id="14307" class="Symbol">))</a> <a id="14310" href="Cat.Instances.Slice.html#14281" class="Bound">p</a>
      <a id="14318" href="Cat.Instances.Slice.html#14071" class="Function">functor</a> <a id="14326" class="Symbol">.</a><a data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" id="14327" href="Cat.Base.html#7747" class="Field">F-id</a> <a id="14332" class="Symbol">=</a> <a data-type="((x : A) → f x ≡ g x) → f ≡ g" id="14334" href="1Lab.Path.html#58409" class="Function">funext</a> <a data-type="(x : A) → transport (λ i → A) x ≡ x" id="14341" href="1Lab.Path.html#13454" class="Function">transport-refl</a>
      <a id="14362" href="Cat.Instances.Slice.html#14071" class="Function">functor</a> <a id="14370" class="Symbol">.</a><a data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" id="14371" href="Cat.Base.html#7787" class="Field">F-∘</a> <a id="14375" href="Cat.Instances.Slice.html#14375" class="Bound">f</a> <a id="14377" href="Cat.Instances.Slice.html#14377" class="Bound">g</a> <a id="14379" class="Symbol">=</a> <a data-type="((x : A) → f x ≡ g x) → f ≡ g" id="14381" href="1Lab.Path.html#58409" class="Function">funext</a> <a id="14388" class="Symbol">(</a><a data-type="(B₁ : A → Type ℓ′) (p : x ≡ y) (q : y ≡ z) (u : B₁ x) →
subst B₁ (p ∙ q) u ≡ subst B₁ q (subst B₁ p u)" id="14389" href="1Lab.Univalence.html#28792" class="Function">subst-∙</a> <a id="14397" class="Symbol">(</a><a data-type="(A → B₁) → B₁ → Type (A.ℓ₁ ⊔ B.ℓ₁)" id="14398" href="1Lab.Equiv.html#1873" class="Function">fibre</a> <a id="14404" class="Symbol">(</a><a id="14405" href="Cat.Instances.Slice.html#14023" class="Bound">fam</a> <a id="14409" class="Symbol">.</a><a data-type="(r : /-Obj c) → Hom C (r .domain) c" id="14410" href="Cat.Instances.Slice.html#2306" class="Field">map</a><a id="14413" class="Symbol">))</a> <a id="14416" class="Symbol">_</a> <a id="14418" class="Symbol">_)</a>

      <a id="14428" href="Cat.Instances.Slice.html#14428" class="Function">path</a> <a id="14433" class="Symbol">:</a> <a data-type="Functor C D → C .Ob → Ob D" id="14435" href="Cat.Base.html#7400" class="Field">F₀</a> <a data-type="Functor Cat[ Disc′ I₁ , Sets ℓ ] (Slice (Sets ℓ) I₁)" id="14438" href="Cat.Instances.Slice.html#11518" class="Function">Total-space</a> <a id="14450" href="Cat.Instances.Slice.html#14071" class="Function">functor</a> <a data-type="A → A → Type ℓ" id="14458" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="14460" href="Cat.Instances.Slice.html#14023" class="Bound">fam</a>
      <a id="14470" href="Cat.Instances.Slice.html#14428" class="Function">path</a> <a id="14475" class="Symbol">=</a> <a data-type="(p : x .domain ≡ y .domain) →
PathP (λ i → Hom C (p i) c) (x .map) (y .map) → x ≡ y" id="14477" href="Cat.Instances.Slice.html#3045" class="Function">/-Obj-path</a> <a id="14488" class="Symbol">(</a><a data-type="∣ X ∣ ≃ ∣ Y ∣ → X ≡ Y" id="14489" href="1Lab.HLevel.Universe.html#3600" class="Function">n-ua</a> <a id="14494" class="Symbol">(</a><a data-type="(p : E → B₁) → E ≃ Σ (fibre p)" id="14495" href="1Lab.Univalence.html#23719" class="Function">Total-equiv</a> <a id="14507" class="Symbol">_</a>  <a data-type="A ≃ B₁ → B₁ ≃ A" id="14510" href="1Lab.Equiv.html#21355" class="Function Operator">e⁻¹</a><a id="14513" class="Symbol">))</a> <a id="14516" class="Symbol">(</a><a data-type="((a : A₀) → PathP B₁ (f₀ a) (f₁ (e .fst a))) →
PathP (λ i → ua e i → B₁ i) f₀ f₁" id="14517" href="1Lab.Univalence.html#27786" class="Function">ua→</a> <a id="14521" class="Symbol">λ</a> <a id="14523" href="Cat.Instances.Slice.html#14523" class="Bound">a</a> <a id="14525" class="Symbol">→</a> <a data-type="x ≡ y → y ≡ x" id="14527" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="14531" class="Symbol">(</a><a id="14532" href="Cat.Instances.Slice.html#14523" class="Bound">a</a> <a id="14534" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="14535" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a> <a id="14539" class="Symbol">.</a><a data-type="(r : ∑ A B₁) → B₁ (r .fst)" id="14540" href="Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="14543" class="Symbol">))</a>
</pre>
<h1 id="slices-preserve-univalence"><a href="#slices-preserve-univalence" class="header-link">Slices preserve univalence<span class="header-link-emoji">🔗</span></a></h1>
<p>An important property of slice categories is that they preserve <a href="Cat.Univalent.html">univalence</a>. This can be seen intuitively: If <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span> is a univalent category, then let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a, b, c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span></span></span></span> be some objects, with the pairs <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>g</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(b, g)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span> objects in the slice <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi><mi mathvariant="normal">/</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">\ca{C}/c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mord">/</span><span class="mord mathnormal">c</span></span></span></span>.</span> An isomorphism <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>:</mo><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo><mo>≅</mo><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>g</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h : (a, f) \cong (b, g)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≅</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span> induces an identification <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≡</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \equiv b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4637em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span>,</span> which extends to an identification <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo><mo>≡</mo><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>g</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, f) \equiv (b, g)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span> since <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>∘</mo><mi>g</mi><mo>=</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">h \circ g = f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∘</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>.</span></p>
<pre class="Agda"><a id="15037" class="Keyword">module</a> <a id="15044" href="Cat.Instances.Slice.html#15044" class="Module">_</a> <a id="15046" class="Symbol">{</a><a id="15047" href="Cat.Instances.Slice.html#15047" class="Bound">C</a> <a id="15049" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="15051" href="Cat.Base.html#644" class="Record">Precategory</a> <a id="15063" href="Cat.Instances.Slice.html#483" class="Generalizable">o</a> <a id="15065" href="Cat.Instances.Slice.html#485" class="Generalizable">ℓ</a><a id="15066" class="Symbol">}</a> <a id="15068" class="Symbol">{</a><a id="15069" href="Cat.Instances.Slice.html#15069" class="Bound">o</a> <a id="15071" class="Symbol">:</a> <a data-type="Precategory o h → Type o" id="15073" href="Cat.Base.html#1341" class="Field">Precategory.Ob</a> <a id="15088" href="Cat.Instances.Slice.html#15047" class="Bound">C</a><a id="15089" class="Symbol">}</a> <a id="15091" class="Symbol">(</a><a id="15092" href="Cat.Instances.Slice.html#15092" class="Bound">isc</a> <a id="15096" class="Symbol">:</a> <a data-type="(C : Precategory o h) → Type (o ⊔ h)" id="15098" href="Cat.Univalent.html#946" class="Function">is-category</a> <a id="15110" href="Cat.Instances.Slice.html#15047" class="Bound">C</a><a id="15111" class="Symbol">)</a> <a id="15113" class="Keyword">where</a>
  <a id="15121" class="Keyword">private</a>
    <a id="15133" class="Keyword">module</a> <a id="15140" href="Cat.Instances.Slice.html#15140" class="Module">C</a>   <a id="15144" class="Symbol">=</a> <a id="15146" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="15160" href="Cat.Instances.Slice.html#15047" class="Bound">C</a>
    <a id="15166" class="Keyword">module</a> <a id="15173" href="Cat.Instances.Slice.html#15173" class="Module">C/o</a> <a id="15177" class="Symbol">=</a> <a id="15179" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="15193" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) → Ob C → Precategory (o ⊔ ℓ) ℓ" id="15194" href="Cat.Instances.Slice.html#4907" class="Function">Slice</a> <a id="15200" href="Cat.Instances.Slice.html#15047" class="Bound">C</a> <a id="15202" href="Cat.Instances.Slice.html#15069" class="Bound">o</a><a id="15203" class="Symbol">)</a>
    <a id="15209" class="Keyword">module</a> <a id="15216" href="Cat.Instances.Slice.html#15216" class="Module">Cu</a>  <a id="15220" class="Symbol">=</a> <a id="15222" href="Cat.Univalent.html" class="Module">Cat.Univalent</a> <a id="15236" href="Cat.Instances.Slice.html#15047" class="Bound">C</a>

    <a id="15243" class="Keyword">open</a> <a data-type="(c : Ob C) → Type (o ⊔ ℓ)" id="15248" href="Cat.Instances.Slice.html#2190" class="Module">/-Obj</a>
    <a id="15258" class="Keyword">open</a> <a data-type="(a b : /-Obj c) → Type ℓ" id="15263" href="Cat.Instances.Slice.html#2816" class="Module">/-Hom</a>
    <a id="15273" class="Keyword">open</a> <a data-type="(C : Precategory o h) (a b : Ob C) → Type (o ⊔ h)" id="15278" href="Cat.Morphism.html#2194" class="Module Operator">C/o._≅_</a>
    <a id="15290" class="Keyword">open</a> <a data-type="(C : Precategory o h) (a b : Ob C) → Type (o ⊔ h)" id="15295" href="Cat.Morphism.html#2194" class="Module Operator">C._≅_</a>

  <a data-type="(isc : is-category C) → is-category (Slice C o)" id="15304" href="Cat.Instances.Slice.html#15304" class="Function">slice-is-category</a> <a id="15322" class="Symbol">:</a> <a data-type="(C : Precategory o h) → Type (o ⊔ h)" id="15324" href="Cat.Univalent.html#946" class="Function">is-category</a> <a id="15336" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) → Ob C → Precategory (o ⊔ ℓ) ℓ" id="15337" href="Cat.Instances.Slice.html#4907" class="Function">Slice</a> <a id="15343" href="Cat.Instances.Slice.html#15047" class="Bound">C</a> <a id="15345" href="Cat.Instances.Slice.html#15069" class="Bound">o</a><a id="15346" class="Symbol">)</a>
  <a data-type="(isc : is-category C) → is-category (Slice C o)" id="15350" href="Cat.Instances.Slice.html#15304" class="Function">slice-is-category</a> <a id="15368" href="Cat.Instances.Slice.html#15368" class="Bound">A</a> <a id="15370" class="Symbol">.</a><a data-type="is-contr A → A" id="15371" href="1Lab.HLevel.html#1401" class="Field">centre</a> <a id="15378" class="Symbol">=</a> <a id="15380" href="Cat.Instances.Slice.html#15368" class="Bound">A</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="15382" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a data-type="(C : Precategory o h) → (C ≅ a) a" id="15384" href="Cat.Morphism.html#4889" class="Function">C/o.id-iso</a>
  <a data-type="(isc : is-category C) → is-category (Slice C o)" id="15397" href="Cat.Instances.Slice.html#15304" class="Function">slice-is-category</a> <a id="15415" href="Cat.Instances.Slice.html#15415" class="Bound">A</a> <a id="15417" class="Symbol">.</a><a data-type="(r : is-contr A) (x : A) → r .centre ≡ x" id="15418" href="1Lab.HLevel.html#1416" class="Field">paths</a> <a id="15424" class="Symbol">(</a><a id="15425" href="Cat.Instances.Slice.html#15425" class="Bound">B</a> <a data-type="(fst₁ : A) (snd₁ : B₁ fst₁) → ∑ A B₁" id="15427" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="15429" href="Cat.Instances.Slice.html#15429" class="Bound">isom</a><a id="15433" class="Symbol">)</a> <a id="15435" class="Symbol">=</a> <a data-type="(p : x .fst ≡ y .fst) →
PathP (λ i → B₁ (p i)) (x .snd) (y .snd) → x ≡ y" id="15437" href="1Lab.Path.html#57211" class="Function">Σ-pathp</a> <a id="15445" href="Cat.Instances.Slice.html#15770" class="Function">A≡B</a> <a id="15449" href="Cat.Instances.Slice.html#15804" class="Function">eql</a> <a id="15453" class="Keyword">where</a>
    <a id="15463" href="Cat.Instances.Slice.html#15463" class="Function">Ad≡Bd</a> <a id="15469" class="Symbol">:</a> <a id="15471" href="Cat.Instances.Slice.html#15415" class="Bound">A</a> <a id="15473" class="Symbol">.</a><a data-type="/-Obj c → Ob C" id="15474" href="Cat.Instances.Slice.html#2285" class="Field">domain</a> <a data-type="A → A → Type ℓ" id="15481" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="15483" href="Cat.Instances.Slice.html#15425" class="Bound">B</a> <a id="15485" class="Symbol">.</a><a data-type="/-Obj c → Ob C" id="15486" href="Cat.Instances.Slice.html#2285" class="Field">domain</a>
    <a id="15497" href="Cat.Instances.Slice.html#15463" class="Function">Ad≡Bd</a> <a id="15503" class="Symbol">=</a> <a data-type="(C : Precategory o h) → is-category C → (C ≅ A) B₁ → A ≡ B₁" id="15505" href="Cat.Univalent.html#2601" class="Function">Cu.iso→path</a> <a id="15517" href="Cat.Instances.Slice.html#15092" class="Bound">isc</a>
      <a id="15527" class="Symbol">(</a><a data-type="(C : Precategory o h) (f : Hom C a b) (g : Hom C b a) →
(C ∘ f) g ≡ id C → (C ∘ g) f ≡ id C → (C ≅ a) b" id="15528" href="Cat.Morphism.html#3455" class="Function">C.make-iso</a> <a id="15539" class="Symbol">(</a><a id="15540" href="Cat.Instances.Slice.html#15429" class="Bound">isom</a> <a id="15545" class="Symbol">.</a><a data-type="(C ≅ a) b → Hom C a b" id="15546" href="Cat.Morphism.html#2242" class="Field">to</a> <a id="15549" class="Symbol">.</a><a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="15550" href="Cat.Instances.Slice.html#2951" class="Field">map</a><a id="15553" class="Symbol">)</a> <a id="15555" class="Symbol">(</a><a id="15556" href="Cat.Instances.Slice.html#15429" class="Bound">isom</a> <a id="15561" class="Symbol">.</a><a data-type="(C ≅ a) b → Hom C b a" id="15562" href="Cat.Morphism.html#2265" class="Field">from</a> <a id="15567" class="Symbol">.</a><a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="15568" href="Cat.Instances.Slice.html#2951" class="Field">map</a><a id="15571" class="Symbol">)</a>
        <a id="15581" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="15582" href="1Lab.Path.html#20756" class="Function">ap</a> <a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="15585" href="Cat.Instances.Slice.html#2951" class="Field">map</a> <a id="15589" class="Symbol">(</a><a data-type="(r : (C ≅ a) b) → (C ∘ r .to) (r .from) ≡ id C" id="15590" href="Cat.Morphism.html#1853" class="Function">C/o._≅_.invˡ</a> <a id="15603" href="Cat.Instances.Slice.html#15429" class="Bound">isom</a><a id="15607" class="Symbol">))</a> <a id="15610" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="15611" href="1Lab.Path.html#20756" class="Function">ap</a> <a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="15614" href="Cat.Instances.Slice.html#2951" class="Field">map</a> <a id="15618" class="Symbol">(</a><a data-type="(r : (C ≅ a) b) → (C ∘ r .from) (r .to) ≡ id C" id="15619" href="Cat.Morphism.html#1875" class="Function">C/o._≅_.invʳ</a> <a id="15632" href="Cat.Instances.Slice.html#15429" class="Bound">isom</a><a id="15636" class="Symbol">)))</a>

    <a id="15645" href="Cat.Instances.Slice.html#15645" class="Function">Af≡Bf</a> <a id="15651" class="Symbol">:</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="15653" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="15659" class="Symbol">(λ</a> <a id="15662" href="Cat.Instances.Slice.html#15662" class="Bound">i</a> <a id="15664" class="Symbol">→</a> <a data-type="(r : Precategory o h) → r .Ob → r .Ob → Type h" id="15666" href="Cat.Base.html#1358" class="Function">C.Hom</a> <a id="15672" class="Symbol">(</a><a id="15673" href="Cat.Instances.Slice.html#15463" class="Function">Ad≡Bd</a> <a id="15679" href="Cat.Instances.Slice.html#15662" class="Bound">i</a><a id="15680" class="Symbol">)</a> <a id="15682" href="Cat.Instances.Slice.html#15069" class="Bound">o</a><a id="15683" class="Symbol">)</a> <a id="15685" class="Symbol">(</a><a id="15686" href="Cat.Instances.Slice.html#15415" class="Bound">A</a> <a id="15688" class="Symbol">.</a><a data-type="(r : /-Obj c) → Hom C (r .domain) c" id="15689" href="Cat.Instances.Slice.html#2306" class="Field">map</a><a id="15692" class="Symbol">)</a> <a id="15694" class="Symbol">(</a><a id="15695" href="Cat.Instances.Slice.html#15425" class="Bound">B</a> <a id="15697" class="Symbol">.</a><a data-type="(r : /-Obj c) → Hom C (r .domain) c" id="15698" href="Cat.Instances.Slice.html#2306" class="Field">map</a><a id="15701" class="Symbol">)</a>
    <a id="15707" href="Cat.Instances.Slice.html#15645" class="Function">Af≡Bf</a> <a id="15713" class="Symbol">=</a> <a data-type="(C : Precategory o h) (isc : is-category C) →
(C ∘ h) (p .from) ≡ h&#39; →
PathP (λ i → Hom C (iso→path C isc p i) B₁) h h&#39;" id="15715" href="Cat.Univalent.html#6055" class="Function">Cu.Hom-pathp-reflˡ-iso</a> <a id="15738" href="Cat.Instances.Slice.html#15092" class="Bound">isc</a> <a id="15742" class="Symbol">(</a><a id="15743" href="Cat.Instances.Slice.html#15429" class="Bound">isom</a> <a id="15748" class="Symbol">.</a><a data-type="(C ≅ a) b → Hom C b a" id="15749" href="Cat.Morphism.html#2265" class="Field">from</a> <a id="15754" class="Symbol">.</a><a data-type="(r : /-Hom a b) → (C ∘ map b) (r .map) ≡ a .map" id="15755" href="Cat.Instances.Slice.html#2992" class="Field">commutes</a><a id="15763" class="Symbol">)</a>

    <a id="15770" href="Cat.Instances.Slice.html#15770" class="Function">A≡B</a> <a id="15774" class="Symbol">=</a> <a data-type="(p : x .domain ≡ y .domain) →
PathP (λ i → Hom C (p i) c) (x .map) (y .map) → x ≡ y" id="15776" href="Cat.Instances.Slice.html#3045" class="Function">/-Obj-path</a> <a id="15787" href="Cat.Instances.Slice.html#15463" class="Function">Ad≡Bd</a> <a id="15793" href="Cat.Instances.Slice.html#15645" class="Function">Af≡Bf</a>

    <a id="15804" href="Cat.Instances.Slice.html#15804" class="Function">eql</a> <a id="15808" class="Symbol">:</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="15810" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="15816" class="Symbol">(λ</a> <a id="15819" href="Cat.Instances.Slice.html#15819" class="Bound">i</a> <a id="15821" class="Symbol">→</a> <a id="15823" href="Cat.Instances.Slice.html#15415" class="Bound">A</a> <a data-type="(C : Precategory o h) (a b : Ob C) → Type (o ⊔ h)" id="15825" href="Cat.Morphism.html#2194" class="Record Operator">C/o.≅</a> <a id="15831" href="Cat.Instances.Slice.html#15770" class="Function">A≡B</a> <a id="15835" href="Cat.Instances.Slice.html#15819" class="Bound">i</a><a id="15836" class="Symbol">)</a> <a data-type="(C : Precategory o h) → (C ≅ a) a" id="15838" href="Cat.Morphism.html#4889" class="Function">C/o.id-iso</a> <a id="15849" href="Cat.Instances.Slice.html#15429" class="Bound">isom</a>
    <a id="15858" href="Cat.Instances.Slice.html#15804" class="Function">eql</a> <a id="15862" class="Symbol">=</a> <a data-type="(C : Precategory o h) (p : a ≡ c) (q : b ≡ d) →
PathP (λ i → Hom C (p i) (q i)) (f .to) (g .to) →
PathP (λ i → Hom C (q i) (p i)) (f .from) (g .from) →
PathP (λ i → (C ≅ p i) (q i)) f g" id="15864" href="Cat.Morphism.html#4442" class="Function">C/o.≅-pathp</a> <a data-type="x ≡ x" id="15876" href="1Lab.Path.html#3593" class="Function">refl</a> <a id="15881" href="Cat.Instances.Slice.html#15770" class="Function">A≡B</a>
      <a id="15891" class="Symbol">(</a><a data-type="(p : a ≡ a′) (q : b ≡ b′) →
PathP (λ i → Hom C (p i .domain) (q i .domain)) (x .map) (y .map) →
PathP (λ i → /-Hom (p i) (q i)) x y" id="15892" href="Cat.Instances.Slice.html#3307" class="Function">/-Hom-pathp</a> <a id="15904" class="Symbol">_</a> <a id="15906" class="Symbol">_</a> <a id="15908" class="Symbol">(</a><a data-type="(C : Precategory o h) (isc : is-category C) →
(C ∘ q .to) h ≡ h&#39; →
PathP (λ i → Hom C A (iso→path C isc q i)) h h&#39;" id="15909" href="Cat.Univalent.html#6641" class="Function">Cu.Hom-pathp-reflʳ-iso</a> <a id="15932" href="Cat.Instances.Slice.html#15092" class="Bound">isc</a> <a id="15936" class="Symbol">(</a><a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ f (r .id) ≡ f" id="15937" href="Cat.Base.html#3359" class="Function">C.idr</a> <a id="15943" class="Symbol">_)))</a>
      <a id="15954" class="Symbol">(</a><a data-type="(p : a ≡ a′) (q : b ≡ b′) →
PathP (λ i → Hom C (p i .domain) (q i .domain)) (x .map) (y .map) →
PathP (λ i → /-Hom (p i) (q i)) x y" id="15955" href="Cat.Instances.Slice.html#3307" class="Function">/-Hom-pathp</a> <a id="15967" class="Symbol">_</a> <a id="15969" class="Symbol">_</a> <a id="15971" class="Symbol">(</a><a data-type="(C : Precategory o h) (isc : is-category C) →
(C ∘ h) (p .from) ≡ h&#39; →
PathP (λ i → Hom C (iso→path C isc p i) B₁) h h&#39;" id="15972" href="Cat.Univalent.html#6055" class="Function">Cu.Hom-pathp-reflˡ-iso</a> <a id="15995" href="Cat.Instances.Slice.html#15092" class="Bound">isc</a> <a id="15999" class="Symbol">(</a><a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" id="16000" href="Cat.Base.html#3404" class="Function">C.idl</a> <a id="16006" class="Symbol">_)))</a>
</pre>
<h1 id="arbitrary-limits-in-slices"><a href="#arbitrary-limits-in-slices" class="header-link">Arbitrary limits in slices<span class="header-link-emoji">🔗</span></a></h1>
<p>Suppose we have some really weird diagram <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi mathvariant="script">J</mi><mo>→</mo><mi mathvariant="script">C</mi><mi mathvariant="normal">/</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">F : \ca{J} \to \ca{C}/c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7805em;vertical-align:-0.0972em;"></span><span class="mord mathcal" style="margin-right:0.18472em;">J</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mord">/</span><span class="mord mathnormal">c</span></span></span></span>,</span> like the one below. Well, alright, it’s not that weird, but it’s not a pullback or a terminal object, so we don’t <em>a priori</em> know how to compute it.</p>
<div class="diagram-container">
<img src="98cf8acd558a5b6badb6aed1fadafccc7bf71563.svg" title="commutative diagram" class="diagram quiver" />
</div>
<p>The observation that will let us compute a limit for this diagram is inspecting the computation of products in slice categories, above. To compute the product of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>f</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a, f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span> and <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>g</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(b, g)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span>,</span> we had to pass to a <em>pullback</em> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mi>f</mi></mpadded></mover><mi>c</mi><mover><mo stretchy="true" minsize="3.0em">←</mo><mpadded width="+0.6em" lspace="0.3em"><mi>b</mi></mpadded></mover></mrow><annotation encoding="application/x-tex">a \xto{f} c \xot{b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1191em;vertical-align:-0.011em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1081em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1191em;vertical-align:-0.011em;"></span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1081em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="0.522em" viewBox="0 0 400000 522" preserveAspectRatio="xMinYMin slice"><path d="M400000 241H110l3-3c68.7-52.7 113.7-120
 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8
-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247
c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208
 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3
 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202
 l-3-3h399890zM100 241v40h399900v-40z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span></span></span></span> in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span> — which we had assumed exists. But! Take a look at what that diagram <em>looks like</em>:</p>
<div class="diagram-container">
<img src="f678b4cefaf2d4ca6764b9d0dc4303684432ea5a.svg" title="commutative diagram" class="diagram quiver" />
</div>
<p>We “exploded” a diagram of shape <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∙</mo><mspace width="1em"></mspace><mo>∙</mo></mrow><annotation encoding="application/x-tex">\bullet \quad \bullet</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord">∙</span><span class="mspace" style="margin-right:1em;"></span><span class="mord">∙</span></span></span></span> to one of shape <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∙</mo><mo>→</mo><mo>∙</mo><mo>←</mo><mo>∙</mo></mrow><annotation encoding="application/x-tex">\bullet \to \bullet \ot \bullet</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord">∙</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord">∙</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord">∙</span></span></span></span>.</span> This process can be described in a way easier to generalise: We “exploded” our diagram <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mo stretchy="false">{</mo><mo>∗</mo><mo separator="true">,</mo><mo>∗</mo><mo stretchy="false">}</mo><mo>→</mo><mi mathvariant="script">C</mi><mi mathvariant="normal">/</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">F : \{*,*\} \to \ca{C}/c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">∗</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∗</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mord">/</span><span class="mord mathnormal">c</span></span></span></span> to one indexed by a category which contains <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mo>∗</mo><mo separator="true">,</mo><mo>∗</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{*,*\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">∗</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∗</span><span class="mclose">}</span></span></span></span>,</span> contains an extra point, and has a unique map between each object of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mo>∗</mo><mo separator="true">,</mo><mo>∗</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{*,*\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">∗</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">∗</span><span class="mclose">}</span></span></span></span> — the <a href="Cat.Instances.Shape.Join.html"><em>join</em></a> of these categories.</p>
<!--
<pre class="Agda"><a id="17387" class="Keyword">module</a>
  <a id="17396" href="Cat.Instances.Slice.html#17396" class="Module">_</a> <a id="17398" class="Symbol">{</a><a id="17399" href="Cat.Instances.Slice.html#17399" class="Bound">C</a> <a id="17401" class="Symbol">:</a> <a id="17403" href="Cat.Base.html#644" class="Record">Precategory</a> <a id="17415" href="Cat.Instances.Slice.html#483" class="Generalizable">o</a> <a id="17417" href="Cat.Instances.Slice.html#485" class="Generalizable">ℓ</a><a id="17418" class="Symbol">}</a>
    <a id="17424" class="Symbol">{</a><a id="17425" href="Cat.Instances.Slice.html#17425" class="Bound">J</a> <a id="17427" class="Symbol">:</a> <a id="17429" href="Cat.Base.html#644" class="Record">Precategory</a> <a id="17441" href="Cat.Instances.Slice.html#487" class="Generalizable">o′</a> <a id="17444" href="Cat.Instances.Slice.html#490" class="Generalizable">ℓ′</a><a id="17446" class="Symbol">}</a>
    <a id="17452" class="Symbol">{</a><a id="17453" href="Cat.Instances.Slice.html#17453" class="Bound">o</a> <a id="17455" class="Symbol">:</a> <a id="17457" href="Cat.Base.html#1341" class="Field">Precategory.Ob</a> <a id="17472" href="Cat.Instances.Slice.html#17399" class="Bound">C</a><a id="17473" class="Symbol">}</a>
    <a id="17479" class="Symbol">(</a><a id="17480" href="Cat.Instances.Slice.html#17480" class="Bound">F</a> <a id="17482" class="Symbol">:</a> <a id="17484" href="Cat.Base.html#6614" class="Record">Functor</a> <a id="17492" href="Cat.Instances.Slice.html#17425" class="Bound">J</a> <a id="17494" class="Symbol">(</a><a id="17495" href="Cat.Instances.Slice.html#4907" class="Function">Slice</a> <a id="17501" href="Cat.Instances.Slice.html#17399" class="Bound">C</a> <a id="17503" href="Cat.Instances.Slice.html#17453" class="Bound">o</a><a id="17504" class="Symbol">))</a>
    <a id="17511" class="Keyword">where</a>

  <a id="17520" class="Keyword">open</a> <a id="17525" href="Cat.Diagram.Terminal.html#405" class="Module">Terminal</a>
  <a id="17536" class="Keyword">open</a> <a id="17541" href="Cat.Diagram.Limit.Base.html#7691" class="Module">Cone-hom</a>
  <a id="17552" class="Keyword">open</a> <a id="17557" href="Cat.Diagram.Limit.Base.html#5890" class="Module">Cone</a>
  <a id="17564" class="Keyword">open</a> <a id="17569" href="Cat.Instances.Slice.html#2190" class="Module">/-Obj</a>
  <a id="17577" class="Keyword">open</a> <a id="17582" href="Cat.Instances.Slice.html#2816" class="Module">/-Hom</a>

  <a id="17591" class="Keyword">private</a>
    <a id="17603" class="Keyword">module</a> <a id="17610" href="Cat.Instances.Slice.html#17610" class="Module">C</a>   <a id="17614" class="Symbol">=</a> <a id="17616" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="17630" href="Cat.Instances.Slice.html#17399" class="Bound">C</a>
    <a id="17636" class="Keyword">module</a> <a id="17643" href="Cat.Instances.Slice.html#17643" class="Module">C/o</a> <a id="17647" class="Symbol">=</a> <a id="17649" href="Cat.Reasoning.html" class="Module">Cat.Reasoning</a> <a id="17663" class="Symbol">(</a><a id="17664" href="Cat.Instances.Slice.html#4907" class="Function">Slice</a> <a id="17670" href="Cat.Instances.Slice.html#17399" class="Bound">C</a> <a id="17672" href="Cat.Instances.Slice.html#17453" class="Bound">o</a><a id="17673" class="Symbol">)</a>
    <a id="17679" class="Keyword">module</a> <a id="17686" href="Cat.Instances.Slice.html#17686" class="Module">F</a> <a id="17688" class="Symbol">=</a> <a id="17690" href="Cat.Base.html#6614" class="Module">Functor</a> <a id="17698" href="Cat.Instances.Slice.html#17480" class="Bound">F</a>
</pre>-->
<p>Generically, if we have a diagram <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>:</mo><mi>J</mi><mo>→</mo><mi mathvariant="script">C</mi><mi mathvariant="normal">/</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">F : J \to \ca{C}/c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span><span class="mord">/</span><span class="mord mathnormal">c</span></span></span></span>,</span> we can “explode” this into a diagram <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>:</mo><mo stretchy="false">(</mo><mi>J</mi><mo>⋆</mo><mo stretchy="false">{</mo><mo>∗</mo><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>→</mo><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">F&#39; : (J \star \{*\}) \to \ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7519em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7519em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋆</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">∗</span><span class="mclose">})</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>,</span> compute the limit in <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span>,</span> then pass back to the slice category.</p>
<pre class="Agda">    <a id="17919" href="Cat.Instances.Slice.html#17919" class="Function">F′</a> <a id="17922" class="Symbol">:</a> <a data-type="(C : Precategory o₁ h₁) (D : Precategory o₂ h₂) →
Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="17924" href="Cat.Base.html#6614" class="Record">Functor</a> <a id="17932" class="Symbol">(</a><a id="17933" href="Cat.Instances.Slice.html#17425" class="Bound">J</a> <a data-type="(C : Precategory o ℓ) (D : Precategory o′ ℓ′) →
Precategory (o ⊔ o′) (ℓ ⊔ ℓ′)" id="17935" href="Cat.Instances.Shape.Join.html#1097" class="Function Operator">⋆</a> <a data-type="Precategory lzero lzero" id="17937" href="Cat.Instances.Shape.Terminal.html#244" class="Function">⊤Cat</a><a id="17941" class="Symbol">)</a> <a id="17943" href="Cat.Instances.Slice.html#17399" class="Bound">C</a>
    <a id="17949" href="Cat.Instances.Slice.html#17919" class="Function">F′</a> <a id="17952" class="Symbol">.</a><a data-type="Functor C D → C .Ob → Ob D" id="17953" href="Cat.Base.html#7400" class="Field">F₀</a> <a id="17956" class="Symbol">(</a><a data-type="A → A ⊎ B₁" id="17957" href="Data.Sum.html#669" class="InductiveConstructor">inl</a> <a id="17961" href="Cat.Instances.Slice.html#17961" class="Bound">x</a><a id="17962" class="Symbol">)</a> <a id="17964" class="Symbol">=</a> <a data-type="(r : Functor C D) → C .Ob → D .Ob" id="17966" href="Cat.Base.html#8131" class="Function">F.₀</a> <a id="17970" href="Cat.Instances.Slice.html#17961" class="Bound">x</a> <a id="17972" class="Symbol">.</a><a data-type="/-Obj c → Ob C" id="17973" href="Cat.Instances.Slice.html#2285" class="Field">domain</a>
    <a id="17984" href="Cat.Instances.Slice.html#17919" class="Function">F′</a> <a id="17987" class="Symbol">.</a><a data-type="Functor C D → C .Ob → Ob D" id="17988" href="Cat.Base.html#7400" class="Field">F₀</a> <a id="17991" class="Symbol">(</a><a data-type="B₁ → A ⊎ B₁" id="17992" href="Data.Sum.html#687" class="InductiveConstructor">inr</a> <a id="17996" href="Cat.Instances.Slice.html#17996" class="Bound">x</a><a id="17997" class="Symbol">)</a> <a id="17999" class="Symbol">=</a> <a id="18001" href="Cat.Instances.Slice.html#17453" class="Bound">o</a>
    <a id="18007" href="Cat.Instances.Slice.html#17919" class="Function">F′</a> <a id="18010" class="Symbol">.</a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="18011" href="Cat.Base.html#7421" class="Field">F₁</a> <a id="18014" class="Symbol">{</a><a data-type="A → A ⊎ B₁" id="18015" href="Data.Sum.html#669" class="InductiveConstructor">inl</a> <a id="18019" href="Cat.Instances.Slice.html#18019" class="Bound">x</a><a id="18020" class="Symbol">}</a> <a id="18022" class="Symbol">{</a><a data-type="A → A ⊎ B₁" id="18023" href="Data.Sum.html#669" class="InductiveConstructor">inl</a> <a id="18027" href="Cat.Instances.Slice.html#18027" class="Bound">y</a><a id="18028" class="Symbol">}</a> <a id="18030" class="Symbol">(</a><a data-type="(lower : A) → Lift ℓ A" id="18031" href="1Lab.Type.html#2075" class="InductiveConstructor">lift</a> <a id="18036" href="Cat.Instances.Slice.html#18036" class="Bound">f</a><a id="18037" class="Symbol">)</a> <a id="18039" class="Symbol">=</a> <a data-type="(r : Functor C D) → C .Hom x y → D .Hom (F₀ r x) (F₀ r y)" id="18041" href="Cat.Base.html#8212" class="Function">F.₁</a> <a id="18045" href="Cat.Instances.Slice.html#18036" class="Bound">f</a> <a id="18047" class="Symbol">.</a><a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="18048" href="Cat.Instances.Slice.html#2951" class="Field">map</a>
    <a id="18056" href="Cat.Instances.Slice.html#17919" class="Function">F′</a> <a id="18059" class="Symbol">.</a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="18060" href="Cat.Base.html#7421" class="Field">F₁</a> <a id="18063" class="Symbol">{</a><a data-type="A → A ⊎ B₁" id="18064" href="Data.Sum.html#669" class="InductiveConstructor">inl</a> <a id="18068" href="Cat.Instances.Slice.html#18068" class="Bound">x</a><a id="18069" class="Symbol">}</a> <a id="18071" class="Symbol">{</a><a data-type="B₁ → A ⊎ B₁" id="18072" href="Data.Sum.html#687" class="InductiveConstructor">inr</a> <a id="18076" href="Cat.Instances.Slice.html#18076" class="Bound">y</a><a id="18077" class="Symbol">}</a> <a id="18079" class="Symbol">_</a> <a id="18081" class="Symbol">=</a> <a data-type="(r : Functor C D) → C .Ob → D .Ob" id="18083" href="Cat.Base.html#8131" class="Function">F.₀</a> <a id="18087" href="Cat.Instances.Slice.html#18068" class="Bound">x</a> <a id="18089" class="Symbol">.</a><a data-type="(r : /-Obj c) → Hom C (r .domain) c" id="18090" href="Cat.Instances.Slice.html#2306" class="Field">map</a>
    <a id="18098" href="Cat.Instances.Slice.html#17919" class="Function">F′</a> <a id="18101" class="Symbol">.</a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="18102" href="Cat.Base.html#7421" class="Field">F₁</a> <a id="18105" class="Symbol">{</a><a data-type="B₁ → A ⊎ B₁" id="18106" href="Data.Sum.html#687" class="InductiveConstructor">inr</a> <a id="18110" href="Cat.Instances.Slice.html#18110" class="Bound">x</a><a id="18111" class="Symbol">}</a> <a id="18113" class="Symbol">{</a><a data-type="B₁ → A ⊎ B₁" id="18114" href="Data.Sum.html#687" class="InductiveConstructor">inr</a> <a id="18118" href="Cat.Instances.Slice.html#18118" class="Bound">y</a><a id="18119" class="Symbol">}</a> <a id="18121" class="Symbol">(</a><a data-type="(lower : A) → Lift ℓ A" id="18122" href="1Lab.Type.html#2075" class="InductiveConstructor">lift</a> <a id="18127" href="Cat.Instances.Slice.html#18127" class="Bound">h</a><a id="18128" class="Symbol">)</a> <a id="18130" class="Symbol">=</a> <a data-type="(r : Precategory o h) → r .Hom x x" id="18132" href="Cat.Base.html#2898" class="Function">C.id</a>
    <a id="18141" href="Cat.Instances.Slice.html#17919" class="Function">F′</a> <a id="18144" class="Symbol">.</a><a data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" id="18145" href="Cat.Base.html#7747" class="Field">F-id</a> <a id="18150" class="Symbol">{</a><a data-type="A → A ⊎ B₁" id="18151" href="Data.Sum.html#669" class="InductiveConstructor">inl</a> <a id="18155" href="Cat.Instances.Slice.html#18155" class="Bound">x</a><a id="18156" class="Symbol">}</a> <a id="18158" class="Symbol">=</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="18160" href="1Lab.Path.html#20756" class="Function">ap</a> <a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="18163" href="Cat.Instances.Slice.html#2951" class="Field">map</a> <a data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" id="18167" href="Cat.Base.html#7747" class="Field">F.F-id</a>
    <a id="18178" href="Cat.Instances.Slice.html#17919" class="Function">F′</a> <a id="18181" class="Symbol">.</a><a data-type="(r : Functor C D) → r .F₁ (C .id) ≡ id D" id="18182" href="Cat.Base.html#7747" class="Field">F-id</a> <a id="18187" class="Symbol">{</a><a data-type="B₁ → A ⊎ B₁" id="18188" href="Data.Sum.html#687" class="InductiveConstructor">inr</a> <a id="18192" href="Cat.Instances.Slice.html#18192" class="Bound">x</a><a id="18193" class="Symbol">}</a> <a id="18195" class="Symbol">=</a> <a data-type="x ≡ x" id="18197" href="1Lab.Path.html#3593" class="Function">refl</a>
    <a id="18206" href="Cat.Instances.Slice.html#17919" class="Function">F′</a> <a id="18209" class="Symbol">.</a><a data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" id="18210" href="Cat.Base.html#7787" class="Field">F-∘</a> <a id="18214" class="Symbol">{</a><a data-type="A → A ⊎ B₁" id="18215" href="Data.Sum.html#669" class="InductiveConstructor">inl</a> <a id="18219" href="Cat.Instances.Slice.html#18219" class="Bound">x</a><a id="18220" class="Symbol">}</a> <a id="18222" class="Symbol">{</a><a data-type="A → A ⊎ B₁" id="18223" href="Data.Sum.html#669" class="InductiveConstructor">inl</a> <a id="18227" href="Cat.Instances.Slice.html#18227" class="Bound">y</a><a id="18228" class="Symbol">}</a> <a id="18230" class="Symbol">{</a><a data-type="A → A ⊎ B₁" id="18231" href="Data.Sum.html#669" class="InductiveConstructor">inl</a> <a id="18235" href="Cat.Instances.Slice.html#18235" class="Bound">z</a><a id="18236" class="Symbol">}</a> <a id="18238" class="Symbol">(</a><a data-type="(lower : A) → Lift ℓ A" id="18239" href="1Lab.Type.html#2075" class="InductiveConstructor">lift</a> <a id="18244" href="Cat.Instances.Slice.html#18244" class="Bound">f</a><a id="18245" class="Symbol">)</a> <a id="18247" class="Symbol">(</a><a data-type="(lower : A) → Lift ℓ A" id="18248" href="1Lab.Type.html#2075" class="InductiveConstructor">lift</a> <a id="18253" href="Cat.Instances.Slice.html#18253" class="Bound">g</a><a id="18254" class="Symbol">)</a> <a id="18256" class="Symbol">=</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="18258" href="1Lab.Path.html#20756" class="Function">ap</a> <a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="18261" href="Cat.Instances.Slice.html#2951" class="Field">map</a> <a id="18265" class="Symbol">(</a><a data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" id="18266" href="Cat.Base.html#7787" class="Field">F.F-∘</a> <a id="18272" href="Cat.Instances.Slice.html#18244" class="Bound">f</a> <a id="18274" href="Cat.Instances.Slice.html#18253" class="Bound">g</a><a id="18275" class="Symbol">)</a>
    <a id="18281" href="Cat.Instances.Slice.html#17919" class="Function">F′</a> <a id="18284" class="Symbol">.</a><a data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" id="18285" href="Cat.Base.html#7787" class="Field">F-∘</a> <a id="18289" class="Symbol">{</a><a data-type="A → A ⊎ B₁" id="18290" href="Data.Sum.html#669" class="InductiveConstructor">inl</a> <a id="18294" href="Cat.Instances.Slice.html#18294" class="Bound">x</a><a id="18295" class="Symbol">}</a> <a id="18297" class="Symbol">{</a><a data-type="A → A ⊎ B₁" id="18298" href="Data.Sum.html#669" class="InductiveConstructor">inl</a> <a id="18302" href="Cat.Instances.Slice.html#18302" class="Bound">y</a><a id="18303" class="Symbol">}</a> <a id="18305" class="Symbol">{</a><a data-type="B₁ → A ⊎ B₁" id="18306" href="Data.Sum.html#687" class="InductiveConstructor">inr</a> <a id="18310" href="Cat.Instances.Slice.html#18310" class="Bound">z</a><a id="18311" class="Symbol">}</a> <a id="18313" class="Symbol">(</a><a data-type="(lower : A) → Lift ℓ A" id="18314" href="1Lab.Type.html#2075" class="InductiveConstructor">lift</a> <a id="18319" href="Cat.Instances.Slice.html#18319" class="Bound">f</a><a id="18320" class="Symbol">)</a> <a id="18322" class="Symbol">(</a><a data-type="(lower : A) → Lift ℓ A" id="18323" href="1Lab.Type.html#2075" class="InductiveConstructor">lift</a> <a id="18328" href="Cat.Instances.Slice.html#18328" class="Bound">g</a><a id="18329" class="Symbol">)</a> <a id="18331" class="Symbol">=</a> <a data-type="x ≡ y → y ≡ x" id="18333" href="1Lab.Path.html#10558" class="Function">sym</a> <a id="18337" class="Symbol">(</a><a data-type="(r : Functor C D) → C .Hom x y → Hom D (r .F₀ x) (r .F₀ y)" id="18338" href="Cat.Base.html#7421" class="Field">F.F₁</a> <a id="18343" href="Cat.Instances.Slice.html#18328" class="Bound">g</a> <a id="18345" class="Symbol">.</a><a data-type="(r : /-Hom a b) → (C ∘ map b) (r .map) ≡ a .map" id="18346" href="Cat.Instances.Slice.html#2992" class="Field">commutes</a><a id="18354" class="Symbol">)</a>
    <a id="18360" href="Cat.Instances.Slice.html#17919" class="Function">F′</a> <a id="18363" class="Symbol">.</a><a data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" id="18364" href="Cat.Base.html#7787" class="Field">F-∘</a> <a id="18368" class="Symbol">{</a><a data-type="A → A ⊎ B₁" id="18369" href="Data.Sum.html#669" class="InductiveConstructor">inl</a> <a id="18373" href="Cat.Instances.Slice.html#18373" class="Bound">x</a><a id="18374" class="Symbol">}</a> <a id="18376" class="Symbol">{</a><a data-type="B₁ → A ⊎ B₁" id="18377" href="Data.Sum.html#687" class="InductiveConstructor">inr</a> <a id="18381" href="Cat.Instances.Slice.html#18381" class="Bound">y</a><a id="18382" class="Symbol">}</a> <a id="18384" class="Symbol">{</a><a data-type="B₁ → A ⊎ B₁" id="18385" href="Data.Sum.html#687" class="InductiveConstructor">inr</a> <a id="18389" href="Cat.Instances.Slice.html#18389" class="Bound">z</a><a id="18390" class="Symbol">}</a> <a id="18392" class="Symbol">(</a><a data-type="(lower : A) → Lift ℓ A" id="18393" href="1Lab.Type.html#2075" class="InductiveConstructor">lift</a> <a id="18398" href="Cat.Instances.Slice.html#18398" class="Bound">f</a><a id="18399" class="Symbol">)</a> <a id="18401" class="Symbol">(</a><a data-type="(lower : A) → Lift ℓ A" id="18402" href="1Lab.Type.html#2075" class="InductiveConstructor">lift</a> <a id="18407" href="Cat.Instances.Slice.html#18407" class="Bound">g</a><a id="18408" class="Symbol">)</a> <a id="18410" class="Symbol">=</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → f ≡ (C ∘ a) f" id="18412" href="Cat.Reasoning.html#1213" class="Function">C.introl</a> <a data-type="x ≡ x" id="18421" href="1Lab.Path.html#3593" class="Function">refl</a>
    <a id="18430" href="Cat.Instances.Slice.html#17919" class="Function">F′</a> <a id="18433" class="Symbol">.</a><a data-type="(r : Functor C D) (f : C .Hom y z) (g : C .Hom x y) →
r .F₁ (C ._∘_ f g) ≡ (D ∘ r .F₁ f) (r .F₁ g)" id="18434" href="Cat.Base.html#7787" class="Field">F-∘</a> <a id="18438" class="Symbol">{</a><a data-type="B₁ → A ⊎ B₁" id="18439" href="Data.Sum.html#687" class="InductiveConstructor">inr</a> <a id="18443" href="Cat.Instances.Slice.html#18443" class="Bound">x</a><a id="18444" class="Symbol">}</a> <a id="18446" class="Symbol">{</a><a data-type="B₁ → A ⊎ B₁" id="18447" href="Data.Sum.html#687" class="InductiveConstructor">inr</a> <a id="18451" href="Cat.Instances.Slice.html#18451" class="Bound">y</a><a id="18452" class="Symbol">}</a> <a id="18454" class="Symbol">{</a><a data-type="B₁ → A ⊎ B₁" id="18455" href="Data.Sum.html#687" class="InductiveConstructor">inr</a> <a id="18459" href="Cat.Instances.Slice.html#18459" class="Bound">z</a><a id="18460" class="Symbol">}</a> <a id="18462" class="Symbol">(</a><a data-type="(lower : A) → Lift ℓ A" id="18463" href="1Lab.Type.html#2075" class="InductiveConstructor">lift</a> <a id="18468" href="Cat.Instances.Slice.html#18468" class="Bound">f</a><a id="18469" class="Symbol">)</a> <a id="18471" class="Symbol">(</a><a data-type="(lower : A) → Lift ℓ A" id="18472" href="1Lab.Type.html#2075" class="InductiveConstructor">lift</a> <a id="18477" href="Cat.Instances.Slice.html#18477" class="Bound">g</a><a id="18478" class="Symbol">)</a> <a id="18480" class="Symbol">=</a> <a data-type="(C : Precategory o ℓ) (a≡id : a ≡ id C) → f ≡ (C ∘ a) f" id="18482" href="Cat.Reasoning.html#1213" class="Function">C.introl</a> <a data-type="x ≡ x" id="18491" href="1Lab.Path.html#3593" class="Function">refl</a>

  <a data-type="(F : Functor J₁ (Slice C o)) → Limit (F′ F) → Limit F" id="18499" href="Cat.Instances.Slice.html#18499" class="Function">limit-above→limit-in-slice</a> <a id="18526" class="Symbol">:</a> <a data-type="(F : Functor J₁ C) → Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="18528" href="Cat.Diagram.Limit.Base.html#10647" class="Function">Limit</a> <a id="18534" href="Cat.Instances.Slice.html#17919" class="Function">F′</a> <a id="18537" class="Symbol">→</a> <a data-type="(F : Functor J₁ C) → Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="18539" href="Cat.Diagram.Limit.Base.html#10647" class="Function">Limit</a> <a id="18545" href="Cat.Instances.Slice.html#17480" class="Bound">F</a>
  <a data-type="(F : Functor J₁ (Slice C o)) → Limit (F′ F) → Limit F" id="18549" href="Cat.Instances.Slice.html#18499" class="Function">limit-above→limit-in-slice</a> <a id="18576" href="Cat.Instances.Slice.html#18576" class="Bound">lims</a> <a id="18581" class="Symbol">=</a> <a id="18583" href="Cat.Instances.Slice.html#18909" class="Function">lim</a> <a id="18587" class="Keyword">where</a>
    <a id="18597" class="Keyword">module</a> <a id="18604" href="Cat.Instances.Slice.html#18604" class="Module">lim</a> <a id="18608" class="Symbol">=</a> <a data-type="(C : Precategory o h) → Type (o ⊔ h)" id="18610" href="Cat.Diagram.Terminal.html#405" class="Module">Terminal</a> <a id="18619" href="Cat.Instances.Slice.html#18576" class="Bound">lims</a>
    <a id="18628" class="Keyword">module</a> <a id="18635" href="Cat.Instances.Slice.html#18635" class="Module">limob</a> <a id="18641" class="Symbol">=</a> <a data-type="(F : Functor J₁ C) → Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="18643" href="Cat.Diagram.Limit.Base.html#5890" class="Module">Cone</a> <a data-type="Terminal C → Ob C" id="18648" href="Cat.Diagram.Terminal.html#447" class="Field">lim.top</a>

    <a id="18661" href="Cat.Instances.Slice.html#18661" class="Function">nadir</a> <a id="18667" class="Symbol">:</a> <a data-type="(F : Functor J₁ C) → Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="18669" href="Cat.Diagram.Limit.Base.html#5890" class="Record">Cone</a> <a id="18674" href="Cat.Instances.Slice.html#17480" class="Bound">F</a>
    <a id="18680" href="Cat.Instances.Slice.html#18661" class="Function">nadir</a> <a id="18686" class="Symbol">.</a><a data-type="Cone F → C .Ob" id="18687" href="Cat.Diagram.Limit.Base.html#6193" class="Field">apex</a> <a id="18692" class="Symbol">.</a><a data-type="/-Obj c → Ob C" id="18693" href="Cat.Instances.Slice.html#2285" class="Field">domain</a> <a id="18700" class="Symbol">=</a> <a data-type="Cone F → C .Ob" id="18702" href="Cat.Diagram.Limit.Base.html#6193" class="Function">limob.apex</a>
    <a id="18717" href="Cat.Instances.Slice.html#18661" class="Function">nadir</a> <a id="18723" class="Symbol">.</a><a data-type="Cone F → C .Ob" id="18724" href="Cat.Diagram.Limit.Base.html#6193" class="Field">apex</a> <a id="18729" class="Symbol">.</a><a data-type="(r : /-Obj c) → Hom C (r .domain) c" id="18730" href="Cat.Instances.Slice.html#2306" class="Field">map</a> <a id="18734" class="Symbol">=</a> <a data-type="(r : Cone F) (x : J₁ .Ob) → C .Hom (r .apex) (₀ F x)" id="18736" href="Cat.Diagram.Limit.Base.html#6215" class="Function">limob.ψ</a> <a id="18744" class="Symbol">(</a><a data-type="B₁ → A ⊎ B₁" id="18745" href="Data.Sum.html#687" class="InductiveConstructor">inr</a> <a data-type="⊤" id="18749" href="Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a><a id="18751" class="Symbol">)</a>
    <a id="18757" href="Cat.Instances.Slice.html#18661" class="Function">nadir</a> <a id="18763" class="Symbol">.</a><a data-type="(r : Cone F) (x : J₁ .Ob) → C .Hom (r .apex) (₀ F x)" id="18764" href="Cat.Diagram.Limit.Base.html#6215" class="Field">ψ</a> <a id="18766" href="Cat.Instances.Slice.html#18766" class="Bound">x</a> <a id="18768" class="Symbol">.</a><a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="18769" href="Cat.Instances.Slice.html#2951" class="Field">map</a> <a id="18773" class="Symbol">=</a> <a data-type="(r : Cone F) (x : J₁ .Ob) → C .Hom (r .apex) (₀ F x)" id="18775" href="Cat.Diagram.Limit.Base.html#6215" class="Function">limob.ψ</a> <a id="18783" class="Symbol">(</a><a data-type="A → A ⊎ B₁" id="18784" href="Data.Sum.html#669" class="InductiveConstructor">inl</a> <a id="18788" href="Cat.Instances.Slice.html#18766" class="Bound">x</a><a id="18789" class="Symbol">)</a>
    <a id="18795" href="Cat.Instances.Slice.html#18661" class="Function">nadir</a> <a id="18801" class="Symbol">.</a><a data-type="(r : Cone F) (x : J₁ .Ob) → C .Hom (r .apex) (₀ F x)" id="18802" href="Cat.Diagram.Limit.Base.html#6215" class="Field">ψ</a> <a id="18804" href="Cat.Instances.Slice.html#18804" class="Bound">x</a> <a id="18806" class="Symbol">.</a><a data-type="(r : /-Hom a b) → (C ∘ map b) (r .map) ≡ a .map" id="18807" href="Cat.Instances.Slice.html#2992" class="Field">commutes</a> <a id="18816" class="Symbol">=</a> <a data-type="(r : Cone F) (f : J₁ .Hom x y) → C ._∘_ (₁ F f) (r .ψ x) ≡ r .ψ y" id="18818" href="Cat.Diagram.Limit.Base.html#6522" class="Function">limob.commutes</a> <a id="18833" class="Symbol">(</a><a data-type="(lower : A) → Lift ℓ A" id="18834" href="1Lab.Type.html#2075" class="InductiveConstructor">lift</a> <a data-type="⊤" id="18839" href="Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a><a id="18841" class="Symbol">)</a>
    <a id="18847" href="Cat.Instances.Slice.html#18661" class="Function">nadir</a> <a id="18853" class="Symbol">.</a><a data-type="(r : Cone F) (f : J₁ .Hom x y) → C ._∘_ (₁ F f) (r .ψ x) ≡ r .ψ y" id="18854" href="Cat.Diagram.Limit.Base.html#6522" class="Field">commutes</a> <a id="18863" href="Cat.Instances.Slice.html#18863" class="Bound">f</a> <a id="18865" class="Symbol">=</a> <a data-type="x .map ≡ y .map → x ≡ y" id="18867" href="Cat.Instances.Slice.html#3929" class="Function">/-Hom-path</a> <a id="18878" class="Symbol">(</a><a data-type="(r : Cone F) (f : J₁ .Hom x y) → C ._∘_ (₁ F f) (r .ψ x) ≡ r .ψ y" id="18879" href="Cat.Diagram.Limit.Base.html#6522" class="Function">limob.commutes</a> <a id="18894" class="Symbol">(</a><a data-type="(lower : A) → Lift ℓ A" id="18895" href="1Lab.Type.html#2075" class="InductiveConstructor">lift</a> <a id="18900" href="Cat.Instances.Slice.html#18863" class="Bound">f</a><a id="18901" class="Symbol">))</a>

    <a id="18909" href="Cat.Instances.Slice.html#18909" class="Function">lim</a> <a id="18913" class="Symbol">:</a> <a data-type="(F : Functor J₁ C) → Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="18915" href="Cat.Diagram.Limit.Base.html#10647" class="Function">Limit</a> <a id="18921" href="Cat.Instances.Slice.html#17480" class="Bound">F</a>
    <a id="18927" href="Cat.Instances.Slice.html#18909" class="Function">lim</a> <a id="18931" class="Symbol">.</a><a data-type="Terminal C → Ob C" id="18932" href="Cat.Diagram.Terminal.html#447" class="Field">top</a> <a id="18936" class="Symbol">=</a> <a id="18938" href="Cat.Instances.Slice.html#18661" class="Function">nadir</a>
    <a id="18948" href="Cat.Instances.Slice.html#18909" class="Function">lim</a> <a id="18952" class="Symbol">.</a><a data-type="(r : Terminal C) → is-terminal C (r .top)" id="18953" href="Cat.Diagram.Terminal.html#460" class="Field">has⊤</a> <a id="18958" href="Cat.Instances.Slice.html#18958" class="Bound">other</a> <a id="18964" class="Symbol">=</a> <a data-type="(centre₁ : A) (paths₁ : (x : A) → centre₁ ≡ x) → is-contr A" id="18966" href="1Lab.HLevel.html#1383" class="InductiveConstructor">contr</a> <a id="18972" href="Cat.Instances.Slice.html#19396" class="Function">ch</a> <a id="18975" href="Cat.Instances.Slice.html#19602" class="Function">cont</a> <a id="18980" class="Keyword">where</a>
      <a id="18992" href="Cat.Instances.Slice.html#18992" class="Function">other′</a> <a id="18999" class="Symbol">:</a> <a data-type="(F : Functor J₁ C) → Type (o₁ ⊔ h₁ ⊔ o₂ ⊔ h₂)" id="19001" href="Cat.Diagram.Limit.Base.html#5890" class="Record">Cone</a> <a id="19006" href="Cat.Instances.Slice.html#17919" class="Function">F′</a>
      <a id="19015" href="Cat.Instances.Slice.html#18992" class="Function">other′</a> <a id="19022" class="Symbol">.</a><a data-type="Cone F → C .Ob" id="19023" href="Cat.Diagram.Limit.Base.html#6193" class="Field">apex</a> <a id="19028" class="Symbol">=</a> <a id="19030" href="Cat.Instances.Slice.html#18958" class="Bound">other</a> <a id="19036" class="Symbol">.</a><a data-type="Cone F → C .Ob" id="19037" href="Cat.Diagram.Limit.Base.html#6193" class="Field">apex</a> <a id="19042" class="Symbol">.</a><a data-type="/-Obj c → Ob C" id="19043" href="Cat.Instances.Slice.html#2285" class="Field">domain</a>
      <a id="19056" href="Cat.Instances.Slice.html#18992" class="Function">other′</a> <a id="19063" class="Symbol">.</a><a data-type="(r : Cone F) (x : J₁ .Ob) → C .Hom (r .apex) (₀ F x)" id="19064" href="Cat.Diagram.Limit.Base.html#6215" class="Field">ψ</a> <a id="19066" class="Symbol">(</a><a data-type="A → A ⊎ B₁" id="19067" href="Data.Sum.html#669" class="InductiveConstructor">inl</a> <a id="19071" href="Cat.Instances.Slice.html#19071" class="Bound">x</a><a id="19072" class="Symbol">)</a> <a id="19074" class="Symbol">=</a> <a id="19076" href="Cat.Instances.Slice.html#18958" class="Bound">other</a> <a id="19082" class="Symbol">.</a><a data-type="(r : Cone F) (x : J₁ .Ob) → C .Hom (r .apex) (₀ F x)" id="19083" href="Cat.Diagram.Limit.Base.html#6215" class="Field">ψ</a> <a id="19085" href="Cat.Instances.Slice.html#19071" class="Bound">x</a> <a id="19087" class="Symbol">.</a><a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="19088" href="Cat.Instances.Slice.html#2951" class="Field">map</a>
      <a id="19098" href="Cat.Instances.Slice.html#18992" class="Function">other′</a> <a id="19105" class="Symbol">.</a><a data-type="(r : Cone F) (x : J₁ .Ob) → C .Hom (r .apex) (₀ F x)" id="19106" href="Cat.Diagram.Limit.Base.html#6215" class="Field">ψ</a> <a id="19108" class="Symbol">(</a><a data-type="B₁ → A ⊎ B₁" id="19109" href="Data.Sum.html#687" class="InductiveConstructor">inr</a> <a data-type="⊤" id="19113" href="Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a><a id="19115" class="Symbol">)</a> <a id="19117" class="Symbol">=</a> <a id="19119" href="Cat.Instances.Slice.html#18958" class="Bound">other</a> <a id="19125" class="Symbol">.</a><a data-type="Cone F → C .Ob" id="19126" href="Cat.Diagram.Limit.Base.html#6193" class="Field">apex</a> <a id="19131" class="Symbol">.</a><a data-type="(r : /-Obj c) → Hom C (r .domain) c" id="19132" href="Cat.Instances.Slice.html#2306" class="Field">map</a>
      <a id="19142" href="Cat.Instances.Slice.html#18992" class="Function">other′</a> <a id="19149" class="Symbol">.</a><a data-type="(r : Cone F) (f : J₁ .Hom x y) → C ._∘_ (₁ F f) (r .ψ x) ≡ r .ψ y" id="19150" href="Cat.Diagram.Limit.Base.html#6522" class="Field">commutes</a> <a id="19159" class="Symbol">{</a><a data-type="A → A ⊎ B₁" id="19160" href="Data.Sum.html#669" class="InductiveConstructor">inl</a> <a id="19164" href="Cat.Instances.Slice.html#19164" class="Bound">x</a><a id="19165" class="Symbol">}</a> <a id="19167" class="Symbol">{</a><a data-type="A → A ⊎ B₁" id="19168" href="Data.Sum.html#669" class="InductiveConstructor">inl</a> <a id="19172" href="Cat.Instances.Slice.html#19172" class="Bound">y</a><a id="19173" class="Symbol">}</a> <a id="19175" class="Symbol">(</a><a data-type="(lower : A) → Lift ℓ A" id="19176" href="1Lab.Type.html#2075" class="InductiveConstructor">lift</a> <a id="19181" href="Cat.Instances.Slice.html#19181" class="Bound">f</a><a id="19182" class="Symbol">)</a> <a id="19184" class="Symbol">=</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="19186" href="1Lab.Path.html#20756" class="Function">ap</a> <a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="19189" href="Cat.Instances.Slice.html#2951" class="Field">map</a> <a id="19193" class="Symbol">(</a><a id="19194" href="Cat.Instances.Slice.html#18958" class="Bound">other</a> <a id="19200" class="Symbol">.</a><a data-type="(r : Cone F) (f : J₁ .Hom x y) → C ._∘_ (₁ F f) (r .ψ x) ≡ r .ψ y" id="19201" href="Cat.Diagram.Limit.Base.html#6522" class="Field">commutes</a> <a id="19210" href="Cat.Instances.Slice.html#19181" class="Bound">f</a><a id="19211" class="Symbol">)</a>
      <a id="19219" href="Cat.Instances.Slice.html#18992" class="Function">other′</a> <a id="19226" class="Symbol">.</a><a data-type="(r : Cone F) (f : J₁ .Hom x y) → C ._∘_ (₁ F f) (r .ψ x) ≡ r .ψ y" id="19227" href="Cat.Diagram.Limit.Base.html#6522" class="Field">commutes</a> <a id="19236" class="Symbol">{</a><a data-type="A → A ⊎ B₁" id="19237" href="Data.Sum.html#669" class="InductiveConstructor">inl</a> <a id="19241" href="Cat.Instances.Slice.html#19241" class="Bound">x</a><a id="19242" class="Symbol">}</a> <a id="19244" class="Symbol">{</a><a data-type="B₁ → A ⊎ B₁" id="19245" href="Data.Sum.html#687" class="InductiveConstructor">inr</a> <a id="19249" href="Cat.Instances.Slice.html#19249" class="Bound">y</a><a id="19250" class="Symbol">}</a> <a id="19252" class="Symbol">(</a><a data-type="(lower : A) → Lift ℓ A" id="19253" href="1Lab.Type.html#2075" class="InductiveConstructor">lift</a> <a id="19258" href="Cat.Instances.Slice.html#19258" class="Bound">f</a><a id="19259" class="Symbol">)</a> <a id="19261" class="Symbol">=</a> <a id="19263" href="Cat.Instances.Slice.html#18958" class="Bound">other</a> <a id="19269" class="Symbol">.</a><a data-type="(r : Cone F) (x : J₁ .Ob) → C .Hom (r .apex) (₀ F x)" id="19270" href="Cat.Diagram.Limit.Base.html#6215" class="Field">ψ</a> <a id="19272" href="Cat.Instances.Slice.html#19241" class="Bound">x</a> <a id="19274" class="Symbol">.</a><a data-type="(r : /-Hom a b) → (C ∘ map b) (r .map) ≡ a .map" id="19275" href="Cat.Instances.Slice.html#2992" class="Field">commutes</a>
      <a id="19290" href="Cat.Instances.Slice.html#18992" class="Function">other′</a> <a id="19297" class="Symbol">.</a><a data-type="(r : Cone F) (f : J₁ .Hom x y) → C ._∘_ (₁ F f) (r .ψ x) ≡ r .ψ y" id="19298" href="Cat.Diagram.Limit.Base.html#6522" class="Field">commutes</a> <a id="19307" class="Symbol">{</a><a data-type="B₁ → A ⊎ B₁" id="19308" href="Data.Sum.html#687" class="InductiveConstructor">inr</a> <a id="19312" href="Cat.Instances.Slice.html#19312" class="Bound">x</a><a id="19313" class="Symbol">}</a> <a id="19315" class="Symbol">{</a><a data-type="B₁ → A ⊎ B₁" id="19316" href="Data.Sum.html#687" class="InductiveConstructor">inr</a> <a id="19320" href="Cat.Instances.Slice.html#19320" class="Bound">y</a><a id="19321" class="Symbol">}</a> <a id="19323" class="Symbol">(</a><a data-type="(lower : A) → Lift ℓ A" id="19324" href="1Lab.Type.html#2075" class="InductiveConstructor">lift</a> <a id="19329" href="Cat.Instances.Slice.html#19329" class="Bound">f</a><a id="19330" class="Symbol">)</a> <a id="19332" class="Symbol">=</a> <a data-type="(r : Precategory o h) (f : r .Hom x y) → r ._∘_ (r .id) f ≡ f" id="19334" href="Cat.Base.html#3404" class="Function">C.idl</a> <a id="19340" class="Symbol">_</a>

      <a id="19349" class="Keyword">module</a> <a id="19356" href="Cat.Instances.Slice.html#19356" class="Module">cont</a> <a id="19361" class="Symbol">=</a> <a data-type="(A : Type ℓ) → Type ℓ" id="19363" href="1Lab.HLevel.html#1328" class="Module">is-contr</a> <a id="19372" class="Symbol">(</a><a data-type="(r : Terminal C) → is-terminal C (r .top)" id="19373" href="Cat.Diagram.Terminal.html#460" class="Field">lim.has⊤</a> <a id="19382" href="Cat.Instances.Slice.html#18992" class="Function">other′</a><a id="19388" class="Symbol">)</a>
      <a id="19396" href="Cat.Instances.Slice.html#19396" class="Function">ch</a> <a id="19399" class="Symbol">:</a> <a data-type="(F : Functor J₁ C) (x y : Cone F) → Type (o₁ ⊔ h₂)" id="19401" href="Cat.Diagram.Limit.Base.html#7691" class="Record">Cone-hom</a> <a id="19410" href="Cat.Instances.Slice.html#17480" class="Bound">F</a> <a id="19412" href="Cat.Instances.Slice.html#18958" class="Bound">other</a> <a id="19418" href="Cat.Instances.Slice.html#18661" class="Function">nadir</a>
      <a id="19430" href="Cat.Instances.Slice.html#19396" class="Function">ch</a> <a id="19433" class="Symbol">.</a><a data-type="Cone-hom F x y → C .Hom (apex x) (apex y)" id="19434" href="Cat.Diagram.Limit.Base.html#8202" class="Field">hom</a> <a id="19438" class="Symbol">.</a><a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="19439" href="Cat.Instances.Slice.html#2951" class="Field">map</a> <a id="19443" class="Symbol">=</a> <a data-type="is-contr A → A" id="19445" href="1Lab.HLevel.html#1401" class="Function">cont.centre</a> <a id="19457" class="Symbol">.</a><a data-type="Cone-hom F x y → C .Hom (apex x) (apex y)" id="19458" href="Cat.Diagram.Limit.Base.html#8202" class="Field">hom</a>
      <a id="19468" href="Cat.Instances.Slice.html#19396" class="Function">ch</a> <a id="19471" class="Symbol">.</a><a data-type="Cone-hom F x y → C .Hom (apex x) (apex y)" id="19472" href="Cat.Diagram.Limit.Base.html#8202" class="Field">hom</a> <a id="19476" class="Symbol">.</a><a data-type="(r : /-Hom a b) → (C ∘ map b) (r .map) ≡ a .map" id="19477" href="Cat.Instances.Slice.html#2992" class="Field">commutes</a> <a id="19486" class="Symbol">=</a> <a data-type="is-contr A → A" id="19488" href="1Lab.HLevel.html#1401" class="Function">cont.centre</a> <a id="19500" class="Symbol">.</a><a data-type="(r : Cone-hom F x y) → C ._∘_ (ψ y o) (r .hom) ≡ ψ x o" id="19501" href="Cat.Diagram.Limit.Base.html#8253" class="Field">commutes</a> <a id="19510" class="Symbol">{</a><a id="19511" class="Argument">o</a> <a id="19513" class="Symbol">=</a> <a data-type="B₁ → A ⊎ B₁" id="19515" href="Data.Sum.html#687" class="InductiveConstructor">inr</a> <a data-type="⊤" id="19519" href="Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a><a id="19521" class="Symbol">}</a>
      <a id="19529" href="Cat.Instances.Slice.html#19396" class="Function">ch</a> <a id="19532" class="Symbol">.</a><a data-type="(r : Cone-hom F x y) → C ._∘_ (ψ y o) (r .hom) ≡ ψ x o" id="19533" href="Cat.Diagram.Limit.Base.html#8253" class="Field">commutes</a> <a id="19542" class="Symbol">{</a><a id="19543" href="Cat.Instances.Slice.html#19543" class="Bound">o</a><a id="19544" class="Symbol">}</a> <a id="19546" class="Symbol">=</a> <a data-type="x .map ≡ y .map → x ≡ y" id="19548" href="Cat.Instances.Slice.html#3929" class="Function">/-Hom-path</a> <a id="19559" class="Symbol">(</a><a data-type="is-contr A → A" id="19560" href="1Lab.HLevel.html#1401" class="Function">cont.centre</a> <a id="19572" class="Symbol">.</a><a data-type="(r : Cone-hom F x y) → C ._∘_ (ψ y o) (r .hom) ≡ ψ x o" id="19573" href="Cat.Diagram.Limit.Base.html#8253" class="Field">commutes</a> <a id="19582" class="Symbol">{</a><a id="19583" class="Argument">o</a> <a id="19585" class="Symbol">=</a> <a data-type="A → A ⊎ B₁" id="19587" href="Data.Sum.html#669" class="InductiveConstructor">inl</a> <a id="19591" href="Cat.Instances.Slice.html#19543" class="Bound">o</a><a id="19592" class="Symbol">})</a>

      <a id="19602" href="Cat.Instances.Slice.html#19602" class="Function">cont</a> <a id="19607" class="Symbol">:</a> <a id="19609" class="Symbol">∀</a> <a id="19611" href="Cat.Instances.Slice.html#19611" class="Bound">c</a> <a id="19613" class="Symbol">→</a> <a id="19615" href="Cat.Instances.Slice.html#19396" class="Function">ch</a> <a data-type="A → A → Type ℓ" id="19618" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="19620" href="Cat.Instances.Slice.html#19611" class="Bound">c</a>
      <a id="19628" href="Cat.Instances.Slice.html#19602" class="Function">cont</a> <a id="19633" href="Cat.Instances.Slice.html#19633" class="Bound">c</a> <a id="19635" class="Symbol">=</a> <a data-type="(F : Functor J₁ C) → hom f ≡ hom g → f ≡ g" id="19637" href="Cat.Diagram.Limit.Base.html#8324" class="Function">Cone-hom-path</a> <a id="19651" class="Symbol">_</a> <a id="19653" class="Symbol">(</a><a data-type="x .map ≡ y .map → x ≡ y" id="19654" href="Cat.Instances.Slice.html#3929" class="Function">/-Hom-path</a> <a id="19665" class="Symbol">(</a><a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="19666" href="1Lab.Path.html#20756" class="Function">ap</a> <a data-type="Cone-hom F x y → C .Hom (apex x) (apex y)" id="19669" href="Cat.Diagram.Limit.Base.html#8202" class="Field">hom</a> <a id="19673" href="Cat.Instances.Slice.html#19874" class="Function">uniq</a><a id="19677" class="Symbol">))</a> <a id="19680" class="Keyword">where</a>
        <a id="19694" href="Cat.Instances.Slice.html#19694" class="Function">c′</a> <a id="19697" class="Symbol">:</a> <a data-type="(F : Functor J₁ C) (x y : Cone F) → Type (o₁ ⊔ h₂)" id="19699" href="Cat.Diagram.Limit.Base.html#7691" class="Record">Cone-hom</a> <a id="19708" href="Cat.Instances.Slice.html#17919" class="Function">F′</a> <a id="19711" href="Cat.Instances.Slice.html#18992" class="Function">other′</a> <a data-type="Terminal C → Ob C" id="19718" href="Cat.Diagram.Terminal.html#447" class="Field">lim.top</a>
        <a id="19734" href="Cat.Instances.Slice.html#19694" class="Function">c′</a> <a id="19737" class="Symbol">.</a><a data-type="Cone-hom F x y → C .Hom (apex x) (apex y)" id="19738" href="Cat.Diagram.Limit.Base.html#8202" class="Field">hom</a> <a id="19742" class="Symbol">=</a> <a id="19744" href="Cat.Instances.Slice.html#19633" class="Bound">c</a> <a id="19746" class="Symbol">.</a><a data-type="Cone-hom F x y → C .Hom (apex x) (apex y)" id="19747" href="Cat.Diagram.Limit.Base.html#8202" class="Field">hom</a> <a id="19751" class="Symbol">.</a><a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="19752" href="Cat.Instances.Slice.html#2951" class="Field">map</a>
        <a id="19764" href="Cat.Instances.Slice.html#19694" class="Function">c′</a> <a id="19767" class="Symbol">.</a><a data-type="(r : Cone-hom F x y) → C ._∘_ (ψ y o) (r .hom) ≡ ψ x o" id="19768" href="Cat.Diagram.Limit.Base.html#8253" class="Field">commutes</a> <a id="19777" class="Symbol">{</a><a data-type="A → A ⊎ B₁" id="19778" href="Data.Sum.html#669" class="InductiveConstructor">inl</a> <a id="19782" href="Cat.Instances.Slice.html#19782" class="Bound">x</a><a id="19783" class="Symbol">}</a> <a id="19785" class="Symbol">=</a> <a data-type="(f : (x : A) → B₁ x) (p : x ≡ y) →
PathP (λ i → B₁ (p i)) (f x) (f y)" id="19787" href="1Lab.Path.html#20756" class="Function">ap</a> <a data-type="/-Hom a b → Hom C (a .domain) (domain b)" id="19790" href="Cat.Instances.Slice.html#2951" class="Field">map</a> <a id="19794" class="Symbol">(</a><a id="19795" href="Cat.Instances.Slice.html#19633" class="Bound">c</a> <a id="19797" class="Symbol">.</a><a data-type="(r : Cone-hom F x y) → C ._∘_ (ψ y o) (r .hom) ≡ ψ x o" id="19798" href="Cat.Diagram.Limit.Base.html#8253" class="Field">commutes</a> <a id="19807" class="Symbol">{</a><a id="19808" class="Argument">o</a> <a id="19810" class="Symbol">=</a> <a id="19812" href="Cat.Instances.Slice.html#19782" class="Bound">x</a><a id="19813" class="Symbol">})</a>
        <a id="19824" href="Cat.Instances.Slice.html#19694" class="Function">c′</a> <a id="19827" class="Symbol">.</a><a data-type="(r : Cone-hom F x y) → C ._∘_ (ψ y o) (r .hom) ≡ ψ x o" id="19828" href="Cat.Diagram.Limit.Base.html#8253" class="Field">commutes</a> <a id="19837" class="Symbol">{</a><a data-type="B₁ → A ⊎ B₁" id="19838" href="Data.Sum.html#687" class="InductiveConstructor">inr</a> <a data-type="⊤" id="19842" href="Agda.Builtin.Unit.html#201" class="InductiveConstructor">tt</a><a id="19844" class="Symbol">}</a> <a id="19846" class="Symbol">=</a> <a id="19848" href="Cat.Instances.Slice.html#19633" class="Bound">c</a> <a id="19850" class="Symbol">.</a><a data-type="Cone-hom F x y → C .Hom (apex x) (apex y)" id="19851" href="Cat.Diagram.Limit.Base.html#8202" class="Field">hom</a> <a id="19855" class="Symbol">.</a><a data-type="(r : /-Hom a b) → (C ∘ map b) (r .map) ≡ a .map" id="19856" href="Cat.Instances.Slice.html#2992" class="Field">commutes</a>

        <a id="19874" href="Cat.Instances.Slice.html#19874" class="Function">uniq</a> <a id="19879" class="Symbol">=</a> <a data-type="(r : is-contr A) (x : A) → r .centre ≡ x" id="19881" href="1Lab.HLevel.html#1416" class="Function">cont.paths</a> <a id="19892" href="Cat.Instances.Slice.html#19694" class="Function">c′</a>
</pre>
<p>In particular, if a category <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">C</mi></mrow><annotation encoding="application/x-tex">\ca{C}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal" style="margin-right:0.05834em;">C</span></span></span></span> is complete, then so are its slices:</p>
<pre class="Agda"><a id="is-complete→slice-is-complete"></a><a data-type="is-complete o′ ℓ′ C → is-complete o′ ℓ′ (Slice C c)" id="19984" href="Cat.Instances.Slice.html#19984" class="Function">is-complete→slice-is-complete</a>
  <a id="20016" class="Symbol">:</a> <a id="20018" class="Symbol">∀</a> <a id="20020" class="Symbol">{</a><a id="20021" href="Cat.Instances.Slice.html#20021" class="Bound">ℓ</a> <a id="20023" href="Cat.Instances.Slice.html#20023" class="Bound">o</a> <a id="20025" href="Cat.Instances.Slice.html#20025" class="Bound">ℓ′</a><a id="20027" class="Symbol">}</a> <a id="20029" class="Symbol">{</a><a id="20030" href="Cat.Instances.Slice.html#20030" class="Bound">C</a> <a id="20032" class="Symbol">:</a> <a data-type="(o h : Level) → Type (lsuc o ⊔ lsuc h)" id="20034" href="Cat.Base.html#644" class="Record">Precategory</a> <a id="20046" href="Cat.Instances.Slice.html#20023" class="Bound">o</a> <a id="20048" href="Cat.Instances.Slice.html#20021" class="Bound">ℓ</a><a id="20049" class="Symbol">}</a> <a id="20051" class="Symbol">{</a><a id="20052" href="Cat.Instances.Slice.html#20052" class="Bound">c</a> <a id="20054" class="Symbol">:</a> <a data-type="Precategory o h → Type o" id="20056" href="Cat.Base.html#1341" class="Field">Precategory.Ob</a> <a id="20071" href="Cat.Instances.Slice.html#20030" class="Bound">C</a><a id="20072" class="Symbol">}</a>
  <a id="20076" class="Symbol">→</a> <a data-type="(o ℓ : Level) →
Precategory oc ℓc → Type (oc ⊔ ℓc ⊔ lsuc o ⊔ lsuc ℓ)" id="20078" href="Cat.Diagram.Limit.Base.html#16298" class="Function">is-complete</a> <a id="20090" href="Cat.Instances.Slice.html#487" class="Generalizable">o′</a> <a id="20093" href="Cat.Instances.Slice.html#20025" class="Bound">ℓ′</a> <a id="20096" href="Cat.Instances.Slice.html#20030" class="Bound">C</a>
  <a id="20100" class="Symbol">→</a> <a data-type="(o ℓ : Level) →
Precategory oc ℓc → Type (oc ⊔ ℓc ⊔ lsuc o ⊔ lsuc ℓ)" id="20102" href="Cat.Diagram.Limit.Base.html#16298" class="Function">is-complete</a> <a id="20114" href="Cat.Instances.Slice.html#487" class="Generalizable">o′</a> <a id="20117" href="Cat.Instances.Slice.html#20025" class="Bound">ℓ′</a> <a id="20120" class="Symbol">(</a><a data-type="(C : Precategory o ℓ) → Ob C → Precategory (o ⊔ ℓ) ℓ" id="20121" href="Cat.Instances.Slice.html#4907" class="Function">Slice</a> <a id="20127" href="Cat.Instances.Slice.html#20030" class="Bound">C</a> <a id="20129" href="Cat.Instances.Slice.html#20052" class="Bound">c</a><a id="20130" class="Symbol">)</a>
<a data-type="is-complete o′ ℓ′ C → is-complete o′ ℓ′ (Slice C c)" id="20132" href="Cat.Instances.Slice.html#19984" class="Function">is-complete→slice-is-complete</a> <a id="20162" href="Cat.Instances.Slice.html#20162" class="Bound">lims</a> <a id="20167" href="Cat.Instances.Slice.html#20167" class="Bound">F</a> <a id="20169" class="Symbol">=</a> <a data-type="(F : Functor J₁ (Slice C o)) → Limit (F′ F) → Limit F" id="20171" href="Cat.Instances.Slice.html#18499" class="Function">limit-above→limit-in-slice</a> <a id="20198" href="Cat.Instances.Slice.html#20167" class="Bound">F</a> <a id="20200" class="Symbol">(</a><a id="20201" href="Cat.Instances.Slice.html#20162" class="Bound">lims</a> <a id="20206" class="Symbol">_)</a>
</pre>
  </article>
</div>

</main>
</body>
</html>
