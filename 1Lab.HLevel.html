<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8"></meta>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"></meta>
  <meta name="keywords" content="Agda,categories,topos"></meta>

  <title>1Lab.HLevel - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css"></link>
  <link rel="stylesheet" href="/css/katex.min.css"></link>
  <link rel="stylesheet" href="/css/agda-cats.css"></link>

  <meta name="twitter:card" content="summary"></meta>
  <meta name="twitter:title" content="1Lab.HLevel - 1Lab"></meta>
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png"></meta>

  <meta name="og:title" content="1Lab.HLevel - 1Lab"></meta>
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png"></meta>
  <meta name="og:site-name" content="1Lab"></meta>
  <meta name="og:type" content="website"></meta>

    <meta name="og:description" content="A formalised, explorable online resource for Homotopy Type Theory."></meta>
  <meta name="twitter:description" content="A formalised, explorable online resource for Homotopy Type Theory."></meta>
  <meta name="description" content="A formalised, explorable online resource for Homotopy Type Theory."></meta>
  
  <script src="/equations.js" type="text/javascript"></script>
  <script src="/highlight-hover.js" type="text/javascript"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>
</head>

<body>
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">1Lab.HLevel</a>
              </h3>

      <!-- Cube logo -->
      <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px"></img>

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr></hr>
      <ul>
      <li><a href="#h-levels"><a href="#h-levels" class="header-link">h-Levels<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#preservation-of-h-levels"><a href="#preservation-of-h-levels" class="header-link">Preservation of h-levels<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#ishlevel-is-a-proposition"><a href="#ishlevel-is-a-proposition" class="header-link">isHLevel is a proposition<span class="header-link-emoji">🔗</span></a></a></li>
      <li><a href="#dependent-h-levels"><a href="#dependent-h-levels" class="header-link">Dependent h-Levels<span class="header-link-emoji">🔗</span></a></a></li>
      </ul>
      <hr></hr>

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>
      </div>

      <hr></hr>

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
              <a href="index.html">️back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/8495e73c6e3d172ea4aabdeda938ec406a4c4ac8/src/1Lab/HLevel.lagda.md">link to source</a> <br />
                <hr></hr> <div class="author-list">Written by Amélia Liao</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="index.html">️back to index</a>
      </div>
      
      <!-- Font toggle checkbox -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>
    </div>

<pre class="Agda"><a id="9" class="Keyword">open</a> <a id="14" class="Keyword">import</a> <a id="21" href="1Lab.Path.html" class="Module">1Lab.Path</a>
<a id="31" class="Keyword">open</a> <a id="36" class="Keyword">import</a> <a id="43" href="1Lab.Type.html" class="Module">1Lab.Type</a>

<a id="54" class="Keyword">module</a> <a id="61" href="1Lab.HLevel.html" class="Module">1Lab.HLevel</a> <a id="73" class="Keyword">where</a>
</pre>
<h1 id="h-levels"><a href="#h-levels" class="header-link">h-Levels<span class="header-link-emoji">🔗</span></a></h1>
<p>The “homotopy level” (h-level for short) of a type is a measure of how <a href="https://ncatlab.org/nlab/show/truncated+object">truncated</a> it is, where the numbering is offset by 2. Specifically, a (-2)-truncated type is a type of h-level 0. In another sense, h-level measures how “homotopically interesting” a given type is:</p>
<ul>
<li><p>The contractible types are maximally uninteresting because there is only one.</p></li>
<li><p>The only interesting information about a proposition is whether it is inhabited.</p></li>
<li><p>The interesting information about a set is the collection of its inhabitants.</p></li>
<li><p>The interesting information about a groupoid includes, in addition to its inhabitants, the way those are related by paths. As an extreme example, the delooping groupoid of a group – for instance, <a href="1Lab.HIT.S1.html">the circle</a> – has uninteresting points (there’s only one), but interesting <em>loops</em>.</p></li>
</ul>
<p>For convenience, we refer to the collection of types of h-level <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> as <em>homotopy <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n-2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>-types</span></em>. For instance: “The sets are the homotopy 0-types”. The use of the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">2</span></span></span></span> offset is so the naming here matches that of the HoTT book.</p>
<p>The h-levels are defined by induction, where the base case are the <em>contractible types</em>.</p>
<pre class="Agda"><a id="1321" class="Keyword">record</a> <a id="isContr"></a><a data-type="(A : Type ℓ) → Type ℓ" id="1328" href="1Lab.HLevel.html#1328" class="Record">isContr</a> <a id="1336" class="Symbol">{</a><a id="1337" href="1Lab.HLevel.html#1337" class="Bound">ℓ</a><a id="1338" class="Symbol">}</a> <a id="1340" class="Symbol">(</a><a id="1341" href="1Lab.HLevel.html#1341" class="Bound">A</a> <a id="1343" class="Symbol">:</a> <a id="1345" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="1350" href="1Lab.HLevel.html#1337" class="Bound">ℓ</a><a id="1351" class="Symbol">)</a> <a id="1353" class="Symbol">:</a> <a id="1355" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="1360" href="1Lab.HLevel.html#1337" class="Bound">ℓ</a> <a id="1362" class="Keyword">where</a>
  <a id="1370" class="Keyword">constructor</a> <a id="contr"></a><a data-type="(centre₁ : A) (paths₁ : (x : A) → centre₁ ≡ x) → isContr A" id="1382" href="1Lab.HLevel.html#1382" class="InductiveConstructor">contr</a>
  <a id="1390" class="Keyword">field</a>
    <a id="isContr.centre"></a><a data-type="isContr A → A" id="1400" href="1Lab.HLevel.html#1400" class="Field">centre</a> <a id="1407" class="Symbol">:</a> <a id="1409" href="1Lab.HLevel.html#1341" class="Bound">A</a>
    <a id="isContr.paths"></a><a data-type="(r : isContr A) (x : A) → r .centre ≡ x" id="1415" href="1Lab.HLevel.html#1415" class="Field">paths</a> <a id="1421" class="Symbol">:</a> <a id="1423" class="Symbol">(</a><a id="1424" href="1Lab.HLevel.html#1424" class="Bound">x</a> <a id="1426" class="Symbol">:</a> <a id="1428" href="1Lab.HLevel.html#1341" class="Bound">A</a><a id="1429" class="Symbol">)</a> <a id="1431" class="Symbol">→</a> <a data-type="isContr A → A" id="1433" href="1Lab.HLevel.html#1400" class="Field">centre</a> <a data-type="A → A → Type ℓ" id="1440" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="1442" href="1Lab.HLevel.html#1424" class="Bound">x</a>

<a id="1445" class="Keyword">open</a> <a data-type="(A : Type ℓ) → Type ℓ" id="1450" href="1Lab.HLevel.html#1328" class="Module">isContr</a> <a id="1458" class="Keyword">public</a>
</pre>
<p>A contractible type is one for which the unique map <code>X → ⊤</code> is an equivalence. Thus, it has “one element”. This doesn’t mean that we can’t have “multiple”, distinctly named, inhabitants of the type; It means any inhabitants of the type must be connected by a path, and this path must be picked uniformly.</p>
<pre class="Agda"><a id="1784" class="Keyword">module</a> <a id="1791" href="1Lab.HLevel.html#1791" class="Module">_</a> <a id="1793" class="Keyword">where</a>
  <a id="1801" class="Keyword">data</a> <a data-type="Type" id="1806" href="1Lab.HLevel.html#1806" class="Datatype">[0,1]</a> <a id="1812" class="Symbol">:</a> <a id="1814" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="1819" class="Keyword">where</a>
    <a data-type="[0,1]" id="1829" href="1Lab.HLevel.html#1829" class="InductiveConstructor">ii0</a> <a id="1833" class="Symbol">:</a> <a data-type="Type" id="1835" href="1Lab.HLevel.html#1806" class="Datatype">[0,1]</a>
    <a data-type="[0,1]" id="1845" href="1Lab.HLevel.html#1845" class="InductiveConstructor">ii1</a> <a id="1849" class="Symbol">:</a> <a data-type="Type" id="1851" href="1Lab.HLevel.html#1806" class="Datatype">[0,1]</a>
    <a data-type="ii0 ≡ ii1" id="1861" href="1Lab.HLevel.html#1861" class="InductiveConstructor">seg</a> <a id="1865" class="Symbol">:</a> <a data-type="[0,1]" id="1867" href="1Lab.HLevel.html#1829" class="InductiveConstructor">ii0</a> <a data-type="A → A → Type ℓ" id="1871" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a data-type="[0,1]" id="1873" href="1Lab.HLevel.html#1845" class="InductiveConstructor">ii1</a>
</pre>
<p>An example of a contractible type that is not <em>directly</em> defined as another name for <code>⊤</code> is the unit interval, defined as a higher inductive type.</p>
<pre class="Agda">  <a data-type="isContr [0,1]" id="2040" href="1Lab.HLevel.html#2040" class="Function">interval-contractible</a> <a id="2062" class="Symbol">:</a> <a data-type="(A : Type ℓ) → Type ℓ" id="2064" href="1Lab.HLevel.html#1328" class="Record">isContr</a> <a data-type="Type" id="2072" href="1Lab.HLevel.html#1806" class="Datatype">[0,1]</a>
  <a data-type="isContr [0,1]" id="2080" href="1Lab.HLevel.html#2040" class="Function">interval-contractible</a> <a id="2102" class="Symbol">.</a><a data-type="isContr A → A" id="2103" href="1Lab.HLevel.html#1400" class="Field">centre</a> <a id="2110" class="Symbol">=</a> <a data-type="[0,1]" id="2112" href="1Lab.HLevel.html#1829" class="InductiveConstructor">ii0</a>
  <a data-type="isContr [0,1]" id="2118" href="1Lab.HLevel.html#2040" class="Function">interval-contractible</a> <a id="2140" class="Symbol">.</a><a data-type="(r : isContr A) (x : A) → r .centre ≡ x" id="2141" href="1Lab.HLevel.html#1415" class="Field">paths</a> <a data-type="[0,1]" id="2147" href="1Lab.HLevel.html#1829" class="InductiveConstructor">ii0</a> <a id="2151" href="1Lab.HLevel.html#2151" class="Bound">i</a> <a id="2153" class="Symbol">=</a> <a data-type="[0,1]" id="2155" href="1Lab.HLevel.html#1829" class="InductiveConstructor">ii0</a>
  <a data-type="isContr [0,1]" id="2161" href="1Lab.HLevel.html#2040" class="Function">interval-contractible</a> <a id="2183" class="Symbol">.</a><a data-type="(r : isContr A) (x : A) → r .centre ≡ x" id="2184" href="1Lab.HLevel.html#1415" class="Field">paths</a> <a data-type="[0,1]" id="2190" href="1Lab.HLevel.html#1845" class="InductiveConstructor">ii1</a> <a id="2194" href="1Lab.HLevel.html#2194" class="Bound">i</a> <a id="2196" class="Symbol">=</a> <a data-type="ii0 ≡ ii1" id="2198" href="1Lab.HLevel.html#1861" class="InductiveConstructor">seg</a> <a id="2202" href="1Lab.HLevel.html#2194" class="Bound">i</a>
  <a data-type="isContr [0,1]" id="2206" href="1Lab.HLevel.html#2040" class="Function">interval-contractible</a> <a id="2228" class="Symbol">.</a><a data-type="(r : isContr A) (x : A) → r .centre ≡ x" id="2229" href="1Lab.HLevel.html#1415" class="Field">paths</a> <a id="2235" class="Symbol">(</a><a data-type="ii0 ≡ ii1" id="2236" href="1Lab.HLevel.html#1861" class="InductiveConstructor">seg</a> <a id="2240" href="1Lab.HLevel.html#2240" class="Bound">i</a><a id="2241" class="Symbol">)</a> <a id="2243" href="1Lab.HLevel.html#2243" class="Bound">j</a> <a id="2245" class="Symbol">=</a> <a data-type="ii0 ≡ ii1" id="2247" href="1Lab.HLevel.html#1861" class="InductiveConstructor">seg</a> <a id="2251" class="Symbol">(</a><a id="2252" href="1Lab.HLevel.html#2240" class="Bound">i</a> <a id="2254" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="2256" href="1Lab.HLevel.html#2243" class="Bound">j</a><a id="2257" class="Symbol">)</a>
</pre>
<p>A type is (n+1)-truncated if its path types are all n-truncated. However, if we directly take this as the definition, the types we end up with are very inconvenient! That’s why we introduce this immediate step: An <strong>h-proposition</strong>, or <strong>proposition</strong> for short, is a type where any two elements are connected by a path.</p>
<pre class="Agda"><a id="isProp"></a><a data-type="Type ℓ → Type ℓ" id="2594" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="2601" class="Symbol">:</a> <a id="2603" class="Symbol">∀</a> <a id="2605" class="Symbol">{</a><a id="2606" href="1Lab.HLevel.html#2606" class="Bound">ℓ</a><a id="2607" class="Symbol">}</a> <a id="2609" class="Symbol">→</a> <a id="2611" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2616" href="1Lab.HLevel.html#2606" class="Bound">ℓ</a> <a id="2618" class="Symbol">→</a> <a id="2620" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2625" class="Symbol">_</a>
<a data-type="Type ℓ → Type ℓ" id="2627" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="2634" href="1Lab.HLevel.html#2634" class="Bound">A</a> <a id="2636" class="Symbol">=</a> <a id="2638" class="Symbol">(</a><a id="2639" href="1Lab.HLevel.html#2639" class="Bound">x</a> <a id="2641" href="1Lab.HLevel.html#2641" class="Bound">y</a> <a id="2643" class="Symbol">:</a> <a id="2645" href="1Lab.HLevel.html#2634" class="Bound">A</a><a id="2646" class="Symbol">)</a> <a id="2648" class="Symbol">→</a> <a id="2650" href="1Lab.HLevel.html#2639" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="2652" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="2654" href="1Lab.HLevel.html#2641" class="Bound">y</a>
</pre>
<p>With this, we can define the <span class="Agda"><a data-type="Type ℓ → Nat → Type ℓ" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a></span> predicate. For h-levels greater than zero, this definition results in much simpler types!</p>
<pre class="Agda"><a id="isHLevel"></a><a data-type="Type ℓ → Nat → Type ℓ" id="2807" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a> <a id="2816" class="Symbol">:</a> <a id="2818" class="Symbol">∀</a> <a id="2820" class="Symbol">{</a><a id="2821" href="1Lab.HLevel.html#2821" class="Bound">ℓ</a><a id="2822" class="Symbol">}</a> <a id="2824" class="Symbol">→</a> <a id="2826" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2831" href="1Lab.HLevel.html#2821" class="Bound">ℓ</a> <a id="2833" class="Symbol">→</a> <a data-type="Type" id="2835" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a> <a id="2839" class="Symbol">→</a> <a id="2841" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="2846" class="Symbol">_</a>
<a data-type="Type ℓ → Nat → Type ℓ" id="2848" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a> <a id="2857" href="1Lab.HLevel.html#2857" class="Bound">A</a> <a id="2859" class="Number">0</a> <a id="2861" class="Symbol">=</a> <a data-type="(A : Type ℓ) → Type ℓ" id="2863" href="1Lab.HLevel.html#1328" class="Record">isContr</a> <a id="2871" href="1Lab.HLevel.html#2857" class="Bound">A</a>
<a data-type="Type ℓ → Nat → Type ℓ" id="2873" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a> <a id="2882" href="1Lab.HLevel.html#2882" class="Bound">A</a> <a id="2884" class="Number">1</a> <a id="2886" class="Symbol">=</a> <a data-type="Type ℓ → Type ℓ" id="2888" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="2895" href="1Lab.HLevel.html#2882" class="Bound">A</a>
<a data-type="Type ℓ → Nat → Type ℓ" id="2897" href="1Lab.HLevel.html#2807" class="CatchallClause Function">isHLevel</a><a id="2905" class="CatchallClause"> </a><a id="2906" href="1Lab.HLevel.html#2906" class="CatchallClause Bound">A</a><a id="2907" class="CatchallClause"> </a><a id="2908" class="CatchallClause Symbol">(</a><a data-type="Nat → Nat" id="2909" href="Agda.Builtin.Nat.html#223" class="CatchallClause InductiveConstructor">suc</a><a id="2912" class="CatchallClause"> </a><a id="2913" href="1Lab.HLevel.html#2913" class="CatchallClause Bound">n</a><a id="2914" class="CatchallClause Symbol">)</a> <a id="2916" class="Symbol">=</a> <a id="2918" class="Symbol">(</a><a id="2919" href="1Lab.HLevel.html#2919" class="Bound">x</a> <a id="2921" href="1Lab.HLevel.html#2921" class="Bound">y</a> <a id="2923" class="Symbol">:</a> <a id="2925" href="1Lab.HLevel.html#2906" class="Bound">A</a><a id="2926" class="Symbol">)</a> <a id="2928" class="Symbol">→</a> <a data-type="Type ℓ → Nat → Type ℓ" id="2930" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a> <a id="2939" class="Symbol">(</a><a data-type="(A : Type ℓ) → A → A → Type ℓ" id="2940" href="1Lab.Path.html#2466" class="Function">Path</a> <a id="2945" href="1Lab.HLevel.html#2906" class="Bound">A</a> <a id="2947" href="1Lab.HLevel.html#2919" class="Bound">x</a> <a id="2949" href="1Lab.HLevel.html#2921" class="Bound">y</a><a id="2950" class="Symbol">)</a> <a id="2952" href="1Lab.HLevel.html#2913" class="Bound">n</a>
</pre>
<p>Since types of h-level 2 are very common, they get a special name: <strong>h-sets</strong>, or just <strong>sets</strong> for short. This is justified because we can think of classical sets as being equipped with an equality <em>proposition</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x = y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> - having propositional paths is exactly the definition of <span class="Agda"><a data-type="Type ℓ → Type ℓ" href="1Lab.HLevel.html#3342" class="Function">isSet</a></span>. The universe of all types that are sets, is, correspondingly, called <strong>Set</strong>.</p>
<pre class="Agda"><a id="isSet"></a><a data-type="Type ℓ → Type ℓ" id="3342" href="1Lab.HLevel.html#3342" class="Function">isSet</a> <a id="3348" class="Symbol">:</a> <a id="3350" class="Symbol">∀</a> <a id="3352" class="Symbol">{</a><a id="3353" href="1Lab.HLevel.html#3353" class="Bound">ℓ</a><a id="3354" class="Symbol">}</a> <a id="3356" class="Symbol">→</a> <a id="3358" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3363" href="1Lab.HLevel.html#3353" class="Bound">ℓ</a> <a id="3365" class="Symbol">→</a> <a id="3367" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3372" href="1Lab.HLevel.html#3353" class="Bound">ℓ</a>
<a data-type="Type ℓ → Type ℓ" id="3374" href="1Lab.HLevel.html#3342" class="Function">isSet</a> <a id="3380" href="1Lab.HLevel.html#3380" class="Bound">A</a> <a id="3382" class="Symbol">=</a> <a data-type="Type ℓ → Nat → Type ℓ" id="3384" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a> <a id="3393" href="1Lab.HLevel.html#3380" class="Bound">A</a> <a id="3395" class="Number">2</a>

<a id="Set"></a><a data-type="(ℓ : Level) → Type (lsuc ℓ)" id="3398" href="1Lab.HLevel.html#3398" class="Function">Set</a> <a id="3402" class="Symbol">:</a> <a id="3404" class="Symbol">(</a><a id="3405" href="1Lab.HLevel.html#3405" class="Bound">ℓ</a> <a id="3407" class="Symbol">:</a> <a data-type="Type" id="3409" href="Agda.Primitive.html#597" class="Postulate">Level</a><a id="3414" class="Symbol">)</a> <a id="3416" class="Symbol">→</a> <a id="3418" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3423" class="Symbol">(</a><a data-type="Level → Level" id="3424" href="Agda.Primitive.html#780" class="Primitive">lsuc</a> <a id="3429" href="1Lab.HLevel.html#3405" class="Bound">ℓ</a><a id="3430" class="Symbol">)</a>
<a data-type="(ℓ : Level) → Type (lsuc ℓ)" id="3432" href="1Lab.HLevel.html#3398" class="Function">Set</a> <a id="3436" href="1Lab.HLevel.html#3436" class="Bound">ℓ</a> <a id="3438" class="Symbol">=</a> <a data-type="(B₁ : A → Type b) → Type (a ⊔ b)" id="3440" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="3442" class="Symbol">(</a><a data-type="Type ℓ → Type ℓ" id="3443" href="1Lab.HLevel.html#3342" class="Function">isSet</a> <a id="3449" class="Symbol">{</a><a id="3450" class="Argument">ℓ</a> <a id="3452" class="Symbol">=</a> <a id="3454" href="1Lab.HLevel.html#3436" class="Bound">ℓ</a><a id="3455" class="Symbol">})</a>
</pre>
<!--
<pre class="Agda"><a id="Prop"></a><a id="3476" href="1Lab.HLevel.html#3476" class="Function">Prop</a> <a id="3481" class="Symbol">:</a> <a id="3483" class="Symbol">(</a><a id="3484" href="1Lab.HLevel.html#3484" class="Bound">ℓ</a> <a id="3486" class="Symbol">:</a> <a id="3488" href="Agda.Primitive.html#597" class="Postulate">Level</a><a id="3493" class="Symbol">)</a> <a id="3495" class="Symbol">→</a> <a id="3497" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3502" class="Symbol">(</a><a id="3503" href="Agda.Primitive.html#780" class="Primitive">lsuc</a> <a id="3508" href="1Lab.HLevel.html#3484" class="Bound">ℓ</a><a id="3509" class="Symbol">)</a>
<a id="3511" href="1Lab.HLevel.html#3476" class="Function">Prop</a> <a id="3516" href="1Lab.HLevel.html#3516" class="Bound">ℓ</a> <a id="3518" class="Symbol">=</a> <a id="3520" href="1Lab.Type.html#1563" class="Function">Σ</a> <a id="3522" class="Symbol">(</a><a id="3523" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="3530" class="Symbol">{</a><a id="3531" class="Argument">ℓ</a> <a id="3533" class="Symbol">=</a> <a id="3535" href="1Lab.HLevel.html#3516" class="Bound">ℓ</a><a id="3536" class="Symbol">})</a>
</pre>-->
<p>Similarly, the types of h-level 3 are called <strong>groupoids</strong>.</p>
<pre class="Agda"><a id="isGroupoid"></a><a data-type="Type ℓ → Type ℓ" id="3617" href="1Lab.HLevel.html#3617" class="Function">isGroupoid</a> <a id="3628" class="Symbol">:</a> <a id="3630" class="Symbol">∀</a> <a id="3632" class="Symbol">{</a><a id="3633" href="1Lab.HLevel.html#3633" class="Bound">ℓ</a><a id="3634" class="Symbol">}</a> <a id="3636" class="Symbol">→</a> <a id="3638" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3643" href="1Lab.HLevel.html#3633" class="Bound">ℓ</a> <a id="3645" class="Symbol">→</a> <a id="3647" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3652" href="1Lab.HLevel.html#3633" class="Bound">ℓ</a>
<a data-type="Type ℓ → Type ℓ" id="3654" href="1Lab.HLevel.html#3617" class="Function">isGroupoid</a> <a id="3665" href="1Lab.HLevel.html#3665" class="Bound">A</a> <a id="3667" class="Symbol">=</a> <a data-type="Type ℓ → Nat → Type ℓ" id="3669" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a> <a id="3678" href="1Lab.HLevel.html#3665" class="Bound">A</a> <a id="3680" class="Number">3</a>
</pre>
<hr></hr>
<pre class="Agda"><a id="3700" class="Keyword">private</a>
  <a id="3710" class="Keyword">variable</a>
    <a id="3723" href="1Lab.HLevel.html#3723" class="Generalizable">ℓ</a> <a id="3725" class="Symbol">:</a> <a data-type="Type" id="3727" href="Agda.Primitive.html#597" class="Postulate">Level</a>
    <a id="3737" href="1Lab.HLevel.html#3737" class="Generalizable">A</a> <a id="3739" class="Symbol">:</a> <a id="3741" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="3746" href="1Lab.HLevel.html#3723" class="Generalizable">ℓ</a>
</pre>
<h1 id="preservation-of-h-levels"><a href="#preservation-of-h-levels" class="header-link">Preservation of h-levels<span class="header-link-emoji">🔗</span></a></h1>
<p>If a type is of h-level <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>,</span> then it’s automatically of h-level <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>+</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">k+n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>,</span> for any <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>.</span> We first prove a couple of common cases that deserve their own names:</p>
<pre class="Agda"><a id="isContr→isProp"></a><a data-type="isContr A → isProp A" id="3944" href="1Lab.HLevel.html#3944" class="Function">isContr→isProp</a> <a id="3959" class="Symbol">:</a> <a data-type="(A : Type ℓ) → Type ℓ" id="3961" href="1Lab.HLevel.html#1328" class="Record">isContr</a> <a id="3969" href="1Lab.HLevel.html#3737" class="Generalizable">A</a> <a id="3971" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="3973" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="3980" href="1Lab.HLevel.html#3737" class="Generalizable">A</a>
<a data-type="isContr A → isProp A" id="3982" href="1Lab.HLevel.html#3944" class="Function">isContr→isProp</a> <a id="3997" href="1Lab.HLevel.html#3997" class="Bound">C</a> <a id="3999" href="1Lab.HLevel.html#3999" class="Bound">x</a> <a id="4001" href="1Lab.HLevel.html#4001" class="Bound">y</a> <a id="4003" href="1Lab.HLevel.html#4003" class="Bound">i</a> <a id="4005" class="Symbol">=</a>
  <a id="4009" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="4015" class="Symbol">(λ</a> <a id="4018" href="1Lab.HLevel.html#4018" class="Bound">j</a> <a id="4020" class="Symbol">→</a> <a id="4022" class="Symbol">λ</a> <a id="4024" class="Symbol">{</a> <a id="4026" class="Symbol">(</a><a id="4027" href="1Lab.HLevel.html#4003" class="Bound">i</a> <a id="4029" class="Symbol">=</a> <a id="4031" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="4033" class="Symbol">)</a> <a id="4035" class="Symbol">→</a> <a id="4037" href="1Lab.HLevel.html#3997" class="Bound">C</a> <a id="4039" class="Symbol">.</a><a data-type="(r : isContr A) (x : A) → r .centre ≡ x" id="4040" href="1Lab.HLevel.html#1415" class="Field">paths</a> <a id="4046" href="1Lab.HLevel.html#3999" class="Bound">x</a> <a id="4048" href="1Lab.HLevel.html#4018" class="Bound">j</a>
                 <a id="4067" class="Symbol">;</a> <a id="4069" class="Symbol">(</a><a id="4070" href="1Lab.HLevel.html#4003" class="Bound">i</a> <a id="4072" class="Symbol">=</a> <a id="4074" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="4076" class="Symbol">)</a> <a id="4078" class="Symbol">→</a> <a id="4080" href="1Lab.HLevel.html#3997" class="Bound">C</a> <a id="4082" class="Symbol">.</a><a data-type="(r : isContr A) (x : A) → r .centre ≡ x" id="4083" href="1Lab.HLevel.html#1415" class="Field">paths</a> <a id="4089" href="1Lab.HLevel.html#4001" class="Bound">y</a> <a id="4091" href="1Lab.HLevel.html#4018" class="Bound">j</a>
                 <a id="4110" class="Symbol">}</a> <a id="4112" class="Symbol">)</a>
        <a id="4122" class="Symbol">(</a><a id="4123" href="1Lab.HLevel.html#3997" class="Bound">C</a> <a id="4125" class="Symbol">.</a><a data-type="isContr A → A" id="4126" href="1Lab.HLevel.html#1400" class="Field">centre</a><a id="4132" class="Symbol">)</a>
</pre>
<!--
<pre class="Agda"><a id="SingletonP"></a><a id="4152" href="1Lab.HLevel.html#4152" class="Function">SingletonP</a> <a id="4163" class="Symbol">:</a> <a id="4165" class="Symbol">∀</a> <a id="4167" class="Symbol">{</a><a id="4168" href="1Lab.HLevel.html#4168" class="Bound">ℓ</a><a id="4169" class="Symbol">}</a> <a id="4171" class="Symbol">(</a><a id="4172" href="1Lab.HLevel.html#4172" class="Bound">A</a> <a id="4174" class="Symbol">:</a> <a id="4176" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="4178" class="Symbol">→</a> <a id="4180" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="4185" href="1Lab.HLevel.html#4168" class="Bound">ℓ</a><a id="4186" class="Symbol">)</a> <a id="4188" class="Symbol">(</a><a id="4189" href="1Lab.HLevel.html#4189" class="Bound">a</a> <a id="4191" class="Symbol">:</a> <a id="4193" href="1Lab.HLevel.html#4172" class="Bound">A</a> <a id="4195" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="4197" class="Symbol">)</a> <a id="4199" class="Symbol">→</a> <a id="4201" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="4206" class="Symbol">_</a>
<a id="4208" href="1Lab.HLevel.html#4152" class="Function">SingletonP</a> <a id="4219" href="1Lab.HLevel.html#4219" class="Bound">A</a> <a id="4221" href="1Lab.HLevel.html#4221" class="Bound">a</a> <a id="4223" class="Symbol">=</a> <a id="4225" href="1Lab.Type.html#1563" class="Function">Σ[</a> <a id="4228" href="1Lab.HLevel.html#4228" class="Bound">x</a> <a id="4230" href="1Lab.Type.html#1563" class="Function">∈</a> <a id="4232" href="1Lab.HLevel.html#4219" class="Bound">A</a> <a id="4234" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a> <a id="4237" href="1Lab.Type.html#1563" class="Function">]</a> <a id="4239" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="4245" href="1Lab.HLevel.html#4219" class="Bound">A</a> <a id="4247" href="1Lab.HLevel.html#4221" class="Bound">a</a> <a id="4249" href="1Lab.HLevel.html#4228" class="Bound">x</a>

<a id="isContrSinglP"></a><a id="4252" href="1Lab.HLevel.html#4252" class="Function">isContrSinglP</a> <a id="4266" class="Symbol">:</a> <a id="4268" class="Symbol">∀</a> <a id="4270" class="Symbol">{</a><a id="4271" href="1Lab.HLevel.html#4271" class="Bound">ℓ</a><a id="4272" class="Symbol">}</a> <a id="4274" class="Symbol">(</a><a id="4275" href="1Lab.HLevel.html#4275" class="Bound">A</a> <a id="4277" class="Symbol">:</a> <a id="4279" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="4281" class="Symbol">→</a> <a id="4283" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="4288" href="1Lab.HLevel.html#4271" class="Bound">ℓ</a><a id="4289" class="Symbol">)</a> <a id="4291" class="Symbol">(</a><a id="4292" href="1Lab.HLevel.html#4292" class="Bound">a</a> <a id="4294" class="Symbol">:</a> <a id="4296" href="1Lab.HLevel.html#4275" class="Bound">A</a> <a id="4298" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="4300" class="Symbol">)</a> <a id="4302" class="Symbol">→</a> <a id="4304" href="1Lab.HLevel.html#1328" class="Record">isContr</a> <a id="4312" class="Symbol">(</a><a id="4313" href="1Lab.HLevel.html#4152" class="Function">SingletonP</a> <a id="4324" href="1Lab.HLevel.html#4275" class="Bound">A</a> <a id="4326" href="1Lab.HLevel.html#4292" class="Bound">a</a><a id="4327" class="Symbol">)</a>
<a id="4329" href="1Lab.HLevel.html#4252" class="Function">isContrSinglP</a> <a id="4343" href="1Lab.HLevel.html#4343" class="Bound">A</a> <a id="4345" href="1Lab.HLevel.html#4345" class="Bound">a</a> <a id="4347" class="Symbol">.</a><a id="4348" href="1Lab.HLevel.html#1400" class="Field">centre</a> <a id="4355" class="Symbol">=</a> <a id="4357" class="Symbol">_</a> <a id="4359" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4361" href="1Lab.Path.html#14075" class="Function">transport-filler</a> <a id="4378" class="Symbol">(λ</a> <a id="4381" href="1Lab.HLevel.html#4381" class="Bound">i</a> <a id="4383" class="Symbol">→</a> <a id="4385" href="1Lab.HLevel.html#4343" class="Bound">A</a> <a id="4387" href="1Lab.HLevel.html#4381" class="Bound">i</a><a id="4388" class="Symbol">)</a> <a id="4390" href="1Lab.HLevel.html#4345" class="Bound">a</a>
<a id="4392" href="1Lab.HLevel.html#4252" class="Function">isContrSinglP</a> <a id="4406" href="1Lab.HLevel.html#4406" class="Bound">A</a> <a id="4408" href="1Lab.HLevel.html#4408" class="Bound">a</a> <a id="4410" class="Symbol">.</a><a id="4411" href="1Lab.HLevel.html#1415" class="Field">paths</a> <a id="4417" class="Symbol">(</a><a id="4418" href="1Lab.HLevel.html#4418" class="Bound">x</a> <a id="4420" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4422" href="1Lab.HLevel.html#4422" class="Bound">p</a><a id="4423" class="Symbol">)</a> <a id="4425" href="1Lab.HLevel.html#4425" class="Bound">i</a> <a id="4427" class="Symbol">=</a>
  <a id="4431" class="Symbol">_</a> <a id="4433" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4435" class="Symbol">λ</a> <a id="4437" href="1Lab.HLevel.html#4437" class="Bound">j</a> <a id="4439" class="Symbol">→</a> <a id="4441" href="1Lab.Path.html#37643" class="Function">fill</a> <a id="4446" href="1Lab.HLevel.html#4406" class="Bound">A</a> <a id="4448" class="Symbol">(λ</a> <a id="4451" href="1Lab.HLevel.html#4451" class="Bound">j</a> <a id="4453" class="Symbol">→</a> <a id="4455" class="Symbol">λ</a> <a id="4457" class="Symbol">{(</a><a id="4459" href="1Lab.HLevel.html#4425" class="Bound">i</a> <a id="4461" class="Symbol">=</a> <a id="4463" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="4465" class="Symbol">)</a> <a id="4467" class="Symbol">→</a> <a id="4469" href="1Lab.Path.html#14075" class="Function">transport-filler</a> <a id="4486" class="Symbol">(λ</a> <a id="4489" href="1Lab.HLevel.html#4489" class="Bound">i</a> <a id="4491" class="Symbol">→</a> <a id="4493" href="1Lab.HLevel.html#4406" class="Bound">A</a> <a id="4495" href="1Lab.HLevel.html#4489" class="Bound">i</a><a id="4496" class="Symbol">)</a> <a id="4498" href="1Lab.HLevel.html#4408" class="Bound">a</a> <a id="4500" href="1Lab.HLevel.html#4451" class="Bound">j</a><a id="4501" class="Symbol">;</a> <a id="4503" class="Symbol">(</a><a id="4504" href="1Lab.HLevel.html#4425" class="Bound">i</a> <a id="4506" class="Symbol">=</a> <a id="4508" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="4510" class="Symbol">)</a> <a id="4512" class="Symbol">→</a> <a id="4514" href="1Lab.HLevel.html#4422" class="Bound">p</a> <a id="4516" href="1Lab.HLevel.html#4451" class="Bound">j</a><a id="4517" class="Symbol">})</a> <a id="4520" class="Symbol">(</a><a id="4521" href="1Lab.Path.html#2069" class="Postulate">inS</a> <a id="4525" href="1Lab.HLevel.html#4408" class="Bound">a</a><a id="4526" class="Symbol">)</a> <a id="4528" href="1Lab.HLevel.html#4437" class="Bound">j</a>

<a id="isPropSinglP"></a><a id="4531" href="1Lab.HLevel.html#4531" class="Function">isPropSinglP</a> <a id="4544" class="Symbol">:</a> <a id="4546" class="Symbol">∀</a> <a id="4548" class="Symbol">{</a><a id="4549" href="1Lab.HLevel.html#4549" class="Bound">ℓ</a><a id="4550" class="Symbol">}</a> <a id="4552" class="Symbol">{</a><a id="4553" href="1Lab.HLevel.html#4553" class="Bound">A</a> <a id="4555" class="Symbol">:</a> <a id="4557" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="4559" class="Symbol">→</a> <a id="4561" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="4566" href="1Lab.HLevel.html#4549" class="Bound">ℓ</a><a id="4567" class="Symbol">}</a> <a id="4569" class="Symbol">{</a><a id="4570" href="1Lab.HLevel.html#4570" class="Bound">a</a> <a id="4572" class="Symbol">:</a> <a id="4574" href="1Lab.HLevel.html#4553" class="Bound">A</a> <a id="4576" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="4578" class="Symbol">}</a> <a id="4580" class="Symbol">→</a> <a id="4582" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="4589" class="Symbol">(</a><a id="4590" href="1Lab.HLevel.html#4152" class="Function">SingletonP</a> <a id="4601" href="1Lab.HLevel.html#4553" class="Bound">A</a> <a id="4603" href="1Lab.HLevel.html#4570" class="Bound">a</a><a id="4604" class="Symbol">)</a>
<a id="4606" href="1Lab.HLevel.html#4531" class="Function">isPropSinglP</a> <a id="4619" class="Symbol">=</a> <a id="4621" href="1Lab.HLevel.html#3944" class="Function">isContr→isProp</a> <a id="4636" class="Symbol">(</a><a id="4637" href="1Lab.HLevel.html#4252" class="Function">isContrSinglP</a> <a id="4651" class="Symbol">_</a> <a id="4653" class="Symbol">_)</a>
</pre>-->
<p>This enables another useful characterisation of being a proposition, which is that the propositions are precisely the types which are contractible when they are inhabited:</p>
<pre class="Agda"><a id="inhContr→isProp"></a><a data-type="(A → isContr A) → isProp A" id="4846" href="1Lab.HLevel.html#4846" class="Function">inhContr→isProp</a> <a id="4862" class="Symbol">:</a> <a id="4864" class="Symbol">∀</a> <a id="4866" class="Symbol">{</a><a id="4867" href="1Lab.HLevel.html#4867" class="Bound">ℓ</a><a id="4868" class="Symbol">}</a> <a id="4870" class="Symbol">{</a><a id="4871" href="1Lab.HLevel.html#4871" class="Bound">A</a> <a id="4873" class="Symbol">:</a> <a id="4875" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="4880" href="1Lab.HLevel.html#4867" class="Bound">ℓ</a><a id="4881" class="Symbol">}</a> <a id="4883" class="Symbol">→</a> <a id="4885" class="Symbol">(</a><a id="4886" href="1Lab.HLevel.html#4871" class="Bound">A</a> <a id="4888" class="Symbol">→</a> <a data-type="(A : Type ℓ) → Type ℓ" id="4890" href="1Lab.HLevel.html#1328" class="Record">isContr</a> <a id="4898" href="1Lab.HLevel.html#4871" class="Bound">A</a><a id="4899" class="Symbol">)</a> <a id="4901" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="4903" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="4910" href="1Lab.HLevel.html#4871" class="Bound">A</a>
<a data-type="(A → isContr A) → isProp A" id="4912" href="1Lab.HLevel.html#4846" class="Function">inhContr→isProp</a> <a id="4928" href="1Lab.HLevel.html#4928" class="Bound">cont</a> <a id="4933" href="1Lab.HLevel.html#4933" class="Bound">x</a> <a id="4935" href="1Lab.HLevel.html#4935" class="Bound">y</a> <a id="4937" class="Symbol">=</a> <a data-type="isContr A → isProp A" id="4939" href="1Lab.HLevel.html#3944" class="Function">isContr→isProp</a> <a id="4954" class="Symbol">(</a><a id="4955" href="1Lab.HLevel.html#4928" class="Bound">cont</a> <a id="4960" href="1Lab.HLevel.html#4933" class="Bound">x</a><a id="4961" class="Symbol">)</a> <a id="4963" href="1Lab.HLevel.html#4933" class="Bound">x</a> <a id="4965" href="1Lab.HLevel.html#4935" class="Bound">y</a>
</pre>
<p>The proof that any contractible type is a proposition is not too complicated. We can get a line connecting any two elements as the lid of the square below:</p>
<div class="diagram-container">
<img src="1b14d7db6144684b319b6433af6df217d07cea87.svg" title="commutative diagram" class="diagram quiver"></img>
</div>
<p>This is equivalently the composition of <code>sym (C .paths x) ∙ C.paths y</code> - a path <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \to y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> which factors through the <span class="Agda"><a data-type="isContr A → A" href="1Lab.HLevel.html#1400" class="Field">centre</a></span>. The direct cubical description is, however, slightly more efficient.</p>
<pre class="Agda"><a id="isProp→isSet"></a><a data-type="isProp A → isSet A" id="5654" href="1Lab.HLevel.html#5654" class="Function">isProp→isSet</a> <a id="5667" class="Symbol">:</a> <a data-type="Type ℓ → Type ℓ" id="5669" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="5676" href="1Lab.HLevel.html#3737" class="Generalizable">A</a> <a id="5678" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="5680" href="1Lab.HLevel.html#3342" class="Function">isSet</a> <a id="5686" href="1Lab.HLevel.html#3737" class="Generalizable">A</a>
<a data-type="isProp A → isSet A" id="5688" href="1Lab.HLevel.html#5654" class="Function">isProp→isSet</a> <a id="5701" href="1Lab.HLevel.html#5701" class="Bound">h</a> <a id="5703" href="1Lab.HLevel.html#5703" class="Bound">x</a> <a id="5705" href="1Lab.HLevel.html#5705" class="Bound">y</a> <a id="5707" href="1Lab.HLevel.html#5707" class="Bound">p</a> <a id="5709" href="1Lab.HLevel.html#5709" class="Bound">q</a> <a id="5711" href="1Lab.HLevel.html#5711" class="Bound">i</a> <a id="5713" href="1Lab.HLevel.html#5713" class="Bound">j</a> <a id="5715" class="Symbol">=</a>
  <a id="5719" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="5725" class="Symbol">(λ</a> <a id="5728" href="1Lab.HLevel.html#5728" class="Bound">k</a> <a id="5730" class="Symbol">→</a> <a id="5732" class="Symbol">λ</a> <a id="5734" class="Symbol">{</a> <a id="5736" class="Symbol">(</a><a id="5737" href="1Lab.HLevel.html#5711" class="Bound">i</a> <a id="5739" class="Symbol">=</a> <a id="5741" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="5743" class="Symbol">)</a> <a id="5745" class="Symbol">→</a> <a id="5747" href="1Lab.HLevel.html#5701" class="Bound">h</a> <a id="5749" href="1Lab.HLevel.html#5703" class="Bound">x</a> <a id="5751" class="Symbol">(</a><a id="5752" href="1Lab.HLevel.html#5707" class="Bound">p</a> <a id="5754" href="1Lab.HLevel.html#5713" class="Bound">j</a><a id="5755" class="Symbol">)</a> <a id="5757" href="1Lab.HLevel.html#5728" class="Bound">k</a>
                 <a id="5776" class="Symbol">;</a> <a id="5778" class="Symbol">(</a><a id="5779" href="1Lab.HLevel.html#5711" class="Bound">i</a> <a id="5781" class="Symbol">=</a> <a id="5783" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="5785" class="Symbol">)</a> <a id="5787" class="Symbol">→</a> <a id="5789" href="1Lab.HLevel.html#5701" class="Bound">h</a> <a id="5791" href="1Lab.HLevel.html#5703" class="Bound">x</a> <a id="5793" class="Symbol">(</a><a id="5794" href="1Lab.HLevel.html#5709" class="Bound">q</a> <a id="5796" href="1Lab.HLevel.html#5713" class="Bound">j</a><a id="5797" class="Symbol">)</a> <a id="5799" href="1Lab.HLevel.html#5728" class="Bound">k</a>
                 <a id="5818" class="Symbol">;</a> <a id="5820" class="Symbol">(</a><a id="5821" href="1Lab.HLevel.html#5713" class="Bound">j</a> <a id="5823" class="Symbol">=</a> <a id="5825" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="5827" class="Symbol">)</a> <a id="5829" class="Symbol">→</a> <a id="5831" href="1Lab.HLevel.html#5701" class="Bound">h</a> <a id="5833" href="1Lab.HLevel.html#5703" class="Bound">x</a> <a id="5835" href="1Lab.HLevel.html#5703" class="Bound">x</a> <a id="5837" href="1Lab.HLevel.html#5728" class="Bound">k</a>
                 <a id="5856" class="Symbol">;</a> <a id="5858" class="Symbol">(</a><a id="5859" href="1Lab.HLevel.html#5713" class="Bound">j</a> <a id="5861" class="Symbol">=</a> <a id="5863" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="5865" class="Symbol">)</a> <a id="5867" class="Symbol">→</a> <a id="5869" href="1Lab.HLevel.html#5701" class="Bound">h</a> <a id="5871" href="1Lab.HLevel.html#5703" class="Bound">x</a> <a id="5873" href="1Lab.HLevel.html#5705" class="Bound">y</a> <a id="5875" href="1Lab.HLevel.html#5728" class="Bound">k</a>
                 <a id="5894" class="Symbol">})</a>
        <a id="5905" href="1Lab.HLevel.html#5703" class="Bound">x</a>
</pre>
<p>The proof that any proposition is a set is slightly more complicated. Since the desired homotopy <code>p ≡ q</code> is a square, we need to describe a <em>cube</em> where the missing face is the square we need. I have painstakingly illustrated it here:</p>
<div class="diagram-container">
<img src="3d2706f7aabb81b12af4515c5bc8e759b537a27a.svg" title="commutative diagram" class="diagram quiver tall-2"></img>
</div>
<p>To set your perspective: You are looking at a cube that has a transparent front face. The front face has four <code>x</code> corners, and four <code>λ i → x</code> edges. Each double arrow pointing from the front face to the back face is one of the sides of the composition. They’re labelled with the terms in the <span class="Agda"><a href="1Lab.Path.html#2368" class="Primitive">hcomp</a></span> for <span class="Agda"><a data-type="isProp A → isSet A" href="1Lab.HLevel.html#5654" class="Function">isProp→isSet</a></span>: For example, the square you get when fixing <code>i = i0</code> is on top of the diagram. Since we have an open box, it has a lid — which, in this case, is the back face — which expresses the identification we wanted: <code>p ≡ q</code>.</p>
<p>With these two base cases, we can prove the general case by recursion:</p>
<pre class="Agda"><a id="isHLevel-suc"></a><a data-type="(n : Nat) → isHLevel A n → isHLevel A (suc n)" id="8658" href="1Lab.HLevel.html#8658" class="Function">isHLevel-suc</a> <a id="8671" class="Symbol">:</a> <a id="8673" class="Symbol">∀</a> <a id="8675" class="Symbol">{</a><a id="8676" href="1Lab.HLevel.html#8676" class="Bound">ℓ</a><a id="8677" class="Symbol">}</a> <a id="8679" class="Symbol">{</a><a id="8680" href="1Lab.HLevel.html#8680" class="Bound">A</a> <a id="8682" class="Symbol">:</a> <a id="8684" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="8689" href="1Lab.HLevel.html#8676" class="Bound">ℓ</a><a id="8690" class="Symbol">}</a> <a id="8692" class="Symbol">(</a><a id="8693" href="1Lab.HLevel.html#8693" class="Bound">n</a> <a id="8695" class="Symbol">:</a> <a data-type="Type" id="8697" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a><a id="8700" class="Symbol">)</a> <a id="8702" class="Symbol">→</a> <a data-type="Type ℓ → Nat → Type ℓ" id="8704" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a> <a id="8713" href="1Lab.HLevel.html#8680" class="Bound">A</a> <a id="8715" href="1Lab.HLevel.html#8693" class="Bound">n</a> <a id="8717" class="Symbol">→</a> <a data-type="Type ℓ → Nat → Type ℓ" id="8719" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a> <a id="8728" href="1Lab.HLevel.html#8680" class="Bound">A</a> <a id="8730" class="Symbol">(</a><a data-type="Nat → Nat" id="8731" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="8735" href="1Lab.HLevel.html#8693" class="Bound">n</a><a id="8736" class="Symbol">)</a>
<a data-type="(n : Nat) → isHLevel A n → isHLevel A (suc n)" id="8738" href="1Lab.HLevel.html#8658" class="Function">isHLevel-suc</a> <a id="8751" class="Number">0</a> <a id="8753" href="1Lab.HLevel.html#8753" class="Bound">x</a> <a id="8755" class="Symbol">=</a> <a data-type="isContr A → isProp A" id="8757" href="1Lab.HLevel.html#3944" class="Function">isContr→isProp</a> <a id="8772" href="1Lab.HLevel.html#8753" class="Bound">x</a>
<a data-type="(n : Nat) → isHLevel A n → isHLevel A (suc n)" id="8774" href="1Lab.HLevel.html#8658" class="Function">isHLevel-suc</a> <a id="8787" class="Number">1</a> <a id="8789" href="1Lab.HLevel.html#8789" class="Bound">x</a> <a id="8791" class="Symbol">=</a> <a data-type="isProp A → isSet A" id="8793" href="1Lab.HLevel.html#5654" class="Function">isProp→isSet</a> <a id="8806" href="1Lab.HLevel.html#8789" class="Bound">x</a>
<a data-type="(n : Nat) → isHLevel A n → isHLevel A (suc n)" id="8808" href="1Lab.HLevel.html#8658" class="Function">isHLevel-suc</a> <a id="8821" class="Symbol">(</a><a data-type="Nat → Nat" id="8822" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="8826" class="Symbol">(</a><a data-type="Nat → Nat" id="8827" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="8831" href="1Lab.HLevel.html#8831" class="Bound">n</a><a id="8832" class="Symbol">))</a> <a id="8835" href="1Lab.HLevel.html#8835" class="Bound">h</a> <a id="8837" href="1Lab.HLevel.html#8837" class="Bound">x</a> <a id="8839" href="1Lab.HLevel.html#8839" class="Bound">y</a> <a id="8841" class="Symbol">=</a> <a data-type="(n : Nat) → isHLevel A n → isHLevel A (suc n)" id="8843" href="1Lab.HLevel.html#8658" class="Function">isHLevel-suc</a> <a id="8856" class="Symbol">(</a><a data-type="Nat → Nat" id="8857" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="8861" href="1Lab.HLevel.html#8831" class="Bound">n</a><a id="8862" class="Symbol">)</a> <a id="8864" class="Symbol">(</a><a id="8865" href="1Lab.HLevel.html#8835" class="Bound">h</a> <a id="8867" href="1Lab.HLevel.html#8837" class="Bound">x</a> <a id="8869" href="1Lab.HLevel.html#8839" class="Bound">y</a><a id="8870" class="Symbol">)</a>
</pre>
<p>By another inductive argument, we can prove that any offset works:</p>
<pre class="Agda"><a id="isHLevel-+"></a><a data-type="(n k : Nat) → isHLevel A n → isHLevel A (k + n)" id="8953" href="1Lab.HLevel.html#8953" class="Function">isHLevel-+</a> <a id="8964" class="Symbol">:</a> <a id="8966" class="Symbol">∀</a> <a id="8968" class="Symbol">{</a><a id="8969" href="1Lab.HLevel.html#8969" class="Bound">ℓ</a><a id="8970" class="Symbol">}</a> <a id="8972" class="Symbol">{</a><a id="8973" href="1Lab.HLevel.html#8973" class="Bound">A</a> <a id="8975" class="Symbol">:</a> <a id="8977" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="8982" href="1Lab.HLevel.html#8969" class="Bound">ℓ</a><a id="8983" class="Symbol">}</a> <a id="8985" class="Symbol">(</a><a id="8986" href="1Lab.HLevel.html#8986" class="Bound">n</a> <a id="8988" href="1Lab.HLevel.html#8988" class="Bound">k</a> <a id="8990" class="Symbol">:</a> <a data-type="Type" id="8992" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a><a id="8995" class="Symbol">)</a> <a id="8997" class="Symbol">→</a> <a data-type="Type ℓ → Nat → Type ℓ" id="8999" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a> <a id="9008" href="1Lab.HLevel.html#8973" class="Bound">A</a> <a id="9010" href="1Lab.HLevel.html#8986" class="Bound">n</a> <a id="9012" class="Symbol">→</a> <a data-type="Type ℓ → Nat → Type ℓ" id="9014" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a> <a id="9023" href="1Lab.HLevel.html#8973" class="Bound">A</a> <a id="9025" class="Symbol">(</a><a id="9026" href="1Lab.HLevel.html#8988" class="Bound">k</a> <a data-type="Nat → Nat → Nat" id="9028" href="Agda.Builtin.Nat.html#325" class="Primitive Operator">+</a> <a id="9030" href="1Lab.HLevel.html#8986" class="Bound">n</a><a id="9031" class="Symbol">)</a>
<a data-type="(n k : Nat) → isHLevel A n → isHLevel A (k + n)" id="9033" href="1Lab.HLevel.html#8953" class="Function">isHLevel-+</a> <a id="9044" href="1Lab.HLevel.html#9044" class="Bound">n</a> <a data-type="Nat" id="9046" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="9051" href="1Lab.HLevel.html#9051" class="Bound">x</a>    <a id="9056" class="Symbol">=</a> <a id="9058" href="1Lab.HLevel.html#9051" class="Bound">x</a>
<a data-type="(n k : Nat) → isHLevel A n → isHLevel A (k + n)" id="9060" href="1Lab.HLevel.html#8953" class="Function">isHLevel-+</a> <a id="9071" href="1Lab.HLevel.html#9071" class="Bound">n</a> <a id="9073" class="Symbol">(</a><a data-type="Nat → Nat" id="9074" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="9078" href="1Lab.HLevel.html#9078" class="Bound">k</a><a id="9079" class="Symbol">)</a> <a id="9081" href="1Lab.HLevel.html#9081" class="Bound">x</a> <a id="9083" class="Symbol">=</a> <a data-type="(n : Nat) → isHLevel A n → isHLevel A (suc n)" id="9085" href="1Lab.HLevel.html#8658" class="Function">isHLevel-suc</a> <a id="9098" class="Symbol">_</a> <a id="9100" class="Symbol">(</a><a data-type="(n k : Nat) → isHLevel A n → isHLevel A (k + n)" id="9101" href="1Lab.HLevel.html#8953" class="Function">isHLevel-+</a> <a id="9112" href="1Lab.HLevel.html#9071" class="Bound">n</a> <a id="9114" href="1Lab.HLevel.html#9078" class="Bound">k</a> <a id="9116" href="1Lab.HLevel.html#9081" class="Bound">x</a><a id="9117" class="Symbol">)</a>
</pre>
<p>A very convenient specialisation of the argument above is that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> is a proposition, then it has any non-zero h-level:</p>
<pre class="Agda"><a id="isProp→isHLevel-suc"></a><a data-type="isProp A → isHLevel A (suc n)" id="9255" href="1Lab.HLevel.html#9255" class="Function">isProp→isHLevel-suc</a> <a id="9275" class="Symbol">:</a> <a id="9277" class="Symbol">∀</a> <a id="9279" class="Symbol">{</a><a id="9280" href="1Lab.HLevel.html#9280" class="Bound">ℓ</a><a id="9281" class="Symbol">}</a> <a id="9283" class="Symbol">{</a><a id="9284" href="1Lab.HLevel.html#9284" class="Bound">A</a> <a id="9286" class="Symbol">:</a> <a id="9288" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="9293" href="1Lab.HLevel.html#9280" class="Bound">ℓ</a><a id="9294" class="Symbol">}</a> <a id="9296" class="Symbol">{</a><a id="9297" href="1Lab.HLevel.html#9297" class="Bound">n</a> <a id="9299" class="Symbol">:</a> <a data-type="Type" id="9301" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a><a id="9304" class="Symbol">}</a> <a id="9306" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="9308" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="9315" href="1Lab.HLevel.html#9284" class="Bound">A</a> <a id="9317" class="Symbol">→</a> <a data-type="Type ℓ → Nat → Type ℓ" id="9319" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a> <a id="9328" href="1Lab.HLevel.html#9284" class="Bound">A</a> <a id="9330" class="Symbol">(</a><a data-type="Nat → Nat" id="9331" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="9335" href="1Lab.HLevel.html#9297" class="Bound">n</a><a id="9336" class="Symbol">)</a>
<a data-type="isProp A → isHLevel A (suc n)" id="9338" href="1Lab.HLevel.html#9255" class="Function">isProp→isHLevel-suc</a> <a id="9358" class="Symbol">{</a><a id="9359" class="Argument">n</a> <a id="9361" class="Symbol">=</a> <a data-type="Nat" id="9363" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="9367" class="Symbol">}</a> <a id="9369" href="1Lab.HLevel.html#9369" class="Bound">aprop</a> <a id="9375" class="Symbol">=</a> <a id="9377" href="1Lab.HLevel.html#9369" class="Bound">aprop</a>
<a data-type="isProp A → isHLevel A (suc n)" id="9383" href="1Lab.HLevel.html#9255" class="Function">isProp→isHLevel-suc</a> <a id="9403" class="Symbol">{</a><a id="9404" class="Argument">n</a> <a id="9406" class="Symbol">=</a> <a data-type="Nat → Nat" id="9408" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="9412" href="1Lab.HLevel.html#9412" class="Bound">n</a><a id="9413" class="Symbol">}</a> <a id="9415" href="1Lab.HLevel.html#9415" class="Bound">aprop</a> <a id="9421" class="Symbol">=</a>
  <a data-type="(n : Nat) → isHLevel A n → isHLevel A (suc n)" id="9425" href="1Lab.HLevel.html#8658" class="Function">isHLevel-suc</a> <a id="9438" class="Symbol">(</a><a data-type="Nat → Nat" id="9439" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="9443" href="1Lab.HLevel.html#9412" class="Bound">n</a><a id="9444" class="Symbol">)</a> <a id="9446" class="Symbol">(</a><a data-type="isProp A → isHLevel A (suc n)" id="9447" href="1Lab.HLevel.html#9255" class="Function">isProp→isHLevel-suc</a> <a id="9467" href="1Lab.HLevel.html#9415" class="Bound">aprop</a><a id="9472" class="Symbol">)</a>
</pre>
<p>Furthermore, by the upwards closure of h-levels, we have that if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> is an n-type, then paths in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> are also <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-types.</span> This is because, by definition, the paths in a <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-type</span> are “<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>-types</span>”, which <span class="Agda"><a data-type="(n : Nat) → isHLevel A n → isHLevel A (suc n)" href="1Lab.HLevel.html#8658" class="Function">isHLevel-suc</a></span> extends into <span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>-types.</span></p>
<pre class="Agda"><a id="isHLevelPath"></a><a data-type="(n : Nat) → isHLevel A n → isHLevel (x ≡ y) n" id="9738" href="1Lab.HLevel.html#9738" class="Function">isHLevelPath</a> <a id="9751" class="Symbol">:</a> <a id="9753" class="Symbol">∀</a> <a id="9755" class="Symbol">{</a><a id="9756" href="1Lab.HLevel.html#9756" class="Bound">ℓ</a><a id="9757" class="Symbol">}</a> <a id="9759" class="Symbol">{</a><a id="9760" href="1Lab.HLevel.html#9760" class="Bound">A</a> <a id="9762" class="Symbol">:</a> <a id="9764" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="9769" href="1Lab.HLevel.html#9756" class="Bound">ℓ</a><a id="9770" class="Symbol">}</a> <a id="9772" class="Symbol">(</a><a id="9773" href="1Lab.HLevel.html#9773" class="Bound">n</a> <a id="9775" class="Symbol">:</a> <a data-type="Type" id="9777" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a><a id="9780" class="Symbol">)</a> <a id="9782" class="Symbol">→</a> <a data-type="Type ℓ → Nat → Type ℓ" id="9784" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a> <a id="9793" href="1Lab.HLevel.html#9760" class="Bound">A</a> <a id="9795" href="1Lab.HLevel.html#9773" class="Bound">n</a> <a id="9797" class="Symbol">→</a> <a id="9799" class="Symbol">{</a><a id="9800" href="1Lab.HLevel.html#9800" class="Bound">x</a> <a id="9802" href="1Lab.HLevel.html#9802" class="Bound">y</a> <a id="9804" class="Symbol">:</a> <a id="9806" href="1Lab.HLevel.html#9760" class="Bound">A</a><a id="9807" class="Symbol">}</a>
             <a id="9822" class="Symbol">→</a> <a data-type="Type ℓ → Nat → Type ℓ" id="9824" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a> <a id="9833" class="Symbol">(</a><a id="9834" href="1Lab.HLevel.html#9800" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="9836" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="9838" href="1Lab.HLevel.html#9802" class="Bound">y</a><a id="9839" class="Symbol">)</a> <a id="9841" href="1Lab.HLevel.html#9773" class="Bound">n</a>
<a data-type="(n : Nat) → isHLevel A n → isHLevel (x ≡ y) n" id="9843" href="1Lab.HLevel.html#9738" class="Function">isHLevelPath</a> <a data-type="Nat" id="9856" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="9861" href="1Lab.HLevel.html#9861" class="Bound">ahl</a> <a id="9865" class="Symbol">=</a>
  <a data-type="(centre₁ : A) (paths₁ : (x : A) → centre₁ ≡ x) → isContr A" id="9869" href="1Lab.HLevel.html#1382" class="InductiveConstructor">contr</a> <a id="9875" class="Symbol">(</a><a data-type="isContr A → isProp A" id="9876" href="1Lab.HLevel.html#3944" class="Function">isContr→isProp</a> <a id="9891" href="1Lab.HLevel.html#9861" class="Bound">ahl</a> <a id="9895" class="Symbol">_</a> <a id="9897" class="Symbol">_)</a>
        <a id="9908" class="Symbol">λ</a> <a id="9910" href="1Lab.HLevel.html#9910" class="Bound">x</a> <a id="9912" class="Symbol">→</a> <a data-type="isProp A → isSet A" id="9914" href="1Lab.HLevel.html#5654" class="Function">isProp→isSet</a> <a id="9927" class="Symbol">(</a><a data-type="isContr A → isProp A" id="9928" href="1Lab.HLevel.html#3944" class="Function">isContr→isProp</a> <a id="9943" href="1Lab.HLevel.html#9861" class="Bound">ahl</a><a id="9946" class="Symbol">)</a> <a id="9948" class="Symbol">_</a> <a id="9950" class="Symbol">_</a> <a id="9952" class="Symbol">_</a> <a id="9954" href="1Lab.HLevel.html#9910" class="Bound">x</a>
<a data-type="(n : Nat) → isHLevel A n → isHLevel (x ≡ y) n" id="9956" href="1Lab.HLevel.html#9738" class="Function">isHLevelPath</a> <a id="9969" class="Symbol">(</a><a data-type="Nat → Nat" id="9970" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="9974" href="1Lab.HLevel.html#9974" class="Bound">n</a><a id="9975" class="Symbol">)</a> <a id="9977" href="1Lab.HLevel.html#9977" class="Bound">ahl</a> <a id="9981" class="Symbol">=</a> <a data-type="(n : Nat) → isHLevel A n → isHLevel A (suc n)" id="9983" href="1Lab.HLevel.html#8658" class="Function">isHLevel-suc</a> <a id="9996" class="Symbol">(</a><a data-type="Nat → Nat" id="9997" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="10001" href="1Lab.HLevel.html#9974" class="Bound">n</a><a id="10002" class="Symbol">)</a> <a id="10004" href="1Lab.HLevel.html#9977" class="Bound">ahl</a> <a id="10008" class="Symbol">_</a> <a id="10010" class="Symbol">_</a>

<a id="isHLevelPathP"></a><a data-type="(n : Nat) → isHLevel (A i1) n → isHLevel (PathP A x y) n" id="10013" href="1Lab.HLevel.html#10013" class="Function">isHLevelPathP</a> <a id="10027" class="Symbol">:</a> <a id="10029" class="Symbol">∀</a> <a id="10031" class="Symbol">{</a><a id="10032" href="1Lab.HLevel.html#10032" class="Bound">ℓ</a><a id="10033" class="Symbol">}</a> <a id="10035" class="Symbol">{</a><a id="10036" href="1Lab.HLevel.html#10036" class="Bound">A</a> <a id="10038" class="Symbol">:</a> <a id="10040" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="10042" class="Symbol">→</a> <a id="10044" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="10049" href="1Lab.HLevel.html#10032" class="Bound">ℓ</a><a id="10050" class="Symbol">}</a> <a id="10052" class="Symbol">(</a><a id="10053" href="1Lab.HLevel.html#10053" class="Bound">n</a> <a id="10055" class="Symbol">:</a> <a data-type="Type" id="10057" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a><a id="10060" class="Symbol">)</a>
              <a id="10076" class="Symbol">→</a> <a data-type="Type ℓ → Nat → Type ℓ" id="10078" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a> <a id="10087" class="Symbol">(</a><a id="10088" href="1Lab.HLevel.html#10036" class="Bound">A</a> <a id="10090" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="10092" class="Symbol">)</a> <a id="10094" href="1Lab.HLevel.html#10053" class="Bound">n</a>
              <a id="10110" class="Symbol">→</a> <a id="10112" class="Symbol">{</a><a id="10113" href="1Lab.HLevel.html#10113" class="Bound">x</a> <a id="10115" class="Symbol">:</a> <a id="10117" href="1Lab.HLevel.html#10036" class="Bound">A</a> <a id="10119" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="10121" class="Symbol">}</a> <a id="10123" class="Symbol">{</a><a id="10124" href="1Lab.HLevel.html#10124" class="Bound">y</a> <a id="10126" class="Symbol">:</a> <a id="10128" href="1Lab.HLevel.html#10036" class="Bound">A</a> <a id="10130" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="10132" class="Symbol">}</a>
              <a id="10148" class="Symbol">→</a> <a data-type="Type ℓ → Nat → Type ℓ" id="10150" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a> <a id="10159" class="Symbol">(</a><a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="10160" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="10166" href="1Lab.HLevel.html#10036" class="Bound">A</a> <a id="10168" href="1Lab.HLevel.html#10113" class="Bound">x</a> <a id="10170" href="1Lab.HLevel.html#10124" class="Bound">y</a><a id="10171" class="Symbol">)</a> <a id="10173" href="1Lab.HLevel.html#10053" class="Bound">n</a>
<a data-type="(n : Nat) → isHLevel (A i1) n → isHLevel (PathP A x y) n" id="10175" href="1Lab.HLevel.html#10013" class="Function">isHLevelPathP</a> <a id="10189" class="Symbol">{</a><a id="10190" class="Argument">A</a> <a id="10192" class="Symbol">=</a> <a id="10194" href="1Lab.HLevel.html#10194" class="Bound">A</a><a id="10195" class="Symbol">}</a> <a id="10197" href="1Lab.HLevel.html#10197" class="Bound">n</a> <a id="10199" href="1Lab.HLevel.html#10199" class="Bound">ahl</a> <a id="10203" class="Symbol">{</a><a id="10204" href="1Lab.HLevel.html#10204" class="Bound">x</a><a id="10205" class="Symbol">}</a> <a id="10207" class="Symbol">{</a><a id="10208" href="1Lab.HLevel.html#10208" class="Bound">y</a><a id="10209" class="Symbol">}</a> <a id="10211" class="Symbol">=</a>
  <a data-type="(P : A → Type ℓ₂) → x ≡ y → P x → P y" id="10215" href="1Lab.Path.html#15372" class="Function">subst</a> <a id="10221" class="Symbol">(λ</a> <a id="10224" href="1Lab.HLevel.html#10224" class="Bound">e</a> <a id="10226" class="Symbol">→</a> <a data-type="Type ℓ → Nat → Type ℓ" id="10228" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a> <a id="10237" href="1Lab.HLevel.html#10224" class="Bound">e</a> <a id="10239" href="1Lab.HLevel.html#10197" class="Bound">n</a><a id="10240" class="Symbol">)</a>
        <a id="10250" class="Symbol">(</a><a data-type="x ≡ y → y ≡ x" id="10251" href="1Lab.Path.html#10628" class="Function">sym</a> <a id="10255" class="Symbol">(</a><a data-type="(P : I → Type ℓ) (p : P i0) (q : P i1) →
PathP P p q ≡ Path (P i1) (transport P p) q" id="10256" href="1Lab.Path.html#49329" class="Function">PathP≡Path</a> <a id="10267" href="1Lab.HLevel.html#10194" class="Bound">A</a> <a id="10269" href="1Lab.HLevel.html#10204" class="Bound">x</a> <a id="10271" href="1Lab.HLevel.html#10208" class="Bound">y</a><a id="10272" class="Symbol">))</a>
        <a id="10283" class="Symbol">(</a><a data-type="(n : Nat) → isHLevel A n → isHLevel (x ≡ y) n" id="10284" href="1Lab.HLevel.html#9738" class="Function">isHLevelPath</a> <a id="10297" href="1Lab.HLevel.html#10197" class="Bound">n</a> <a id="10299" href="1Lab.HLevel.html#10199" class="Bound">ahl</a><a id="10302" class="Symbol">)</a>
</pre>
<!--
<pre class="Agda"><a id="isHLevelPath&#39;"></a><a id="10318" href="1Lab.HLevel.html#10318" class="Function">isHLevelPath&#39;</a> <a id="10332" class="Symbol">:</a> <a id="10334" class="Symbol">(</a><a id="10335" href="1Lab.HLevel.html#10335" class="Bound">n</a> <a id="10337" class="Symbol">:</a> <a id="10339" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a><a id="10342" class="Symbol">)</a> <a id="10344" class="Symbol">→</a> <a id="10346" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a> <a id="10355" href="1Lab.HLevel.html#3737" class="Generalizable">A</a> <a id="10357" class="Symbol">(</a><a id="10358" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="10362" href="1Lab.HLevel.html#10335" class="Bound">n</a><a id="10363" class="Symbol">)</a> <a id="10365" class="Symbol">→</a> <a id="10367" class="Symbol">(</a><a id="10368" href="1Lab.HLevel.html#10368" class="Bound">x</a> <a id="10370" href="1Lab.HLevel.html#10370" class="Bound">y</a> <a id="10372" class="Symbol">:</a> <a id="10374" href="1Lab.HLevel.html#3737" class="Generalizable">A</a><a id="10375" class="Symbol">)</a> <a id="10377" class="Symbol">→</a> <a id="10379" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a> <a id="10388" class="Symbol">(</a><a id="10389" href="1Lab.HLevel.html#10368" class="Bound">x</a> <a id="10391" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="10393" href="1Lab.HLevel.html#10370" class="Bound">y</a><a id="10394" class="Symbol">)</a> <a id="10396" href="1Lab.HLevel.html#10335" class="Bound">n</a>
<a id="10398" href="1Lab.HLevel.html#10318" class="Function">isHLevelPath&#39;</a> <a id="10412" class="Number">0</a> <a id="10414" href="1Lab.HLevel.html#10414" class="Bound">ahl</a> <a id="10418" href="1Lab.HLevel.html#10418" class="Bound">x</a> <a id="10420" href="1Lab.HLevel.html#10420" class="Bound">y</a> <a id="10422" class="Symbol">=</a>
  <a id="10426" href="1Lab.HLevel.html#1382" class="InductiveConstructor">contr</a> <a id="10432" class="Symbol">(</a><a id="10433" href="1Lab.HLevel.html#10414" class="Bound">ahl</a> <a id="10437" href="1Lab.HLevel.html#10418" class="Bound">x</a> <a id="10439" href="1Lab.HLevel.html#10420" class="Bound">y</a><a id="10440" class="Symbol">)</a>
        <a id="10450" class="Symbol">λ</a> <a id="10452" href="1Lab.HLevel.html#10452" class="Bound">x</a> <a id="10454" class="Symbol">→</a> <a id="10456" href="1Lab.HLevel.html#5654" class="Function">isProp→isSet</a> <a id="10469" href="1Lab.HLevel.html#10414" class="Bound">ahl</a> <a id="10473" class="Symbol">_</a> <a id="10475" class="Symbol">_</a> <a id="10477" class="Symbol">_</a> <a id="10479" href="1Lab.HLevel.html#10452" class="Bound">x</a>
<a id="10481" href="1Lab.HLevel.html#10318" class="Function">isHLevelPath&#39;</a> <a id="10495" class="Symbol">(</a><a id="10496" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="10500" href="1Lab.HLevel.html#10500" class="Bound">n</a><a id="10501" class="Symbol">)</a> <a id="10503" href="1Lab.HLevel.html#10503" class="Bound">h</a> <a id="10505" href="1Lab.HLevel.html#10505" class="Bound">x</a> <a id="10507" href="1Lab.HLevel.html#10507" class="Bound">y</a> <a id="10509" class="Symbol">=</a> <a id="10511" href="1Lab.HLevel.html#10503" class="Bound">h</a> <a id="10513" href="1Lab.HLevel.html#10505" class="Bound">x</a> <a id="10515" href="1Lab.HLevel.html#10507" class="Bound">y</a>

<a id="isHLevelPathP&#39;"></a><a id="10518" href="1Lab.HLevel.html#10518" class="Function">isHLevelPathP&#39;</a> <a id="10533" class="Symbol">:</a> <a id="10535" class="Symbol">∀</a> <a id="10537" class="Symbol">{</a><a id="10538" href="1Lab.HLevel.html#10538" class="Bound">ℓ</a><a id="10539" class="Symbol">}</a> <a id="10541" class="Symbol">{</a><a id="10542" href="1Lab.HLevel.html#10542" class="Bound">A</a> <a id="10544" class="Symbol">:</a> <a id="10546" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="10548" class="Symbol">→</a> <a id="10550" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="10555" href="1Lab.HLevel.html#10538" class="Bound">ℓ</a><a id="10556" class="Symbol">}</a> <a id="10558" class="Symbol">(</a><a id="10559" href="1Lab.HLevel.html#10559" class="Bound">n</a> <a id="10561" class="Symbol">:</a> <a id="10563" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a><a id="10566" class="Symbol">)</a>
               <a id="10583" class="Symbol">→</a> <a id="10585" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a> <a id="10594" class="Symbol">(</a><a id="10595" href="1Lab.HLevel.html#10542" class="Bound">A</a> <a id="10597" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="10599" class="Symbol">)</a> <a id="10601" class="Symbol">(</a><a id="10602" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="10606" href="1Lab.HLevel.html#10559" class="Bound">n</a><a id="10607" class="Symbol">)</a>
               <a id="10624" class="Symbol">→</a> <a id="10626" class="Symbol">(</a><a id="10627" href="1Lab.HLevel.html#10627" class="Bound">x</a> <a id="10629" class="Symbol">:</a> <a id="10631" href="1Lab.HLevel.html#10542" class="Bound">A</a> <a id="10633" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="10635" class="Symbol">)</a> <a id="10637" class="Symbol">(</a><a id="10638" href="1Lab.HLevel.html#10638" class="Bound">y</a> <a id="10640" class="Symbol">:</a> <a id="10642" href="1Lab.HLevel.html#10542" class="Bound">A</a> <a id="10644" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="10646" class="Symbol">)</a>
               <a id="10663" class="Symbol">→</a> <a id="10665" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a> <a id="10674" class="Symbol">(</a><a id="10675" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="10681" href="1Lab.HLevel.html#10542" class="Bound">A</a> <a id="10683" href="1Lab.HLevel.html#10627" class="Bound">x</a> <a id="10685" href="1Lab.HLevel.html#10638" class="Bound">y</a><a id="10686" class="Symbol">)</a> <a id="10688" href="1Lab.HLevel.html#10559" class="Bound">n</a>
<a id="10690" href="1Lab.HLevel.html#10518" class="Function">isHLevelPathP&#39;</a> <a id="10705" class="Symbol">{</a><a id="10706" class="Argument">A</a> <a id="10708" class="Symbol">=</a> <a id="10710" href="1Lab.HLevel.html#10710" class="Bound">A</a><a id="10711" class="Symbol">}</a> <a id="10713" href="1Lab.HLevel.html#10713" class="Bound">n</a> <a id="10715" href="1Lab.HLevel.html#10715" class="Bound">ahl</a> <a id="10719" href="1Lab.HLevel.html#10719" class="Bound">x</a> <a id="10721" href="1Lab.HLevel.html#10721" class="Bound">y</a> <a id="10723" class="Symbol">=</a>
  <a id="10727" href="1Lab.Path.html#15372" class="Function">subst</a> <a id="10733" class="Symbol">(λ</a> <a id="10736" href="1Lab.HLevel.html#10736" class="Bound">e</a> <a id="10738" class="Symbol">→</a> <a id="10740" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a> <a id="10749" href="1Lab.HLevel.html#10736" class="Bound">e</a> <a id="10751" href="1Lab.HLevel.html#10713" class="Bound">n</a><a id="10752" class="Symbol">)</a>
        <a id="10762" class="Symbol">(</a><a id="10763" href="1Lab.Path.html#10628" class="Function">sym</a> <a id="10767" class="Symbol">(</a><a id="10768" href="1Lab.Path.html#49329" class="Function">PathP≡Path</a> <a id="10779" href="1Lab.HLevel.html#10710" class="Bound">A</a> <a id="10781" href="1Lab.HLevel.html#10719" class="Bound">x</a> <a id="10783" href="1Lab.HLevel.html#10721" class="Bound">y</a><a id="10784" class="Symbol">))</a>
        <a id="10795" class="Symbol">(</a><a id="10796" href="1Lab.HLevel.html#10318" class="Function">isHLevelPath&#39;</a> <a id="10810" href="1Lab.HLevel.html#10713" class="Bound">n</a> <a id="10812" href="1Lab.HLevel.html#10715" class="Bound">ahl</a> <a id="10816" class="Symbol">_</a> <a id="10818" class="Symbol">_)</a>
</pre>-->
<h1 id="ishlevel-is-a-proposition"><a href="#ishlevel-is-a-proposition" class="header-link">isHLevel is a proposition<span class="header-link-emoji">🔗</span></a></h1>
<p>Perhaps surprisingly, “being of h-level n” is a proposition, for any n! To get an intuitive feel for why this might be true before we go prove it, I’d like to suggest an alternative interpretation of the proposition <code>isHLevel A n</code>: The type <code>A</code> admits <em>unique</em> fillers for any <code>n</code>-cube.</p>
<p>A contractible type is one that has a unique point: It has a unique filler for the 0-cube, which is a point. A proposition is a type that admits unique fillers for 1-cubes, which are lines: given any endpoint, there is a line that connects them. A set is a type that admits unique fillers for 2-cubes, or squares, and so on.</p>
<p>Since these fillers are <em>unique</em>, if a type has them, it has them in at most one way!</p>
<pre class="Agda"><a id="isProp-isContr"></a><a data-type="isProp (isContr A)" id="11568" href="1Lab.HLevel.html#11568" class="Function">isProp-isContr</a> <a id="11583" class="Symbol">:</a> <a data-type="Type ℓ → Type ℓ" id="11585" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="11592" class="Symbol">(</a><a data-type="(A : Type ℓ) → Type ℓ" id="11593" href="1Lab.HLevel.html#1328" class="Record">isContr</a> <a id="11601" href="1Lab.HLevel.html#3737" class="Generalizable">A</a><a id="11602" class="Symbol">)</a>
<a data-type="isProp (isContr A)" id="11604" href="1Lab.HLevel.html#11568" class="Function">isProp-isContr</a> <a id="11619" class="Symbol">{</a><a id="11620" class="Argument">A</a> <a id="11622" class="Symbol">=</a> <a id="11624" href="1Lab.HLevel.html#11624" class="Bound">A</a><a id="11625" class="Symbol">}</a> <a id="11627" class="Symbol">(</a><a data-type="(centre₁ : A) (paths₁ : (x : A) → centre₁ ≡ x) → isContr A" id="11628" href="1Lab.HLevel.html#1382" class="InductiveConstructor">contr</a> <a id="11634" href="1Lab.HLevel.html#11634" class="Bound">c₁</a> <a id="11637" href="1Lab.HLevel.html#11637" class="Bound">h₁</a><a id="11639" class="Symbol">)</a> <a id="11641" class="Symbol">(</a><a data-type="(centre₁ : A) (paths₁ : (x : A) → centre₁ ≡ x) → isContr A" id="11642" href="1Lab.HLevel.html#1382" class="InductiveConstructor">contr</a> <a id="11648" href="1Lab.HLevel.html#11648" class="Bound">c₂</a> <a id="11651" href="1Lab.HLevel.html#11651" class="Bound">h₂</a><a id="11653" class="Symbol">)</a> <a id="11655" href="1Lab.HLevel.html#11655" class="Bound">i</a> <a id="11657" class="Symbol">=</a>
  <a id="11661" class="Keyword">record</a> <a id="11668" class="Symbol">{</a> <a data-type="isContr A → A" id="11670" href="1Lab.HLevel.html#1400" class="Field">centre</a> <a id="11677" class="Symbol">=</a> <a id="11679" href="1Lab.HLevel.html#11637" class="Bound">h₁</a> <a id="11682" href="1Lab.HLevel.html#11648" class="Bound">c₂</a> <a id="11685" href="1Lab.HLevel.html#11655" class="Bound">i</a>
         <a id="11696" class="Symbol">;</a> <a data-type="(r : isContr A) (x : A) → r .centre ≡ x" id="11698" href="1Lab.HLevel.html#1415" class="Field">paths</a> <a id="11704" class="Symbol">=</a> <a id="11706" class="Symbol">λ</a> <a id="11708" href="1Lab.HLevel.html#11708" class="Bound">x</a> <a id="11710" href="1Lab.HLevel.html#11710" class="Bound">j</a> <a id="11712" class="Symbol">→</a> <a id="11714" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="11720" class="Symbol">(λ</a> <a id="11723" href="1Lab.HLevel.html#11723" class="Bound">k</a> <a id="11725" class="Symbol">→</a> <a id="11727" class="Symbol">λ</a> <a id="11729" class="Symbol">{</a> <a id="11731" class="Symbol">(</a><a id="11732" href="1Lab.HLevel.html#11655" class="Bound">i</a> <a id="11734" class="Symbol">=</a> <a id="11736" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="11738" class="Symbol">)</a> <a id="11740" class="Symbol">→</a> <a id="11742" href="1Lab.HLevel.html#11637" class="Bound">h₁</a> <a id="11745" class="Symbol">(</a><a id="11746" href="1Lab.HLevel.html#11637" class="Bound">h₁</a> <a id="11749" href="1Lab.HLevel.html#11708" class="Bound">x</a> <a id="11751" href="1Lab.HLevel.html#11710" class="Bound">j</a><a id="11752" class="Symbol">)</a> <a id="11754" href="1Lab.HLevel.html#11723" class="Bound">k</a> 
                                          <a id="11799" class="Symbol">;</a> <a id="11801" class="Symbol">(</a><a id="11802" href="1Lab.HLevel.html#11655" class="Bound">i</a> <a id="11804" class="Symbol">=</a> <a id="11806" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="11808" class="Symbol">)</a> <a id="11810" class="Symbol">→</a> <a id="11812" href="1Lab.HLevel.html#11637" class="Bound">h₁</a> <a id="11815" class="Symbol">(</a><a id="11816" href="1Lab.HLevel.html#11651" class="Bound">h₂</a> <a id="11819" href="1Lab.HLevel.html#11708" class="Bound">x</a> <a id="11821" href="1Lab.HLevel.html#11710" class="Bound">j</a><a id="11822" class="Symbol">)</a> <a id="11824" href="1Lab.HLevel.html#11723" class="Bound">k</a>
                                          <a id="11868" class="Symbol">;</a> <a id="11870" class="Symbol">(</a><a id="11871" href="1Lab.HLevel.html#11710" class="Bound">j</a> <a id="11873" class="Symbol">=</a> <a id="11875" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="11877" class="Symbol">)</a> <a id="11879" class="Symbol">→</a> <a id="11881" href="1Lab.HLevel.html#11637" class="Bound">h₁</a> <a id="11884" class="Symbol">(</a><a id="11885" href="1Lab.HLevel.html#11637" class="Bound">h₁</a> <a id="11888" href="1Lab.HLevel.html#11648" class="Bound">c₂</a> <a id="11891" href="1Lab.HLevel.html#11655" class="Bound">i</a><a id="11892" class="Symbol">)</a> <a id="11894" href="1Lab.HLevel.html#11723" class="Bound">k</a>
                                          <a id="11938" class="Symbol">;</a> <a id="11940" class="Symbol">(</a><a id="11941" href="1Lab.HLevel.html#11710" class="Bound">j</a> <a id="11943" class="Symbol">=</a> <a id="11945" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="11947" class="Symbol">)</a> <a id="11949" class="Symbol">→</a> <a id="11951" href="1Lab.HLevel.html#11637" class="Bound">h₁</a> <a id="11954" href="1Lab.HLevel.html#11708" class="Bound">x</a> <a id="11956" href="1Lab.HLevel.html#11723" class="Bound">k</a> <a id="11958" class="Symbol">})</a>
                                 <a id="11994" href="1Lab.HLevel.html#11634" class="Bound">c₁</a>
         <a id="12006" class="Symbol">}</a>
</pre>
<p>First, we prove that being contractible is a proposition. Next, we prove that being a proposition is a proposition. This follows from <span class="Agda"><a data-type="isProp A → isSet A" href="1Lab.HLevel.html#5654" class="Function">isProp→isSet</a></span>, since what we want to prove is that <code>h₁</code> and <code>h₂</code> always give homotopic paths.</p>
<pre class="Agda"><a id="isProp-isProp"></a><a data-type="isProp (isProp A)" id="12258" href="1Lab.HLevel.html#12258" class="Function">isProp-isProp</a> <a id="12272" class="Symbol">:</a> <a data-type="Type ℓ → Type ℓ" id="12274" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="12281" class="Symbol">(</a><a data-type="Type ℓ → Type ℓ" id="12282" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="12289" href="1Lab.HLevel.html#3737" class="Generalizable">A</a><a id="12290" class="Symbol">)</a>
<a data-type="isProp (isProp A)" id="12292" href="1Lab.HLevel.html#12258" class="Function">isProp-isProp</a> <a id="12306" class="Symbol">{</a><a id="12307" class="Argument">A</a> <a id="12309" class="Symbol">=</a> <a id="12311" href="1Lab.HLevel.html#12311" class="Bound">A</a><a id="12312" class="Symbol">}</a> <a id="12314" href="1Lab.HLevel.html#12314" class="Bound">h₁</a> <a id="12317" href="1Lab.HLevel.html#12317" class="Bound">h₂</a> <a id="12320" href="1Lab.HLevel.html#12320" class="Bound">i</a> <a id="12322" href="1Lab.HLevel.html#12322" class="Bound">x</a> <a id="12324" href="1Lab.HLevel.html#12324" class="Bound">y</a> <a id="12326" class="Symbol">=</a> <a data-type="isProp A → isSet A" id="12328" href="1Lab.HLevel.html#5654" class="Function">isProp→isSet</a> <a id="12341" href="1Lab.HLevel.html#12314" class="Bound">h₁</a> <a id="12344" href="1Lab.HLevel.html#12322" class="Bound">x</a> <a id="12346" href="1Lab.HLevel.html#12324" class="Bound">y</a> <a id="12348" class="Symbol">(</a><a id="12349" href="1Lab.HLevel.html#12314" class="Bound">h₁</a> <a id="12352" href="1Lab.HLevel.html#12322" class="Bound">x</a> <a id="12354" href="1Lab.HLevel.html#12324" class="Bound">y</a><a id="12355" class="Symbol">)</a> <a id="12357" class="Symbol">(</a><a id="12358" href="1Lab.HLevel.html#12317" class="Bound">h₂</a> <a id="12361" href="1Lab.HLevel.html#12322" class="Bound">x</a> <a id="12363" href="1Lab.HLevel.html#12324" class="Bound">y</a><a id="12364" class="Symbol">)</a> <a id="12366" href="1Lab.HLevel.html#12320" class="Bound">i</a>
</pre>
<p>Now we can prove the general case by the same inductive argument we used to prove h-levels can be raised:</p>
<pre class="Agda"><a id="isProp-isHLevel"></a><a data-type="(n : Nat) → isProp (isHLevel A n)" id="12488" href="1Lab.HLevel.html#12488" class="Function">isProp-isHLevel</a> <a id="12504" class="Symbol">:</a> <a id="12506" class="Symbol">∀</a> <a id="12508" class="Symbol">{</a><a id="12509" href="1Lab.HLevel.html#12509" class="Bound">ℓ</a><a id="12510" class="Symbol">}</a> <a id="12512" class="Symbol">{</a><a id="12513" href="1Lab.HLevel.html#12513" class="Bound">A</a> <a id="12515" class="Symbol">:</a> <a id="12517" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="12522" href="1Lab.HLevel.html#12509" class="Bound">ℓ</a><a id="12523" class="Symbol">}</a> <a id="12525" class="Symbol">(</a><a id="12526" href="1Lab.HLevel.html#12526" class="Bound">n</a> <a id="12528" class="Symbol">:</a> <a data-type="Type" id="12530" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a><a id="12533" class="Symbol">)</a> <a id="12535" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="12537" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="12544" class="Symbol">(</a><a data-type="Type ℓ → Nat → Type ℓ" id="12545" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a> <a id="12554" href="1Lab.HLevel.html#12513" class="Bound">A</a> <a id="12556" href="1Lab.HLevel.html#12526" class="Bound">n</a><a id="12557" class="Symbol">)</a>
<a data-type="(n : Nat) → isProp (isHLevel A n)" id="12559" href="1Lab.HLevel.html#12488" class="Function">isProp-isHLevel</a> <a id="12575" class="Number">0</a> <a id="12577" class="Symbol">=</a> <a data-type="isProp (isContr A)" id="12579" href="1Lab.HLevel.html#11568" class="Function">isProp-isContr</a>
<a data-type="(n : Nat) → isProp (isHLevel A n)" id="12594" href="1Lab.HLevel.html#12488" class="Function">isProp-isHLevel</a> <a id="12610" class="Number">1</a> <a id="12612" class="Symbol">=</a> <a data-type="isProp (isProp A)" id="12614" href="1Lab.HLevel.html#12258" class="Function">isProp-isProp</a>
<a data-type="(n : Nat) → isProp (isHLevel A n)" id="12628" href="1Lab.HLevel.html#12488" class="Function">isProp-isHLevel</a> <a id="12644" class="Symbol">(</a><a data-type="Nat → Nat" id="12645" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="12649" class="Symbol">(</a><a data-type="Nat → Nat" id="12650" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="12654" href="1Lab.HLevel.html#12654" class="Bound">n</a><a id="12655" class="Symbol">))</a> <a id="12658" href="1Lab.HLevel.html#12658" class="Bound">x</a> <a id="12660" href="1Lab.HLevel.html#12660" class="Bound">y</a> <a id="12662" href="1Lab.HLevel.html#12662" class="Bound">i</a> <a id="12664" href="1Lab.HLevel.html#12664" class="Bound">a</a> <a id="12666" href="1Lab.HLevel.html#12666" class="Bound">b</a> <a id="12668" class="Symbol">=</a> <a data-type="(n : Nat) → isProp (isHLevel A n)" id="12670" href="1Lab.HLevel.html#12488" class="Function">isProp-isHLevel</a> <a id="12686" class="Symbol">(</a><a data-type="Nat → Nat" id="12687" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="12691" href="1Lab.HLevel.html#12654" class="Bound">n</a><a id="12692" class="Symbol">)</a> <a id="12694" class="Symbol">(</a><a id="12695" href="1Lab.HLevel.html#12658" class="Bound">x</a> <a id="12697" href="1Lab.HLevel.html#12664" class="Bound">a</a> <a id="12699" href="1Lab.HLevel.html#12666" class="Bound">b</a><a id="12700" class="Symbol">)</a> <a id="12702" class="Symbol">(</a><a id="12703" href="1Lab.HLevel.html#12660" class="Bound">y</a> <a id="12705" href="1Lab.HLevel.html#12664" class="Bound">a</a> <a id="12707" href="1Lab.HLevel.html#12666" class="Bound">b</a><a id="12708" class="Symbol">)</a> <a id="12710" href="1Lab.HLevel.html#12662" class="Bound">i</a>
</pre>
<h1 id="dependent-h-levels"><a href="#dependent-h-levels" class="header-link">Dependent h-Levels<span class="header-link-emoji">🔗</span></a></h1>
<p>In cubical type theory, it’s natural to consider a notion of <em>dependent</em> h-level for a <em>family</em> of types, where, rather than having (e.g.) <span class="Agda"><a data-type="(A : Type ℓ) → A → A → Type ℓ" href="1Lab.Path.html#2466" class="Function">Path</a></span>s for any two elements, we have <span class="Agda"><a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a></span>s. Since dependent contractibility doesn’t make a lot of sense, this definition is offset by one to start at the propositions.</p>
<pre class="Agda"><a id="isHLevelDep"></a><a data-type="(A → Type ℓ&#39;) → Nat → Type (ℓ ⊔ ℓ&#39;)" id="13073" href="1Lab.HLevel.html#13073" class="Function">isHLevelDep</a> <a id="13085" class="Symbol">:</a> <a id="13087" class="Symbol">∀</a> <a id="13089" class="Symbol">{</a><a id="13090" href="1Lab.HLevel.html#13090" class="Bound">ℓ</a> <a id="13092" href="1Lab.HLevel.html#13092" class="Bound">ℓ&#39;</a><a id="13094" class="Symbol">}</a> <a id="13096" class="Symbol">{</a><a id="13097" href="1Lab.HLevel.html#13097" class="Bound">A</a> <a id="13099" class="Symbol">:</a> <a id="13101" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13106" href="1Lab.HLevel.html#13090" class="Bound">ℓ</a><a id="13107" class="Symbol">}</a> <a id="13109" class="Symbol">→</a> <a id="13111" class="Symbol">(</a><a id="13112" href="1Lab.HLevel.html#13097" class="Bound">A</a> <a id="13114" class="Symbol">→</a> <a id="13116" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13121" href="1Lab.HLevel.html#13092" class="Bound">ℓ&#39;</a><a id="13123" class="Symbol">)</a> <a id="13125" class="Symbol">→</a> <a data-type="Type" id="13127" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a> <a id="13131" class="Symbol">→</a> <a id="13133" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13138" class="Symbol">_</a>
<a data-type="(A → Type ℓ&#39;) → Nat → Type (ℓ ⊔ ℓ&#39;)" id="13140" href="1Lab.HLevel.html#13073" class="Function">isHLevelDep</a> <a id="13152" href="1Lab.HLevel.html#13152" class="Bound">B</a> <a data-type="Nat" id="13154" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="13159" class="Symbol">=</a> <a id="13161" class="Symbol">∀</a> <a id="13163" class="Symbol">{</a><a id="13164" href="1Lab.HLevel.html#13164" class="Bound">x</a> <a id="13166" href="1Lab.HLevel.html#13166" class="Bound">y</a><a id="13167" class="Symbol">}</a> <a id="13169" class="Symbol">(</a><a id="13170" href="1Lab.HLevel.html#13170" class="Bound">α</a> <a id="13172" class="Symbol">:</a> <a id="13174" href="1Lab.HLevel.html#13152" class="Bound">B</a> <a id="13176" href="1Lab.HLevel.html#13164" class="Bound">x</a><a id="13177" class="Symbol">)</a> <a id="13179" class="Symbol">(</a><a id="13180" href="1Lab.HLevel.html#13180" class="Bound">β</a> <a id="13182" class="Symbol">:</a> <a id="13184" href="1Lab.HLevel.html#13152" class="Bound">B</a> <a id="13186" href="1Lab.HLevel.html#13166" class="Bound">y</a><a id="13187" class="Symbol">)</a> <a id="13189" class="Symbol">(</a><a id="13190" href="1Lab.HLevel.html#13190" class="Bound">p</a> <a id="13192" class="Symbol">:</a> <a id="13194" href="1Lab.HLevel.html#13164" class="Bound">x</a> <a data-type="A → A → Type ℓ" id="13196" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="13198" href="1Lab.HLevel.html#13166" class="Bound">y</a><a id="13199" class="Symbol">)</a>
                   <a id="13220" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="13222" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="13228" class="Symbol">(λ</a> <a id="13231" href="1Lab.HLevel.html#13231" class="Bound">i</a> <a id="13233" class="Symbol">→</a> <a id="13235" href="1Lab.HLevel.html#13152" class="Bound">B</a> <a id="13237" class="Symbol">(</a><a id="13238" href="1Lab.HLevel.html#13190" class="Bound">p</a> <a id="13240" href="1Lab.HLevel.html#13231" class="Bound">i</a><a id="13241" class="Symbol">))</a> <a id="13244" href="1Lab.HLevel.html#13170" class="Bound">α</a> <a id="13246" href="1Lab.HLevel.html#13180" class="Bound">β</a>
<a data-type="(A → Type ℓ&#39;) → Nat → Type (ℓ ⊔ ℓ&#39;)" id="13248" href="1Lab.HLevel.html#13073" class="Function">isHLevelDep</a> <a id="13260" href="1Lab.HLevel.html#13260" class="Bound">B</a> <a id="13262" class="Symbol">(</a><a data-type="Nat → Nat" id="13263" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="13267" href="1Lab.HLevel.html#13267" class="Bound">n</a><a id="13268" class="Symbol">)</a> <a id="13270" class="Symbol">=</a>
   <a id="13275" class="Symbol">∀</a> <a id="13277" class="Symbol">{</a><a id="13278" href="1Lab.HLevel.html#13278" class="Bound">a0</a> <a id="13281" href="1Lab.HLevel.html#13281" class="Bound">a1</a><a id="13283" class="Symbol">}</a> <a id="13285" class="Symbol">(</a><a id="13286" href="1Lab.HLevel.html#13286" class="Bound">b0</a> <a id="13289" class="Symbol">:</a> <a id="13291" href="1Lab.HLevel.html#13260" class="Bound">B</a> <a id="13293" href="1Lab.HLevel.html#13278" class="Bound">a0</a><a id="13295" class="Symbol">)</a> <a id="13297" class="Symbol">(</a><a id="13298" href="1Lab.HLevel.html#13298" class="Bound">b1</a> <a id="13301" class="Symbol">:</a> <a id="13303" href="1Lab.HLevel.html#13260" class="Bound">B</a> <a id="13305" href="1Lab.HLevel.html#13281" class="Bound">a1</a><a id="13307" class="Symbol">)</a>
   <a id="13312" class="Symbol">→</a> <a data-type="(A → Type ℓ&#39;) → Nat → Type (ℓ ⊔ ℓ&#39;)" id="13314" href="1Lab.HLevel.html#13073" class="Function">isHLevelDep</a> <a id="13326" class="Symbol">{</a><a id="13327" class="Argument">A</a> <a id="13329" class="Symbol">=</a> <a id="13331" href="1Lab.HLevel.html#13278" class="Bound">a0</a> <a data-type="A → A → Type ℓ" id="13334" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="13336" href="1Lab.HLevel.html#13281" class="Bound">a1</a><a id="13338" class="Symbol">}</a> <a id="13340" class="Symbol">(λ</a> <a id="13343" href="1Lab.HLevel.html#13343" class="Bound">p</a> <a id="13345" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="13347" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="13353" class="Symbol">(λ</a> <a id="13356" href="1Lab.HLevel.html#13356" class="Bound">i</a> <a id="13358" class="Symbol">→</a> <a id="13360" href="1Lab.HLevel.html#13260" class="Bound">B</a> <a id="13362" class="Symbol">(</a><a id="13363" href="1Lab.HLevel.html#13343" class="Bound">p</a> <a id="13365" href="1Lab.HLevel.html#13356" class="Bound">i</a><a id="13366" class="Symbol">))</a> <a id="13369" href="1Lab.HLevel.html#13286" class="Bound">b0</a> <a id="13372" href="1Lab.HLevel.html#13298" class="Bound">b1</a><a id="13374" class="Symbol">)</a> <a id="13376" href="1Lab.HLevel.html#13267" class="Bound">n</a>
</pre>
<p>It’s sufficient for a type family to be of an h-level everywhere for the whole family to be the same h-level.</p>
<pre class="Agda"><a id="isProp→PathP"></a><a data-type="((i : I) → isProp (B₁ i)) →
(b0 : B₁ i0) (b1 : B₁ i1) → PathP B₁ b0 b1" id="13502" href="1Lab.HLevel.html#13502" class="Function">isProp→PathP</a> <a id="13515" class="Symbol">:</a> <a id="13517" class="Symbol">∀</a> <a id="13519" class="Symbol">{</a><a id="13520" href="1Lab.HLevel.html#13520" class="Bound">B</a> <a id="13522" class="Symbol">:</a> <a id="13524" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="13526" class="Symbol">→</a> <a id="13528" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13533" href="1Lab.HLevel.html#3723" class="Generalizable">ℓ</a><a id="13534" class="Symbol">}</a> <a id="13536" class="Symbol">→</a> <a id="13538" class="Symbol">((</a><a id="13540" href="1Lab.HLevel.html#13540" class="Bound">i</a> <a id="13542" class="Symbol">:</a> <a id="13544" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="13545" class="Symbol">)</a> <a id="13547" class="Symbol">→</a> <a data-type="Type ℓ → Type ℓ" id="13549" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="13556" class="Symbol">(</a><a id="13557" href="1Lab.HLevel.html#13520" class="Bound">B</a> <a id="13559" href="1Lab.HLevel.html#13540" class="Bound">i</a><a id="13560" class="Symbol">))</a>
             <a id="13576" class="Symbol">→</a> <a id="13578" class="Symbol">(</a><a id="13579" href="1Lab.HLevel.html#13579" class="Bound">b0</a> <a id="13582" class="Symbol">:</a> <a id="13584" href="1Lab.HLevel.html#13520" class="Bound">B</a> <a id="13586" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="13588" class="Symbol">)</a> <a id="13590" class="Symbol">(</a><a id="13591" href="1Lab.HLevel.html#13591" class="Bound">b1</a> <a id="13594" class="Symbol">:</a> <a id="13596" href="1Lab.HLevel.html#13520" class="Bound">B</a> <a id="13598" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="13600" class="Symbol">)</a>
             <a id="13615" class="Symbol">→</a> <a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="13617" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="13623" class="Symbol">(λ</a> <a id="13626" href="1Lab.HLevel.html#13626" class="Bound">i</a> <a id="13628" class="Symbol">→</a> <a id="13630" href="1Lab.HLevel.html#13520" class="Bound">B</a> <a id="13632" href="1Lab.HLevel.html#13626" class="Bound">i</a><a id="13633" class="Symbol">)</a> <a id="13635" href="1Lab.HLevel.html#13579" class="Bound">b0</a> <a id="13638" href="1Lab.HLevel.html#13591" class="Bound">b1</a>
<a data-type="((i : I) → isProp (B₁ i)) →
(b0 : B₁ i0) (b1 : B₁ i1) → PathP B₁ b0 b1" id="13641" href="1Lab.HLevel.html#13502" class="Function">isProp→PathP</a> <a id="13654" class="Symbol">{</a><a id="13655" class="Argument">B</a> <a id="13657" class="Symbol">=</a> <a id="13659" href="1Lab.HLevel.html#13659" class="Bound">B</a><a id="13660" class="Symbol">}</a> <a id="13662" href="1Lab.HLevel.html#13662" class="Bound">hB</a> <a id="13665" href="1Lab.HLevel.html#13665" class="Bound">b0</a> <a id="13668" href="1Lab.HLevel.html#13668" class="Bound">b1</a> <a id="13671" class="Symbol">=</a> <a data-type="(A : I → Type ℓ) (x : A i0) (y : A i1) →
coe0→1 A x ≡ y → PathP A x y" id="13673" href="1Lab.Path.html#56078" class="Function">toPathP</a> <a id="13681" class="Symbol">_</a> <a id="13683" class="Symbol">_</a> <a id="13685" class="Symbol">_</a> <a id="13687" class="Symbol">(</a><a id="13688" href="1Lab.HLevel.html#13662" class="Bound">hB</a> <a id="13691" class="Symbol">_</a> <a id="13693" class="Symbol">_</a> <a id="13695" class="Symbol">_)</a>
</pre>
<p>The base case is turning a proof that a type is a proposition uniformly over the interval to a filler for any PathP.</p>
<pre class="Agda"><a id="isHLevel→isHLevelDep"></a><a data-type="(n : Nat) → ((x : A) → isHLevel (B₁ x) (suc n)) → isHLevelDep B₁ n" id="13829" href="1Lab.HLevel.html#13829" class="Function">isHLevel→isHLevelDep</a> <a id="13850" class="Symbol">:</a> <a id="13852" class="Symbol">∀</a> <a id="13854" class="Symbol">{</a><a id="13855" href="1Lab.HLevel.html#13855" class="Bound">ℓ</a> <a id="13857" href="1Lab.HLevel.html#13857" class="Bound">ℓ&#39;</a><a id="13859" class="Symbol">}</a> <a id="13861" class="Symbol">{</a><a id="13862" href="1Lab.HLevel.html#13862" class="Bound">A</a> <a id="13864" class="Symbol">:</a> <a id="13866" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13871" href="1Lab.HLevel.html#13855" class="Bound">ℓ</a><a id="13872" class="Symbol">}</a> <a id="13874" class="Symbol">{</a><a id="13875" href="1Lab.HLevel.html#13875" class="Bound">B</a> <a id="13877" class="Symbol">:</a> <a id="13879" href="1Lab.HLevel.html#13862" class="Bound">A</a> <a id="13881" class="Symbol">→</a> <a id="13883" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="13888" href="1Lab.HLevel.html#13857" class="Bound">ℓ&#39;</a><a id="13890" class="Symbol">}</a>
                     <a id="13913" class="Symbol">→</a> <a id="13915" class="Symbol">(</a><a id="13916" href="1Lab.HLevel.html#13916" class="Bound">n</a> <a id="13918" class="Symbol">:</a> <a data-type="Type" id="13920" href="Agda.Builtin.Nat.html#192" class="Datatype">Nat</a><a id="13923" class="Symbol">)</a> <a id="13925" class="Symbol">→</a> <a id="13927" class="Symbol">((</a><a id="13929" href="1Lab.HLevel.html#13929" class="Bound">x</a> <a id="13931" class="Symbol">:</a> <a id="13933" href="1Lab.HLevel.html#13862" class="Bound">A</a><a id="13934" class="Symbol">)</a> <a id="13936" class="Symbol">→</a> <a data-type="Type ℓ → Nat → Type ℓ" id="13938" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a> <a id="13947" class="Symbol">(</a><a id="13948" href="1Lab.HLevel.html#13875" class="Bound">B</a> <a id="13950" href="1Lab.HLevel.html#13929" class="Bound">x</a><a id="13951" class="Symbol">)</a> <a id="13953" class="Symbol">(</a><a data-type="Nat → Nat" id="13954" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="13958" href="1Lab.HLevel.html#13916" class="Bound">n</a><a id="13959" class="Symbol">))</a>
                     <a id="13983" class="Symbol">→</a> <a data-type="(A → Type ℓ&#39;) → Nat → Type (ℓ ⊔ ℓ&#39;)" id="13985" href="1Lab.HLevel.html#13073" class="Function">isHLevelDep</a> <a id="13997" href="1Lab.HLevel.html#13875" class="Bound">B</a> <a id="13999" href="1Lab.HLevel.html#13916" class="Bound">n</a>
<a data-type="(n : Nat) → ((x : A) → isHLevel (B₁ x) (suc n)) → isHLevelDep B₁ n" id="14001" href="1Lab.HLevel.html#13829" class="Function">isHLevel→isHLevelDep</a> <a data-type="Nat" id="14022" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a> <a id="14027" href="1Lab.HLevel.html#14027" class="Bound">hl</a> <a id="14030" href="1Lab.HLevel.html#14030" class="Bound">α</a> <a id="14032" href="1Lab.HLevel.html#14032" class="Bound">β</a> <a id="14034" href="1Lab.HLevel.html#14034" class="Bound">p</a> <a id="14036" class="Symbol">=</a> <a data-type="((i : I) → isProp (B₁ i)) →
(b0 : B₁ i0) (b1 : B₁ i1) → PathP B₁ b0 b1" id="14038" href="1Lab.HLevel.html#13502" class="Function">isProp→PathP</a> <a id="14051" class="Symbol">(λ</a> <a id="14054" href="1Lab.HLevel.html#14054" class="Bound">i</a> <a id="14056" class="Symbol">→</a> <a id="14058" href="1Lab.HLevel.html#14027" class="Bound">hl</a> <a id="14061" class="Symbol">(</a><a id="14062" href="1Lab.HLevel.html#14034" class="Bound">p</a> <a id="14064" href="1Lab.HLevel.html#14054" class="Bound">i</a><a id="14065" class="Symbol">))</a> <a id="14068" href="1Lab.HLevel.html#14030" class="Bound">α</a> <a id="14070" href="1Lab.HLevel.html#14032" class="Bound">β</a>
<a data-type="(n : Nat) → ((x : A) → isHLevel (B₁ x) (suc n)) → isHLevelDep B₁ n" id="14072" href="1Lab.HLevel.html#13829" class="Function">isHLevel→isHLevelDep</a> <a id="14093" class="Symbol">{</a><a id="14094" class="Argument">A</a> <a id="14096" class="Symbol">=</a> <a id="14098" href="1Lab.HLevel.html#14098" class="Bound">A</a><a id="14099" class="Symbol">}</a> <a id="14101" class="Symbol">{</a><a id="14102" class="Argument">B</a> <a id="14104" class="Symbol">=</a> <a id="14106" href="1Lab.HLevel.html#14106" class="Bound">B</a><a id="14107" class="Symbol">}</a> <a id="14109" class="Symbol">(</a><a data-type="Nat → Nat" id="14110" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="14114" href="1Lab.HLevel.html#14114" class="Bound">n</a><a id="14115" class="Symbol">)</a> <a id="14117" href="1Lab.HLevel.html#14117" class="Bound">hl</a> <a id="14120" class="Symbol">{</a><a id="14121" href="1Lab.HLevel.html#14121" class="Bound">a0</a><a id="14123" class="Symbol">}</a> <a id="14125" class="Symbol">{</a><a id="14126" href="1Lab.HLevel.html#14126" class="Bound">a1</a><a id="14128" class="Symbol">}</a> <a id="14130" href="1Lab.HLevel.html#14130" class="Bound">b0</a> <a id="14133" href="1Lab.HLevel.html#14133" class="Bound">b1</a> <a id="14136" class="Symbol">=</a>
  <a data-type="(n : Nat) → ((x : A) → isHLevel (B₁ x) (suc n)) → isHLevelDep B₁ n" id="14140" href="1Lab.HLevel.html#13829" class="Function">isHLevel→isHLevelDep</a> <a id="14161" href="1Lab.HLevel.html#14114" class="Bound">n</a> <a id="14163" class="Symbol">(λ</a> <a id="14166" href="1Lab.HLevel.html#14166" class="Bound">p</a> <a id="14168" class="Symbol">→</a> <a id="14170" href="1Lab.HLevel.html#14198" class="Function">helper</a> <a id="14177" href="1Lab.HLevel.html#14126" class="Bound">a1</a> <a id="14180" href="1Lab.HLevel.html#14166" class="Bound">p</a> <a id="14182" href="1Lab.HLevel.html#14133" class="Bound">b1</a><a id="14184" class="Symbol">)</a>
  <a id="14188" class="Keyword">where</a>
    <a id="14198" href="1Lab.HLevel.html#14198" class="Function">helper</a> <a id="14205" class="Symbol">:</a> <a id="14207" class="Symbol">(</a><a id="14208" href="1Lab.HLevel.html#14208" class="Bound">a1</a> <a id="14211" class="Symbol">:</a> <a id="14213" href="1Lab.HLevel.html#14098" class="Bound">A</a><a id="14214" class="Symbol">)</a> <a id="14216" class="Symbol">(</a><a id="14217" href="1Lab.HLevel.html#14217" class="Bound">p</a> <a id="14219" class="Symbol">:</a> <a id="14221" href="1Lab.HLevel.html#14121" class="Bound">a0</a> <a data-type="A → A → Type ℓ" id="14224" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="14226" href="1Lab.HLevel.html#14208" class="Bound">a1</a><a id="14228" class="Symbol">)</a> <a id="14230" class="Symbol">(</a><a id="14231" href="1Lab.HLevel.html#14231" class="Bound">b1</a> <a id="14234" class="Symbol">:</a> <a id="14236" href="1Lab.HLevel.html#14106" class="Bound">B</a> <a id="14238" href="1Lab.HLevel.html#14208" class="Bound">a1</a><a id="14240" class="Symbol">)</a>
           <a id="14253" class="Symbol">→</a> <a data-type="Type ℓ → Nat → Type ℓ" id="14255" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a> <a id="14264" class="Symbol">(</a><a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="14265" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="14271" class="Symbol">(λ</a> <a id="14274" href="1Lab.HLevel.html#14274" class="Bound">i</a> <a id="14276" class="Symbol">→</a> <a id="14278" href="1Lab.HLevel.html#14106" class="Bound">B</a> <a id="14280" class="Symbol">(</a><a id="14281" href="1Lab.HLevel.html#14217" class="Bound">p</a> <a id="14283" href="1Lab.HLevel.html#14274" class="Bound">i</a><a id="14284" class="Symbol">))</a> <a id="14287" href="1Lab.HLevel.html#14130" class="Bound">b0</a> <a id="14290" href="1Lab.HLevel.html#14231" class="Bound">b1</a><a id="14292" class="Symbol">)</a> <a id="14294" class="Symbol">(</a><a data-type="Nat → Nat" id="14295" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="14299" href="1Lab.HLevel.html#14114" class="Bound">n</a><a id="14300" class="Symbol">)</a>
    <a id="14306" href="1Lab.HLevel.html#14198" class="Function">helper</a> <a id="14313" href="1Lab.HLevel.html#14313" class="Bound">a1</a> <a id="14316" href="1Lab.HLevel.html#14316" class="Bound">p</a> <a id="14318" href="1Lab.HLevel.html#14318" class="Bound">b1</a> <a id="14321" class="Symbol">=</a> <a data-type="(P : (y : A) → x ≡ y → Type ℓ₂) → P x refl → (p : x ≡ y) → P y p" id="14323" href="1Lab.Path.html#19603" class="Function">J</a> <a id="14325" class="Symbol">(λ</a> <a id="14328" href="1Lab.HLevel.html#14328" class="Bound">a1</a> <a id="14331" href="1Lab.HLevel.html#14331" class="Bound">p</a> <a id="14333" class="Symbol">→</a> <a id="14335" class="Symbol">∀</a> <a id="14337" href="1Lab.HLevel.html#14337" class="Bound">b1</a> <a id="14340" class="Symbol">→</a> <a data-type="Type ℓ → Nat → Type ℓ" id="14342" href="1Lab.HLevel.html#2807" class="Function">isHLevel</a> <a id="14351" class="Symbol">(</a><a data-type="(A : I → Type ℓ) → A i0 → A i1 → Type ℓ" id="14352" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="14358" class="Symbol">(λ</a> <a id="14361" href="1Lab.HLevel.html#14361" class="Bound">i</a> <a id="14363" class="Symbol">→</a> <a id="14365" href="1Lab.HLevel.html#14106" class="Bound">B</a> <a id="14367" class="Symbol">(</a><a id="14368" href="1Lab.HLevel.html#14331" class="Bound">p</a> <a id="14370" href="1Lab.HLevel.html#14361" class="Bound">i</a><a id="14371" class="Symbol">))</a> <a id="14374" href="1Lab.HLevel.html#14130" class="Bound">b0</a> <a id="14377" href="1Lab.HLevel.html#14337" class="Bound">b1</a><a id="14379" class="Symbol">)</a> <a id="14381" class="Symbol">(</a><a data-type="Nat → Nat" id="14382" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="14386" href="1Lab.HLevel.html#14114" class="Bound">n</a><a id="14387" class="Symbol">))</a>
                      <a id="14412" class="Symbol">(λ</a> <a id="14415" href="1Lab.HLevel.html#14415" class="Bound">_</a> <a id="14417" class="Symbol">→</a> <a id="14419" href="1Lab.HLevel.html#14117" class="Bound">hl</a> <a id="14422" class="Symbol">_</a> <a id="14424" class="Symbol">_</a> <a id="14426" class="Symbol">_)</a> <a id="14429" href="1Lab.HLevel.html#14316" class="Bound">p</a> <a id="14431" href="1Lab.HLevel.html#14318" class="Bound">b1</a>
</pre>
<!--
<pre class="Agda"><a id="isProp→SquareP"></a><a id="14452" href="1Lab.HLevel.html#14452" class="Function">isProp→SquareP</a> <a id="14467" class="Symbol">:</a> <a id="14469" class="Symbol">∀</a> <a id="14471" class="Symbol">{</a><a id="14472" href="1Lab.HLevel.html#14472" class="Bound">B</a> <a id="14474" class="Symbol">:</a> <a id="14476" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="14478" class="Symbol">→</a> <a id="14480" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="14482" class="Symbol">→</a> <a id="14484" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="14489" href="1Lab.HLevel.html#3723" class="Generalizable">ℓ</a><a id="14490" class="Symbol">}</a> <a id="14492" class="Symbol">→</a> <a id="14494" class="Symbol">((</a><a id="14496" href="1Lab.HLevel.html#14496" class="Bound">i</a> <a id="14498" href="1Lab.HLevel.html#14498" class="Bound">j</a> <a id="14500" class="Symbol">:</a> <a id="14502" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="14503" class="Symbol">)</a> <a id="14505" class="Symbol">→</a> <a id="14507" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="14514" class="Symbol">(</a><a id="14515" href="1Lab.HLevel.html#14472" class="Bound">B</a> <a id="14517" href="1Lab.HLevel.html#14496" class="Bound">i</a> <a id="14519" href="1Lab.HLevel.html#14498" class="Bound">j</a><a id="14520" class="Symbol">))</a>
             <a id="14536" class="Symbol">→</a> <a id="14538" class="Symbol">{</a><a id="14539" href="1Lab.HLevel.html#14539" class="Bound">a</a> <a id="14541" class="Symbol">:</a> <a id="14543" href="1Lab.HLevel.html#14472" class="Bound">B</a> <a id="14545" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a id="14548" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="14550" class="Symbol">}</a> <a id="14552" class="Symbol">{</a><a id="14553" href="1Lab.HLevel.html#14553" class="Bound">b</a> <a id="14555" class="Symbol">:</a> <a id="14557" href="1Lab.HLevel.html#14472" class="Bound">B</a> <a id="14559" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a id="14562" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="14564" class="Symbol">}</a> <a id="14566" class="Symbol">{</a><a id="14567" href="1Lab.HLevel.html#14567" class="Bound">c</a> <a id="14569" class="Symbol">:</a> <a id="14571" href="1Lab.HLevel.html#14472" class="Bound">B</a> <a id="14573" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a> <a id="14576" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="14578" class="Symbol">}</a> <a id="14580" class="Symbol">{</a><a id="14581" href="1Lab.HLevel.html#14581" class="Bound">d</a> <a id="14583" class="Symbol">:</a> <a id="14585" href="1Lab.HLevel.html#14472" class="Bound">B</a> <a id="14587" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a> <a id="14590" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="14592" class="Symbol">}</a>
             <a id="14607" class="Symbol">→</a> <a id="14609" class="Symbol">(</a><a id="14610" href="1Lab.HLevel.html#14610" class="Bound">p</a> <a id="14612" class="Symbol">:</a> <a id="14614" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="14620" class="Symbol">(λ</a> <a id="14623" href="1Lab.HLevel.html#14623" class="Bound">j</a> <a id="14625" class="Symbol">→</a> <a id="14627" href="1Lab.HLevel.html#14472" class="Bound">B</a> <a id="14629" href="1Lab.HLevel.html#14623" class="Bound">j</a> <a id="14631" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="14633" class="Symbol">)</a> <a id="14635" href="1Lab.HLevel.html#14539" class="Bound">a</a> <a id="14637" href="1Lab.HLevel.html#14567" class="Bound">c</a><a id="14638" class="Symbol">)</a>
             <a id="14653" class="Symbol">→</a> <a id="14655" class="Symbol">(</a><a id="14656" href="1Lab.HLevel.html#14656" class="Bound">q</a> <a id="14658" class="Symbol">:</a> <a id="14660" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="14666" class="Symbol">(λ</a> <a id="14669" href="1Lab.HLevel.html#14669" class="Bound">j</a> <a id="14671" class="Symbol">→</a> <a id="14673" href="1Lab.HLevel.html#14472" class="Bound">B</a> <a id="14675" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a id="14678" href="1Lab.HLevel.html#14669" class="Bound">j</a><a id="14679" class="Symbol">)</a> <a id="14681" href="1Lab.HLevel.html#14539" class="Bound">a</a> <a id="14683" href="1Lab.HLevel.html#14553" class="Bound">b</a><a id="14684" class="Symbol">)</a>
             <a id="14699" class="Symbol">→</a> <a id="14701" class="Symbol">(</a><a id="14702" href="1Lab.HLevel.html#14702" class="Bound">s</a> <a id="14704" class="Symbol">:</a> <a id="14706" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="14712" class="Symbol">(λ</a> <a id="14715" href="1Lab.HLevel.html#14715" class="Bound">j</a> <a id="14717" class="Symbol">→</a> <a id="14719" href="1Lab.HLevel.html#14472" class="Bound">B</a> <a id="14721" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a> <a id="14724" href="1Lab.HLevel.html#14715" class="Bound">j</a><a id="14725" class="Symbol">)</a> <a id="14727" href="1Lab.HLevel.html#14567" class="Bound">c</a> <a id="14729" href="1Lab.HLevel.html#14581" class="Bound">d</a><a id="14730" class="Symbol">)</a>
             <a id="14745" class="Symbol">→</a> <a id="14747" class="Symbol">(</a><a id="14748" href="1Lab.HLevel.html#14748" class="Bound">r</a> <a id="14750" class="Symbol">:</a> <a id="14752" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="14758" class="Symbol">(λ</a> <a id="14761" href="1Lab.HLevel.html#14761" class="Bound">j</a> <a id="14763" class="Symbol">→</a> <a id="14765" href="1Lab.HLevel.html#14472" class="Bound">B</a> <a id="14767" href="1Lab.HLevel.html#14761" class="Bound">j</a> <a id="14769" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="14771" class="Symbol">)</a> <a id="14773" href="1Lab.HLevel.html#14553" class="Bound">b</a> <a id="14775" href="1Lab.HLevel.html#14581" class="Bound">d</a><a id="14776" class="Symbol">)</a>
             <a id="14791" class="Symbol">→</a> <a id="14793" href="1Lab.Path.html#48224" class="Function">SquareP</a> <a id="14801" href="1Lab.HLevel.html#14472" class="Bound">B</a> <a id="14803" href="1Lab.HLevel.html#14610" class="Bound">p</a> <a id="14805" href="1Lab.HLevel.html#14656" class="Bound">q</a> <a id="14807" href="1Lab.HLevel.html#14702" class="Bound">s</a> <a id="14809" href="1Lab.HLevel.html#14748" class="Bound">r</a>
<a id="14811" href="1Lab.HLevel.html#14452" class="Function">isProp→SquareP</a> <a id="14826" class="Symbol">{</a><a id="14827" class="Argument">B</a> <a id="14829" class="Symbol">=</a> <a id="14831" href="1Lab.HLevel.html#14831" class="Bound">B</a><a id="14832" class="Symbol">}</a> <a id="14834" href="1Lab.HLevel.html#14834" class="Bound">isPropB</a> <a id="14842" class="Symbol">{</a><a id="14843" class="Argument">a</a> <a id="14845" class="Symbol">=</a> <a id="14847" href="1Lab.HLevel.html#14847" class="Bound">a</a><a id="14848" class="Symbol">}</a> <a id="14850" href="1Lab.HLevel.html#14850" class="Bound">p</a> <a id="14852" href="1Lab.HLevel.html#14852" class="Bound">q</a> <a id="14854" href="1Lab.HLevel.html#14854" class="Bound">s</a> <a id="14856" href="1Lab.HLevel.html#14856" class="Bound">r</a> <a id="14858" href="1Lab.HLevel.html#14858" class="Bound">i</a> <a id="14860" href="1Lab.HLevel.html#14860" class="Bound">j</a> <a id="14862" class="Symbol">=</a>
  <a id="14866" href="1Lab.Path.html#2368" class="Primitive">hcomp</a> <a id="14872" class="Symbol">(λ</a> <a id="14875" class="Symbol">{</a> <a id="14877" href="1Lab.HLevel.html#14877" class="Bound">k</a> <a id="14879" class="Symbol">(</a><a id="14880" href="1Lab.HLevel.html#14860" class="Bound">j</a> <a id="14882" class="Symbol">=</a> <a id="14884" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="14886" class="Symbol">)</a> <a id="14888" class="Symbol">→</a> <a id="14890" href="1Lab.HLevel.html#14834" class="Bound">isPropB</a> <a id="14898" href="1Lab.HLevel.html#14858" class="Bound">i</a> <a id="14900" href="1Lab.HLevel.html#14860" class="Bound">j</a> <a id="14902" class="Symbol">(</a><a id="14903" href="1Lab.HLevel.html#15124" class="Function">base</a> <a id="14908" href="1Lab.HLevel.html#14858" class="Bound">i</a> <a id="14910" href="1Lab.HLevel.html#14860" class="Bound">j</a><a id="14911" class="Symbol">)</a> <a id="14913" class="Symbol">(</a><a id="14914" href="1Lab.HLevel.html#14850" class="Bound">p</a> <a id="14916" href="1Lab.HLevel.html#14858" class="Bound">i</a><a id="14917" class="Symbol">)</a> <a id="14919" href="1Lab.HLevel.html#14877" class="Bound">k</a>
           <a id="14932" class="Symbol">;</a> <a id="14934" href="1Lab.HLevel.html#14934" class="Bound">k</a> <a id="14936" class="Symbol">(</a><a id="14937" href="1Lab.HLevel.html#14860" class="Bound">j</a> <a id="14939" class="Symbol">=</a> <a id="14941" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="14943" class="Symbol">)</a> <a id="14945" class="Symbol">→</a> <a id="14947" href="1Lab.HLevel.html#14834" class="Bound">isPropB</a> <a id="14955" href="1Lab.HLevel.html#14858" class="Bound">i</a> <a id="14957" href="1Lab.HLevel.html#14860" class="Bound">j</a> <a id="14959" class="Symbol">(</a><a id="14960" href="1Lab.HLevel.html#15124" class="Function">base</a> <a id="14965" href="1Lab.HLevel.html#14858" class="Bound">i</a> <a id="14967" href="1Lab.HLevel.html#14860" class="Bound">j</a><a id="14968" class="Symbol">)</a> <a id="14970" class="Symbol">(</a><a id="14971" href="1Lab.HLevel.html#14856" class="Bound">r</a> <a id="14973" href="1Lab.HLevel.html#14858" class="Bound">i</a><a id="14974" class="Symbol">)</a> <a id="14976" href="1Lab.HLevel.html#14934" class="Bound">k</a>
           <a id="14989" class="Symbol">;</a> <a id="14991" href="1Lab.HLevel.html#14991" class="Bound">k</a> <a id="14993" class="Symbol">(</a><a id="14994" href="1Lab.HLevel.html#14858" class="Bound">i</a> <a id="14996" class="Symbol">=</a> <a id="14998" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="15000" class="Symbol">)</a> <a id="15002" class="Symbol">→</a> <a id="15004" href="1Lab.HLevel.html#14834" class="Bound">isPropB</a> <a id="15012" href="1Lab.HLevel.html#14858" class="Bound">i</a> <a id="15014" href="1Lab.HLevel.html#14860" class="Bound">j</a> <a id="15016" class="Symbol">(</a><a id="15017" href="1Lab.HLevel.html#15124" class="Function">base</a> <a id="15022" href="1Lab.HLevel.html#14858" class="Bound">i</a> <a id="15024" href="1Lab.HLevel.html#14860" class="Bound">j</a><a id="15025" class="Symbol">)</a> <a id="15027" class="Symbol">(</a><a id="15028" href="1Lab.HLevel.html#14852" class="Bound">q</a> <a id="15030" href="1Lab.HLevel.html#14860" class="Bound">j</a><a id="15031" class="Symbol">)</a> <a id="15033" href="1Lab.HLevel.html#14991" class="Bound">k</a>
           <a id="15046" class="Symbol">;</a> <a id="15048" href="1Lab.HLevel.html#15048" class="Bound">k</a> <a id="15050" class="Symbol">(</a><a id="15051" href="1Lab.HLevel.html#14858" class="Bound">i</a> <a id="15053" class="Symbol">=</a> <a id="15055" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="15057" class="Symbol">)</a> <a id="15059" class="Symbol">→</a> <a id="15061" href="1Lab.HLevel.html#14834" class="Bound">isPropB</a> <a id="15069" href="1Lab.HLevel.html#14858" class="Bound">i</a> <a id="15071" href="1Lab.HLevel.html#14860" class="Bound">j</a> <a id="15073" class="Symbol">(</a><a id="15074" href="1Lab.HLevel.html#15124" class="Function">base</a> <a id="15079" href="1Lab.HLevel.html#14858" class="Bound">i</a> <a id="15081" href="1Lab.HLevel.html#14860" class="Bound">j</a><a id="15082" class="Symbol">)</a> <a id="15084" class="Symbol">(</a><a id="15085" href="1Lab.HLevel.html#14854" class="Bound">s</a> <a id="15087" href="1Lab.HLevel.html#14860" class="Bound">j</a><a id="15088" class="Symbol">)</a> <a id="15090" href="1Lab.HLevel.html#15048" class="Bound">k</a>
        <a id="15100" class="Symbol">})</a> <a id="15103" class="Symbol">(</a><a id="15104" href="1Lab.HLevel.html#15124" class="Function">base</a> <a id="15109" href="1Lab.HLevel.html#14858" class="Bound">i</a> <a id="15111" href="1Lab.HLevel.html#14860" class="Bound">j</a><a id="15112" class="Symbol">)</a> <a id="15114" class="Keyword">where</a>
    <a id="15124" href="1Lab.HLevel.html#15124" class="Function">base</a> <a id="15129" class="Symbol">:</a> <a id="15131" class="Symbol">(</a><a id="15132" href="1Lab.HLevel.html#15132" class="Bound">i</a> <a id="15134" href="1Lab.HLevel.html#15134" class="Bound">j</a> <a id="15136" class="Symbol">:</a> <a id="15138" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="15139" class="Symbol">)</a> <a id="15141" class="Symbol">→</a> <a id="15143" href="1Lab.HLevel.html#14831" class="Bound">B</a> <a id="15145" href="1Lab.HLevel.html#15132" class="Bound">i</a> <a id="15147" href="1Lab.HLevel.html#15134" class="Bound">j</a>
    <a id="15153" href="1Lab.HLevel.html#15124" class="Function">base</a> <a id="15158" href="1Lab.HLevel.html#15158" class="Bound">i</a> <a id="15160" href="1Lab.HLevel.html#15160" class="Bound">j</a> <a id="15162" class="Symbol">=</a> <a id="15164" href="1Lab.Path.html#11846" class="Function">transport</a> <a id="15174" class="Symbol">(λ</a> <a id="15177" href="1Lab.HLevel.html#15177" class="Bound">k</a> <a id="15179" class="Symbol">→</a> <a id="15181" href="1Lab.HLevel.html#14831" class="Bound">B</a> <a id="15183" class="Symbol">(</a><a id="15184" href="1Lab.HLevel.html#15158" class="Bound">i</a> <a id="15186" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="15188" href="1Lab.HLevel.html#15177" class="Bound">k</a><a id="15189" class="Symbol">)</a> <a id="15191" class="Symbol">(</a><a id="15192" href="1Lab.HLevel.html#15160" class="Bound">j</a> <a id="15194" href="1Lab.Path.html#2191" class="Primitive Operator">∧</a> <a id="15196" href="1Lab.HLevel.html#15177" class="Bound">k</a><a id="15197" class="Symbol">))</a> <a id="15200" href="1Lab.HLevel.html#14847" class="Bound">a</a>

<a id="isProp→isContrPathP"></a><a id="15203" href="1Lab.HLevel.html#15203" class="Function">isProp→isContrPathP</a> <a id="15223" class="Symbol">:</a> <a id="15225" class="Symbol">{</a><a id="15226" href="1Lab.HLevel.html#15226" class="Bound">A</a> <a id="15228" class="Symbol">:</a> <a id="15230" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="15232" class="Symbol">→</a> <a id="15234" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="15239" href="1Lab.HLevel.html#3723" class="Generalizable">ℓ</a><a id="15240" class="Symbol">}</a> <a id="15242" class="Symbol">→</a> <a id="15244" class="Symbol">((</a><a id="15246" href="1Lab.HLevel.html#15246" class="Bound">i</a> <a id="15248" class="Symbol">:</a> <a id="15250" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="15251" class="Symbol">)</a> <a id="15253" class="Symbol">→</a> <a id="15255" href="1Lab.HLevel.html#2594" class="Function">isProp</a> <a id="15262" class="Symbol">(</a><a id="15263" href="1Lab.HLevel.html#15226" class="Bound">A</a> <a id="15265" href="1Lab.HLevel.html#15246" class="Bound">i</a><a id="15266" class="Symbol">))</a>
                    <a id="15289" class="Symbol">→</a> <a id="15291" class="Symbol">(</a><a id="15292" href="1Lab.HLevel.html#15292" class="Bound">x</a> <a id="15294" class="Symbol">:</a> <a id="15296" href="1Lab.HLevel.html#15226" class="Bound">A</a> <a id="15298" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="15300" class="Symbol">)</a> <a id="15302" class="Symbol">(</a><a id="15303" href="1Lab.HLevel.html#15303" class="Bound">y</a> <a id="15305" class="Symbol">:</a> <a id="15307" href="1Lab.HLevel.html#15226" class="Bound">A</a> <a id="15309" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="15311" class="Symbol">)</a> <a id="15313" class="Symbol">→</a> <a id="15315" href="1Lab.HLevel.html#1328" class="Record">isContr</a> <a id="15323" class="Symbol">(</a><a id="15324" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="15330" href="1Lab.HLevel.html#15226" class="Bound">A</a> <a id="15332" href="1Lab.HLevel.html#15292" class="Bound">x</a> <a id="15334" href="1Lab.HLevel.html#15303" class="Bound">y</a><a id="15335" class="Symbol">)</a>
<a id="15337" href="1Lab.HLevel.html#15203" class="Function">isProp→isContrPathP</a> <a id="15357" href="1Lab.HLevel.html#15357" class="Bound">ap</a> <a id="15360" href="1Lab.HLevel.html#15360" class="Bound">x</a> <a id="15362" href="1Lab.HLevel.html#15362" class="Bound">y</a> <a id="15364" class="Symbol">.</a><a id="15365" href="1Lab.HLevel.html#1400" class="Field">centre</a> <a id="15372" class="Symbol">=</a> <a id="15374" href="1Lab.HLevel.html#13502" class="Function">isProp→PathP</a> <a id="15387" href="1Lab.HLevel.html#15357" class="Bound">ap</a> <a id="15390" href="1Lab.HLevel.html#15360" class="Bound">x</a> <a id="15392" href="1Lab.HLevel.html#15362" class="Bound">y</a>
<a id="15394" href="1Lab.HLevel.html#15203" class="Function">isProp→isContrPathP</a> <a id="15414" href="1Lab.HLevel.html#15414" class="Bound">ap</a> <a id="15417" href="1Lab.HLevel.html#15417" class="Bound">x</a> <a id="15419" href="1Lab.HLevel.html#15419" class="Bound">y</a> <a id="15421" class="Symbol">.</a><a id="15422" href="1Lab.HLevel.html#1415" class="Field">paths</a> <a id="15428" href="1Lab.HLevel.html#15428" class="Bound">p</a> <a id="15430" class="Symbol">=</a>
  <a id="15434" href="1Lab.HLevel.html#14452" class="Function">isProp→SquareP</a> <a id="15449" class="Symbol">(λ</a> <a id="15452" href="1Lab.HLevel.html#15452" class="Bound">i</a> <a id="15454" href="1Lab.HLevel.html#15454" class="Bound">j</a> <a id="15456" class="Symbol">→</a> <a id="15458" href="1Lab.HLevel.html#15414" class="Bound">ap</a> <a id="15461" href="1Lab.HLevel.html#15454" class="Bound">j</a><a id="15462" class="Symbol">)</a> <a id="15464" href="1Lab.Path.html#3591" class="Function">refl</a> <a id="15469" class="Symbol">_</a> <a id="15471" class="Symbol">_</a> <a id="15473" href="1Lab.Path.html#3591" class="Function">refl</a>

<a id="15479" class="Keyword">abstract</a>
  <a id="isSet→SquareP"></a><a id="15490" href="1Lab.HLevel.html#15490" class="Function">isSet→SquareP</a> <a id="15504" class="Symbol">:</a>
    <a id="15510" class="Symbol">{</a><a id="15511" href="1Lab.HLevel.html#15511" class="Bound">A</a> <a id="15513" class="Symbol">:</a> <a id="15515" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="15517" class="Symbol">→</a> <a id="15519" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a> <a id="15521" class="Symbol">→</a> <a id="15523" href="1Lab.Type.html#394" class="Primitive">Type</a> <a id="15528" href="1Lab.HLevel.html#3723" class="Generalizable">ℓ</a><a id="15529" class="Symbol">}</a>
    <a id="15535" class="Symbol">(</a><a id="15536" href="1Lab.HLevel.html#15536" class="Bound">isSet</a> <a id="15542" class="Symbol">:</a> <a id="15544" class="Symbol">(</a><a id="15545" href="1Lab.HLevel.html#15545" class="Bound">i</a> <a id="15547" href="1Lab.HLevel.html#15547" class="Bound">j</a> <a id="15549" class="Symbol">:</a> <a id="15551" href="Agda.Primitive.Cubical.html#101" class="Datatype">I</a><a id="15552" class="Symbol">)</a> <a id="15554" class="Symbol">→</a> <a id="15556" href="1Lab.HLevel.html#3342" class="Function">isSet</a> <a id="15562" class="Symbol">(</a><a id="15563" href="1Lab.HLevel.html#15511" class="Bound">A</a> <a id="15565" href="1Lab.HLevel.html#15545" class="Bound">i</a> <a id="15567" href="1Lab.HLevel.html#15547" class="Bound">j</a><a id="15568" class="Symbol">))</a>
    <a id="15575" class="Symbol">→</a> <a id="15577" class="Symbol">{</a><a id="15578" href="1Lab.HLevel.html#15578" class="Bound">a</a> <a id="15580" class="Symbol">:</a> <a id="15582" href="1Lab.HLevel.html#15511" class="Bound">A</a> <a id="15584" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a id="15587" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="15589" class="Symbol">}</a> <a id="15591" class="Symbol">{</a><a id="15592" href="1Lab.HLevel.html#15592" class="Bound">b</a> <a id="15594" class="Symbol">:</a> <a id="15596" href="1Lab.HLevel.html#15511" class="Bound">A</a> <a id="15598" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a id="15601" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="15603" class="Symbol">}</a> <a id="15605" class="Symbol">{</a><a id="15606" href="1Lab.HLevel.html#15606" class="Bound">c</a> <a id="15608" class="Symbol">:</a> <a id="15610" href="1Lab.HLevel.html#15511" class="Bound">A</a> <a id="15612" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a> <a id="15615" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="15617" class="Symbol">}</a> <a id="15619" class="Symbol">{</a><a id="15620" href="1Lab.HLevel.html#15620" class="Bound">d</a> <a id="15622" class="Symbol">:</a> <a id="15624" href="1Lab.HLevel.html#15511" class="Bound">A</a> <a id="15626" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a> <a id="15629" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="15631" class="Symbol">}</a>
    <a id="15637" class="Symbol">→</a> <a id="15639" class="Symbol">(</a><a id="15640" href="1Lab.HLevel.html#15640" class="Bound">p</a> <a id="15642" class="Symbol">:</a> <a id="15644" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="15650" class="Symbol">(λ</a> <a id="15653" href="1Lab.HLevel.html#15653" class="Bound">j</a> <a id="15655" class="Symbol">→</a> <a id="15657" href="1Lab.HLevel.html#15511" class="Bound">A</a> <a id="15659" href="1Lab.HLevel.html#15653" class="Bound">j</a> <a id="15661" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a><a id="15663" class="Symbol">)</a> <a id="15665" href="1Lab.HLevel.html#15578" class="Bound">a</a> <a id="15667" href="1Lab.HLevel.html#15606" class="Bound">c</a><a id="15668" class="Symbol">)</a>
    <a id="15674" class="Symbol">→</a> <a id="15676" class="Symbol">(</a><a id="15677" href="1Lab.HLevel.html#15677" class="Bound">q</a> <a id="15679" class="Symbol">:</a> <a id="15681" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="15687" class="Symbol">(λ</a> <a id="15690" href="1Lab.HLevel.html#15690" class="Bound">j</a> <a id="15692" class="Symbol">→</a> <a id="15694" href="1Lab.HLevel.html#15511" class="Bound">A</a> <a id="15696" href="Agda.Primitive.Cubical.html#143" class="InductiveConstructor">i0</a> <a id="15699" href="1Lab.HLevel.html#15690" class="Bound">j</a><a id="15700" class="Symbol">)</a> <a id="15702" href="1Lab.HLevel.html#15578" class="Bound">a</a> <a id="15704" href="1Lab.HLevel.html#15592" class="Bound">b</a><a id="15705" class="Symbol">)</a>
    <a id="15711" class="Symbol">→</a> <a id="15713" class="Symbol">(</a><a id="15714" href="1Lab.HLevel.html#15714" class="Bound">s</a> <a id="15716" class="Symbol">:</a> <a id="15718" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="15724" class="Symbol">(λ</a> <a id="15727" href="1Lab.HLevel.html#15727" class="Bound">j</a> <a id="15729" class="Symbol">→</a> <a id="15731" href="1Lab.HLevel.html#15511" class="Bound">A</a> <a id="15733" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a> <a id="15736" href="1Lab.HLevel.html#15727" class="Bound">j</a><a id="15737" class="Symbol">)</a> <a id="15739" href="1Lab.HLevel.html#15606" class="Bound">c</a> <a id="15741" href="1Lab.HLevel.html#15620" class="Bound">d</a><a id="15742" class="Symbol">)</a>
    <a id="15748" class="Symbol">→</a> <a id="15750" class="Symbol">(</a><a id="15751" href="1Lab.HLevel.html#15751" class="Bound">r</a> <a id="15753" class="Symbol">:</a> <a id="15755" href="Agda.Builtin.Cubical.Path.html#190" class="Postulate">PathP</a> <a id="15761" class="Symbol">(λ</a> <a id="15764" href="1Lab.HLevel.html#15764" class="Bound">j</a> <a id="15766" class="Symbol">→</a> <a id="15768" href="1Lab.HLevel.html#15511" class="Bound">A</a> <a id="15770" href="1Lab.HLevel.html#15764" class="Bound">j</a> <a id="15772" href="Agda.Primitive.Cubical.html#171" class="InductiveConstructor">i1</a><a id="15774" class="Symbol">)</a> <a id="15776" href="1Lab.HLevel.html#15592" class="Bound">b</a> <a id="15778" href="1Lab.HLevel.html#15620" class="Bound">d</a><a id="15779" class="Symbol">)</a>
    <a id="15785" class="Symbol">→</a> <a id="15787" href="1Lab.Path.html#48224" class="Function">SquareP</a> <a id="15795" href="1Lab.HLevel.html#15511" class="Bound">A</a> <a id="15797" href="1Lab.HLevel.html#15640" class="Bound">p</a> <a id="15799" href="1Lab.HLevel.html#15677" class="Bound">q</a> <a id="15801" href="1Lab.HLevel.html#15714" class="Bound">s</a> <a id="15803" href="1Lab.HLevel.html#15751" class="Bound">r</a>
  <a id="15807" href="1Lab.HLevel.html#15490" class="Function">isSet→SquareP</a> <a id="15821" href="1Lab.HLevel.html#15821" class="Bound">isset</a> <a id="15827" href="1Lab.HLevel.html#15827" class="Bound">a₀₋</a> <a id="15831" href="1Lab.HLevel.html#15831" class="Bound">a₁₋</a> <a id="15835" href="1Lab.HLevel.html#15835" class="Bound">a₋₀</a> <a id="15839" href="1Lab.HLevel.html#15839" class="Bound">a₋₁</a> <a id="15843" class="Symbol">=</a>
    <a id="15849" href="1Lab.Path.html#11846" class="Function">transport</a> <a id="15859" class="Symbol">(</a><a id="15860" href="1Lab.Path.html#10628" class="Function">sym</a> <a id="15864" class="Symbol">(</a><a id="15865" href="1Lab.Path.html#49329" class="Function">PathP≡Path</a> <a id="15876" class="Symbol">_</a> <a id="15878" class="Symbol">_</a> <a id="15880" class="Symbol">_))</a>
              <a id="15898" class="Symbol">(</a><a id="15899" href="1Lab.HLevel.html#10518" class="Function">isHLevelPathP&#39;</a> <a id="15914" class="Number">1</a> <a id="15916" class="Symbol">(</a><a id="15917" href="1Lab.HLevel.html#15821" class="Bound">isset</a> <a id="15923" class="Symbol">_</a> <a id="15925" class="Symbol">_)</a> <a id="15928" class="Symbol">_</a> <a id="15930" class="Symbol">_</a> <a id="15932" class="Symbol">_</a> <a id="15934" class="Symbol">_)</a>

<a id="15938" class="Comment">-- Has to go through:</a>
<a id="15960" href="1Lab.HLevel.html#15960" class="Function">_</a> <a id="15962" class="Symbol">:</a> <a id="15964" class="Symbol">∀</a> <a id="15966" class="Symbol">{</a><a id="15967" href="1Lab.HLevel.html#15967" class="Bound">A</a> <a id="15969" class="Symbol">:</a> <a id="15971" href="1Lab.Type.html#394" class="Primitive">Type</a><a id="15975" class="Symbol">}</a> <a id="15977" class="Symbol">{</a><a id="15978" href="1Lab.HLevel.html#15978" class="Bound">a</a> <a id="15980" href="1Lab.HLevel.html#15980" class="Bound">b</a> <a id="15982" href="1Lab.HLevel.html#15982" class="Bound">c</a> <a id="15984" href="1Lab.HLevel.html#15984" class="Bound">d</a> <a id="15986" class="Symbol">:</a> <a id="15988" href="1Lab.HLevel.html#15967" class="Bound">A</a><a id="15989" class="Symbol">}</a> <a id="15991" class="Symbol">(</a><a id="15992" href="1Lab.HLevel.html#15992" class="Bound">p</a> <a id="15994" class="Symbol">:</a> <a id="15996" href="1Lab.HLevel.html#15978" class="Bound">a</a> <a id="15998" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="16000" href="1Lab.HLevel.html#15982" class="Bound">c</a><a id="16001" class="Symbol">)</a> <a id="16003" class="Symbol">(</a><a id="16004" href="1Lab.HLevel.html#16004" class="Bound">q</a> <a id="16006" class="Symbol">:</a> <a id="16008" href="1Lab.HLevel.html#15978" class="Bound">a</a> <a id="16010" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="16012" href="1Lab.HLevel.html#15980" class="Bound">b</a><a id="16013" class="Symbol">)</a> <a id="16015" class="Symbol">(</a><a id="16016" href="1Lab.HLevel.html#16016" class="Bound">s</a> <a id="16018" class="Symbol">:</a> <a id="16020" href="1Lab.HLevel.html#15982" class="Bound">c</a> <a id="16022" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="16024" href="1Lab.HLevel.html#15984" class="Bound">d</a><a id="16025" class="Symbol">)</a> <a id="16027" class="Symbol">(</a><a id="16028" href="1Lab.HLevel.html#16028" class="Bound">r</a> <a id="16030" class="Symbol">:</a> <a id="16032" href="1Lab.HLevel.html#15980" class="Bound">b</a> <a id="16034" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="16036" href="1Lab.HLevel.html#15984" class="Bound">d</a><a id="16037" class="Symbol">)</a>
  <a id="16041" class="Symbol">→</a> <a id="16043" href="1Lab.Path.html#9479" class="Function">Square</a> <a id="16050" href="1Lab.HLevel.html#15992" class="Bound">p</a> <a id="16052" href="1Lab.HLevel.html#16004" class="Bound">q</a> <a id="16054" href="1Lab.HLevel.html#16016" class="Bound">s</a> <a id="16056" href="1Lab.HLevel.html#16028" class="Bound">r</a> <a id="16058" href="Agda.Builtin.Cubical.Path.html#381" class="Function Operator">≡</a> <a id="16060" href="1Lab.Path.html#48224" class="Function">SquareP</a> <a id="16068" class="Symbol">(λ</a> <a id="16071" href="1Lab.HLevel.html#16071" class="Bound">_</a> <a id="16073" href="1Lab.HLevel.html#16073" class="Bound">_</a> <a id="16075" class="Symbol">→</a> <a id="16077" href="1Lab.HLevel.html#15967" class="Bound">A</a><a id="16078" class="Symbol">)</a> <a id="16080" href="1Lab.HLevel.html#15992" class="Bound">p</a> <a id="16082" href="1Lab.HLevel.html#16004" class="Bound">q</a> <a id="16084" href="1Lab.HLevel.html#16016" class="Bound">s</a> <a id="16086" href="1Lab.HLevel.html#16028" class="Bound">r</a>
<a id="16088" class="Symbol">_</a> <a id="16090" class="Symbol">=</a> <a id="16092" class="Symbol">λ</a> <a id="16094" href="1Lab.HLevel.html#16094" class="Bound">_</a> <a id="16096" href="1Lab.HLevel.html#16096" class="Bound">_</a> <a id="16098" href="1Lab.HLevel.html#16098" class="Bound">_</a> <a id="16100" href="1Lab.HLevel.html#16100" class="Bound">_</a> <a id="16102" class="Symbol">→</a> <a id="16104" href="1Lab.Path.html#3591" class="Function">refl</a>
</pre>-->
  </article>
</div>

</main>
</body>
<style>.equations { display: none !important; }</style></html>
